<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>ExSubst (dedukti.Kernel.Exsubst.ExSubst)</title><link rel="stylesheet" href="../../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../../index.html">dedukti</a> &#x00BB; <a href="../../index.html">Kernel</a> &#x00BB; <a href="../index.html">Exsubst</a> &#x00BB; ExSubst</nav><header class="odoc-preamble"><h1>Module <code><span>Exsubst.ExSubst</span></code></h1><p>This modules implements extended substitution of DB variables in a term. This is typically used to: 1) infer a &quot;most general&quot; typing substitution from constraints gathered while inferring the type of the LHS of a rule. 2) apply the substitution to the RHS of the rule before typechecking it.</p></header><div class="odoc-content"><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-identity" class="anchored"><a href="#val-identity" class="anchor"></a><code><span><span class="keyword">val</span> identity : <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Empty substitution</p></div></div><div class="odoc-spec"><div class="spec value" id="val-is_identity" class="anchored"><a href="#val-is_identity" class="anchor"></a><code><span><span class="keyword">val</span> is_identity : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Checks emptyness</p></div></div><div class="odoc-spec"><div class="spec value" id="val-add" class="anchored"><a href="#val-add" class="anchor"></a><code><span><span class="keyword">val</span> add : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="../../Term/index.html#type-term">Term.term</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>add sigma n t</code> returns the substitution <code>sigma</code> with the extra mapping <code>n</code> -&gt; <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-apply" class="anchored"><a href="#val-apply" class="anchor"></a><code><span><span class="keyword">val</span> apply : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="../../Term/index.html#type-term">Term.term</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../Term/index.html#type-term">Term.term</a></span></code></div><div class="spec-doc"><p><code>apply sigma n t</code> applies the subsitution <code>sigma</code> to <code>t</code> considered under <code>n</code> lambda abstractions.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-apply'" class="anchored"><a href="#val-apply'" class="anchor"></a><code><span><span class="keyword">val</span> apply' : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="../../Term/index.html#type-term">Term.term</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../Term/index.html#type-term">Term.term</a> * bool</span></code></div><div class="spec-doc"><p>Same as apply, but outputting a boolean <code>true</code> if the term is modified by the substitution.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-apply2" class="anchored"><a href="#val-apply2" class="anchor"></a><code><span><span class="keyword">val</span> apply2 : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="../../Term/index.html#type-term">Term.term</a> <span class="arrow">&#45;&gt;</span></span> <a href="../../Term/index.html#type-term">Term.term</a></span></code></div><div class="spec-doc"><p>Special substitution function corresponding to given ExSubst.t instance <code>sigma</code> &quot;in a smaller context&quot;: Assume <code>sigma</code> a substitution in a context Gamma = Gamma' ; Delta with |Delta|=<code>i</code>. Then this function represents the substitution <code>sigma</code> in the context Gamma'. All variables of Delta are ignored and substitutes of the variables of Gamma' are unshifted. This may therefore raise UnshiftExn in case substitutes of variables of Gamma' refers to variables of Delta.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mk_idempotent" class="anchored"><a href="#val-mk_idempotent" class="anchor"></a><code><span><span class="keyword">val</span> mk_idempotent : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>mk_idempotent sigma</code> successively applies sigma to its mapped terms until this operation has no effect anymore.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pp" class="anchored"><a href="#val-pp" class="anchor"></a><code><span><span class="keyword">val</span> pp : <span><span>(<span>int <span class="arrow">&#45;&gt;</span></span> <a href="../../Basic/index.html#type-ident">Basic.ident</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <a href="../../Basic/index.html#type-printer">Basic.printer</a></span></span></code></div><div class="spec-doc"><p>Prints the substitution using given naming function</p></div></div></div></body></html>