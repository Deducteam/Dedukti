<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Dtree (dedukti.Kernel.Dtree)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">dedukti</a> &#x00BB; <a href="../index.html">Kernel</a> &#x00BB; Dtree</nav><header class="odoc-preamble"><h1>Module <code><span>Kernel.Dtree</span></code></h1></header><nav class="odoc-toc"><ul><li><a href="#error">Error</a></li><li><a href="#pre-matching-problems">Pre-Matching problems</a></li><li><a href="#decision-trees">Decision Trees</a></li></ul></nav><div class="odoc-content"><h3 id="error"><a href="#error" class="anchor"></a>Error</h3><div class="odoc-spec"><div class="spec type" id="type-dtree_error" class="anchored"><a href="#type-dtree_error" class="anchor"></a><code><span><span class="keyword">type</span> dtree_error</span><span> = </span></code><table><tr id="type-dtree_error.HeadSymbolMismatch" class="anchored"><td class="def variant constructor"><a href="#type-dtree_error.HeadSymbolMismatch" class="anchor"></a><code><span>| </span><span><span class="constructor">HeadSymbolMismatch</span> <span class="keyword">of</span> <a href="../Basic/index.html#type-loc">Basic.loc</a> * <a href="../Basic/index.html#type-name">Basic.name</a> * <a href="../Basic/index.html#type-name">Basic.name</a></span></code></td></tr><tr id="type-dtree_error.ArityInnerMismatch" class="anchored"><td class="def variant constructor"><a href="#type-dtree_error.ArityInnerMismatch" class="anchor"></a><code><span>| </span><span><span class="constructor">ArityInnerMismatch</span> <span class="keyword">of</span> <a href="../Basic/index.html#type-loc">Basic.loc</a> * <a href="../Basic/index.html#type-ident">Basic.ident</a> * <a href="../Basic/index.html#type-ident">Basic.ident</a></span></code></td></tr><tr id="type-dtree_error.ACSymbolRewritten" class="anchored"><td class="def variant constructor"><a href="#type-dtree_error.ACSymbolRewritten" class="anchor"></a><code><span>| </span><span><span class="constructor">ACSymbolRewritten</span> <span class="keyword">of</span> <a href="../Basic/index.html#type-loc">Basic.loc</a> * <a href="../Basic/index.html#type-name">Basic.name</a> * int</span></code></td></tr></table></div></div><div class="odoc-spec"><div class="spec exception" id="exception-Dtree_error" class="anchored"><a href="#exception-Dtree_error" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">Dtree_error</span> <span class="keyword">of</span> <a href="#type-dtree_error">dtree_error</a></span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-miller_var" class="anchored"><a href="#type-miller_var" class="anchor"></a><code><span><span class="keyword">type</span> miller_var</span><span> = </span><span>{</span></code><table><tr id="type-miller_var.arity" class="anchored"><td class="def record field"><a href="#type-miller_var.arity" class="anchor"></a><code><span>arity : int;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Arity of the meta variable</p><span class="comment-delim">*)</span></td></tr><tr id="type-miller_var.depth" class="anchored"><td class="def record field"><a href="#type-miller_var.depth" class="anchor"></a><code><span>depth : int;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Depth under which this occurence of the meta variable is considered</p><span class="comment-delim">*)</span></td></tr><tr id="type-miller_var.vars" class="anchored"><td class="def record field"><a href="#type-miller_var.vars" class="anchor"></a><code><span>vars : <span>int list</span>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>The list of local DB indices of argument variables</p><span class="comment-delim">*)</span></td></tr><tr id="type-miller_var.mapping" class="anchored"><td class="def record field"><a href="#type-miller_var.mapping" class="anchor"></a><code><span>mapping : <span>int array</span>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>The mapping from all local DB indices for either -1 or position in the list of argument variables (starting from the end)</p><span class="comment-delim">*)</span></td></tr></table><code><span>}</span></code></div><div class="spec-doc"><p>This represent a meta variables applied to distinct locally bounded variables: X x_1 ... x_n.</p><ul><li><code>arity</code> is the number of arguments</li><li><code>depth</code> is the number of locally bounded variables available</li><li><code>vars</code> is the list of successive arguments in order</li><li><code>mapping</code> is a mapping for all available bounded variable n to</li><li>either -1 is this variable is absent from the list of arguments</li><li>or the index of that integer in the <code>vars</code> list</li></ul><p>The following invariants should therefore be verified:</p><ul><li><code>arity</code> is the length of vars</li><li><code>depth</code> is the length of mapping</li><li>All elements of <code>vars</code> are between 0 and <code>depth</code>-1</li><li>Non negative elements of <code>mapping</code> are between 0 and <code>arity</code>-1</li><li><code>mapping</code>.(i) = n &gt;= 0 iff List.nth <code>vars</code> (<code>arity</code>-n-1) = i</li><li>This means exactly <code>arity</code> elements of <code>mapping</code> are non negative</li></ul><p>An example: { arity = 2; depth = 5; vars = <code>4; 2</code>; mapping = <code>| (-1) ; (-1) ; 0 ; (-1) ; 1 |</code> }</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mapping_of_vars" class="anchored"><a href="#val-mapping_of_vars" class="anchor"></a><code><span><span class="keyword">val</span> mapping_of_vars : <span>int <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><span>int list</span> <span class="arrow">&#45;&gt;</span></span> <span>int array</span></span></code></div><div class="spec-doc"><p><code>mapping_of_vars depth arity vars</code> build a reverse mapping from the list <code>vars</code> of DB indices arguments of a Miller variable. For instance the pattern x =&gt; y =&gt; z =&gt; F y x produces a call to <code>mapping_of_vars 3 2 [1; 0] </code> which returns the array <code>| 1 ; 0 ; (-1) |</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-fo_var" class="anchored"><a href="#val-fo_var" class="anchor"></a><code><span><span class="keyword">val</span> fo_var : <a href="#type-miller_var">miller_var</a></span></code></div></div><h3 id="pre-matching-problems"><a href="#pre-matching-problems" class="anchor"></a>Pre-Matching problems</h3><p>Abstract matching problems. This can be instantiated with</p><ul><li>When building a decision tree <code>'a = int</code> refers to positions in the stack</li><li>When matching against a term, <code>'a = term Lazy.t</code> refers to actual terms</li></ul><div class="odoc-spec"><div class="spec type" id="type-eq_problem" class="anchored"><a href="#type-eq_problem" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a eq_problem</span></span><span> = <a href="#type-miller_var">miller_var</a> * <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>(vars, matched)</code> is the higher order equational problem: X x1 ... xn = <code>matched</code> with <code>vars</code>=[ x1 ; ... ; xn ]</p></div></div><div class="odoc-spec"><div class="spec type" id="type-var_p" class="anchored"><a href="#type-var_p" class="anchor"></a><code><span><span class="keyword">type</span> var_p</span><span> = int * <a href="#type-miller_var">miller_var</a></span></code></div><div class="spec-doc"><p>(<code>n</code>, <code>vars</code>) represents the <code>n</code>-th variable applied to the <code>vars</code> bound variables.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-ac_problem" class="anchored"><a href="#type-ac_problem" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a ac_problem</span></span><span> = int * <a href="../Ac/index.html#type-ac_ident">Ac.ac_ident</a> * int * <span><a href="#type-var_p">var_p</a> list</span> * <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p><code>(depth, symb, njoks, vars, terms)</code> Represents the flattenned equality under AC symbol <code>symb</code> of:</p><ul><li><code>njoks</code> jokers and the given variables <code>vars</code></li><li>The given <code>terms</code> e.g. <code> +{ X[x] , _, Y[y,z] } = +{ f(a), f(y), f(x)} </code> the <code>depth</code> field in all elements of <code>vars</code> should be equal to <code>depth</code> FIXME: do we need <code>depth</code> here then ?</li></ul></div></div><div class="odoc-spec"><div class="spec type" id="type-pre_matching_problem" class="anchored"><a href="#type-pre_matching_problem" class="anchor"></a><code><span><span class="keyword">type</span> pre_matching_problem</span><span> = </span><span>{</span></code><table><tr id="type-pre_matching_problem.pm_eq_problems" class="anchored"><td class="def record field"><a href="#type-pre_matching_problem.pm_eq_problems" class="anchor"></a><code><span>pm_eq_problems : <span><span><span>int <a href="#type-eq_problem">eq_problem</a></span> list</span> <a href="../Basic/LList/index.html#type-t">Basic.LList.t</a></span>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>For each variable of a rewrite rule (array), a list of equational problems under various depths</p><span class="comment-delim">*)</span></td></tr><tr id="type-pre_matching_problem.pm_ac_problems" class="anchored"><td class="def record field"><a href="#type-pre_matching_problem.pm_ac_problems" class="anchor"></a><code><span>pm_ac_problems : <span><span>int <a href="#type-ac_problem">ac_problem</a></span> list</span>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>A list of AC-matching problems under a certain depth</p><span class="comment-delim">*)</span></td></tr><tr id="type-pre_matching_problem.pm_arity" class="anchored"><td class="def record field"><a href="#type-pre_matching_problem.pm_arity" class="anchor"></a><code><span>pm_arity : <span>int array</span>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Constant time access to a variable's arity</p><span class="comment-delim">*)</span></td></tr></table><code><span>}</span></code></div><div class="spec-doc"><p>A problem with int indices referencing positions in the stack</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_var_type" class="anchored"><a href="#val-pp_var_type" class="anchor"></a><code><span><span class="keyword">val</span> pp_var_type : <span><a href="#type-var_p">var_p</a> <a href="../Basic/index.html#type-printer">Basic.printer</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_eq_problems" class="anchored"><a href="#val-pp_eq_problems" class="anchor"></a><code><span><span class="keyword">val</span> pp_eq_problems : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="../Basic/index.html#type-printer">Basic.printer</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span>(int * <span><span><span class="type-var">'a</span> <a href="#type-eq_problem">eq_problem</a></span> list</span>)</span> <a href="../Basic/index.html#type-printer">Basic.printer</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_ac_problem" class="anchored"><a href="#val-pp_ac_problem" class="anchor"></a><code><span><span class="keyword">val</span> pp_ac_problem : <span><span><span class="type-var">'a</span> <a href="../Basic/index.html#type-printer">Basic.printer</a></span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> <a href="#type-ac_problem">ac_problem</a></span> <a href="../Basic/index.html#type-printer">Basic.printer</a></span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_pre_matching_problem" class="anchored"><a href="#val-pp_pre_matching_problem" class="anchor"></a><code><span><span class="keyword">val</span> pp_pre_matching_problem : <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-pre_matching_problem">pre_matching_problem</a> <a href="../Basic/index.html#type-printer">Basic.printer</a></span></span></code></div><div class="spec-doc"><p>int matching problem printing function (for dtree).</p></div></div><h3 id="decision-trees"><a href="#decision-trees" class="anchor"></a>Decision Trees</h3><div class="odoc-spec"><div class="spec type" id="type-case" class="anchored"><a href="#type-case" class="anchor"></a><code><span><span class="keyword">type</span> case</span><span> = </span></code><table><tr id="type-case.CConst" class="anchored"><td class="def variant constructor"><a href="#type-case.CConst" class="anchor"></a><code><span>| </span><span><span class="constructor">CConst</span> <span class="keyword">of</span> int * <a href="../Basic/index.html#type-name">Basic.name</a> * bool</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p><code>(size,name,ac)</code> where <code>size</code> is the number of arguments expected for the constant <code>c</code> and <code>ac</code> is true iff the constant is a definable AC(U) symbol.</p><span class="comment-delim">*)</span></td></tr><tr id="type-case.CDB" class="anchored"><td class="def variant constructor"><a href="#type-case.CDB" class="anchor"></a><code><span>| </span><span><span class="constructor">CDB</span> <span class="keyword">of</span> int * int</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p><code>(size,db_index)</code> where <code>size</code> is the number of *static* arguments expected for the bounded variable <code>db_index</code></p><span class="comment-delim">*)</span></td></tr><tr id="type-case.CLam" class="anchored"><td class="def variant constructor"><a href="#type-case.CLam" class="anchor"></a><code><span>| </span><span><span class="constructor">CLam</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>A lambda headed term</p><span class="comment-delim">*)</span></td></tr></table></div><div class="spec-doc"><p>Arguments of a pattern may be the following:</p><ul><li>a constant</li><li>a variable</li><li>a lambda expression</li></ul></div></div><div class="odoc-spec"><div class="spec type" id="type-atomic_problem" class="anchored"><a href="#type-atomic_problem" class="anchor"></a><code><span><span class="keyword">type</span> atomic_problem</span><span> = </span><span>{</span></code><table><tr id="type-atomic_problem.a_pos" class="anchored"><td class="def record field"><a href="#type-atomic_problem.a_pos" class="anchor"></a><code><span>a_pos : int;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>position of the term to match in the stack.</p><span class="comment-delim">*)</span></td></tr><tr id="type-atomic_problem.a_depth" class="anchored"><td class="def record field"><a href="#type-atomic_problem.a_depth" class="anchor"></a><code><span>a_depth : int;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>depth of the argument regarding absractions</p><span class="comment-delim">*)</span></td></tr><tr id="type-atomic_problem.a_args" class="anchored"><td class="def record field"><a href="#type-atomic_problem.a_args" class="anchor"></a><code><span>a_args : <span>int array</span>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Arguments DB indices (distinct bound variables)</p><span class="comment-delim">*)</span></td></tr></table><code><span>}</span></code></div><div class="spec-doc"><p>An atomic matching problem. stack.(pos) ~? X<code> DB(args_0), ..., DB(args_n)</code> where X is the variable and the problem is considered under depth abstractions.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-matching_problem" class="anchored"><a href="#type-matching_problem" class="anchor"></a><code><span><span class="keyword">type</span> matching_problem</span><span> = <span><a href="#type-atomic_problem">atomic_problem</a> <a href="../Basic/LList/index.html#type-t">Basic.LList.t</a></span></span></code></div><div class="spec-doc"><p>A matching problem to build a solution context from the stack</p></div></div><div class="odoc-spec"><div class="spec type" id="type-dtree" class="anchored"><a href="#type-dtree" class="anchor"></a><code><span><span class="keyword">type</span> dtree</span><span> = </span></code><table><tr id="type-dtree.Switch" class="anchored"><td class="def variant constructor"><a href="#type-dtree.Switch" class="anchor"></a><code><span>| </span><span><span class="constructor">Switch</span> <span class="keyword">of</span> int * <span><span>(<a href="#type-case">case</a> * <a href="#type-dtree">dtree</a>)</span> list</span> * <span><a href="#type-dtree">dtree</a> option</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p><code>Switch i [(case_0,tree_0) ; ... ; (case_n, tree_n)] default_tree</code> tests whether the <code>i</code>-th argument in the stack matches with one of the given cases. If it does then proceed with the corresponding tree Otherwise, branch to the given default tree.</p><span class="comment-delim">*)</span></td></tr><tr id="type-dtree.Test" class="anchored"><td class="def variant constructor"><a href="#type-dtree.Test" class="anchor"></a><code><span>| </span><span><span class="constructor">Test</span> <span class="keyword">of</span> <a href="../Rule/index.html#type-rule_name">Rule.rule_name</a> * <a href="#type-pre_matching_problem">pre_matching_problem</a> * <span><a href="../Rule/index.html#type-constr">Rule.constr</a> list</span> * <a href="../Term/index.html#type-term">Term.term</a> * <span><a href="#type-dtree">dtree</a> option</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p><code>Test name pb cstrs rhs default_tree</code> are the leaves of the tree. Checks that each problem can be solved such that constraints are satisfied. If it does then return a local context for the term <code>rhs</code>.</p><span class="comment-delim">*)</span></td></tr><tr id="type-dtree.Fetch" class="anchored"><td class="def variant constructor"><a href="#type-dtree.Fetch" class="anchor"></a><code><span>| </span><span><span class="constructor">Fetch</span> <span class="keyword">of</span> int * <a href="#type-case">case</a> * <a href="#type-dtree">dtree</a> * <span><a href="#type-dtree">dtree</a> option</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p><code>Fetch i case tree_suc tree_def</code> assumes the <code>i</code>-th argument of a pattern is a * flattened AC symbols and checks that it contains a term that can be matched with the given * case. * If so then look at the corresponding tree, otherwise/afterwise, look at the default tree</p><span class="comment-delim">*)</span></td></tr><tr id="type-dtree.ACEmpty" class="anchored"><td class="def variant constructor"><a href="#type-dtree.ACEmpty" class="anchor"></a><code><span>| </span><span><span class="constructor">ACEmpty</span> <span class="keyword">of</span> int * <a href="#type-dtree">dtree</a> * <span><a href="#type-dtree">dtree</a> option</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p><code>ACEmpty i tree_suc tree_def</code> assumes the <code>i</code>-th argument of a pattern is a * flattened AC symbols and checks that it is now empty.</p><span class="comment-delim">*)</span></td></tr></table></div><div class="spec-doc"><p>Type of decision trees</p></div></div><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span></code></div><div class="spec-doc"><p>Type mapping arities to decision trees (also called &quot;forest&quot;)</p></div></div><div class="odoc-spec"><div class="spec value" id="val-empty" class="anchored"><a href="#val-empty" class="anchor"></a><code><span><span class="keyword">val</span> empty : <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Empty forest for a free algebra</p></div></div><div class="odoc-spec"><div class="spec value" id="val-find_dtree" class="anchored"><a href="#val-find_dtree" class="anchor"></a><code><span><span class="keyword">val</span> find_dtree : <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Term/index.html#type-algebra">Term.algebra</a> * <span><span>(int * <a href="#type-dtree">dtree</a>)</span> option</span></span></code></div><div class="spec-doc"><p><code>find_dtree ar forest</code> returns a pair (arity,dtree) in given forest such that arity &lt;= ar. Returns <code>None</code> when not found.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_dtree" class="anchored"><a href="#val-pp_dtree" class="anchor"></a><code><span><span class="keyword">val</span> pp_dtree : <span><a href="#type-dtree">dtree</a> <a href="../Basic/index.html#type-printer">Basic.printer</a></span></span></code></div><div class="spec-doc"><p>Printer for a single decision tree.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pp_dforest" class="anchored"><a href="#val-pp_dforest" class="anchor"></a><code><span><span class="keyword">val</span> pp_dforest : <span><a href="#type-t">t</a> <a href="../Basic/index.html#type-printer">Basic.printer</a></span></span></code></div><div class="spec-doc"><p>Printer for forests of decision trees.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_rules" class="anchored"><a href="#val-of_rules" class="anchor"></a><code><span><span class="keyword">val</span> of_rules : <span><a href="../Basic/index.html#type-name">Basic.name</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(<span><a href="../Basic/index.html#type-name">Basic.name</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Term/index.html#type-algebra">Term.algebra</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="../Rule/index.html#type-rule_infos">Rule.rule_infos</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Compilation of rewrite rules into decision trees. Returns a list of arities and corresponding decision trees. Invariant : arities must be sorted in decreasing order. (see use case in <code>state_whnf</code> in <code>reduction.ml</code>) May raise Dtree_error.</p></div></div></div></body></html>