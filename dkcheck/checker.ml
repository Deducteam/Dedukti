open Basics

(* ********************************* *)

let verbose = ref false

let set_debug_level lvl =
  if lvl > 0 then ( verbose := true; Pp.print_db := true )

let eprint lc fmt =
  if !verbose then (
  let (l,c) = of_loc lc in
    Printf.eprintf "line:%i column:%i " l c;
    Printf.kfprintf (fun _ -> prerr_newline () ) stderr fmt
  ) else
    Printf.ifprintf stderr fmt

let print fmt =
  Printf.kfprintf (fun _ -> print_newline () ) stdout fmt

(* ********************************* *)
(*TODO move*)
let pp_context out = function
  | [] -> ()
  | ctx -> Printf.fprintf out " in context:\n%a" Pp.pp_context ctx

let fail_typing_error err =
  let open Typing in
    match err with
      | KindIsNotTypable -> Print.fail dloc "Kind is not typable."
      | ConvertibilityError (te,ctx,exp,inf) ->
(*   let exp = if !errors_in_snf then Reduction.snf exp else exp in *)
(*   let inf = if !errors_in_snf then Reduction.snf inf else inf in *)
          Print.fail (Term.get_loc te)
  "Error while typing '%a'%a.\nExpected: %a\nInferred: %a."
  Pp.pp_term te pp_context ctx Pp.pp_term exp Pp.pp_term inf
  | VariableNotFound (lc,x,n,ctx) ->
      Print.fail lc "The variable '%a' was not found in context:\n"
        Pp.pp_term (Term.mk_DB lc x n) Pp.pp_context ctx
  | SortExpected (te,ctx,inf) ->
(*   let inf = if !errors_in_snf then Reduction.snf inf else inf in *)
      Print.fail (Term.get_loc te)
  "Error while typing '%a'%a.\nExpected: a sort.\nInferred: %a."
  Pp.pp_term te pp_context ctx Pp.pp_term inf
  | ProductExpected (te,ctx,inf) ->
      (*   let inf = if !errors_in_snf then Reduction.snf inf else inf in *)
      Print.fail (Term.get_loc te)
        "Error while typing '%a'%a.\nExpected: a product type.\nInferred: %a."
        Pp.pp_term te pp_context ctx Pp.pp_term inf
  | InexpectedKind (te,ctx) ->
      Print.fail (Term.get_loc te)
        "Error while typing '%a'%a.\nExpected: anything but Kind.\nInferred: Kind."
        Pp.pp_term te pp_context ctx
  | DomainFreeLambda lc ->
      Print.fail lc "Cannot infer the type of domain-free lambda."

let fail_dtree_error err=
  let open Dtree in
    match err with
      | BoundVariableExpected pat ->
          Print.fail (Rule.get_loc_pat pat)
            "The pattern '%a' is not a bound variable." Pp.pp_pattern pat
  | VariableBoundOutsideTheGuard te ->
      Print.fail (Term.get_loc te)
        "The term '%a' contains a variable bound outside the brackets."
        Pp.pp_term te
  | NotEnoughArguments (lc,id,n) ->
   Print.fail lc "The variable '%a' must be applied to at least %i argument(s)."
     pp_ident id n
  | HeadSymbolMismatch (lc,hd1,hd2) ->
      Print.fail lc "Unexpected head symbol '%a' \ (expected '%a')."
        pp_ident hd1 pp_ident hd2
  | ArityMismatch (lc,id) ->
      Print.fail lc
        "All the rewrite rules for \ the symbol '%a' should have the same arity."
        pp_ident id
  | UnboundVariable (lc,x,pat) ->
      Print.fail lc "The variables '%a' is not bounded in '%a'."
        pp_ident x Pp.pp_pattern pat
  | AVariableIsNotAPattern (lc,id) ->
      Print.fail lc "A variable is not a valid pattern."

let fail_signature_error err =
  let open Signature in
    match err with
      | FailToCompileModule (lc,md) ->
          Print.fail lc "Fail to compile dependency '%a'." pp_ident md
      | UnmarshalBadVersionNumber (lc,md) ->
          Print.fail lc "Fail to open\ module '%s' (file generated by a different version?)." md
      | UnmarshalSysError (lc,md,msg) ->
          Print.fail lc "Fail to open module '%s' (%s)." md msg
      | UnmarshalUnknown (lc,md) ->
          Print.fail lc "Fail to open module '%s'." md
      | SymbolNotFound (lc,md,id) ->
          Print.fail lc "Cannot find symbol '%a.%a'." pp_ident md pp_ident id
      | AlreadyDefinedSymbol (lc,id) ->
          Print.fail lc "Already defined symbol '%a'." pp_ident id
      | CannotBuildDtree err -> fail_dtree_error err
      | CannotAddRewriteRules (lc,id) ->
          Print.fail lc
            "Cannot add rewrite\ rules for the defined symbol '%a'." pp_ident id

let fail = function
  | Env.EnvErrorSignature e -> fail_signature_error e
  | Env.EnvErrorType e -> fail_typing_error e

(* ********************************* *)

let mk_prelude lc name =
  eprint lc "Module name is '%a'." pp_ident name;
  Env.init name

let mk_declaration lc id pty : unit =
  eprint lc "Declaration of symbol '%a'." pp_ident id;
  match Env.declare lc id pty with
    | OK () -> ()
    | Err e -> fail e

let mk_definition lc id pty_opt pte : unit =
  eprint lc "Definition of symbol '%a'." pp_ident id ;
  match Env.define lc id pte pty_opt with
    | OK () -> ()
    | Err e -> fail e

let mk_opaque lc id pty_opt pte =
  eprint lc "Opaque definition of symbol '%a'." pp_ident id ;
  match Env.define_op lc id pte pty_opt with
    | OK () -> ()
    | Err e -> fail e

let mk_rules lst =
  List.iter (
    fun (ctx,pat,rhs) ->
      eprint (Rule.get_loc_pat pat) "%a" Pp.pp_rule (ctx,pat,rhs)
  ) lst ;
  match Env.add_rules lst with
    | OK () -> ()
    | Err e -> fail e

let mk_command = Cmd.mk_command

let export = ref false

let mk_ending () =
  if !export then
    if not (Env.export ()) then
      Print.fail dloc "Fail to export module '%a'." pp_ident (Env.get_name ())
