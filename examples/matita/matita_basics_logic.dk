(; This file was automatically generated from Matita. ;)

eq :
  cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
    (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
       (cic.type (cic.s (cic.s cic.z)))
       (cic.univ (cic.type (cic.s (cic.s cic.z))))
       (A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
        cic.prod (cic.type (cic.s (cic.s cic.z)))
          (cic.type (cic.s (cic.s cic.z))) A
          (_x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
           cic.prod (cic.type (cic.s (cic.s cic.z))) (cic.type cic.z) A
             (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
              cic.univ cic.prop)))).

refl :
  cic.Term cic.prop
    (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z)))) cic.prop
       (cic.univ (cic.type (cic.s (cic.s cic.z))))
       (A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
        cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop A
          (x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
           matita_basics_logic.eq
             (cic.lift (cic.type (cic.s (cic.s cic.z)))
                (cic.type (cic.s (cic.s cic.z))) A)
             x x))).

def match_eq_Prop :
      cic.Term cic.prop
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z)))) cic.prop
           (cic.univ (cic.type (cic.s (cic.s cic.z))))
           (A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
            cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop A
              (_x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop
                 (cic.prod (cic.type (cic.s (cic.s cic.z))) (cic.type cic.z)
                    A
                    (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                     cic.prod cic.prop (cic.type cic.z)
                       (matita_basics_logic.eq A _x __)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.eq A _x __) =>
                        cic.univ cic.prop)))
                 (return_type :
                    cic.Term (cic.type (cic.s (cic.s cic.z)))
                      (cic.prod (cic.type (cic.s (cic.s cic.z)))
                         (cic.type cic.z) A
                         (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                          cic.prod cic.prop (cic.type cic.z)
                            (matita_basics_logic.eq A _x __)
                            (z :
                               cic.Term cic.prop
                                 (matita_basics_logic.eq A _x __) =>
                             cic.univ cic.prop))) =>
                  cic.prod cic.prop cic.prop
                    (return_type _x (matita_basics_logic.refl A _x))
                    (case_refl :
                       cic.Term cic.prop
                         (return_type _x (matita_basics_logic.refl A _x)) =>
                     cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop A
                       (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                        cic.prod cic.prop cic.prop
                          (matita_basics_logic.eq A _x __)
                          (z :
                             cic.Term cic.prop
                               (matita_basics_logic.eq A _x __) =>
                           return_type __ z))))))).

[ A, _x, return_type, case_refl ]
  match_eq_Prop A _x return_type case_refl (_x)
    (matita_basics_logic.refl A _x) -->
  case_refl.

def match_eq_Type5 :
      cic.Term
        (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
           (cic.univ (cic.type (cic.s (cic.s cic.z))))
           (A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
            cic.prod (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
              A
              (_x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.prod
                 (cic.type
                    (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                 (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                 (cic.prod (cic.type (cic.s (cic.s cic.z)))
                    (cic.type
                       (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                    A
                    (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                     cic.prod cic.prop
                       (cic.type
                          (cic.s
                             (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                       (matita_basics_logic.eq A _x __)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.eq A _x __) =>
                        cic.univ
                          (cic.type
                             (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))))
                 (return_type :
                    cic.Term
                      (cic.type
                         (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                      (cic.prod (cic.type (cic.s (cic.s cic.z)))
                         (cic.type
                            (cic.s
                               (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                         A
                         (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                          cic.prod cic.prop
                            (cic.type
                               (cic.s
                                  (cic.s
                                     (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                            (matita_basics_logic.eq A _x __)
                            (z :
                               cic.Term cic.prop
                                 (matita_basics_logic.eq A _x __) =>
                             cic.univ
                               (cic.type
                                  (cic.s
                                     (cic.s (cic.s (cic.s (cic.s cic.z))))))))) =>
                  cic.prod
                    (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                    (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                    (return_type _x (matita_basics_logic.refl A _x))
                    (case_refl :
                       cic.Term
                         (cic.type
                            (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                         (return_type _x (matita_basics_logic.refl A _x)) =>
                     cic.prod (cic.type (cic.s (cic.s cic.z)))
                       (cic.type
                          (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                       A
                       (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                        cic.prod cic.prop
                          (cic.type
                             (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                          (matita_basics_logic.eq A _x __)
                          (z :
                             cic.Term cic.prop
                               (matita_basics_logic.eq A _x __) =>
                           return_type __ z))))))).

[ A, _x, return_type, case_refl ]
  match_eq_Type5 A _x return_type case_refl (_x)
    (matita_basics_logic.refl A _x) -->
  case_refl.

def match_eq_Type4 :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
           (cic.univ (cic.type (cic.s (cic.s cic.z))))
           (A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
            cic.prod (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))) A
              (_x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.prod
                 (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                 (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                 (cic.prod (cic.type (cic.s (cic.s cic.z)))
                    (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                    A
                    (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                     cic.prod cic.prop
                       (cic.type
                          (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                       (matita_basics_logic.eq A _x __)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.eq A _x __) =>
                        cic.univ
                          (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))))))
                 (return_type :
                    cic.Term
                      (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                      (cic.prod (cic.type (cic.s (cic.s cic.z)))
                         (cic.type
                            (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                         A
                         (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                          cic.prod cic.prop
                            (cic.type
                               (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                            (matita_basics_logic.eq A _x __)
                            (z :
                               cic.Term cic.prop
                                 (matita_basics_logic.eq A _x __) =>
                             cic.univ
                               (cic.type
                                  (cic.s (cic.s (cic.s (cic.s cic.z)))))))) =>
                  cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                    (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                    (return_type _x (matita_basics_logic.refl A _x))
                    (case_refl :
                       cic.Term
                         (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                         (return_type _x (matita_basics_logic.refl A _x)) =>
                     cic.prod (cic.type (cic.s (cic.s cic.z)))
                       (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))) A
                       (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                        cic.prod cic.prop
                          (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                          (matita_basics_logic.eq A _x __)
                          (z :
                             cic.Term cic.prop
                               (matita_basics_logic.eq A _x __) =>
                           return_type __ z))))))).

[ A, _x, return_type, case_refl ]
  match_eq_Type4 A _x return_type case_refl (_x)
    (matita_basics_logic.refl A _x) -->
  case_refl.

def match_eq_Type3 :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
           (cic.univ (cic.type (cic.s (cic.s cic.z))))
           (A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
            cic.prod (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))) A
              (_x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                 (cic.type (cic.s (cic.s (cic.s cic.z))))
                 (cic.prod (cic.type (cic.s (cic.s cic.z)))
                    (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))) A
                    (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                     cic.prod cic.prop
                       (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                       (matita_basics_logic.eq A _x __)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.eq A _x __) =>
                        cic.univ (cic.type (cic.s (cic.s (cic.s cic.z)))))))
                 (return_type :
                    cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                      (cic.prod (cic.type (cic.s (cic.s cic.z)))
                         (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))) A
                         (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                          cic.prod cic.prop
                            (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                            (matita_basics_logic.eq A _x __)
                            (z :
                               cic.Term cic.prop
                                 (matita_basics_logic.eq A _x __) =>
                             cic.univ
                               (cic.type (cic.s (cic.s (cic.s cic.z))))))) =>
                  cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
                    (cic.type (cic.s (cic.s (cic.s cic.z))))
                    (return_type _x (matita_basics_logic.refl A _x))
                    (case_refl :
                       cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                         (return_type _x (matita_basics_logic.refl A _x)) =>
                     cic.prod (cic.type (cic.s (cic.s cic.z)))
                       (cic.type (cic.s (cic.s (cic.s cic.z)))) A
                       (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                        cic.prod cic.prop
                          (cic.type (cic.s (cic.s (cic.s cic.z))))
                          (matita_basics_logic.eq A _x __)
                          (z :
                             cic.Term cic.prop
                               (matita_basics_logic.eq A _x __) =>
                           return_type __ z))))))).

[ A, _x, return_type, case_refl ]
  match_eq_Type3 A _x return_type case_refl (_x)
    (matita_basics_logic.refl A _x) -->
  case_refl.

def match_eq_Type2 :
      cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.univ (cic.type (cic.s (cic.s cic.z))))
           (A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
            cic.prod (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s (cic.s (cic.s cic.z)))) A
              (_x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
                 (cic.type (cic.s (cic.s cic.z)))
                 (cic.prod (cic.type (cic.s (cic.s cic.z)))
                    (cic.type (cic.s (cic.s (cic.s cic.z)))) A
                    (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                     cic.prod cic.prop
                       (cic.type (cic.s (cic.s (cic.s cic.z))))
                       (matita_basics_logic.eq A _x __)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.eq A _x __) =>
                        cic.univ (cic.type (cic.s (cic.s cic.z))))))
                 (return_type :
                    cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                      (cic.prod (cic.type (cic.s (cic.s cic.z)))
                         (cic.type (cic.s (cic.s (cic.s cic.z)))) A
                         (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                          cic.prod cic.prop
                            (cic.type (cic.s (cic.s (cic.s cic.z))))
                            (matita_basics_logic.eq A _x __)
                            (z :
                               cic.Term cic.prop
                                 (matita_basics_logic.eq A _x __) =>
                             cic.univ (cic.type (cic.s (cic.s cic.z)))))) =>
                  cic.prod (cic.type (cic.s (cic.s cic.z)))
                    (cic.type (cic.s (cic.s cic.z)))
                    (return_type _x (matita_basics_logic.refl A _x))
                    (case_refl :
                       cic.Term (cic.type (cic.s (cic.s cic.z)))
                         (return_type _x (matita_basics_logic.refl A _x)) =>
                     cic.prod (cic.type (cic.s (cic.s cic.z)))
                       (cic.type (cic.s (cic.s cic.z))) A
                       (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                        cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                          (matita_basics_logic.eq A _x __)
                          (z :
                             cic.Term cic.prop
                               (matita_basics_logic.eq A _x __) =>
                           return_type __ z))))))).

[ A, _x, return_type, case_refl ]
  match_eq_Type2 A _x return_type case_refl (_x)
    (matita_basics_logic.refl A _x) -->
  case_refl.

def match_eq_Type1 :
      cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.type (cic.s (cic.s cic.z)))
           (cic.univ (cic.type (cic.s (cic.s cic.z))))
           (A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
            cic.prod (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s (cic.s cic.z))) A
              (_x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.prod (cic.type (cic.s (cic.s cic.z)))
                 (cic.type (cic.s (cic.s cic.z)))
                 (cic.prod (cic.type (cic.s (cic.s cic.z)))
                    (cic.type (cic.s (cic.s cic.z))) A
                    (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                     cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                       (matita_basics_logic.eq A _x __)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.eq A _x __) =>
                        cic.univ (cic.type (cic.s cic.z)))))
                 (return_type :
                    cic.Term (cic.type (cic.s (cic.s cic.z)))
                      (cic.prod (cic.type (cic.s (cic.s cic.z)))
                         (cic.type (cic.s (cic.s cic.z))) A
                         (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                          cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                            (matita_basics_logic.eq A _x __)
                            (z :
                               cic.Term cic.prop
                                 (matita_basics_logic.eq A _x __) =>
                             cic.univ (cic.type (cic.s cic.z))))) =>
                  cic.prod (cic.type (cic.s cic.z))
                    (cic.type (cic.s (cic.s cic.z)))
                    (return_type _x (matita_basics_logic.refl A _x))
                    (case_refl :
                       cic.Term (cic.type (cic.s cic.z))
                         (return_type _x (matita_basics_logic.refl A _x)) =>
                     cic.prod (cic.type (cic.s (cic.s cic.z)))
                       (cic.type (cic.s cic.z)) A
                       (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                        cic.prod cic.prop (cic.type (cic.s cic.z))
                          (matita_basics_logic.eq A _x __)
                          (z :
                             cic.Term cic.prop
                               (matita_basics_logic.eq A _x __) =>
                           return_type __ z))))))).

[ A, _x, return_type, case_refl ]
  match_eq_Type1 A _x return_type case_refl (_x)
    (matita_basics_logic.refl A _x) -->
  case_refl.

def match_eq_Type0 :
      cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.type (cic.s (cic.s cic.z)))
           (cic.univ (cic.type (cic.s (cic.s cic.z))))
           (A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
            cic.prod (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s (cic.s cic.z))) A
              (_x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.prod (cic.type (cic.s (cic.s cic.z)))
                 (cic.type (cic.s (cic.s cic.z)))
                 (cic.prod (cic.type (cic.s (cic.s cic.z)))
                    (cic.type (cic.s cic.z)) A
                    (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                     cic.prod cic.prop (cic.type (cic.s cic.z))
                       (matita_basics_logic.eq A _x __)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.eq A _x __) =>
                        cic.univ (cic.type cic.z))))
                 (return_type :
                    cic.Term (cic.type (cic.s (cic.s cic.z)))
                      (cic.prod (cic.type (cic.s (cic.s cic.z)))
                         (cic.type (cic.s cic.z)) A
                         (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                          cic.prod cic.prop (cic.type (cic.s cic.z))
                            (matita_basics_logic.eq A _x __)
                            (z :
                               cic.Term cic.prop
                                 (matita_basics_logic.eq A _x __) =>
                             cic.univ (cic.type cic.z)))) =>
                  cic.prod (cic.type cic.z) (cic.type (cic.s (cic.s cic.z)))
                    (return_type _x (matita_basics_logic.refl A _x))
                    (case_refl :
                       cic.Term (cic.type cic.z)
                         (return_type _x (matita_basics_logic.refl A _x)) =>
                     cic.prod (cic.type (cic.s (cic.s cic.z)))
                       (cic.type cic.z) A
                       (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                        cic.prod cic.prop (cic.type cic.z)
                          (matita_basics_logic.eq A _x __)
                          (z :
                             cic.Term cic.prop
                               (matita_basics_logic.eq A _x __) =>
                           return_type __ z))))))).

[ A, _x, return_type, case_refl ]
  match_eq_Type0 A _x return_type case_refl (_x)
    (matita_basics_logic.refl A _x) -->
  case_refl.

def filter_eq_Prop :
      cic.Term cic.prop
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z)))) cic.prop
           (cic.univ (cic.type (cic.s (cic.s cic.z))))
           (A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
            cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop A
              (_x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop A
                 (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                  cic.prod (cic.type cic.z) cic.prop
                    (cic.prod cic.prop (cic.type cic.z)
                       (matita_basics_logic.eq A _x __)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.eq A _x __) =>
                        cic.univ cic.prop))
                    (return_type :
                       cic.Term (cic.type cic.z)
                         (cic.prod cic.prop (cic.type cic.z)
                            (matita_basics_logic.eq A _x __)
                            (z :
                               cic.Term cic.prop
                                 (matita_basics_logic.eq A _x __) =>
                             cic.univ cic.prop)) =>
                     cic.prod cic.prop cic.prop
                       (cic.prod cic.prop cic.prop
                          (matita_basics_logic.eq A _x __)
                          (z :
                             cic.Term cic.prop
                               (matita_basics_logic.eq A _x __) =>
                           return_type z))
                       (return :
                          cic.Term cic.prop
                            (cic.prod cic.prop cic.prop
                               (matita_basics_logic.eq A _x __)
                               (z :
                                  cic.Term cic.prop
                                    (matita_basics_logic.eq A _x __) =>
                                return_type z)) =>
                        cic.prod cic.prop cic.prop
                          (matita_basics_logic.eq A _x __)
                          (z :
                             cic.Term cic.prop
                               (matita_basics_logic.eq A _x __) =>
                           return_type z))))))).

[ A, x, return_type, return ]
  filter_eq_Prop (A) (x) (x) return_type return
    (matita_basics_logic.refl A x) -->
  return (matita_basics_logic.refl A x).

def filter_eq_Type5 :
      cic.Term
        (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
           (cic.univ (cic.type (cic.s (cic.s cic.z))))
           (A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
            cic.prod (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
              A
              (_x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.prod (cic.type (cic.s (cic.s cic.z)))
                 (cic.type
                    (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                 A
                 (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                  cic.prod
                    (cic.type
                       (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                    (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                    (cic.prod cic.prop
                       (cic.type
                          (cic.s
                             (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                       (matita_basics_logic.eq A _x __)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.eq A _x __) =>
                        cic.univ
                          (cic.type
                             (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))))
                    (return_type :
                       cic.Term
                         (cic.type
                            (cic.s
                               (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                         (cic.prod cic.prop
                            (cic.type
                               (cic.s
                                  (cic.s
                                     (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                            (matita_basics_logic.eq A _x __)
                            (z :
                               cic.Term cic.prop
                                 (matita_basics_logic.eq A _x __) =>
                             cic.univ
                               (cic.type
                                  (cic.s
                                     (cic.s (cic.s (cic.s (cic.s cic.z)))))))) =>
                     cic.prod
                       (cic.type
                          (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                       (cic.type
                          (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                       (cic.prod cic.prop
                          (cic.type
                             (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                          (matita_basics_logic.eq A _x __)
                          (z :
                             cic.Term cic.prop
                               (matita_basics_logic.eq A _x __) =>
                           return_type z))
                       (return :
                          cic.Term
                            (cic.type
                               (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                            (cic.prod cic.prop
                               (cic.type
                                  (cic.s
                                     (cic.s (cic.s (cic.s (cic.s cic.z))))))
                               (matita_basics_logic.eq A _x __)
                               (z :
                                  cic.Term cic.prop
                                    (matita_basics_logic.eq A _x __) =>
                                return_type z)) =>
                        cic.prod cic.prop
                          (cic.type
                             (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                          (matita_basics_logic.eq A _x __)
                          (z :
                             cic.Term cic.prop
                               (matita_basics_logic.eq A _x __) =>
                           return_type z))))))).

[ A, x, return_type, return ]
  filter_eq_Type5 (A) (x) (x) return_type return
    (matita_basics_logic.refl A x) -->
  return (matita_basics_logic.refl A x).

def filter_eq_Type4 :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
           (cic.univ (cic.type (cic.s (cic.s cic.z))))
           (A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
            cic.prod (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))) A
              (_x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.prod (cic.type (cic.s (cic.s cic.z)))
                 (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))) A
                 (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                  cic.prod
                    (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                    (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                    (cic.prod cic.prop
                       (cic.type
                          (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                       (matita_basics_logic.eq A _x __)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.eq A _x __) =>
                        cic.univ
                          (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                    (return_type :
                       cic.Term
                         (cic.type
                            (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                         (cic.prod cic.prop
                            (cic.type
                               (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                            (matita_basics_logic.eq A _x __)
                            (z :
                               cic.Term cic.prop
                                 (matita_basics_logic.eq A _x __) =>
                             cic.univ
                               (cic.type
                                  (cic.s (cic.s (cic.s (cic.s cic.z))))))) =>
                     cic.prod
                       (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                       (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                       (cic.prod cic.prop
                          (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                          (matita_basics_logic.eq A _x __)
                          (z :
                             cic.Term cic.prop
                               (matita_basics_logic.eq A _x __) =>
                           return_type z))
                       (return :
                          cic.Term
                            (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                            (cic.prod cic.prop
                               (cic.type
                                  (cic.s (cic.s (cic.s (cic.s cic.z)))))
                               (matita_basics_logic.eq A _x __)
                               (z :
                                  cic.Term cic.prop
                                    (matita_basics_logic.eq A _x __) =>
                                return_type z)) =>
                        cic.prod cic.prop
                          (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                          (matita_basics_logic.eq A _x __)
                          (z :
                             cic.Term cic.prop
                               (matita_basics_logic.eq A _x __) =>
                           return_type z))))))).

[ A, x, return_type, return ]
  filter_eq_Type4 (A) (x) (x) return_type return
    (matita_basics_logic.refl A x) -->
  return (matita_basics_logic.refl A x).

def filter_eq_Type3 :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
           (cic.univ (cic.type (cic.s (cic.s cic.z))))
           (A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
            cic.prod (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))) A
              (_x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.prod (cic.type (cic.s (cic.s cic.z)))
                 (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))) A
                 (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                  cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                    (cic.type (cic.s (cic.s (cic.s cic.z))))
                    (cic.prod cic.prop
                       (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                       (matita_basics_logic.eq A _x __)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.eq A _x __) =>
                        cic.univ (cic.type (cic.s (cic.s (cic.s cic.z))))))
                    (return_type :
                       cic.Term
                         (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                         (cic.prod cic.prop
                            (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                            (matita_basics_logic.eq A _x __)
                            (z :
                               cic.Term cic.prop
                                 (matita_basics_logic.eq A _x __) =>
                             cic.univ
                               (cic.type (cic.s (cic.s (cic.s cic.z)))))) =>
                     cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
                       (cic.type (cic.s (cic.s (cic.s cic.z))))
                       (cic.prod cic.prop
                          (cic.type (cic.s (cic.s (cic.s cic.z))))
                          (matita_basics_logic.eq A _x __)
                          (z :
                             cic.Term cic.prop
                               (matita_basics_logic.eq A _x __) =>
                           return_type z))
                       (return :
                          cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                            (cic.prod cic.prop
                               (cic.type (cic.s (cic.s (cic.s cic.z))))
                               (matita_basics_logic.eq A _x __)
                               (z :
                                  cic.Term cic.prop
                                    (matita_basics_logic.eq A _x __) =>
                                return_type z)) =>
                        cic.prod cic.prop
                          (cic.type (cic.s (cic.s (cic.s cic.z))))
                          (matita_basics_logic.eq A _x __)
                          (z :
                             cic.Term cic.prop
                               (matita_basics_logic.eq A _x __) =>
                           return_type z))))))).

[ A, x, return_type, return ]
  filter_eq_Type3 (A) (x) (x) return_type return
    (matita_basics_logic.refl A x) -->
  return (matita_basics_logic.refl A x).

def filter_eq_Type2 :
      cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.univ (cic.type (cic.s (cic.s cic.z))))
           (A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
            cic.prod (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s (cic.s (cic.s cic.z)))) A
              (_x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.prod (cic.type (cic.s (cic.s cic.z)))
                 (cic.type (cic.s (cic.s (cic.s cic.z)))) A
                 (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                  cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
                    (cic.type (cic.s (cic.s cic.z)))
                    (cic.prod cic.prop
                       (cic.type (cic.s (cic.s (cic.s cic.z))))
                       (matita_basics_logic.eq A _x __)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.eq A _x __) =>
                        cic.univ (cic.type (cic.s (cic.s cic.z)))))
                    (return_type :
                       cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                         (cic.prod cic.prop
                            (cic.type (cic.s (cic.s (cic.s cic.z))))
                            (matita_basics_logic.eq A _x __)
                            (z :
                               cic.Term cic.prop
                                 (matita_basics_logic.eq A _x __) =>
                             cic.univ (cic.type (cic.s (cic.s cic.z))))) =>
                     cic.prod (cic.type (cic.s (cic.s cic.z)))
                       (cic.type (cic.s (cic.s cic.z)))
                       (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                          (matita_basics_logic.eq A _x __)
                          (z :
                             cic.Term cic.prop
                               (matita_basics_logic.eq A _x __) =>
                           return_type z))
                       (return :
                          cic.Term (cic.type (cic.s (cic.s cic.z)))
                            (cic.prod cic.prop
                               (cic.type (cic.s (cic.s cic.z)))
                               (matita_basics_logic.eq A _x __)
                               (z :
                                  cic.Term cic.prop
                                    (matita_basics_logic.eq A _x __) =>
                                return_type z)) =>
                        cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                          (matita_basics_logic.eq A _x __)
                          (z :
                             cic.Term cic.prop
                               (matita_basics_logic.eq A _x __) =>
                           return_type z))))))).

[ A, x, return_type, return ]
  filter_eq_Type2 (A) (x) (x) return_type return
    (matita_basics_logic.refl A x) -->
  return (matita_basics_logic.refl A x).

def filter_eq_Type1 :
      cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.type (cic.s (cic.s cic.z)))
           (cic.univ (cic.type (cic.s (cic.s cic.z))))
           (A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
            cic.prod (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s (cic.s cic.z))) A
              (_x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.prod (cic.type (cic.s (cic.s cic.z)))
                 (cic.type (cic.s (cic.s cic.z))) A
                 (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                  cic.prod (cic.type (cic.s (cic.s cic.z)))
                    (cic.type (cic.s cic.z))
                    (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                       (matita_basics_logic.eq A _x __)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.eq A _x __) =>
                        cic.univ (cic.type (cic.s cic.z))))
                    (return_type :
                       cic.Term (cic.type (cic.s (cic.s cic.z)))
                         (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                            (matita_basics_logic.eq A _x __)
                            (z :
                               cic.Term cic.prop
                                 (matita_basics_logic.eq A _x __) =>
                             cic.univ (cic.type (cic.s cic.z)))) =>
                     cic.prod (cic.type (cic.s cic.z))
                       (cic.type (cic.s cic.z))
                       (cic.prod cic.prop (cic.type (cic.s cic.z))
                          (matita_basics_logic.eq A _x __)
                          (z :
                             cic.Term cic.prop
                               (matita_basics_logic.eq A _x __) =>
                           return_type z))
                       (return :
                          cic.Term (cic.type (cic.s cic.z))
                            (cic.prod cic.prop (cic.type (cic.s cic.z))
                               (matita_basics_logic.eq A _x __)
                               (z :
                                  cic.Term cic.prop
                                    (matita_basics_logic.eq A _x __) =>
                                return_type z)) =>
                        cic.prod cic.prop (cic.type (cic.s cic.z))
                          (matita_basics_logic.eq A _x __)
                          (z :
                             cic.Term cic.prop
                               (matita_basics_logic.eq A _x __) =>
                           return_type z))))))).

[ A, x, return_type, return ]
  filter_eq_Type1 (A) (x) (x) return_type return
    (matita_basics_logic.refl A x) -->
  return (matita_basics_logic.refl A x).

def filter_eq_Type0 :
      cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.type (cic.s (cic.s cic.z)))
           (cic.univ (cic.type (cic.s (cic.s cic.z))))
           (A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
            cic.prod (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s (cic.s cic.z))) A
              (_x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.prod (cic.type (cic.s (cic.s cic.z)))
                 (cic.type (cic.s cic.z)) A
                 (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                  cic.prod (cic.type (cic.s cic.z)) (cic.type cic.z)
                    (cic.prod cic.prop (cic.type (cic.s cic.z))
                       (matita_basics_logic.eq A _x __)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.eq A _x __) =>
                        cic.univ (cic.type cic.z)))
                    (return_type :
                       cic.Term (cic.type (cic.s cic.z))
                         (cic.prod cic.prop (cic.type (cic.s cic.z))
                            (matita_basics_logic.eq A _x __)
                            (z :
                               cic.Term cic.prop
                                 (matita_basics_logic.eq A _x __) =>
                             cic.univ (cic.type cic.z))) =>
                     cic.prod (cic.type cic.z) (cic.type cic.z)
                       (cic.prod cic.prop (cic.type cic.z)
                          (matita_basics_logic.eq A _x __)
                          (z :
                             cic.Term cic.prop
                               (matita_basics_logic.eq A _x __) =>
                           return_type z))
                       (return :
                          cic.Term (cic.type cic.z)
                            (cic.prod cic.prop (cic.type cic.z)
                               (matita_basics_logic.eq A _x __)
                               (z :
                                  cic.Term cic.prop
                                    (matita_basics_logic.eq A _x __) =>
                                return_type z)) =>
                        cic.prod cic.prop (cic.type cic.z)
                          (matita_basics_logic.eq A _x __)
                          (z :
                             cic.Term cic.prop
                               (matita_basics_logic.eq A _x __) =>
                           return_type z))))))).

[ A, x, return_type, return ]
  filter_eq_Type0 (A) (x) (x) return_type return
    (matita_basics_logic.refl A x) -->
  return (matita_basics_logic.refl A x).

def eq_ind :
      cic.Term cic.prop
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z)))) cic.prop
           (cic.univ (cic.type (cic.s (cic.s cic.z))))
           (A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
            cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop A
              (_x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop
                 (cic.prod (cic.type (cic.s (cic.s cic.z))) (cic.type cic.z)
                    A
                    (x_1 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                     cic.prod cic.prop (cic.type cic.z)
                       (matita_basics_logic.eq
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          _x x_1)
                       (_x_2 :
                          cic.Term cic.prop
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x x_1) =>
                        cic.univ cic.prop)))
                 (Q_ :
                    cic.Term (cic.type (cic.s (cic.s cic.z)))
                      (cic.prod (cic.type (cic.s (cic.s cic.z)))
                         (cic.type cic.z) A
                         (x_1 :
                            cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                          cic.prod cic.prop (cic.type cic.z)
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x x_1)
                            (_x_2 :
                               cic.Term cic.prop
                                 (matita_basics_logic.eq
                                    (cic.lift
                                       (cic.type (cic.s (cic.s cic.z)))
                                       (cic.type (cic.s (cic.s cic.z))) A)
                                    _x x_1) =>
                             cic.univ cic.prop))) =>
                  cic.prod cic.prop cic.prop
                    (Q_ _x
                       (matita_basics_logic.refl
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          _x))
                    (_H_refl :
                       cic.Term cic.prop
                         (Q_ _x
                            (matita_basics_logic.refl
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x)) =>
                     cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop A
                       (x_1 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                        cic.prod cic.prop cic.prop
                          (matita_basics_logic.eq
                             (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                (cic.type (cic.s (cic.s cic.z))) A)
                             _x x_1)
                          (x_2 :
                             cic.Term cic.prop
                               (matita_basics_logic.eq
                                  (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                     (cic.type (cic.s (cic.s cic.z))) A)
                                  _x x_1) =>
                           Q_ x_1 x_2))))))).

def eq_ind_body :
      cic.Term cic.prop
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z)))) cic.prop
           (cic.univ (cic.type (cic.s (cic.s cic.z))))
           (A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
            cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop A
              (_x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop
                 (cic.prod (cic.type (cic.s (cic.s cic.z))) (cic.type cic.z)
                    A
                    (x_1 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                     cic.prod cic.prop (cic.type cic.z)
                       (matita_basics_logic.eq
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          _x x_1)
                       (_x_2 :
                          cic.Term cic.prop
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x x_1) =>
                        cic.univ cic.prop)))
                 (Q_ :
                    cic.Term (cic.type (cic.s (cic.s cic.z)))
                      (cic.prod (cic.type (cic.s (cic.s cic.z)))
                         (cic.type cic.z) A
                         (x_1 :
                            cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                          cic.prod cic.prop (cic.type cic.z)
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x x_1)
                            (_x_2 :
                               cic.Term cic.prop
                                 (matita_basics_logic.eq
                                    (cic.lift
                                       (cic.type (cic.s (cic.s cic.z)))
                                       (cic.type (cic.s (cic.s cic.z))) A)
                                    _x x_1) =>
                             cic.univ cic.prop))) =>
                  cic.prod cic.prop cic.prop
                    (Q_ _x
                       (matita_basics_logic.refl
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          _x))
                    (_H_refl :
                       cic.Term cic.prop
                         (Q_ _x
                            (matita_basics_logic.refl
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x)) =>
                     cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop A
                       (x_1 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                        cic.prod cic.prop cic.prop
                          (matita_basics_logic.eq
                             (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                (cic.type (cic.s (cic.s cic.z))) A)
                             _x x_1)
                          (x_2 :
                             cic.Term cic.prop
                               (matita_basics_logic.eq
                                  (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                     (cic.type (cic.s (cic.s cic.z))) A)
                                  _x x_1) =>
                           Q_ x_1 x_2))))))).

[ A, _x, Q_, _H_refl, x_1, x_2 ] eq_ind A _x Q_ _H_refl x_1 x_2 -->
  matita_basics_logic.filter_eq_Prop A _x x_1
    (x_2 :
       cic.Term cic.prop
         (matita_basics_logic.eq
            (cic.lift (cic.type (cic.s (cic.s cic.z)))
               (cic.type (cic.s (cic.s cic.z))) A)
            _x x_1) =>
     Q_ x_1 x_2)
    (matita_basics_logic.eq_ind_body A _x Q_ _H_refl x_1) x_2.

[ A, _x, Q_, _H_refl, x_1, x_2 ] eq_ind_body A _x Q_ _H_refl x_1 x_2 -->
  matita_basics_logic.match_eq_Prop
    (cic.lift (cic.type (cic.s (cic.s cic.z)))
       (cic.type (cic.s (cic.s cic.z))) A)
    _x Q_ _H_refl x_1 x_2.

def eq_rect_Type4 :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
           (cic.univ (cic.type (cic.s (cic.s cic.z))))
           (A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
            cic.prod (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))) A
              (_x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.prod
                 (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                 (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                 (cic.prod (cic.type (cic.s (cic.s cic.z)))
                    (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                    A
                    (x_4 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                     cic.prod cic.prop
                       (cic.type
                          (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                       (matita_basics_logic.eq
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          _x x_4)
                       (_x_5 :
                          cic.Term cic.prop
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x x_4) =>
                        cic.univ
                          (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))))))
                 (Q_ :
                    cic.Term
                      (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                      (cic.prod (cic.type (cic.s (cic.s cic.z)))
                         (cic.type
                            (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                         A
                         (x_4 :
                            cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                          cic.prod cic.prop
                            (cic.type
                               (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x x_4)
                            (_x_5 :
                               cic.Term cic.prop
                                 (matita_basics_logic.eq
                                    (cic.lift
                                       (cic.type (cic.s (cic.s cic.z)))
                                       (cic.type (cic.s (cic.s cic.z))) A)
                                    _x x_4) =>
                             cic.univ
                               (cic.type
                                  (cic.s (cic.s (cic.s (cic.s cic.z)))))))) =>
                  cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                    (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                    (Q_ _x
                       (matita_basics_logic.refl
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          _x))
                    (_H_refl :
                       cic.Term
                         (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                         (Q_ _x
                            (matita_basics_logic.refl
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x)) =>
                     cic.prod (cic.type (cic.s (cic.s cic.z)))
                       (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))) A
                       (x_4 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                        cic.prod cic.prop
                          (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                          (matita_basics_logic.eq
                             (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                (cic.type (cic.s (cic.s cic.z))) A)
                             _x x_4)
                          (x_5 :
                             cic.Term cic.prop
                               (matita_basics_logic.eq
                                  (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                     (cic.type (cic.s (cic.s cic.z))) A)
                                  _x x_4) =>
                           Q_ x_4 x_5))))))).

def eq_rect_Type4_body :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
           (cic.univ (cic.type (cic.s (cic.s cic.z))))
           (A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
            cic.prod (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))) A
              (_x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.prod
                 (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                 (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                 (cic.prod (cic.type (cic.s (cic.s cic.z)))
                    (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                    A
                    (x_4 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                     cic.prod cic.prop
                       (cic.type
                          (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                       (matita_basics_logic.eq
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          _x x_4)
                       (_x_5 :
                          cic.Term cic.prop
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x x_4) =>
                        cic.univ
                          (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))))))
                 (Q_ :
                    cic.Term
                      (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                      (cic.prod (cic.type (cic.s (cic.s cic.z)))
                         (cic.type
                            (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                         A
                         (x_4 :
                            cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                          cic.prod cic.prop
                            (cic.type
                               (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x x_4)
                            (_x_5 :
                               cic.Term cic.prop
                                 (matita_basics_logic.eq
                                    (cic.lift
                                       (cic.type (cic.s (cic.s cic.z)))
                                       (cic.type (cic.s (cic.s cic.z))) A)
                                    _x x_4) =>
                             cic.univ
                               (cic.type
                                  (cic.s (cic.s (cic.s (cic.s cic.z)))))))) =>
                  cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                    (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                    (Q_ _x
                       (matita_basics_logic.refl
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          _x))
                    (_H_refl :
                       cic.Term
                         (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                         (Q_ _x
                            (matita_basics_logic.refl
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x)) =>
                     cic.prod (cic.type (cic.s (cic.s cic.z)))
                       (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))) A
                       (x_4 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                        cic.prod cic.prop
                          (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                          (matita_basics_logic.eq
                             (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                (cic.type (cic.s (cic.s cic.z))) A)
                             _x x_4)
                          (x_5 :
                             cic.Term cic.prop
                               (matita_basics_logic.eq
                                  (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                     (cic.type (cic.s (cic.s cic.z))) A)
                                  _x x_4) =>
                           Q_ x_4 x_5))))))).

[ A, _x, Q_, _H_refl, x_4, x_5 ] eq_rect_Type4 A _x Q_ _H_refl x_4 x_5 -->
  matita_basics_logic.filter_eq_Type4 A _x x_4
    (x_5 :
       cic.Term cic.prop
         (matita_basics_logic.eq
            (cic.lift (cic.type (cic.s (cic.s cic.z)))
               (cic.type (cic.s (cic.s cic.z))) A)
            _x x_4) =>
     Q_ x_4 x_5)
    (matita_basics_logic.eq_rect_Type4_body A _x Q_ _H_refl x_4) x_5.

[ A, _x, Q_, _H_refl, x_4, x_5 ]
  eq_rect_Type4_body A _x Q_ _H_refl x_4 x_5 -->
  matita_basics_logic.match_eq_Type4
    (cic.lift (cic.type (cic.s (cic.s cic.z)))
       (cic.type (cic.s (cic.s cic.z))) A)
    _x Q_ _H_refl x_4 x_5.

def eq_rect_Type5 :
      cic.Term
        (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
           (cic.univ (cic.type (cic.s (cic.s cic.z))))
           (A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
            cic.prod (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
              A
              (_x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.prod
                 (cic.type
                    (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                 (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                 (cic.prod (cic.type (cic.s (cic.s cic.z)))
                    (cic.type
                       (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                    A
                    (x_7 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                     cic.prod cic.prop
                       (cic.type
                          (cic.s
                             (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                       (matita_basics_logic.eq
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          _x x_7)
                       (_x_8 :
                          cic.Term cic.prop
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x x_7) =>
                        cic.univ
                          (cic.type
                             (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))))
                 (Q_ :
                    cic.Term
                      (cic.type
                         (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                      (cic.prod (cic.type (cic.s (cic.s cic.z)))
                         (cic.type
                            (cic.s
                               (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                         A
                         (x_7 :
                            cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                          cic.prod cic.prop
                            (cic.type
                               (cic.s
                                  (cic.s
                                     (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x x_7)
                            (_x_8 :
                               cic.Term cic.prop
                                 (matita_basics_logic.eq
                                    (cic.lift
                                       (cic.type (cic.s (cic.s cic.z)))
                                       (cic.type (cic.s (cic.s cic.z))) A)
                                    _x x_7) =>
                             cic.univ
                               (cic.type
                                  (cic.s
                                     (cic.s (cic.s (cic.s (cic.s cic.z))))))))) =>
                  cic.prod
                    (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                    (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                    (Q_ _x
                       (matita_basics_logic.refl
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          _x))
                    (_H_refl :
                       cic.Term
                         (cic.type
                            (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                         (Q_ _x
                            (matita_basics_logic.refl
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x)) =>
                     cic.prod (cic.type (cic.s (cic.s cic.z)))
                       (cic.type
                          (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                       A
                       (x_7 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                        cic.prod cic.prop
                          (cic.type
                             (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                          (matita_basics_logic.eq
                             (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                (cic.type (cic.s (cic.s cic.z))) A)
                             _x x_7)
                          (x_8 :
                             cic.Term cic.prop
                               (matita_basics_logic.eq
                                  (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                     (cic.type (cic.s (cic.s cic.z))) A)
                                  _x x_7) =>
                           Q_ x_7 x_8))))))).

def eq_rect_Type5_body :
      cic.Term
        (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
           (cic.univ (cic.type (cic.s (cic.s cic.z))))
           (A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
            cic.prod (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
              A
              (_x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.prod
                 (cic.type
                    (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                 (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                 (cic.prod (cic.type (cic.s (cic.s cic.z)))
                    (cic.type
                       (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                    A
                    (x_7 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                     cic.prod cic.prop
                       (cic.type
                          (cic.s
                             (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                       (matita_basics_logic.eq
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          _x x_7)
                       (_x_8 :
                          cic.Term cic.prop
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x x_7) =>
                        cic.univ
                          (cic.type
                             (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))))
                 (Q_ :
                    cic.Term
                      (cic.type
                         (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                      (cic.prod (cic.type (cic.s (cic.s cic.z)))
                         (cic.type
                            (cic.s
                               (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                         A
                         (x_7 :
                            cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                          cic.prod cic.prop
                            (cic.type
                               (cic.s
                                  (cic.s
                                     (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x x_7)
                            (_x_8 :
                               cic.Term cic.prop
                                 (matita_basics_logic.eq
                                    (cic.lift
                                       (cic.type (cic.s (cic.s cic.z)))
                                       (cic.type (cic.s (cic.s cic.z))) A)
                                    _x x_7) =>
                             cic.univ
                               (cic.type
                                  (cic.s
                                     (cic.s (cic.s (cic.s (cic.s cic.z))))))))) =>
                  cic.prod
                    (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                    (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                    (Q_ _x
                       (matita_basics_logic.refl
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          _x))
                    (_H_refl :
                       cic.Term
                         (cic.type
                            (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                         (Q_ _x
                            (matita_basics_logic.refl
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x)) =>
                     cic.prod (cic.type (cic.s (cic.s cic.z)))
                       (cic.type
                          (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                       A
                       (x_7 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                        cic.prod cic.prop
                          (cic.type
                             (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                          (matita_basics_logic.eq
                             (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                (cic.type (cic.s (cic.s cic.z))) A)
                             _x x_7)
                          (x_8 :
                             cic.Term cic.prop
                               (matita_basics_logic.eq
                                  (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                     (cic.type (cic.s (cic.s cic.z))) A)
                                  _x x_7) =>
                           Q_ x_7 x_8))))))).

[ A, _x, Q_, _H_refl, x_7, x_8 ] eq_rect_Type5 A _x Q_ _H_refl x_7 x_8 -->
  matita_basics_logic.filter_eq_Type5 A _x x_7
    (x_8 :
       cic.Term cic.prop
         (matita_basics_logic.eq
            (cic.lift (cic.type (cic.s (cic.s cic.z)))
               (cic.type (cic.s (cic.s cic.z))) A)
            _x x_7) =>
     Q_ x_7 x_8)
    (matita_basics_logic.eq_rect_Type5_body A _x Q_ _H_refl x_7) x_8.

[ A, _x, Q_, _H_refl, x_7, x_8 ]
  eq_rect_Type5_body A _x Q_ _H_refl x_7 x_8 -->
  matita_basics_logic.match_eq_Type5
    (cic.lift (cic.type (cic.s (cic.s cic.z)))
       (cic.type (cic.s (cic.s cic.z))) A)
    _x Q_ _H_refl x_7 x_8.

def eq_rect_Type3 :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
           (cic.univ (cic.type (cic.s (cic.s cic.z))))
           (A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
            cic.prod (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))) A
              (_x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                 (cic.type (cic.s (cic.s (cic.s cic.z))))
                 (cic.prod (cic.type (cic.s (cic.s cic.z)))
                    (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))) A
                    (x_10 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                     cic.prod cic.prop
                       (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                       (matita_basics_logic.eq
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          _x x_10)
                       (_x_11 :
                          cic.Term cic.prop
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x x_10) =>
                        cic.univ (cic.type (cic.s (cic.s (cic.s cic.z)))))))
                 (Q_ :
                    cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                      (cic.prod (cic.type (cic.s (cic.s cic.z)))
                         (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))) A
                         (x_10 :
                            cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                          cic.prod cic.prop
                            (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x x_10)
                            (_x_11 :
                               cic.Term cic.prop
                                 (matita_basics_logic.eq
                                    (cic.lift
                                       (cic.type (cic.s (cic.s cic.z)))
                                       (cic.type (cic.s (cic.s cic.z))) A)
                                    _x x_10) =>
                             cic.univ
                               (cic.type (cic.s (cic.s (cic.s cic.z))))))) =>
                  cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
                    (cic.type (cic.s (cic.s (cic.s cic.z))))
                    (Q_ _x
                       (matita_basics_logic.refl
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          _x))
                    (_H_refl :
                       cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                         (Q_ _x
                            (matita_basics_logic.refl
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x)) =>
                     cic.prod (cic.type (cic.s (cic.s cic.z)))
                       (cic.type (cic.s (cic.s (cic.s cic.z)))) A
                       (x_10 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                        cic.prod cic.prop
                          (cic.type (cic.s (cic.s (cic.s cic.z))))
                          (matita_basics_logic.eq
                             (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                (cic.type (cic.s (cic.s cic.z))) A)
                             _x x_10)
                          (x_11 :
                             cic.Term cic.prop
                               (matita_basics_logic.eq
                                  (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                     (cic.type (cic.s (cic.s cic.z))) A)
                                  _x x_10) =>
                           Q_ x_10 x_11))))))).

def eq_rect_Type3_body :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
           (cic.univ (cic.type (cic.s (cic.s cic.z))))
           (A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
            cic.prod (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))) A
              (_x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                 (cic.type (cic.s (cic.s (cic.s cic.z))))
                 (cic.prod (cic.type (cic.s (cic.s cic.z)))
                    (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))) A
                    (x_10 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                     cic.prod cic.prop
                       (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                       (matita_basics_logic.eq
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          _x x_10)
                       (_x_11 :
                          cic.Term cic.prop
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x x_10) =>
                        cic.univ (cic.type (cic.s (cic.s (cic.s cic.z)))))))
                 (Q_ :
                    cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                      (cic.prod (cic.type (cic.s (cic.s cic.z)))
                         (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))) A
                         (x_10 :
                            cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                          cic.prod cic.prop
                            (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x x_10)
                            (_x_11 :
                               cic.Term cic.prop
                                 (matita_basics_logic.eq
                                    (cic.lift
                                       (cic.type (cic.s (cic.s cic.z)))
                                       (cic.type (cic.s (cic.s cic.z))) A)
                                    _x x_10) =>
                             cic.univ
                               (cic.type (cic.s (cic.s (cic.s cic.z))))))) =>
                  cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
                    (cic.type (cic.s (cic.s (cic.s cic.z))))
                    (Q_ _x
                       (matita_basics_logic.refl
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          _x))
                    (_H_refl :
                       cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                         (Q_ _x
                            (matita_basics_logic.refl
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x)) =>
                     cic.prod (cic.type (cic.s (cic.s cic.z)))
                       (cic.type (cic.s (cic.s (cic.s cic.z)))) A
                       (x_10 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                        cic.prod cic.prop
                          (cic.type (cic.s (cic.s (cic.s cic.z))))
                          (matita_basics_logic.eq
                             (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                (cic.type (cic.s (cic.s cic.z))) A)
                             _x x_10)
                          (x_11 :
                             cic.Term cic.prop
                               (matita_basics_logic.eq
                                  (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                     (cic.type (cic.s (cic.s cic.z))) A)
                                  _x x_10) =>
                           Q_ x_10 x_11))))))).

[ A, _x, Q_, _H_refl, x_10, x_11 ]
  eq_rect_Type3 A _x Q_ _H_refl x_10 x_11 -->
  matita_basics_logic.filter_eq_Type3 A _x x_10
    (x_11 :
       cic.Term cic.prop
         (matita_basics_logic.eq
            (cic.lift (cic.type (cic.s (cic.s cic.z)))
               (cic.type (cic.s (cic.s cic.z))) A)
            _x x_10) =>
     Q_ x_10 x_11)
    (matita_basics_logic.eq_rect_Type3_body A _x Q_ _H_refl x_10) x_11.

[ A, _x, Q_, _H_refl, x_10, x_11 ]
  eq_rect_Type3_body A _x Q_ _H_refl x_10 x_11 -->
  matita_basics_logic.match_eq_Type3
    (cic.lift (cic.type (cic.s (cic.s cic.z)))
       (cic.type (cic.s (cic.s cic.z))) A)
    _x Q_ _H_refl x_10 x_11.

def eq_rect_Type2 :
      cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.univ (cic.type (cic.s (cic.s cic.z))))
           (A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
            cic.prod (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s (cic.s (cic.s cic.z)))) A
              (_x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
                 (cic.type (cic.s (cic.s cic.z)))
                 (cic.prod (cic.type (cic.s (cic.s cic.z)))
                    (cic.type (cic.s (cic.s (cic.s cic.z)))) A
                    (x_13 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                     cic.prod cic.prop
                       (cic.type (cic.s (cic.s (cic.s cic.z))))
                       (matita_basics_logic.eq
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          _x x_13)
                       (_x_14 :
                          cic.Term cic.prop
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x x_13) =>
                        cic.univ (cic.type (cic.s (cic.s cic.z))))))
                 (Q_ :
                    cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                      (cic.prod (cic.type (cic.s (cic.s cic.z)))
                         (cic.type (cic.s (cic.s (cic.s cic.z)))) A
                         (x_13 :
                            cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                          cic.prod cic.prop
                            (cic.type (cic.s (cic.s (cic.s cic.z))))
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x x_13)
                            (_x_14 :
                               cic.Term cic.prop
                                 (matita_basics_logic.eq
                                    (cic.lift
                                       (cic.type (cic.s (cic.s cic.z)))
                                       (cic.type (cic.s (cic.s cic.z))) A)
                                    _x x_13) =>
                             cic.univ (cic.type (cic.s (cic.s cic.z)))))) =>
                  cic.prod (cic.type (cic.s (cic.s cic.z)))
                    (cic.type (cic.s (cic.s cic.z)))
                    (Q_ _x
                       (matita_basics_logic.refl
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          _x))
                    (_H_refl :
                       cic.Term (cic.type (cic.s (cic.s cic.z)))
                         (Q_ _x
                            (matita_basics_logic.refl
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x)) =>
                     cic.prod (cic.type (cic.s (cic.s cic.z)))
                       (cic.type (cic.s (cic.s cic.z))) A
                       (x_13 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                        cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                          (matita_basics_logic.eq
                             (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                (cic.type (cic.s (cic.s cic.z))) A)
                             _x x_13)
                          (x_14 :
                             cic.Term cic.prop
                               (matita_basics_logic.eq
                                  (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                     (cic.type (cic.s (cic.s cic.z))) A)
                                  _x x_13) =>
                           Q_ x_13 x_14))))))).

def eq_rect_Type2_body :
      cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.univ (cic.type (cic.s (cic.s cic.z))))
           (A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
            cic.prod (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s (cic.s (cic.s cic.z)))) A
              (_x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
                 (cic.type (cic.s (cic.s cic.z)))
                 (cic.prod (cic.type (cic.s (cic.s cic.z)))
                    (cic.type (cic.s (cic.s (cic.s cic.z)))) A
                    (x_13 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                     cic.prod cic.prop
                       (cic.type (cic.s (cic.s (cic.s cic.z))))
                       (matita_basics_logic.eq
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          _x x_13)
                       (_x_14 :
                          cic.Term cic.prop
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x x_13) =>
                        cic.univ (cic.type (cic.s (cic.s cic.z))))))
                 (Q_ :
                    cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                      (cic.prod (cic.type (cic.s (cic.s cic.z)))
                         (cic.type (cic.s (cic.s (cic.s cic.z)))) A
                         (x_13 :
                            cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                          cic.prod cic.prop
                            (cic.type (cic.s (cic.s (cic.s cic.z))))
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x x_13)
                            (_x_14 :
                               cic.Term cic.prop
                                 (matita_basics_logic.eq
                                    (cic.lift
                                       (cic.type (cic.s (cic.s cic.z)))
                                       (cic.type (cic.s (cic.s cic.z))) A)
                                    _x x_13) =>
                             cic.univ (cic.type (cic.s (cic.s cic.z)))))) =>
                  cic.prod (cic.type (cic.s (cic.s cic.z)))
                    (cic.type (cic.s (cic.s cic.z)))
                    (Q_ _x
                       (matita_basics_logic.refl
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          _x))
                    (_H_refl :
                       cic.Term (cic.type (cic.s (cic.s cic.z)))
                         (Q_ _x
                            (matita_basics_logic.refl
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x)) =>
                     cic.prod (cic.type (cic.s (cic.s cic.z)))
                       (cic.type (cic.s (cic.s cic.z))) A
                       (x_13 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                        cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                          (matita_basics_logic.eq
                             (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                (cic.type (cic.s (cic.s cic.z))) A)
                             _x x_13)
                          (x_14 :
                             cic.Term cic.prop
                               (matita_basics_logic.eq
                                  (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                     (cic.type (cic.s (cic.s cic.z))) A)
                                  _x x_13) =>
                           Q_ x_13 x_14))))))).

[ A, _x, Q_, _H_refl, x_13, x_14 ]
  eq_rect_Type2 A _x Q_ _H_refl x_13 x_14 -->
  matita_basics_logic.filter_eq_Type2 A _x x_13
    (x_14 :
       cic.Term cic.prop
         (matita_basics_logic.eq
            (cic.lift (cic.type (cic.s (cic.s cic.z)))
               (cic.type (cic.s (cic.s cic.z))) A)
            _x x_13) =>
     Q_ x_13 x_14)
    (matita_basics_logic.eq_rect_Type2_body A _x Q_ _H_refl x_13) x_14.

[ A, _x, Q_, _H_refl, x_13, x_14 ]
  eq_rect_Type2_body A _x Q_ _H_refl x_13 x_14 -->
  matita_basics_logic.match_eq_Type2
    (cic.lift (cic.type (cic.s (cic.s cic.z)))
       (cic.type (cic.s (cic.s cic.z))) A)
    _x Q_ _H_refl x_13 x_14.

def eq_rect_Type1 :
      cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.type (cic.s (cic.s cic.z)))
           (cic.univ (cic.type (cic.s (cic.s cic.z))))
           (A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
            cic.prod (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s (cic.s cic.z))) A
              (_x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.prod (cic.type (cic.s (cic.s cic.z)))
                 (cic.type (cic.s (cic.s cic.z)))
                 (cic.prod (cic.type (cic.s (cic.s cic.z)))
                    (cic.type (cic.s (cic.s cic.z))) A
                    (x_16 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                     cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                       (matita_basics_logic.eq
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          _x x_16)
                       (_x_17 :
                          cic.Term cic.prop
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x x_16) =>
                        cic.univ (cic.type (cic.s cic.z)))))
                 (Q_ :
                    cic.Term (cic.type (cic.s (cic.s cic.z)))
                      (cic.prod (cic.type (cic.s (cic.s cic.z)))
                         (cic.type (cic.s (cic.s cic.z))) A
                         (x_16 :
                            cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                          cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x x_16)
                            (_x_17 :
                               cic.Term cic.prop
                                 (matita_basics_logic.eq
                                    (cic.lift
                                       (cic.type (cic.s (cic.s cic.z)))
                                       (cic.type (cic.s (cic.s cic.z))) A)
                                    _x x_16) =>
                             cic.univ (cic.type (cic.s cic.z))))) =>
                  cic.prod (cic.type (cic.s cic.z))
                    (cic.type (cic.s (cic.s cic.z)))
                    (Q_ _x
                       (matita_basics_logic.refl
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          _x))
                    (_H_refl :
                       cic.Term (cic.type (cic.s cic.z))
                         (Q_ _x
                            (matita_basics_logic.refl
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x)) =>
                     cic.prod (cic.type (cic.s (cic.s cic.z)))
                       (cic.type (cic.s cic.z)) A
                       (x_16 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                        cic.prod cic.prop (cic.type (cic.s cic.z))
                          (matita_basics_logic.eq
                             (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                (cic.type (cic.s (cic.s cic.z))) A)
                             _x x_16)
                          (x_17 :
                             cic.Term cic.prop
                               (matita_basics_logic.eq
                                  (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                     (cic.type (cic.s (cic.s cic.z))) A)
                                  _x x_16) =>
                           Q_ x_16 x_17))))))).

def eq_rect_Type1_body :
      cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.type (cic.s (cic.s cic.z)))
           (cic.univ (cic.type (cic.s (cic.s cic.z))))
           (A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
            cic.prod (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s (cic.s cic.z))) A
              (_x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.prod (cic.type (cic.s (cic.s cic.z)))
                 (cic.type (cic.s (cic.s cic.z)))
                 (cic.prod (cic.type (cic.s (cic.s cic.z)))
                    (cic.type (cic.s (cic.s cic.z))) A
                    (x_16 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                     cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                       (matita_basics_logic.eq
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          _x x_16)
                       (_x_17 :
                          cic.Term cic.prop
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x x_16) =>
                        cic.univ (cic.type (cic.s cic.z)))))
                 (Q_ :
                    cic.Term (cic.type (cic.s (cic.s cic.z)))
                      (cic.prod (cic.type (cic.s (cic.s cic.z)))
                         (cic.type (cic.s (cic.s cic.z))) A
                         (x_16 :
                            cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                          cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x x_16)
                            (_x_17 :
                               cic.Term cic.prop
                                 (matita_basics_logic.eq
                                    (cic.lift
                                       (cic.type (cic.s (cic.s cic.z)))
                                       (cic.type (cic.s (cic.s cic.z))) A)
                                    _x x_16) =>
                             cic.univ (cic.type (cic.s cic.z))))) =>
                  cic.prod (cic.type (cic.s cic.z))
                    (cic.type (cic.s (cic.s cic.z)))
                    (Q_ _x
                       (matita_basics_logic.refl
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          _x))
                    (_H_refl :
                       cic.Term (cic.type (cic.s cic.z))
                         (Q_ _x
                            (matita_basics_logic.refl
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x)) =>
                     cic.prod (cic.type (cic.s (cic.s cic.z)))
                       (cic.type (cic.s cic.z)) A
                       (x_16 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                        cic.prod cic.prop (cic.type (cic.s cic.z))
                          (matita_basics_logic.eq
                             (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                (cic.type (cic.s (cic.s cic.z))) A)
                             _x x_16)
                          (x_17 :
                             cic.Term cic.prop
                               (matita_basics_logic.eq
                                  (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                     (cic.type (cic.s (cic.s cic.z))) A)
                                  _x x_16) =>
                           Q_ x_16 x_17))))))).

[ A, _x, Q_, _H_refl, x_16, x_17 ]
  eq_rect_Type1 A _x Q_ _H_refl x_16 x_17 -->
  matita_basics_logic.filter_eq_Type1 A _x x_16
    (x_17 :
       cic.Term cic.prop
         (matita_basics_logic.eq
            (cic.lift (cic.type (cic.s (cic.s cic.z)))
               (cic.type (cic.s (cic.s cic.z))) A)
            _x x_16) =>
     Q_ x_16 x_17)
    (matita_basics_logic.eq_rect_Type1_body A _x Q_ _H_refl x_16) x_17.

[ A, _x, Q_, _H_refl, x_16, x_17 ]
  eq_rect_Type1_body A _x Q_ _H_refl x_16 x_17 -->
  matita_basics_logic.match_eq_Type1
    (cic.lift (cic.type (cic.s (cic.s cic.z)))
       (cic.type (cic.s (cic.s cic.z))) A)
    _x Q_ _H_refl x_16 x_17.

def eq_rect_Type0 :
      cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.type (cic.s (cic.s cic.z)))
           (cic.univ (cic.type (cic.s (cic.s cic.z))))
           (A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
            cic.prod (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s (cic.s cic.z))) A
              (_x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.prod (cic.type (cic.s (cic.s cic.z)))
                 (cic.type (cic.s (cic.s cic.z)))
                 (cic.prod (cic.type (cic.s (cic.s cic.z)))
                    (cic.type (cic.s cic.z)) A
                    (x_19 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                     cic.prod cic.prop (cic.type (cic.s cic.z))
                       (matita_basics_logic.eq
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          _x x_19)
                       (_x_20 :
                          cic.Term cic.prop
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x x_19) =>
                        cic.univ (cic.type cic.z))))
                 (Q_ :
                    cic.Term (cic.type (cic.s (cic.s cic.z)))
                      (cic.prod (cic.type (cic.s (cic.s cic.z)))
                         (cic.type (cic.s cic.z)) A
                         (x_19 :
                            cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                          cic.prod cic.prop (cic.type (cic.s cic.z))
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x x_19)
                            (_x_20 :
                               cic.Term cic.prop
                                 (matita_basics_logic.eq
                                    (cic.lift
                                       (cic.type (cic.s (cic.s cic.z)))
                                       (cic.type (cic.s (cic.s cic.z))) A)
                                    _x x_19) =>
                             cic.univ (cic.type cic.z)))) =>
                  cic.prod (cic.type cic.z) (cic.type (cic.s (cic.s cic.z)))
                    (Q_ _x
                       (matita_basics_logic.refl
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          _x))
                    (_H_refl :
                       cic.Term (cic.type cic.z)
                         (Q_ _x
                            (matita_basics_logic.refl
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x)) =>
                     cic.prod (cic.type (cic.s (cic.s cic.z)))
                       (cic.type cic.z) A
                       (x_19 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                        cic.prod cic.prop (cic.type cic.z)
                          (matita_basics_logic.eq
                             (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                (cic.type (cic.s (cic.s cic.z))) A)
                             _x x_19)
                          (x_20 :
                             cic.Term cic.prop
                               (matita_basics_logic.eq
                                  (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                     (cic.type (cic.s (cic.s cic.z))) A)
                                  _x x_19) =>
                           Q_ x_19 x_20))))))).

def eq_rect_Type0_body :
      cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.type (cic.s (cic.s cic.z)))
           (cic.univ (cic.type (cic.s (cic.s cic.z))))
           (A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
            cic.prod (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s (cic.s cic.z))) A
              (_x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.prod (cic.type (cic.s (cic.s cic.z)))
                 (cic.type (cic.s (cic.s cic.z)))
                 (cic.prod (cic.type (cic.s (cic.s cic.z)))
                    (cic.type (cic.s cic.z)) A
                    (x_19 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                     cic.prod cic.prop (cic.type (cic.s cic.z))
                       (matita_basics_logic.eq
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          _x x_19)
                       (_x_20 :
                          cic.Term cic.prop
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x x_19) =>
                        cic.univ (cic.type cic.z))))
                 (Q_ :
                    cic.Term (cic.type (cic.s (cic.s cic.z)))
                      (cic.prod (cic.type (cic.s (cic.s cic.z)))
                         (cic.type (cic.s cic.z)) A
                         (x_19 :
                            cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                          cic.prod cic.prop (cic.type (cic.s cic.z))
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x x_19)
                            (_x_20 :
                               cic.Term cic.prop
                                 (matita_basics_logic.eq
                                    (cic.lift
                                       (cic.type (cic.s (cic.s cic.z)))
                                       (cic.type (cic.s (cic.s cic.z))) A)
                                    _x x_19) =>
                             cic.univ (cic.type cic.z)))) =>
                  cic.prod (cic.type cic.z) (cic.type (cic.s (cic.s cic.z)))
                    (Q_ _x
                       (matita_basics_logic.refl
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          _x))
                    (_H_refl :
                       cic.Term (cic.type cic.z)
                         (Q_ _x
                            (matita_basics_logic.refl
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x)) =>
                     cic.prod (cic.type (cic.s (cic.s cic.z)))
                       (cic.type cic.z) A
                       (x_19 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                        cic.prod cic.prop (cic.type cic.z)
                          (matita_basics_logic.eq
                             (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                (cic.type (cic.s (cic.s cic.z))) A)
                             _x x_19)
                          (x_20 :
                             cic.Term cic.prop
                               (matita_basics_logic.eq
                                  (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                     (cic.type (cic.s (cic.s cic.z))) A)
                                  _x x_19) =>
                           Q_ x_19 x_20))))))).

[ A, _x, Q_, _H_refl, x_19, x_20 ]
  eq_rect_Type0 A _x Q_ _H_refl x_19 x_20 -->
  matita_basics_logic.filter_eq_Type0 A _x x_19
    (x_20 :
       cic.Term cic.prop
         (matita_basics_logic.eq
            (cic.lift (cic.type (cic.s (cic.s cic.z)))
               (cic.type (cic.s (cic.s cic.z))) A)
            _x x_19) =>
     Q_ x_19 x_20)
    (matita_basics_logic.eq_rect_Type0_body A _x Q_ _H_refl x_19) x_20.

[ A, _x, Q_, _H_refl, x_19, x_20 ]
  eq_rect_Type0_body A _x Q_ _H_refl x_19 x_20 -->
  matita_basics_logic.match_eq_Type0
    (cic.lift (cic.type (cic.s (cic.s cic.z)))
       (cic.type (cic.s (cic.s cic.z))) A)
    _x Q_ _H_refl x_19 x_20.

def eq_rect_CProp4 :
      cic.Term cic.prop
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z)))) cic.prop
           (cic.univ (cic.type (cic.s (cic.s cic.z))))
           (A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
            cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop A
              (_x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop
                 (cic.prod (cic.type (cic.s (cic.s cic.z))) (cic.type cic.z)
                    A
                    (x_22 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                     cic.prod cic.prop (cic.type cic.z)
                       (matita_basics_logic.eq
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          _x x_22)
                       (_x_23 :
                          cic.Term cic.prop
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x x_22) =>
                        cic.univ cic.prop)))
                 (Q_ :
                    cic.Term (cic.type (cic.s (cic.s cic.z)))
                      (cic.prod (cic.type (cic.s (cic.s cic.z)))
                         (cic.type cic.z) A
                         (x_22 :
                            cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                          cic.prod cic.prop (cic.type cic.z)
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x x_22)
                            (_x_23 :
                               cic.Term cic.prop
                                 (matita_basics_logic.eq
                                    (cic.lift
                                       (cic.type (cic.s (cic.s cic.z)))
                                       (cic.type (cic.s (cic.s cic.z))) A)
                                    _x x_22) =>
                             cic.univ cic.prop))) =>
                  cic.prod cic.prop cic.prop
                    (Q_ _x
                       (matita_basics_logic.refl
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          _x))
                    (_H_refl :
                       cic.Term cic.prop
                         (Q_ _x
                            (matita_basics_logic.refl
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x)) =>
                     cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop A
                       (x_22 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                        cic.prod cic.prop cic.prop
                          (matita_basics_logic.eq
                             (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                (cic.type (cic.s (cic.s cic.z))) A)
                             _x x_22)
                          (x_23 :
                             cic.Term cic.prop
                               (matita_basics_logic.eq
                                  (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                     (cic.type (cic.s (cic.s cic.z))) A)
                                  _x x_22) =>
                           Q_ x_22 x_23))))))).

def eq_rect_CProp4_body :
      cic.Term cic.prop
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z)))) cic.prop
           (cic.univ (cic.type (cic.s (cic.s cic.z))))
           (A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
            cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop A
              (_x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop
                 (cic.prod (cic.type (cic.s (cic.s cic.z))) (cic.type cic.z)
                    A
                    (x_22 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                     cic.prod cic.prop (cic.type cic.z)
                       (matita_basics_logic.eq
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          _x x_22)
                       (_x_23 :
                          cic.Term cic.prop
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x x_22) =>
                        cic.univ cic.prop)))
                 (Q_ :
                    cic.Term (cic.type (cic.s (cic.s cic.z)))
                      (cic.prod (cic.type (cic.s (cic.s cic.z)))
                         (cic.type cic.z) A
                         (x_22 :
                            cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                          cic.prod cic.prop (cic.type cic.z)
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x x_22)
                            (_x_23 :
                               cic.Term cic.prop
                                 (matita_basics_logic.eq
                                    (cic.lift
                                       (cic.type (cic.s (cic.s cic.z)))
                                       (cic.type (cic.s (cic.s cic.z))) A)
                                    _x x_22) =>
                             cic.univ cic.prop))) =>
                  cic.prod cic.prop cic.prop
                    (Q_ _x
                       (matita_basics_logic.refl
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          _x))
                    (_H_refl :
                       cic.Term cic.prop
                         (Q_ _x
                            (matita_basics_logic.refl
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x)) =>
                     cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop A
                       (x_22 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                        cic.prod cic.prop cic.prop
                          (matita_basics_logic.eq
                             (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                (cic.type (cic.s (cic.s cic.z))) A)
                             _x x_22)
                          (x_23 :
                             cic.Term cic.prop
                               (matita_basics_logic.eq
                                  (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                     (cic.type (cic.s (cic.s cic.z))) A)
                                  _x x_22) =>
                           Q_ x_22 x_23))))))).

[ A, _x, Q_, _H_refl, x_22, x_23 ]
  eq_rect_CProp4 A _x Q_ _H_refl x_22 x_23 -->
  matita_basics_logic.filter_eq_Prop A _x x_22
    (x_23 :
       cic.Term cic.prop
         (matita_basics_logic.eq
            (cic.lift (cic.type (cic.s (cic.s cic.z)))
               (cic.type (cic.s (cic.s cic.z))) A)
            _x x_22) =>
     Q_ x_22 x_23)
    (matita_basics_logic.eq_rect_CProp4_body A _x Q_ _H_refl x_22) x_23.

[ A, _x, Q_, _H_refl, x_22, x_23 ]
  eq_rect_CProp4_body A _x Q_ _H_refl x_22 x_23 -->
  matita_basics_logic.match_eq_Prop
    (cic.lift (cic.type (cic.s (cic.s cic.z)))
       (cic.type (cic.s (cic.s cic.z))) A)
    _x Q_ _H_refl x_22 x_23.

def eq_rect_CProp5 :
      cic.Term cic.prop
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z)))) cic.prop
           (cic.univ (cic.type (cic.s (cic.s cic.z))))
           (A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
            cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop A
              (_x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop
                 (cic.prod (cic.type (cic.s (cic.s cic.z))) (cic.type cic.z)
                    A
                    (x_25 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                     cic.prod cic.prop (cic.type cic.z)
                       (matita_basics_logic.eq
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          _x x_25)
                       (_x_26 :
                          cic.Term cic.prop
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x x_25) =>
                        cic.univ cic.prop)))
                 (Q_ :
                    cic.Term (cic.type (cic.s (cic.s cic.z)))
                      (cic.prod (cic.type (cic.s (cic.s cic.z)))
                         (cic.type cic.z) A
                         (x_25 :
                            cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                          cic.prod cic.prop (cic.type cic.z)
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x x_25)
                            (_x_26 :
                               cic.Term cic.prop
                                 (matita_basics_logic.eq
                                    (cic.lift
                                       (cic.type (cic.s (cic.s cic.z)))
                                       (cic.type (cic.s (cic.s cic.z))) A)
                                    _x x_25) =>
                             cic.univ cic.prop))) =>
                  cic.prod cic.prop cic.prop
                    (Q_ _x
                       (matita_basics_logic.refl
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          _x))
                    (_H_refl :
                       cic.Term cic.prop
                         (Q_ _x
                            (matita_basics_logic.refl
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x)) =>
                     cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop A
                       (x_25 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                        cic.prod cic.prop cic.prop
                          (matita_basics_logic.eq
                             (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                (cic.type (cic.s (cic.s cic.z))) A)
                             _x x_25)
                          (x_26 :
                             cic.Term cic.prop
                               (matita_basics_logic.eq
                                  (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                     (cic.type (cic.s (cic.s cic.z))) A)
                                  _x x_25) =>
                           Q_ x_25 x_26))))))).

def eq_rect_CProp5_body :
      cic.Term cic.prop
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z)))) cic.prop
           (cic.univ (cic.type (cic.s (cic.s cic.z))))
           (A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
            cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop A
              (_x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop
                 (cic.prod (cic.type (cic.s (cic.s cic.z))) (cic.type cic.z)
                    A
                    (x_25 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                     cic.prod cic.prop (cic.type cic.z)
                       (matita_basics_logic.eq
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          _x x_25)
                       (_x_26 :
                          cic.Term cic.prop
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x x_25) =>
                        cic.univ cic.prop)))
                 (Q_ :
                    cic.Term (cic.type (cic.s (cic.s cic.z)))
                      (cic.prod (cic.type (cic.s (cic.s cic.z)))
                         (cic.type cic.z) A
                         (x_25 :
                            cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                          cic.prod cic.prop (cic.type cic.z)
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x x_25)
                            (_x_26 :
                               cic.Term cic.prop
                                 (matita_basics_logic.eq
                                    (cic.lift
                                       (cic.type (cic.s (cic.s cic.z)))
                                       (cic.type (cic.s (cic.s cic.z))) A)
                                    _x x_25) =>
                             cic.univ cic.prop))) =>
                  cic.prod cic.prop cic.prop
                    (Q_ _x
                       (matita_basics_logic.refl
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          _x))
                    (_H_refl :
                       cic.Term cic.prop
                         (Q_ _x
                            (matita_basics_logic.refl
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x)) =>
                     cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop A
                       (x_25 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                        cic.prod cic.prop cic.prop
                          (matita_basics_logic.eq
                             (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                (cic.type (cic.s (cic.s cic.z))) A)
                             _x x_25)
                          (x_26 :
                             cic.Term cic.prop
                               (matita_basics_logic.eq
                                  (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                     (cic.type (cic.s (cic.s cic.z))) A)
                                  _x x_25) =>
                           Q_ x_25 x_26))))))).

[ A, _x, Q_, _H_refl, x_25, x_26 ]
  eq_rect_CProp5 A _x Q_ _H_refl x_25 x_26 -->
  matita_basics_logic.filter_eq_Prop A _x x_25
    (x_26 :
       cic.Term cic.prop
         (matita_basics_logic.eq
            (cic.lift (cic.type (cic.s (cic.s cic.z)))
               (cic.type (cic.s (cic.s cic.z))) A)
            _x x_25) =>
     Q_ x_25 x_26)
    (matita_basics_logic.eq_rect_CProp5_body A _x Q_ _H_refl x_25) x_26.

[ A, _x, Q_, _H_refl, x_25, x_26 ]
  eq_rect_CProp5_body A _x Q_ _H_refl x_25 x_26 -->
  matita_basics_logic.match_eq_Prop
    (cic.lift (cic.type (cic.s (cic.s cic.z)))
       (cic.type (cic.s (cic.s cic.z))) A)
    _x Q_ _H_refl x_25 x_26.

def eq_rect_CProp3 :
      cic.Term cic.prop
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z)))) cic.prop
           (cic.univ (cic.type (cic.s (cic.s cic.z))))
           (A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
            cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop A
              (_x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop
                 (cic.prod (cic.type (cic.s (cic.s cic.z))) (cic.type cic.z)
                    A
                    (x_28 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                     cic.prod cic.prop (cic.type cic.z)
                       (matita_basics_logic.eq
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          _x x_28)
                       (_x_29 :
                          cic.Term cic.prop
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x x_28) =>
                        cic.univ cic.prop)))
                 (Q_ :
                    cic.Term (cic.type (cic.s (cic.s cic.z)))
                      (cic.prod (cic.type (cic.s (cic.s cic.z)))
                         (cic.type cic.z) A
                         (x_28 :
                            cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                          cic.prod cic.prop (cic.type cic.z)
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x x_28)
                            (_x_29 :
                               cic.Term cic.prop
                                 (matita_basics_logic.eq
                                    (cic.lift
                                       (cic.type (cic.s (cic.s cic.z)))
                                       (cic.type (cic.s (cic.s cic.z))) A)
                                    _x x_28) =>
                             cic.univ cic.prop))) =>
                  cic.prod cic.prop cic.prop
                    (Q_ _x
                       (matita_basics_logic.refl
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          _x))
                    (_H_refl :
                       cic.Term cic.prop
                         (Q_ _x
                            (matita_basics_logic.refl
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x)) =>
                     cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop A
                       (x_28 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                        cic.prod cic.prop cic.prop
                          (matita_basics_logic.eq
                             (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                (cic.type (cic.s (cic.s cic.z))) A)
                             _x x_28)
                          (x_29 :
                             cic.Term cic.prop
                               (matita_basics_logic.eq
                                  (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                     (cic.type (cic.s (cic.s cic.z))) A)
                                  _x x_28) =>
                           Q_ x_28 x_29))))))).

def eq_rect_CProp3_body :
      cic.Term cic.prop
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z)))) cic.prop
           (cic.univ (cic.type (cic.s (cic.s cic.z))))
           (A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
            cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop A
              (_x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop
                 (cic.prod (cic.type (cic.s (cic.s cic.z))) (cic.type cic.z)
                    A
                    (x_28 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                     cic.prod cic.prop (cic.type cic.z)
                       (matita_basics_logic.eq
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          _x x_28)
                       (_x_29 :
                          cic.Term cic.prop
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x x_28) =>
                        cic.univ cic.prop)))
                 (Q_ :
                    cic.Term (cic.type (cic.s (cic.s cic.z)))
                      (cic.prod (cic.type (cic.s (cic.s cic.z)))
                         (cic.type cic.z) A
                         (x_28 :
                            cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                          cic.prod cic.prop (cic.type cic.z)
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x x_28)
                            (_x_29 :
                               cic.Term cic.prop
                                 (matita_basics_logic.eq
                                    (cic.lift
                                       (cic.type (cic.s (cic.s cic.z)))
                                       (cic.type (cic.s (cic.s cic.z))) A)
                                    _x x_28) =>
                             cic.univ cic.prop))) =>
                  cic.prod cic.prop cic.prop
                    (Q_ _x
                       (matita_basics_logic.refl
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          _x))
                    (_H_refl :
                       cic.Term cic.prop
                         (Q_ _x
                            (matita_basics_logic.refl
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x)) =>
                     cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop A
                       (x_28 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                        cic.prod cic.prop cic.prop
                          (matita_basics_logic.eq
                             (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                (cic.type (cic.s (cic.s cic.z))) A)
                             _x x_28)
                          (x_29 :
                             cic.Term cic.prop
                               (matita_basics_logic.eq
                                  (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                     (cic.type (cic.s (cic.s cic.z))) A)
                                  _x x_28) =>
                           Q_ x_28 x_29))))))).

[ A, _x, Q_, _H_refl, x_28, x_29 ]
  eq_rect_CProp3 A _x Q_ _H_refl x_28 x_29 -->
  matita_basics_logic.filter_eq_Prop A _x x_28
    (x_29 :
       cic.Term cic.prop
         (matita_basics_logic.eq
            (cic.lift (cic.type (cic.s (cic.s cic.z)))
               (cic.type (cic.s (cic.s cic.z))) A)
            _x x_28) =>
     Q_ x_28 x_29)
    (matita_basics_logic.eq_rect_CProp3_body A _x Q_ _H_refl x_28) x_29.

[ A, _x, Q_, _H_refl, x_28, x_29 ]
  eq_rect_CProp3_body A _x Q_ _H_refl x_28 x_29 -->
  matita_basics_logic.match_eq_Prop
    (cic.lift (cic.type (cic.s (cic.s cic.z)))
       (cic.type (cic.s (cic.s cic.z))) A)
    _x Q_ _H_refl x_28 x_29.

def eq_rect_CProp2 :
      cic.Term cic.prop
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z)))) cic.prop
           (cic.univ (cic.type (cic.s (cic.s cic.z))))
           (A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
            cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop A
              (_x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop
                 (cic.prod (cic.type (cic.s (cic.s cic.z))) (cic.type cic.z)
                    A
                    (x_31 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                     cic.prod cic.prop (cic.type cic.z)
                       (matita_basics_logic.eq
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          _x x_31)
                       (_x_32 :
                          cic.Term cic.prop
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x x_31) =>
                        cic.univ cic.prop)))
                 (Q_ :
                    cic.Term (cic.type (cic.s (cic.s cic.z)))
                      (cic.prod (cic.type (cic.s (cic.s cic.z)))
                         (cic.type cic.z) A
                         (x_31 :
                            cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                          cic.prod cic.prop (cic.type cic.z)
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x x_31)
                            (_x_32 :
                               cic.Term cic.prop
                                 (matita_basics_logic.eq
                                    (cic.lift
                                       (cic.type (cic.s (cic.s cic.z)))
                                       (cic.type (cic.s (cic.s cic.z))) A)
                                    _x x_31) =>
                             cic.univ cic.prop))) =>
                  cic.prod cic.prop cic.prop
                    (Q_ _x
                       (matita_basics_logic.refl
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          _x))
                    (_H_refl :
                       cic.Term cic.prop
                         (Q_ _x
                            (matita_basics_logic.refl
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x)) =>
                     cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop A
                       (x_31 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                        cic.prod cic.prop cic.prop
                          (matita_basics_logic.eq
                             (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                (cic.type (cic.s (cic.s cic.z))) A)
                             _x x_31)
                          (x_32 :
                             cic.Term cic.prop
                               (matita_basics_logic.eq
                                  (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                     (cic.type (cic.s (cic.s cic.z))) A)
                                  _x x_31) =>
                           Q_ x_31 x_32))))))).

def eq_rect_CProp2_body :
      cic.Term cic.prop
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z)))) cic.prop
           (cic.univ (cic.type (cic.s (cic.s cic.z))))
           (A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
            cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop A
              (_x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop
                 (cic.prod (cic.type (cic.s (cic.s cic.z))) (cic.type cic.z)
                    A
                    (x_31 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                     cic.prod cic.prop (cic.type cic.z)
                       (matita_basics_logic.eq
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          _x x_31)
                       (_x_32 :
                          cic.Term cic.prop
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x x_31) =>
                        cic.univ cic.prop)))
                 (Q_ :
                    cic.Term (cic.type (cic.s (cic.s cic.z)))
                      (cic.prod (cic.type (cic.s (cic.s cic.z)))
                         (cic.type cic.z) A
                         (x_31 :
                            cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                          cic.prod cic.prop (cic.type cic.z)
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x x_31)
                            (_x_32 :
                               cic.Term cic.prop
                                 (matita_basics_logic.eq
                                    (cic.lift
                                       (cic.type (cic.s (cic.s cic.z)))
                                       (cic.type (cic.s (cic.s cic.z))) A)
                                    _x x_31) =>
                             cic.univ cic.prop))) =>
                  cic.prod cic.prop cic.prop
                    (Q_ _x
                       (matita_basics_logic.refl
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          _x))
                    (_H_refl :
                       cic.Term cic.prop
                         (Q_ _x
                            (matita_basics_logic.refl
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x)) =>
                     cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop A
                       (x_31 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                        cic.prod cic.prop cic.prop
                          (matita_basics_logic.eq
                             (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                (cic.type (cic.s (cic.s cic.z))) A)
                             _x x_31)
                          (x_32 :
                             cic.Term cic.prop
                               (matita_basics_logic.eq
                                  (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                     (cic.type (cic.s (cic.s cic.z))) A)
                                  _x x_31) =>
                           Q_ x_31 x_32))))))).

[ A, _x, Q_, _H_refl, x_31, x_32 ]
  eq_rect_CProp2 A _x Q_ _H_refl x_31 x_32 -->
  matita_basics_logic.filter_eq_Prop A _x x_31
    (x_32 :
       cic.Term cic.prop
         (matita_basics_logic.eq
            (cic.lift (cic.type (cic.s (cic.s cic.z)))
               (cic.type (cic.s (cic.s cic.z))) A)
            _x x_31) =>
     Q_ x_31 x_32)
    (matita_basics_logic.eq_rect_CProp2_body A _x Q_ _H_refl x_31) x_32.

[ A, _x, Q_, _H_refl, x_31, x_32 ]
  eq_rect_CProp2_body A _x Q_ _H_refl x_31 x_32 -->
  matita_basics_logic.match_eq_Prop
    (cic.lift (cic.type (cic.s (cic.s cic.z)))
       (cic.type (cic.s (cic.s cic.z))) A)
    _x Q_ _H_refl x_31 x_32.

def eq_rect_CProp1 :
      cic.Term cic.prop
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z)))) cic.prop
           (cic.univ (cic.type (cic.s (cic.s cic.z))))
           (A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
            cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop A
              (_x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop
                 (cic.prod (cic.type (cic.s (cic.s cic.z))) (cic.type cic.z)
                    A
                    (x_34 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                     cic.prod cic.prop (cic.type cic.z)
                       (matita_basics_logic.eq
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          _x x_34)
                       (_x_35 :
                          cic.Term cic.prop
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x x_34) =>
                        cic.univ cic.prop)))
                 (Q_ :
                    cic.Term (cic.type (cic.s (cic.s cic.z)))
                      (cic.prod (cic.type (cic.s (cic.s cic.z)))
                         (cic.type cic.z) A
                         (x_34 :
                            cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                          cic.prod cic.prop (cic.type cic.z)
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x x_34)
                            (_x_35 :
                               cic.Term cic.prop
                                 (matita_basics_logic.eq
                                    (cic.lift
                                       (cic.type (cic.s (cic.s cic.z)))
                                       (cic.type (cic.s (cic.s cic.z))) A)
                                    _x x_34) =>
                             cic.univ cic.prop))) =>
                  cic.prod cic.prop cic.prop
                    (Q_ _x
                       (matita_basics_logic.refl
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          _x))
                    (_H_refl :
                       cic.Term cic.prop
                         (Q_ _x
                            (matita_basics_logic.refl
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x)) =>
                     cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop A
                       (x_34 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                        cic.prod cic.prop cic.prop
                          (matita_basics_logic.eq
                             (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                (cic.type (cic.s (cic.s cic.z))) A)
                             _x x_34)
                          (x_35 :
                             cic.Term cic.prop
                               (matita_basics_logic.eq
                                  (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                     (cic.type (cic.s (cic.s cic.z))) A)
                                  _x x_34) =>
                           Q_ x_34 x_35))))))).

def eq_rect_CProp1_body :
      cic.Term cic.prop
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z)))) cic.prop
           (cic.univ (cic.type (cic.s (cic.s cic.z))))
           (A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
            cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop A
              (_x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop
                 (cic.prod (cic.type (cic.s (cic.s cic.z))) (cic.type cic.z)
                    A
                    (x_34 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                     cic.prod cic.prop (cic.type cic.z)
                       (matita_basics_logic.eq
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          _x x_34)
                       (_x_35 :
                          cic.Term cic.prop
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x x_34) =>
                        cic.univ cic.prop)))
                 (Q_ :
                    cic.Term (cic.type (cic.s (cic.s cic.z)))
                      (cic.prod (cic.type (cic.s (cic.s cic.z)))
                         (cic.type cic.z) A
                         (x_34 :
                            cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                          cic.prod cic.prop (cic.type cic.z)
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x x_34)
                            (_x_35 :
                               cic.Term cic.prop
                                 (matita_basics_logic.eq
                                    (cic.lift
                                       (cic.type (cic.s (cic.s cic.z)))
                                       (cic.type (cic.s (cic.s cic.z))) A)
                                    _x x_34) =>
                             cic.univ cic.prop))) =>
                  cic.prod cic.prop cic.prop
                    (Q_ _x
                       (matita_basics_logic.refl
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          _x))
                    (_H_refl :
                       cic.Term cic.prop
                         (Q_ _x
                            (matita_basics_logic.refl
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x)) =>
                     cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop A
                       (x_34 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                        cic.prod cic.prop cic.prop
                          (matita_basics_logic.eq
                             (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                (cic.type (cic.s (cic.s cic.z))) A)
                             _x x_34)
                          (x_35 :
                             cic.Term cic.prop
                               (matita_basics_logic.eq
                                  (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                     (cic.type (cic.s (cic.s cic.z))) A)
                                  _x x_34) =>
                           Q_ x_34 x_35))))))).

[ A, _x, Q_, _H_refl, x_34, x_35 ]
  eq_rect_CProp1 A _x Q_ _H_refl x_34 x_35 -->
  matita_basics_logic.filter_eq_Prop A _x x_34
    (x_35 :
       cic.Term cic.prop
         (matita_basics_logic.eq
            (cic.lift (cic.type (cic.s (cic.s cic.z)))
               (cic.type (cic.s (cic.s cic.z))) A)
            _x x_34) =>
     Q_ x_34 x_35)
    (matita_basics_logic.eq_rect_CProp1_body A _x Q_ _H_refl x_34) x_35.

[ A, _x, Q_, _H_refl, x_34, x_35 ]
  eq_rect_CProp1_body A _x Q_ _H_refl x_34 x_35 -->
  matita_basics_logic.match_eq_Prop
    (cic.lift (cic.type (cic.s (cic.s cic.z)))
       (cic.type (cic.s (cic.s cic.z))) A)
    _x Q_ _H_refl x_34 x_35.

def eq_rect_CProp0 :
      cic.Term cic.prop
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z)))) cic.prop
           (cic.univ (cic.type (cic.s (cic.s cic.z))))
           (A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
            cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop A
              (_x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop
                 (cic.prod (cic.type (cic.s (cic.s cic.z))) (cic.type cic.z)
                    A
                    (x_37 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                     cic.prod cic.prop (cic.type cic.z)
                       (matita_basics_logic.eq
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          _x x_37)
                       (_x_38 :
                          cic.Term cic.prop
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x x_37) =>
                        cic.univ cic.prop)))
                 (Q_ :
                    cic.Term (cic.type (cic.s (cic.s cic.z)))
                      (cic.prod (cic.type (cic.s (cic.s cic.z)))
                         (cic.type cic.z) A
                         (x_37 :
                            cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                          cic.prod cic.prop (cic.type cic.z)
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x x_37)
                            (_x_38 :
                               cic.Term cic.prop
                                 (matita_basics_logic.eq
                                    (cic.lift
                                       (cic.type (cic.s (cic.s cic.z)))
                                       (cic.type (cic.s (cic.s cic.z))) A)
                                    _x x_37) =>
                             cic.univ cic.prop))) =>
                  cic.prod cic.prop cic.prop
                    (Q_ _x
                       (matita_basics_logic.refl
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          _x))
                    (_H_refl :
                       cic.Term cic.prop
                         (Q_ _x
                            (matita_basics_logic.refl
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x)) =>
                     cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop A
                       (x_37 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                        cic.prod cic.prop cic.prop
                          (matita_basics_logic.eq
                             (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                (cic.type (cic.s (cic.s cic.z))) A)
                             _x x_37)
                          (x_38 :
                             cic.Term cic.prop
                               (matita_basics_logic.eq
                                  (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                     (cic.type (cic.s (cic.s cic.z))) A)
                                  _x x_37) =>
                           Q_ x_37 x_38))))))).

def eq_rect_CProp0_body :
      cic.Term cic.prop
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z)))) cic.prop
           (cic.univ (cic.type (cic.s (cic.s cic.z))))
           (A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
            cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop A
              (_x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop
                 (cic.prod (cic.type (cic.s (cic.s cic.z))) (cic.type cic.z)
                    A
                    (x_37 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                     cic.prod cic.prop (cic.type cic.z)
                       (matita_basics_logic.eq
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          _x x_37)
                       (_x_38 :
                          cic.Term cic.prop
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x x_37) =>
                        cic.univ cic.prop)))
                 (Q_ :
                    cic.Term (cic.type (cic.s (cic.s cic.z)))
                      (cic.prod (cic.type (cic.s (cic.s cic.z)))
                         (cic.type cic.z) A
                         (x_37 :
                            cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                          cic.prod cic.prop (cic.type cic.z)
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x x_37)
                            (_x_38 :
                               cic.Term cic.prop
                                 (matita_basics_logic.eq
                                    (cic.lift
                                       (cic.type (cic.s (cic.s cic.z)))
                                       (cic.type (cic.s (cic.s cic.z))) A)
                                    _x x_37) =>
                             cic.univ cic.prop))) =>
                  cic.prod cic.prop cic.prop
                    (Q_ _x
                       (matita_basics_logic.refl
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          _x))
                    (_H_refl :
                       cic.Term cic.prop
                         (Q_ _x
                            (matita_basics_logic.refl
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x)) =>
                     cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop A
                       (x_37 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                        cic.prod cic.prop cic.prop
                          (matita_basics_logic.eq
                             (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                (cic.type (cic.s (cic.s cic.z))) A)
                             _x x_37)
                          (x_38 :
                             cic.Term cic.prop
                               (matita_basics_logic.eq
                                  (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                     (cic.type (cic.s (cic.s cic.z))) A)
                                  _x x_37) =>
                           Q_ x_37 x_38))))))).

[ A, _x, Q_, _H_refl, x_37, x_38 ]
  eq_rect_CProp0 A _x Q_ _H_refl x_37 x_38 -->
  matita_basics_logic.filter_eq_Prop A _x x_37
    (x_38 :
       cic.Term cic.prop
         (matita_basics_logic.eq
            (cic.lift (cic.type (cic.s (cic.s cic.z)))
               (cic.type (cic.s (cic.s cic.z))) A)
            _x x_37) =>
     Q_ x_37 x_38)
    (matita_basics_logic.eq_rect_CProp0_body A _x Q_ _H_refl x_37) x_38.

[ A, _x, Q_, _H_refl, x_37, x_38 ]
  eq_rect_CProp0_body A _x Q_ _H_refl x_37 x_38 -->
  matita_basics_logic.match_eq_Prop
    (cic.lift (cic.type (cic.s (cic.s cic.z)))
       (cic.type (cic.s (cic.s cic.z))) A)
    _x Q_ _H_refl x_37 x_38.

def eq_rect_r :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
           (cic.univ (cic.type (cic.s (cic.s cic.z))))
           (A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
            cic.prod (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))) A
              (a : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.prod (cic.type (cic.s (cic.s cic.z)))
                 (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))) A
                 (x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                  cic.prod cic.prop
                    (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                    (matita_basics_logic.eq
                       (cic.lift (cic.type (cic.s (cic.s cic.z)))
                          (cic.type (cic.s (cic.s cic.z))) A)
                       x a)
                    (p :
                       cic.Term cic.prop
                         (matita_basics_logic.eq
                            (cic.lift (cic.type (cic.s (cic.s cic.z)))
                               (cic.type (cic.s (cic.s cic.z))) A)
                            x a) =>
                     cic.prod
                       (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                       (cic.type (cic.s (cic.s (cic.s cic.z))))
                       (cic.prod (cic.type (cic.s (cic.s cic.z)))
                          (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))) A
                          (x0 :
                             cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                           cic.prod cic.prop
                             (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                             (matita_basics_logic.eq
                                (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                   (cic.type (cic.s (cic.s cic.z))) A)
                                x0 a)
                             (__ :
                                cic.Term cic.prop
                                  (matita_basics_logic.eq
                                     (cic.lift
                                        (cic.type (cic.s (cic.s cic.z)))
                                        (cic.type (cic.s (cic.s cic.z))) A)
                                     x0 a) =>
                              cic.univ
                                (cic.type (cic.s (cic.s (cic.s cic.z)))))))
                       (P :
                          cic.Term
                            (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                            (cic.prod (cic.type (cic.s (cic.s cic.z)))
                               (cic.type
                                  (cic.s (cic.s (cic.s (cic.s cic.z)))))
                               A
                               (x0 :
                                  cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                                cic.prod cic.prop
                                  (cic.type
                                     (cic.s (cic.s (cic.s (cic.s cic.z)))))
                                  (matita_basics_logic.eq
                                     (cic.lift
                                        (cic.type (cic.s (cic.s cic.z)))
                                        (cic.type (cic.s (cic.s cic.z))) A)
                                     x0 a)
                                  (__ :
                                     cic.Term cic.prop
                                       (matita_basics_logic.eq
                                          (cic.lift
                                             (cic.type (cic.s (cic.s cic.z)))
                                             (cic.type (cic.s (cic.s cic.z)))
                                             A)
                                          x0 a) =>
                                   cic.univ
                                     (cic.type (cic.s (cic.s (cic.s cic.z))))))) =>
                        cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
                          (cic.type (cic.s (cic.s (cic.s cic.z))))
                          (P a
                             (matita_basics_logic.refl
                                (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                   (cic.type (cic.s (cic.s cic.z))) A)
                                a))
                          (__ :
                             cic.Term
                               (cic.type (cic.s (cic.s (cic.s cic.z))))
                               (P a
                                  (matita_basics_logic.refl
                                     (cic.lift
                                        (cic.type (cic.s (cic.s cic.z)))
                                        (cic.type (cic.s (cic.s cic.z))) A)
                                     a)) =>
                           P x p)))))))
      :=
      A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
      a : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
      x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
      p :
        cic.Term cic.prop
          (matita_basics_logic.eq
             (cic.lift (cic.type (cic.s (cic.s cic.z)))
                (cic.type (cic.s (cic.s cic.z))) A)
             x a) =>
      matita_basics_logic.match_eq_Type4
        (cic.lift (cic.type (cic.s (cic.s cic.z)))
           (cic.type (cic.s (cic.s cic.z))) A)
        x
        (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
         _0 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift (cic.type (cic.s (cic.s cic.z)))
                   (cic.type (cic.s (cic.s cic.z))) A)
                x __) =>
         cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
           (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.prod (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))) A
              (x0 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.prod cic.prop
                 (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                 (matita_basics_logic.eq
                    (cic.lift (cic.type (cic.s (cic.s cic.z)))
                       (cic.type (cic.s (cic.s cic.z))) A)
                    x0 __)
                 (__1 :
                    cic.Term cic.prop
                      (matita_basics_logic.eq
                         (cic.lift (cic.type (cic.s (cic.s cic.z)))
                            (cic.type (cic.s (cic.s cic.z))) A)
                         x0 __) =>
                  cic.univ (cic.type (cic.s (cic.s (cic.s cic.z)))))))
           (P :
              cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                (cic.prod (cic.type (cic.s (cic.s cic.z)))
                   (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))) A
                   (x0 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                    cic.prod cic.prop
                      (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                      (matita_basics_logic.eq
                         (cic.lift (cic.type (cic.s (cic.s cic.z)))
                            (cic.type (cic.s (cic.s cic.z))) A)
                         x0 __)
                      (__1 :
                         cic.Term cic.prop
                           (matita_basics_logic.eq
                              (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                 (cic.type (cic.s (cic.s cic.z))) A)
                              x0 __) =>
                       cic.univ (cic.type (cic.s (cic.s (cic.s cic.z))))))) =>
            cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
              (cic.type (cic.s (cic.s (cic.s cic.z))))
              (P __
                 (matita_basics_logic.refl
                    (cic.lift (cic.type (cic.s (cic.s cic.z)))
                       (cic.type (cic.s (cic.s cic.z))) A)
                    __))
              (__1 :
                 cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                   (P __
                      (matita_basics_logic.refl
                         (cic.lift (cic.type (cic.s (cic.s cic.z)))
                            (cic.type (cic.s (cic.s cic.z))) A)
                         __)) =>
               P x _0)))
        (P :
           cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
             (cic.prod (cic.type (cic.s (cic.s cic.z)))
                (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))) A
                (x0 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                 cic.prod cic.prop
                   (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                   (matita_basics_logic.eq
                      (cic.lift (cic.type (cic.s (cic.s cic.z)))
                         (cic.type (cic.s (cic.s cic.z))) A)
                      x0 x)
                   (__ :
                      cic.Term cic.prop
                        (matita_basics_logic.eq
                           (cic.lift (cic.type (cic.s (cic.s cic.z)))
                              (cic.type (cic.s (cic.s cic.z))) A)
                           x0 x) =>
                    cic.univ (cic.type (cic.s (cic.s (cic.s cic.z))))))) =>
         auto :
           cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
             (P x
                (matita_basics_logic.refl
                   (cic.lift (cic.type (cic.s (cic.s cic.z)))
                      (cic.type (cic.s (cic.s cic.z))) A)
                   x)) =>
         auto)
        a p.

def eq_ind_r :
      cic.Term cic.prop
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z)))) cic.prop
           (cic.univ (cic.type (cic.s (cic.s cic.z))))
           (A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
            cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop A
              (a : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop
                 (cic.prod (cic.type (cic.s (cic.s cic.z))) (cic.type cic.z)
                    A
                    (x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                     cic.prod cic.prop (cic.type cic.z)
                       (matita_basics_logic.eq
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          x a)
                       (__ :
                          cic.Term cic.prop
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               x a) =>
                        cic.univ cic.prop)))
                 (P :
                    cic.Term (cic.type (cic.s (cic.s cic.z)))
                      (cic.prod (cic.type (cic.s (cic.s cic.z)))
                         (cic.type cic.z) A
                         (x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                          cic.prod cic.prop (cic.type cic.z)
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               x a)
                            (__ :
                               cic.Term cic.prop
                                 (matita_basics_logic.eq
                                    (cic.lift
                                       (cic.type (cic.s (cic.s cic.z)))
                                       (cic.type (cic.s (cic.s cic.z))) A)
                                    x a) =>
                             cic.univ cic.prop))) =>
                  cic.prod cic.prop cic.prop
                    (P a
                       (matita_basics_logic.refl
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          a))
                    (__ :
                       cic.Term cic.prop
                         (P a
                            (matita_basics_logic.refl
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               a)) =>
                     cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop A
                       (x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                        cic.prod cic.prop cic.prop
                          (matita_basics_logic.eq
                             (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                (cic.type (cic.s (cic.s cic.z))) A)
                             x a)
                          (p :
                             cic.Term cic.prop
                               (matita_basics_logic.eq
                                  (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                     (cic.type (cic.s (cic.s cic.z))) A)
                                  x a) =>
                           P x p)))))))
      :=
      A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
      a : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
      P :
        cic.Term (cic.type (cic.s (cic.s cic.z)))
          (cic.prod (cic.type (cic.s (cic.s cic.z))) (cic.type cic.z) A
             (x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
              cic.prod cic.prop (cic.type cic.z)
                (matita_basics_logic.eq
                   (cic.lift (cic.type (cic.s (cic.s cic.z)))
                      (cic.type (cic.s (cic.s cic.z))) A)
                   x a)
                (__ :
                   cic.Term cic.prop
                     (matita_basics_logic.eq
                        (cic.lift (cic.type (cic.s (cic.s cic.z)))
                           (cic.type (cic.s (cic.s cic.z))) A)
                        x a) =>
                 cic.univ cic.prop))) =>
      p :
        cic.Term cic.prop
          (P a
             (matita_basics_logic.refl
                (cic.lift (cic.type (cic.s (cic.s cic.z)))
                   (cic.type (cic.s (cic.s cic.z))) A)
                a)) =>
      x0 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
      p0 :
        cic.Term cic.prop
          (matita_basics_logic.eq
             (cic.lift (cic.type (cic.s (cic.s cic.z)))
                (cic.type (cic.s (cic.s cic.z))) A)
             x0 a) =>
      matita_basics_logic.eq_rect_r
        (cic.lift (cic.type (cic.s (cic.s cic.z)))
           (cic.type (cic.s (cic.s cic.z))) A)
        a x0 p0
        (x01 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
         __ :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift (cic.type (cic.s (cic.s cic.z)))
                   (cic.type (cic.s (cic.s cic.z))) A)
                x01 a) =>
         cic.lift cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
           (P x01 __))
        p.

def eq_rect_Type0_r :
      cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.type (cic.s (cic.s cic.z)))
           (cic.univ (cic.type (cic.s (cic.s cic.z))))
           (A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
            cic.prod (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s (cic.s cic.z))) A
              (a : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.prod (cic.type (cic.s (cic.s cic.z)))
                 (cic.type (cic.s (cic.s cic.z)))
                 (cic.prod (cic.type (cic.s (cic.s cic.z)))
                    (cic.type (cic.s cic.z)) A
                    (x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                     cic.prod cic.prop (cic.type (cic.s cic.z))
                       (matita_basics_logic.eq
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          x a)
                       (__ :
                          cic.Term cic.prop
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               x a) =>
                        cic.univ (cic.type cic.z))))
                 (P :
                    cic.Term (cic.type (cic.s (cic.s cic.z)))
                      (cic.prod (cic.type (cic.s (cic.s cic.z)))
                         (cic.type (cic.s cic.z)) A
                         (x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                          cic.prod cic.prop (cic.type (cic.s cic.z))
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               x a)
                            (__ :
                               cic.Term cic.prop
                                 (matita_basics_logic.eq
                                    (cic.lift
                                       (cic.type (cic.s (cic.s cic.z)))
                                       (cic.type (cic.s (cic.s cic.z))) A)
                                    x a) =>
                             cic.univ (cic.type cic.z)))) =>
                  cic.prod (cic.type cic.z) (cic.type (cic.s (cic.s cic.z)))
                    (P a
                       (matita_basics_logic.refl
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          a))
                    (__ :
                       cic.Term (cic.type cic.z)
                         (P a
                            (matita_basics_logic.refl
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               a)) =>
                     cic.prod (cic.type (cic.s (cic.s cic.z)))
                       (cic.type cic.z) A
                       (x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                        cic.prod cic.prop (cic.type cic.z)
                          (matita_basics_logic.eq
                             (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                (cic.type (cic.s (cic.s cic.z))) A)
                             x a)
                          (p :
                             cic.Term cic.prop
                               (matita_basics_logic.eq
                                  (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                     (cic.type (cic.s (cic.s cic.z))) A)
                                  x a) =>
                           P x p)))))))
      :=
      A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
      a : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
      P :
        cic.Term (cic.type (cic.s (cic.s cic.z)))
          (cic.prod (cic.type (cic.s (cic.s cic.z))) (cic.type (cic.s cic.z))
             A
             (x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
              cic.prod cic.prop (cic.type (cic.s cic.z))
                (matita_basics_logic.eq
                   (cic.lift (cic.type (cic.s (cic.s cic.z)))
                      (cic.type (cic.s (cic.s cic.z))) A)
                   x a)
                (__ :
                   cic.Term cic.prop
                     (matita_basics_logic.eq
                        (cic.lift (cic.type (cic.s (cic.s cic.z)))
                           (cic.type (cic.s (cic.s cic.z))) A)
                        x a) =>
                 cic.univ (cic.type cic.z)))) =>
      H :
        cic.Term (cic.type cic.z)
          (P a
             (matita_basics_logic.refl
                (cic.lift (cic.type (cic.s (cic.s cic.z)))
                   (cic.type (cic.s (cic.s cic.z))) A)
                a)) =>
      x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
      p :
        cic.Term cic.prop
          (matita_basics_logic.eq
             (cic.lift (cic.type (cic.s (cic.s cic.z)))
                (cic.type (cic.s (cic.s cic.z))) A)
             x a) =>
      matita_basics_logic.match_eq_Type2
        (cic.lift (cic.type (cic.s (cic.s cic.z)))
           (cic.type (cic.s (cic.s cic.z))) A)
        x
        (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
         _0 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift (cic.type (cic.s (cic.s cic.z)))
                   (cic.type (cic.s (cic.s cic.z))) A)
                x __) =>
         cic.prod (cic.type (cic.s (cic.s cic.z))) (cic.type cic.z)
           (cic.prod (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s cic.z)) A
              (x0 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.prod cic.prop (cic.type (cic.s cic.z))
                 (matita_basics_logic.eq
                    (cic.lift (cic.type (cic.s (cic.s cic.z)))
                       (cic.type (cic.s (cic.s cic.z))) A)
                    x0 __)
                 (__1 :
                    cic.Term cic.prop
                      (matita_basics_logic.eq
                         (cic.lift (cic.type (cic.s (cic.s cic.z)))
                            (cic.type (cic.s (cic.s cic.z))) A)
                         x0 __) =>
                  cic.univ (cic.type cic.z))))
           (f :
              cic.Term (cic.type (cic.s (cic.s cic.z)))
                (cic.prod (cic.type (cic.s (cic.s cic.z)))
                   (cic.type (cic.s cic.z)) A
                   (x0 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                    cic.prod cic.prop (cic.type (cic.s cic.z))
                      (matita_basics_logic.eq
                         (cic.lift (cic.type (cic.s (cic.s cic.z)))
                            (cic.type (cic.s (cic.s cic.z))) A)
                         x0 __)
                      (__1 :
                         cic.Term cic.prop
                           (matita_basics_logic.eq
                              (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                 (cic.type (cic.s (cic.s cic.z))) A)
                              x0 __) =>
                       cic.univ (cic.type cic.z)))) =>
            cic.prod (cic.type cic.z) (cic.type cic.z)
              (f __
                 (matita_basics_logic.refl
                    (cic.lift (cic.type (cic.s (cic.s cic.z)))
                       (cic.type (cic.s (cic.s cic.z))) A)
                    __))
              (__1 :
                 cic.Term (cic.type cic.z)
                   (f __
                      (matita_basics_logic.refl
                         (cic.lift (cic.type (cic.s (cic.s cic.z)))
                            (cic.type (cic.s (cic.s cic.z))) A)
                         __)) =>
               f x _0)))
        (f :
           cic.Term (cic.type (cic.s (cic.s cic.z)))
             (cic.prod (cic.type (cic.s (cic.s cic.z)))
                (cic.type (cic.s cic.z)) A
                (x0 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                 cic.prod cic.prop (cic.type (cic.s cic.z))
                   (matita_basics_logic.eq
                      (cic.lift (cic.type (cic.s (cic.s cic.z)))
                         (cic.type (cic.s (cic.s cic.z))) A)
                      x0 x)
                   (__ :
                      cic.Term cic.prop
                        (matita_basics_logic.eq
                           (cic.lift (cic.type (cic.s (cic.s cic.z)))
                              (cic.type (cic.s (cic.s cic.z))) A)
                           x0 x) =>
                    cic.univ (cic.type cic.z)))) =>
         auto :
           cic.Term (cic.type cic.z)
             (f x
                (matita_basics_logic.refl
                   (cic.lift (cic.type (cic.s (cic.s cic.z)))
                      (cic.type (cic.s (cic.s cic.z))) A)
                   x)) =>
         auto)
        a p P H.

def eq_rect_Type1_r :
      cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.type (cic.s (cic.s cic.z)))
           (cic.univ (cic.type (cic.s (cic.s cic.z))))
           (A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
            cic.prod (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s (cic.s cic.z))) A
              (a : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.prod (cic.type (cic.s (cic.s cic.z)))
                 (cic.type (cic.s (cic.s cic.z)))
                 (cic.prod (cic.type (cic.s (cic.s cic.z)))
                    (cic.type (cic.s (cic.s cic.z))) A
                    (x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                     cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                       (matita_basics_logic.eq
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          x a)
                       (__ :
                          cic.Term cic.prop
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               x a) =>
                        cic.univ (cic.type (cic.s cic.z)))))
                 (P :
                    cic.Term (cic.type (cic.s (cic.s cic.z)))
                      (cic.prod (cic.type (cic.s (cic.s cic.z)))
                         (cic.type (cic.s (cic.s cic.z))) A
                         (x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                          cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               x a)
                            (__ :
                               cic.Term cic.prop
                                 (matita_basics_logic.eq
                                    (cic.lift
                                       (cic.type (cic.s (cic.s cic.z)))
                                       (cic.type (cic.s (cic.s cic.z))) A)
                                    x a) =>
                             cic.univ (cic.type (cic.s cic.z))))) =>
                  cic.prod (cic.type (cic.s cic.z))
                    (cic.type (cic.s (cic.s cic.z)))
                    (P a
                       (matita_basics_logic.refl
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          a))
                    (__ :
                       cic.Term (cic.type (cic.s cic.z))
                         (P a
                            (matita_basics_logic.refl
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               a)) =>
                     cic.prod (cic.type (cic.s (cic.s cic.z)))
                       (cic.type (cic.s cic.z)) A
                       (x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                        cic.prod cic.prop (cic.type (cic.s cic.z))
                          (matita_basics_logic.eq
                             (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                (cic.type (cic.s (cic.s cic.z))) A)
                             x a)
                          (p :
                             cic.Term cic.prop
                               (matita_basics_logic.eq
                                  (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                     (cic.type (cic.s (cic.s cic.z))) A)
                                  x a) =>
                           P x p)))))))
      :=
      A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
      a : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
      P :
        cic.Term (cic.type (cic.s (cic.s cic.z)))
          (cic.prod (cic.type (cic.s (cic.s cic.z)))
             (cic.type (cic.s (cic.s cic.z))) A
             (x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
              cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                (matita_basics_logic.eq
                   (cic.lift (cic.type (cic.s (cic.s cic.z)))
                      (cic.type (cic.s (cic.s cic.z))) A)
                   x a)
                (__ :
                   cic.Term cic.prop
                     (matita_basics_logic.eq
                        (cic.lift (cic.type (cic.s (cic.s cic.z)))
                           (cic.type (cic.s (cic.s cic.z))) A)
                        x a) =>
                 cic.univ (cic.type (cic.s cic.z))))) =>
      H :
        cic.Term (cic.type (cic.s cic.z))
          (P a
             (matita_basics_logic.refl
                (cic.lift (cic.type (cic.s (cic.s cic.z)))
                   (cic.type (cic.s (cic.s cic.z))) A)
                a)) =>
      x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
      p :
        cic.Term cic.prop
          (matita_basics_logic.eq
             (cic.lift (cic.type (cic.s (cic.s cic.z)))
                (cic.type (cic.s (cic.s cic.z))) A)
             x a) =>
      matita_basics_logic.match_eq_Type2
        (cic.lift (cic.type (cic.s (cic.s cic.z)))
           (cic.type (cic.s (cic.s cic.z))) A)
        x
        (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
         _0 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift (cic.type (cic.s (cic.s cic.z)))
                   (cic.type (cic.s (cic.s cic.z))) A)
                x __) =>
         cic.prod (cic.type (cic.s (cic.s cic.z))) (cic.type (cic.s cic.z))
           (cic.prod (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s (cic.s cic.z))) A
              (x0 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                 (matita_basics_logic.eq
                    (cic.lift (cic.type (cic.s (cic.s cic.z)))
                       (cic.type (cic.s (cic.s cic.z))) A)
                    x0 __)
                 (__1 :
                    cic.Term cic.prop
                      (matita_basics_logic.eq
                         (cic.lift (cic.type (cic.s (cic.s cic.z)))
                            (cic.type (cic.s (cic.s cic.z))) A)
                         x0 __) =>
                  cic.univ (cic.type (cic.s cic.z)))))
           (f :
              cic.Term (cic.type (cic.s (cic.s cic.z)))
                (cic.prod (cic.type (cic.s (cic.s cic.z)))
                   (cic.type (cic.s (cic.s cic.z))) A
                   (x0 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                    cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                      (matita_basics_logic.eq
                         (cic.lift (cic.type (cic.s (cic.s cic.z)))
                            (cic.type (cic.s (cic.s cic.z))) A)
                         x0 __)
                      (__1 :
                         cic.Term cic.prop
                           (matita_basics_logic.eq
                              (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                 (cic.type (cic.s (cic.s cic.z))) A)
                              x0 __) =>
                       cic.univ (cic.type (cic.s cic.z))))) =>
            cic.prod (cic.type (cic.s cic.z)) (cic.type (cic.s cic.z))
              (f __
                 (matita_basics_logic.refl
                    (cic.lift (cic.type (cic.s (cic.s cic.z)))
                       (cic.type (cic.s (cic.s cic.z))) A)
                    __))
              (__1 :
                 cic.Term (cic.type (cic.s cic.z))
                   (f __
                      (matita_basics_logic.refl
                         (cic.lift (cic.type (cic.s (cic.s cic.z)))
                            (cic.type (cic.s (cic.s cic.z))) A)
                         __)) =>
               f x _0)))
        (f :
           cic.Term (cic.type (cic.s (cic.s cic.z)))
             (cic.prod (cic.type (cic.s (cic.s cic.z)))
                (cic.type (cic.s (cic.s cic.z))) A
                (x0 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                 cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                   (matita_basics_logic.eq
                      (cic.lift (cic.type (cic.s (cic.s cic.z)))
                         (cic.type (cic.s (cic.s cic.z))) A)
                      x0 x)
                   (__ :
                      cic.Term cic.prop
                        (matita_basics_logic.eq
                           (cic.lift (cic.type (cic.s (cic.s cic.z)))
                              (cic.type (cic.s (cic.s cic.z))) A)
                           x0 x) =>
                    cic.univ (cic.type (cic.s cic.z))))) =>
         auto :
           cic.Term (cic.type (cic.s cic.z))
             (f x
                (matita_basics_logic.refl
                   (cic.lift (cic.type (cic.s (cic.s cic.z)))
                      (cic.type (cic.s (cic.s cic.z))) A)
                   x)) =>
         auto)
        a p P H.

def eq_rect_Type2_r :
      cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.univ (cic.type (cic.s (cic.s cic.z))))
           (A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
            cic.prod (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s (cic.s (cic.s cic.z)))) A
              (a : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
                 (cic.type (cic.s (cic.s cic.z)))
                 (cic.prod (cic.type (cic.s (cic.s cic.z)))
                    (cic.type (cic.s (cic.s (cic.s cic.z)))) A
                    (x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                     cic.prod cic.prop
                       (cic.type (cic.s (cic.s (cic.s cic.z))))
                       (matita_basics_logic.eq
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          x a)
                       (__ :
                          cic.Term cic.prop
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               x a) =>
                        cic.univ (cic.type (cic.s (cic.s cic.z))))))
                 (P :
                    cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                      (cic.prod (cic.type (cic.s (cic.s cic.z)))
                         (cic.type (cic.s (cic.s (cic.s cic.z)))) A
                         (x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                          cic.prod cic.prop
                            (cic.type (cic.s (cic.s (cic.s cic.z))))
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               x a)
                            (__ :
                               cic.Term cic.prop
                                 (matita_basics_logic.eq
                                    (cic.lift
                                       (cic.type (cic.s (cic.s cic.z)))
                                       (cic.type (cic.s (cic.s cic.z))) A)
                                    x a) =>
                             cic.univ (cic.type (cic.s (cic.s cic.z)))))) =>
                  cic.prod (cic.type (cic.s (cic.s cic.z)))
                    (cic.type (cic.s (cic.s cic.z)))
                    (P a
                       (matita_basics_logic.refl
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          a))
                    (__ :
                       cic.Term (cic.type (cic.s (cic.s cic.z)))
                         (P a
                            (matita_basics_logic.refl
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               a)) =>
                     cic.prod (cic.type (cic.s (cic.s cic.z)))
                       (cic.type (cic.s (cic.s cic.z))) A
                       (x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                        cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                          (matita_basics_logic.eq
                             (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                (cic.type (cic.s (cic.s cic.z))) A)
                             x a)
                          (p :
                             cic.Term cic.prop
                               (matita_basics_logic.eq
                                  (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                     (cic.type (cic.s (cic.s cic.z))) A)
                                  x a) =>
                           P x p)))))))
      :=
      A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
      a : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
      P :
        cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
          (cic.prod (cic.type (cic.s (cic.s cic.z)))
             (cic.type (cic.s (cic.s (cic.s cic.z)))) A
             (x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
              cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
                (matita_basics_logic.eq
                   (cic.lift (cic.type (cic.s (cic.s cic.z)))
                      (cic.type (cic.s (cic.s cic.z))) A)
                   x a)
                (__ :
                   cic.Term cic.prop
                     (matita_basics_logic.eq
                        (cic.lift (cic.type (cic.s (cic.s cic.z)))
                           (cic.type (cic.s (cic.s cic.z))) A)
                        x a) =>
                 cic.univ (cic.type (cic.s (cic.s cic.z)))))) =>
      H :
        cic.Term (cic.type (cic.s (cic.s cic.z)))
          (P a
             (matita_basics_logic.refl
                (cic.lift (cic.type (cic.s (cic.s cic.z)))
                   (cic.type (cic.s (cic.s cic.z))) A)
                a)) =>
      x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
      p :
        cic.Term cic.prop
          (matita_basics_logic.eq
             (cic.lift (cic.type (cic.s (cic.s cic.z)))
                (cic.type (cic.s (cic.s cic.z))) A)
             x a) =>
      matita_basics_logic.match_eq_Type3
        (cic.lift (cic.type (cic.s (cic.s cic.z)))
           (cic.type (cic.s (cic.s cic.z))) A)
        x
        (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
         _0 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift (cic.type (cic.s (cic.s cic.z)))
                   (cic.type (cic.s (cic.s cic.z))) A)
                x __) =>
         cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.type (cic.s (cic.s cic.z)))
           (cic.prod (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s (cic.s (cic.s cic.z)))) A
              (x0 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
                 (matita_basics_logic.eq
                    (cic.lift (cic.type (cic.s (cic.s cic.z)))
                       (cic.type (cic.s (cic.s cic.z))) A)
                    x0 __)
                 (__1 :
                    cic.Term cic.prop
                      (matita_basics_logic.eq
                         (cic.lift (cic.type (cic.s (cic.s cic.z)))
                            (cic.type (cic.s (cic.s cic.z))) A)
                         x0 __) =>
                  cic.univ (cic.type (cic.s (cic.s cic.z))))))
           (f :
              cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                (cic.prod (cic.type (cic.s (cic.s cic.z)))
                   (cic.type (cic.s (cic.s (cic.s cic.z)))) A
                   (x0 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                    cic.prod cic.prop
                      (cic.type (cic.s (cic.s (cic.s cic.z))))
                      (matita_basics_logic.eq
                         (cic.lift (cic.type (cic.s (cic.s cic.z)))
                            (cic.type (cic.s (cic.s cic.z))) A)
                         x0 __)
                      (__1 :
                         cic.Term cic.prop
                           (matita_basics_logic.eq
                              (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                 (cic.type (cic.s (cic.s cic.z))) A)
                              x0 __) =>
                       cic.univ (cic.type (cic.s (cic.s cic.z)))))) =>
            cic.prod (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s (cic.s cic.z)))
              (f __
                 (matita_basics_logic.refl
                    (cic.lift (cic.type (cic.s (cic.s cic.z)))
                       (cic.type (cic.s (cic.s cic.z))) A)
                    __))
              (__1 :
                 cic.Term (cic.type (cic.s (cic.s cic.z)))
                   (f __
                      (matita_basics_logic.refl
                         (cic.lift (cic.type (cic.s (cic.s cic.z)))
                            (cic.type (cic.s (cic.s cic.z))) A)
                         __)) =>
               f x _0)))
        (f :
           cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
             (cic.prod (cic.type (cic.s (cic.s cic.z)))
                (cic.type (cic.s (cic.s (cic.s cic.z)))) A
                (x0 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                 cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
                   (matita_basics_logic.eq
                      (cic.lift (cic.type (cic.s (cic.s cic.z)))
                         (cic.type (cic.s (cic.s cic.z))) A)
                      x0 x)
                   (__ :
                      cic.Term cic.prop
                        (matita_basics_logic.eq
                           (cic.lift (cic.type (cic.s (cic.s cic.z)))
                              (cic.type (cic.s (cic.s cic.z))) A)
                           x0 x) =>
                    cic.univ (cic.type (cic.s (cic.s cic.z)))))) =>
         auto :
           cic.Term (cic.type (cic.s (cic.s cic.z)))
             (f x
                (matita_basics_logic.refl
                   (cic.lift (cic.type (cic.s (cic.s cic.z)))
                      (cic.type (cic.s (cic.s cic.z))) A)
                   x)) =>
         auto)
        a p P H.

def eq_rect_Type3_r :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
           (cic.univ (cic.type (cic.s (cic.s cic.z))))
           (A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
            cic.prod (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))) A
              (a : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                 (cic.type (cic.s (cic.s (cic.s cic.z))))
                 (cic.prod (cic.type (cic.s (cic.s cic.z)))
                    (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))) A
                    (x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                     cic.prod cic.prop
                       (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                       (matita_basics_logic.eq
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          x a)
                       (__ :
                          cic.Term cic.prop
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               x a) =>
                        cic.univ (cic.type (cic.s (cic.s (cic.s cic.z)))))))
                 (P :
                    cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                      (cic.prod (cic.type (cic.s (cic.s cic.z)))
                         (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))) A
                         (x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                          cic.prod cic.prop
                            (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               x a)
                            (__ :
                               cic.Term cic.prop
                                 (matita_basics_logic.eq
                                    (cic.lift
                                       (cic.type (cic.s (cic.s cic.z)))
                                       (cic.type (cic.s (cic.s cic.z))) A)
                                    x a) =>
                             cic.univ
                               (cic.type (cic.s (cic.s (cic.s cic.z))))))) =>
                  cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
                    (cic.type (cic.s (cic.s (cic.s cic.z))))
                    (P a
                       (matita_basics_logic.refl
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          a))
                    (__ :
                       cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                         (P a
                            (matita_basics_logic.refl
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               a)) =>
                     cic.prod (cic.type (cic.s (cic.s cic.z)))
                       (cic.type (cic.s (cic.s (cic.s cic.z)))) A
                       (x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                        cic.prod cic.prop
                          (cic.type (cic.s (cic.s (cic.s cic.z))))
                          (matita_basics_logic.eq
                             (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                (cic.type (cic.s (cic.s cic.z))) A)
                             x a)
                          (p :
                             cic.Term cic.prop
                               (matita_basics_logic.eq
                                  (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                     (cic.type (cic.s (cic.s cic.z))) A)
                                  x a) =>
                           P x p)))))))
      :=
      A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
      a : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
      P :
        cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
          (cic.prod (cic.type (cic.s (cic.s cic.z)))
             (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))) A
             (x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
              cic.prod cic.prop
                (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                (matita_basics_logic.eq
                   (cic.lift (cic.type (cic.s (cic.s cic.z)))
                      (cic.type (cic.s (cic.s cic.z))) A)
                   x a)
                (__ :
                   cic.Term cic.prop
                     (matita_basics_logic.eq
                        (cic.lift (cic.type (cic.s (cic.s cic.z)))
                           (cic.type (cic.s (cic.s cic.z))) A)
                        x a) =>
                 cic.univ (cic.type (cic.s (cic.s (cic.s cic.z))))))) =>
      H :
        cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
          (P a
             (matita_basics_logic.refl
                (cic.lift (cic.type (cic.s (cic.s cic.z)))
                   (cic.type (cic.s (cic.s cic.z))) A)
                a)) =>
      x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
      p :
        cic.Term cic.prop
          (matita_basics_logic.eq
             (cic.lift (cic.type (cic.s (cic.s cic.z)))
                (cic.type (cic.s (cic.s cic.z))) A)
             x a) =>
      matita_basics_logic.match_eq_Type4
        (cic.lift (cic.type (cic.s (cic.s cic.z)))
           (cic.type (cic.s (cic.s cic.z))) A)
        x
        (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
         _0 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift (cic.type (cic.s (cic.s cic.z)))
                   (cic.type (cic.s (cic.s cic.z))) A)
                x __) =>
         cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
           (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.prod (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))) A
              (x0 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.prod cic.prop
                 (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                 (matita_basics_logic.eq
                    (cic.lift (cic.type (cic.s (cic.s cic.z)))
                       (cic.type (cic.s (cic.s cic.z))) A)
                    x0 __)
                 (__1 :
                    cic.Term cic.prop
                      (matita_basics_logic.eq
                         (cic.lift (cic.type (cic.s (cic.s cic.z)))
                            (cic.type (cic.s (cic.s cic.z))) A)
                         x0 __) =>
                  cic.univ (cic.type (cic.s (cic.s (cic.s cic.z)))))))
           (f :
              cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                (cic.prod (cic.type (cic.s (cic.s cic.z)))
                   (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))) A
                   (x0 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                    cic.prod cic.prop
                      (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                      (matita_basics_logic.eq
                         (cic.lift (cic.type (cic.s (cic.s cic.z)))
                            (cic.type (cic.s (cic.s cic.z))) A)
                         x0 __)
                      (__1 :
                         cic.Term cic.prop
                           (matita_basics_logic.eq
                              (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                 (cic.type (cic.s (cic.s cic.z))) A)
                              x0 __) =>
                       cic.univ (cic.type (cic.s (cic.s (cic.s cic.z))))))) =>
            cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
              (cic.type (cic.s (cic.s (cic.s cic.z))))
              (f __
                 (matita_basics_logic.refl
                    (cic.lift (cic.type (cic.s (cic.s cic.z)))
                       (cic.type (cic.s (cic.s cic.z))) A)
                    __))
              (__1 :
                 cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                   (f __
                      (matita_basics_logic.refl
                         (cic.lift (cic.type (cic.s (cic.s cic.z)))
                            (cic.type (cic.s (cic.s cic.z))) A)
                         __)) =>
               f x _0)))
        (f :
           cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
             (cic.prod (cic.type (cic.s (cic.s cic.z)))
                (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))) A
                (x0 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                 cic.prod cic.prop
                   (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                   (matita_basics_logic.eq
                      (cic.lift (cic.type (cic.s (cic.s cic.z)))
                         (cic.type (cic.s (cic.s cic.z))) A)
                      x0 x)
                   (__ :
                      cic.Term cic.prop
                        (matita_basics_logic.eq
                           (cic.lift (cic.type (cic.s (cic.s cic.z)))
                              (cic.type (cic.s (cic.s cic.z))) A)
                           x0 x) =>
                    cic.univ (cic.type (cic.s (cic.s (cic.s cic.z))))))) =>
         auto :
           cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
             (f x
                (matita_basics_logic.refl
                   (cic.lift (cic.type (cic.s (cic.s cic.z)))
                      (cic.type (cic.s (cic.s cic.z))) A)
                   x)) =>
         auto)
        a p P H.

def rewrite_l :
      cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.univ (cic.type (cic.s (cic.s cic.z))))
           (A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
            cic.prod (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s (cic.s (cic.s cic.z)))) A
              (x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
                 (cic.type (cic.s (cic.s cic.z)))
                 (cic.prod (cic.type (cic.s (cic.s cic.z)))
                    (cic.type (cic.s (cic.s (cic.s cic.z)))) A
                    (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                     cic.univ (cic.type (cic.s (cic.s cic.z)))))
                 (P :
                    cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                      (cic.prod (cic.type (cic.s (cic.s cic.z)))
                         (cic.type (cic.s (cic.s (cic.s cic.z)))) A
                         (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                          cic.univ (cic.type (cic.s (cic.s cic.z))))) =>
                  cic.prod (cic.type (cic.s (cic.s cic.z)))
                    (cic.type (cic.s (cic.s cic.z))) (P x)
                    (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) (P x) =>
                     cic.prod (cic.type (cic.s (cic.s cic.z)))
                       (cic.type (cic.s (cic.s cic.z))) A
                       (y : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                        cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                          (matita_basics_logic.eq
                             (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                (cic.type (cic.s (cic.s cic.z))) A)
                             x y)
                          (__1 :
                             cic.Term cic.prop
                               (matita_basics_logic.eq
                                  (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                     (cic.type (cic.s (cic.s cic.z))) A)
                                  x y) =>
                           P y)))))))
      :=
      A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
      x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
      P :
        cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
          (cic.prod (cic.type (cic.s (cic.s cic.z)))
             (cic.type (cic.s (cic.s (cic.s cic.z)))) A
             (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
              cic.univ (cic.type (cic.s (cic.s cic.z))))) =>
      Hx : cic.Term (cic.type (cic.s (cic.s cic.z))) (P x) =>
      y : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
      Heq :
        cic.Term cic.prop
          (matita_basics_logic.eq
             (cic.lift (cic.type (cic.s (cic.s cic.z)))
                (cic.type (cic.s (cic.s cic.z))) A)
             x y) =>
      matita_basics_logic.match_eq_Type2
        (cic.lift (cic.type (cic.s (cic.s cic.z)))
           (cic.type (cic.s (cic.s cic.z))) A)
        x
        (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
         _0 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift (cic.type (cic.s (cic.s cic.z)))
                   (cic.type (cic.s (cic.s cic.z))) A)
                x __) =>
         P __)
        Hx y Heq.

def sym_eq :
      cic.Term cic.prop
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z)))) cic.prop
           (cic.univ (cic.type (cic.s (cic.s cic.z))))
           (A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
            cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop A
              (x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop A
                 (y : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                  cic.prod cic.prop cic.prop
                    (matita_basics_logic.eq
                       (cic.lift (cic.type (cic.s (cic.s cic.z)))
                          (cic.type (cic.s (cic.s cic.z))) A)
                       x y)
                    (__ :
                       cic.Term cic.prop
                         (matita_basics_logic.eq
                            (cic.lift (cic.type (cic.s (cic.s cic.z)))
                               (cic.type (cic.s (cic.s cic.z))) A)
                            x y) =>
                     matita_basics_logic.eq
                       (cic.lift (cic.type (cic.s (cic.s cic.z)))
                          (cic.type (cic.s (cic.s cic.z))) A)
                       y x)))))
      :=
      A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
      x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
      y : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
      Heq :
        cic.Term cic.prop
          (matita_basics_logic.eq
             (cic.lift (cic.type (cic.s (cic.s cic.z)))
                (cic.type (cic.s (cic.s cic.z))) A)
             x y) =>
      matita_basics_logic.rewrite_l
        (cic.lift (cic.type (cic.s (cic.s cic.z)))
           (cic.type (cic.s (cic.s cic.z))) A)
        x
        (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
         cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
           ((z : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
             matita_basics_logic.eq
               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                  (cic.type (cic.s (cic.s cic.z))) A)
               z x)
              __))
        (matita_basics_logic.refl
           (cic.lift (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s (cic.s cic.z))) A)
           x)
        y
        (matita_basics_logic.rewrite_l
           (cic.lift (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s (cic.s cic.z))) A)
           x
           (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
            cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
              ((x0 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                matita_basics_logic.eq
                  (cic.lift (cic.type (cic.s (cic.s cic.z)))
                     (cic.type (cic.s (cic.s cic.z))) A)
                  x x0)
                 __))
           (matita_basics_logic.refl
              (cic.lift (cic.type (cic.s (cic.s cic.z)))
                 (cic.type (cic.s (cic.s cic.z))) A)
              x)
           y Heq).

def rewrite_r :
      cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.univ (cic.type (cic.s (cic.s cic.z))))
           (A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
            cic.prod (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s (cic.s (cic.s cic.z)))) A
              (x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
                 (cic.type (cic.s (cic.s cic.z)))
                 (cic.prod (cic.type (cic.s (cic.s cic.z)))
                    (cic.type (cic.s (cic.s (cic.s cic.z)))) A
                    (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                     cic.univ (cic.type (cic.s (cic.s cic.z)))))
                 (P :
                    cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                      (cic.prod (cic.type (cic.s (cic.s cic.z)))
                         (cic.type (cic.s (cic.s (cic.s cic.z)))) A
                         (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                          cic.univ (cic.type (cic.s (cic.s cic.z))))) =>
                  cic.prod (cic.type (cic.s (cic.s cic.z)))
                    (cic.type (cic.s (cic.s cic.z))) (P x)
                    (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) (P x) =>
                     cic.prod (cic.type (cic.s (cic.s cic.z)))
                       (cic.type (cic.s (cic.s cic.z))) A
                       (y : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                        cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                          (matita_basics_logic.eq
                             (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                (cic.type (cic.s (cic.s cic.z))) A)
                             y x)
                          (__1 :
                             cic.Term cic.prop
                               (matita_basics_logic.eq
                                  (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                     (cic.type (cic.s (cic.s cic.z))) A)
                                  y x) =>
                           P y)))))))
      :=
      A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
      x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
      P :
        cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
          (cic.prod (cic.type (cic.s (cic.s cic.z)))
             (cic.type (cic.s (cic.s (cic.s cic.z)))) A
             (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
              cic.univ (cic.type (cic.s (cic.s cic.z))))) =>
      Hx : cic.Term (cic.type (cic.s (cic.s cic.z))) (P x) =>
      y : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
      Heq :
        cic.Term cic.prop
          (matita_basics_logic.eq
             (cic.lift (cic.type (cic.s (cic.s cic.z)))
                (cic.type (cic.s (cic.s cic.z))) A)
             y x) =>
      matita_basics_logic.match_eq_Type2
        (cic.lift (cic.type (cic.s (cic.s cic.z)))
           (cic.type (cic.s (cic.s cic.z))) A)
        x
        (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
         _0 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift (cic.type (cic.s (cic.s cic.z)))
                   (cic.type (cic.s (cic.s cic.z))) A)
                x __) =>
         P __)
        Hx y
        (matita_basics_logic.sym_eq
           (cic.lift (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s (cic.s cic.z))) A)
           y x Heq).

def eq_coerc :
      cic.Term (cic.type (cic.s cic.z))
        (cic.prod (cic.type (cic.s cic.z)) (cic.type (cic.s cic.z))
           (cic.univ (cic.type cic.z))
           (A : cic.Univ (cic.type cic.z) =>
            cic.prod (cic.type (cic.s cic.z)) (cic.type cic.z)
              (cic.univ (cic.type cic.z))
              (B : cic.Univ (cic.type cic.z) =>
               cic.prod (cic.type cic.z) (cic.type cic.z) A
                 (__ : cic.Term (cic.type cic.z) A =>
                  cic.prod cic.prop (cic.type cic.z)
                    (matita_basics_logic.eq
                       (cic.lift (cic.type (cic.s cic.z))
                          (cic.type (cic.s (cic.s cic.z)))
                          (cic.univ (cic.type cic.z)))
                       (cic.lift (cic.type cic.z) (cic.type cic.z) A)
                       (cic.lift (cic.type cic.z) (cic.type cic.z) B))
                    (__1 :
                       cic.Term cic.prop
                         (matita_basics_logic.eq
                            (cic.lift (cic.type (cic.s cic.z))
                               (cic.type (cic.s (cic.s cic.z)))
                               (cic.univ (cic.type cic.z)))
                            (cic.lift (cic.type cic.z) (cic.type cic.z) A)
                            (cic.lift (cic.type cic.z) (cic.type cic.z) B)) =>
                     B)))))
      :=
      A : cic.Univ (cic.type cic.z) =>
      B : cic.Univ (cic.type cic.z) =>
      Ha : cic.Term (cic.type cic.z) A =>
      Heq :
        cic.Term cic.prop
          (matita_basics_logic.eq
             (cic.lift (cic.type (cic.s cic.z))
                (cic.type (cic.s (cic.s cic.z))) (cic.univ (cic.type cic.z)))
             (cic.lift (cic.type cic.z) (cic.type cic.z) A)
             (cic.lift (cic.type cic.z) (cic.type cic.z) B)) =>
      matita_basics_logic.eq_rect_Type0
        (cic.lift (cic.type (cic.s cic.z)) (cic.type (cic.s (cic.s cic.z)))
           (cic.univ (cic.type cic.z)))
        (cic.lift (cic.type cic.z) (cic.type cic.z) A)
        (x_19 : cic.Univ (cic.type cic.z) =>
         _x_20 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift (cic.type (cic.s cic.z))
                   (cic.type (cic.s (cic.s cic.z)))
                   (cic.univ (cic.type cic.z)))
                (cic.lift (cic.type cic.z) (cic.type cic.z) A)
                (cic.lift (cic.type cic.z) (cic.type cic.z) x_19)) =>
         x_19)
        Ha (cic.lift (cic.type cic.z) (cic.type cic.z) B) Heq.

def trans_eq :
      cic.Term cic.prop
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z)))) cic.prop
           (cic.univ (cic.type (cic.s (cic.s cic.z))))
           (A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
            cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop A
              (x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop A
                 (y : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                  cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop A
                    (z : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                     cic.prod cic.prop cic.prop
                       (matita_basics_logic.eq
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          x y)
                       (__ :
                          cic.Term cic.prop
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               x y) =>
                        cic.prod cic.prop cic.prop
                          (matita_basics_logic.eq
                             (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                (cic.type (cic.s (cic.s cic.z))) A)
                             y z)
                          (__1 :
                             cic.Term cic.prop
                               (matita_basics_logic.eq
                                  (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                     (cic.type (cic.s (cic.s cic.z))) A)
                                  y z) =>
                           matita_basics_logic.eq
                             (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                (cic.type (cic.s (cic.s cic.z))) A)
                             x z)))))))
      :=
      A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
      x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
      y : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
      z : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
      H1 :
        cic.Term cic.prop
          (matita_basics_logic.eq
             (cic.lift (cic.type (cic.s (cic.s cic.z)))
                (cic.type (cic.s (cic.s cic.z))) A)
             x y) =>
      H2 :
        cic.Term cic.prop
          (matita_basics_logic.eq
             (cic.lift (cic.type (cic.s (cic.s cic.z)))
                (cic.type (cic.s (cic.s cic.z))) A)
             y z) =>
      matita_basics_logic.eq_ind_r
        (cic.lift (cic.type (cic.s (cic.s cic.z)))
           (cic.type (cic.s (cic.s cic.z))) A)
        y
        (x0 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
         __ :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift (cic.type (cic.s (cic.s cic.z)))
                   (cic.type (cic.s (cic.s cic.z))) A)
                x0 y) =>
         matita_basics_logic.eq
           (cic.lift (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s (cic.s cic.z))) A)
           x0 z)
        (matita_basics_logic.rewrite_l
           (cic.lift (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s (cic.s cic.z))) A)
           x
           (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
            cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
              ((x0 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                matita_basics_logic.eq
                  (cic.lift (cic.type (cic.s (cic.s cic.z)))
                     (cic.type (cic.s (cic.s cic.z))) A)
                  x0 z)
                 __))
           (matita_basics_logic.rewrite_l
              (cic.lift (cic.type (cic.s (cic.s cic.z)))
                 (cic.type (cic.s (cic.s cic.z))) A)
              x
              (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                 ((x0 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                   matita_basics_logic.eq
                     (cic.lift (cic.type (cic.s (cic.s cic.z)))
                        (cic.type (cic.s (cic.s cic.z))) A)
                     x x0)
                    __))
              (matita_basics_logic.refl
                 (cic.lift (cic.type (cic.s (cic.s cic.z)))
                    (cic.type (cic.s (cic.s cic.z))) A)
                 x)
              z
              (matita_basics_logic.rewrite_r
                 (cic.lift (cic.type (cic.s (cic.s cic.z)))
                    (cic.type (cic.s (cic.s cic.z))) A)
                 y
                 (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                  cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    ((x0 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                      matita_basics_logic.eq
                        (cic.lift (cic.type (cic.s (cic.s cic.z)))
                           (cic.type (cic.s (cic.s cic.z))) A)
                        x0 z)
                       __))
                 H2 x H1))
           y H1)
        x H1.

def eq_f :
      cic.Term cic.prop
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z)))) cic.prop
           (cic.univ (cic.type (cic.s (cic.s cic.z))))
           (A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
            cic.prod (cic.type (cic.s (cic.s (cic.s cic.z)))) cic.prop
              (cic.univ (cic.type (cic.s (cic.s cic.z))))
              (B : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
               cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop
                 (cic.prod (cic.type (cic.s (cic.s cic.z)))
                    (cic.type (cic.s (cic.s cic.z))) A
                    (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) A => B))
                 (f :
                    cic.Term (cic.type (cic.s (cic.s cic.z)))
                      (cic.prod (cic.type (cic.s (cic.s cic.z)))
                         (cic.type (cic.s (cic.s cic.z))) A
                         (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                          B)) =>
                  cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop A
                    (x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                     cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop A
                       (y : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                        cic.prod cic.prop cic.prop
                          (matita_basics_logic.eq
                             (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                (cic.type (cic.s (cic.s cic.z))) A)
                             x y)
                          (__ :
                             cic.Term cic.prop
                               (matita_basics_logic.eq
                                  (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                     (cic.type (cic.s (cic.s cic.z))) A)
                                  x y) =>
                           matita_basics_logic.eq
                             (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                (cic.type (cic.s (cic.s cic.z))) B)
                             (f x) (f y))))))))
      :=
      A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
      B : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
      f :
        cic.Term (cic.type (cic.s (cic.s cic.z)))
          (cic.prod (cic.type (cic.s (cic.s cic.z)))
             (cic.type (cic.s (cic.s cic.z))) A
             (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) A => B)) =>
      x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
      y : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
      H :
        cic.Term cic.prop
          (matita_basics_logic.eq
             (cic.lift (cic.type (cic.s (cic.s cic.z)))
                (cic.type (cic.s (cic.s cic.z))) A)
             x y) =>
      matita_basics_logic.eq_ind_r
        (cic.lift (cic.type (cic.s (cic.s cic.z)))
           (cic.type (cic.s (cic.s cic.z))) A)
        y
        (x0 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
         __ :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift (cic.type (cic.s (cic.s cic.z)))
                   (cic.type (cic.s (cic.s cic.z))) A)
                x0 y) =>
         matita_basics_logic.eq
           (cic.lift (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s (cic.s cic.z))) B)
           (f x0) (f y))
        (matita_basics_logic.rewrite_l
           (cic.lift (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s (cic.s cic.z))) A)
           x
           (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
            cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
              ((x0 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                matita_basics_logic.eq
                  (cic.lift (cic.type (cic.s (cic.s cic.z)))
                     (cic.type (cic.s (cic.s cic.z))) B)
                  (f x0) (f y))
                 __))
           (matita_basics_logic.rewrite_l
              (cic.lift (cic.type (cic.s (cic.s cic.z)))
                 (cic.type (cic.s (cic.s cic.z))) A)
              x
              (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                 ((x0 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                   matita_basics_logic.eq
                     (cic.lift (cic.type (cic.s (cic.s cic.z)))
                        (cic.type (cic.s (cic.s cic.z))) B)
                     (f x) (f x0))
                    __))
              (matita_basics_logic.refl
                 (cic.lift (cic.type (cic.s (cic.s cic.z)))
                    (cic.type (cic.s (cic.s cic.z))) B)
                 (f x))
              y H)
           y H)
        x H.

def eq_f2 :
      cic.Term cic.prop
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z)))) cic.prop
           (cic.univ (cic.type (cic.s (cic.s cic.z))))
           (A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
            cic.prod (cic.type (cic.s (cic.s (cic.s cic.z)))) cic.prop
              (cic.univ (cic.type (cic.s (cic.s cic.z))))
              (B : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
               cic.prod (cic.type (cic.s (cic.s (cic.s cic.z)))) cic.prop
                 (cic.univ (cic.type (cic.s (cic.s cic.z))))
                 (C : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
                  cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop
                    (cic.prod (cic.type (cic.s (cic.s cic.z)))
                       (cic.type (cic.s (cic.s cic.z))) A
                       (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                        cic.prod (cic.type (cic.s (cic.s cic.z)))
                          (cic.type (cic.s (cic.s cic.z))) B
                          (__1 :
                             cic.Term (cic.type (cic.s (cic.s cic.z))) B =>
                           C)))
                    (f :
                       cic.Term (cic.type (cic.s (cic.s cic.z)))
                         (cic.prod (cic.type (cic.s (cic.s cic.z)))
                            (cic.type (cic.s (cic.s cic.z))) A
                            (__ :
                               cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                             cic.prod (cic.type (cic.s (cic.s cic.z)))
                               (cic.type (cic.s (cic.s cic.z))) B
                               (__1 :
                                  cic.Term (cic.type (cic.s (cic.s cic.z))) B =>
                                C))) =>
                     cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop A
                       (x1 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                        cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop A
                          (x2 :
                             cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                           cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop
                             B
                             (y1 :
                                cic.Term (cic.type (cic.s (cic.s cic.z))) B =>
                              cic.prod (cic.type (cic.s (cic.s cic.z)))
                                cic.prop B
                                (y2 :
                                   cic.Term (cic.type (cic.s (cic.s cic.z)))
                                     B =>
                                 cic.prod cic.prop cic.prop
                                   (matita_basics_logic.eq
                                      (cic.lift
                                         (cic.type (cic.s (cic.s cic.z)))
                                         (cic.type (cic.s (cic.s cic.z))) A)
                                      x1 x2)
                                   (__ :
                                      cic.Term cic.prop
                                        (matita_basics_logic.eq
                                           (cic.lift
                                              (cic.type (cic.s (cic.s cic.z)))
                                              (cic.type (cic.s (cic.s cic.z)))
                                              A)
                                           x1 x2) =>
                                    cic.prod cic.prop cic.prop
                                      (matita_basics_logic.eq
                                         (cic.lift
                                            (cic.type (cic.s (cic.s cic.z)))
                                            (cic.type (cic.s (cic.s cic.z)))
                                            B)
                                         y1 y2)
                                      (__1 :
                                         cic.Term cic.prop
                                           (matita_basics_logic.eq
                                              (cic.lift
                                                 (cic.type
                                                    (cic.s (cic.s cic.z)))
                                                 (cic.type
                                                    (cic.s (cic.s cic.z)))
                                                 B)
                                              y1 y2) =>
                                       matita_basics_logic.eq
                                         (cic.lift
                                            (cic.type (cic.s (cic.s cic.z)))
                                            (cic.type (cic.s (cic.s cic.z)))
                                            C)
                                         (f x1 y1) (f x2 y2))))))))))))
      :=
      A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
      B : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
      C : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
      f :
        cic.Term (cic.type (cic.s (cic.s cic.z)))
          (cic.prod (cic.type (cic.s (cic.s cic.z)))
             (cic.type (cic.s (cic.s cic.z))) A
             (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
              cic.prod (cic.type (cic.s (cic.s cic.z)))
                (cic.type (cic.s (cic.s cic.z))) B
                (__1 : cic.Term (cic.type (cic.s (cic.s cic.z))) B => C))) =>
      x1 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
      x2 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
      y1 : cic.Term (cic.type (cic.s (cic.s cic.z))) B =>
      y2 : cic.Term (cic.type (cic.s (cic.s cic.z))) B =>
      E1 :
        cic.Term cic.prop
          (matita_basics_logic.eq
             (cic.lift (cic.type (cic.s (cic.s cic.z)))
                (cic.type (cic.s (cic.s cic.z))) A)
             x1 x2) =>
      E2 :
        cic.Term cic.prop
          (matita_basics_logic.eq
             (cic.lift (cic.type (cic.s (cic.s cic.z)))
                (cic.type (cic.s (cic.s cic.z))) B)
             y1 y2) =>
      matita_basics_logic.eq_ind_r
        (cic.lift (cic.type (cic.s (cic.s cic.z)))
           (cic.type (cic.s (cic.s cic.z))) A)
        x2
        (x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
         __ :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift (cic.type (cic.s (cic.s cic.z)))
                   (cic.type (cic.s (cic.s cic.z))) A)
                x x2) =>
         matita_basics_logic.eq
           (cic.lift (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s (cic.s cic.z))) C)
           (f x y1) (f x2 y2))
        (matita_basics_logic.eq_ind_r
           (cic.lift (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s (cic.s cic.z))) B)
           y2
           (x : cic.Term (cic.type (cic.s (cic.s cic.z))) B =>
            __ :
              cic.Term cic.prop
                (matita_basics_logic.eq
                   (cic.lift (cic.type (cic.s (cic.s cic.z)))
                      (cic.type (cic.s (cic.s cic.z))) B)
                   x y2) =>
            matita_basics_logic.eq
              (cic.lift (cic.type (cic.s (cic.s cic.z)))
                 (cic.type (cic.s (cic.s cic.z))) C)
              (f x2 x) (f x2 y2))
           (matita_basics_logic.rewrite_l
              (cic.lift (cic.type (cic.s (cic.s cic.z)))
                 (cic.type (cic.s (cic.s cic.z))) A)
              x1
              (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                 ((x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                   matita_basics_logic.eq
                     (cic.lift (cic.type (cic.s (cic.s cic.z)))
                        (cic.type (cic.s (cic.s cic.z))) C)
                     (f x y2) (f x2 y2))
                    __))
              (matita_basics_logic.rewrite_l
                 (cic.lift (cic.type (cic.s (cic.s cic.z)))
                    (cic.type (cic.s (cic.s cic.z))) B)
                 y1
                 (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) B =>
                  cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    ((x : cic.Term (cic.type (cic.s (cic.s cic.z))) B =>
                      matita_basics_logic.eq
                        (cic.lift (cic.type (cic.s (cic.s cic.z)))
                           (cic.type (cic.s (cic.s cic.z))) C)
                        (f x1 x) (f x2 y2))
                       __))
                 (matita_basics_logic.rewrite_l
                    (cic.lift (cic.type (cic.s (cic.s cic.z)))
                       (cic.type (cic.s (cic.s cic.z))) A)
                    x1
                    (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                     cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                       ((x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                         matita_basics_logic.eq
                           (cic.lift (cic.type (cic.s (cic.s cic.z)))
                              (cic.type (cic.s (cic.s cic.z))) C)
                           (f x1 y1) (f x y2))
                          __))
                    (matita_basics_logic.rewrite_l
                       (cic.lift (cic.type (cic.s (cic.s cic.z)))
                          (cic.type (cic.s (cic.s cic.z))) B)
                       y1
                       (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) B =>
                        cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                          ((x :
                              cic.Term (cic.type (cic.s (cic.s cic.z))) B =>
                            matita_basics_logic.eq
                              (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                 (cic.type (cic.s (cic.s cic.z))) C)
                              (f x1 y1) (f x1 x))
                             __))
                       (matita_basics_logic.refl
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) C)
                          (f x1 y1))
                       y2 E2)
                    x2 E1)
                 y2 E2)
              x2 E1)
           y1 E2)
        x1 E1.

def eq_f3 :
      cic.Term cic.prop
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z)))) cic.prop
           (cic.univ (cic.type (cic.s (cic.s cic.z))))
           (A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
            cic.prod (cic.type (cic.s (cic.s (cic.s cic.z)))) cic.prop
              (cic.univ (cic.type (cic.s (cic.s cic.z))))
              (B : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
               cic.prod (cic.type (cic.s (cic.s (cic.s cic.z)))) cic.prop
                 (cic.univ (cic.type (cic.s (cic.s cic.z))))
                 (C : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
                  cic.prod (cic.type (cic.s (cic.s (cic.s cic.z)))) cic.prop
                    (cic.univ (cic.type (cic.s (cic.s cic.z))))
                    (D : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
                     cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop
                       (cic.prod (cic.type (cic.s (cic.s cic.z)))
                          (cic.type (cic.s (cic.s cic.z))) A
                          (__ :
                             cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                           cic.prod (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) B
                             (__1 :
                                cic.Term (cic.type (cic.s (cic.s cic.z))) B =>
                              cic.prod (cic.type (cic.s (cic.s cic.z)))
                                (cic.type (cic.s (cic.s cic.z))) C
                                (__2 :
                                   cic.Term (cic.type (cic.s (cic.s cic.z)))
                                     C =>
                                 D))))
                       (f :
                          cic.Term (cic.type (cic.s (cic.s cic.z)))
                            (cic.prod (cic.type (cic.s (cic.s cic.z)))
                               (cic.type (cic.s (cic.s cic.z))) A
                               (__ :
                                  cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                                cic.prod (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) B
                                  (__1 :
                                     cic.Term
                                       (cic.type (cic.s (cic.s cic.z))) B =>
                                   cic.prod (cic.type (cic.s (cic.s cic.z)))
                                     (cic.type (cic.s (cic.s cic.z))) C
                                     (__2 :
                                        cic.Term
                                          (cic.type (cic.s (cic.s cic.z))) C =>
                                      D)))) =>
                        cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop A
                          (x1 :
                             cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                           cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop
                             A
                             (x2 :
                                cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                              cic.prod (cic.type (cic.s (cic.s cic.z)))
                                cic.prop B
                                (y1 :
                                   cic.Term (cic.type (cic.s (cic.s cic.z)))
                                     B =>
                                 cic.prod (cic.type (cic.s (cic.s cic.z)))
                                   cic.prop B
                                   (y2 :
                                      cic.Term
                                        (cic.type (cic.s (cic.s cic.z))) B =>
                                    cic.prod (cic.type (cic.s (cic.s cic.z)))
                                      cic.prop C
                                      (z1 :
                                         cic.Term
                                           (cic.type (cic.s (cic.s cic.z))) C =>
                                       cic.prod
                                         (cic.type (cic.s (cic.s cic.z)))
                                         cic.prop C
                                         (z2 :
                                            cic.Term
                                              (cic.type (cic.s (cic.s cic.z)))
                                              C =>
                                          cic.prod cic.prop cic.prop
                                            (matita_basics_logic.eq
                                               (cic.lift
                                                  (cic.type
                                                     (cic.s (cic.s cic.z)))
                                                  (cic.type
                                                     (cic.s (cic.s cic.z)))
                                                  A)
                                               x1 x2)
                                            (__ :
                                               cic.Term cic.prop
                                                 (matita_basics_logic.eq
                                                    (cic.lift
                                                       (cic.type
                                                          (cic.s
                                                             (cic.s cic.z)))
                                                       (cic.type
                                                          (cic.s
                                                             (cic.s cic.z)))
                                                       A)
                                                    x1 x2) =>
                                             cic.prod cic.prop cic.prop
                                               (matita_basics_logic.eq
                                                  (cic.lift
                                                     (cic.type
                                                        (cic.s (cic.s cic.z)))
                                                     (cic.type
                                                        (cic.s (cic.s cic.z)))
                                                     B)
                                                  y1 y2)
                                               (__1 :
                                                  cic.Term cic.prop
                                                    (matita_basics_logic.eq
                                                       (cic.lift
                                                          (cic.type
                                                             (cic.s
                                                                (cic.s cic.z)))
                                                          (cic.type
                                                             (cic.s
                                                                (cic.s cic.z)))
                                                          B)
                                                       y1 y2) =>
                                                cic.prod cic.prop cic.prop
                                                  (matita_basics_logic.eq
                                                     (cic.lift
                                                        (cic.type
                                                           (cic.s
                                                              (cic.s cic.z)))
                                                        (cic.type
                                                           (cic.s
                                                              (cic.s cic.z)))
                                                        C)
                                                     z1 z2)
                                                  (__2 :
                                                     cic.Term cic.prop
                                                       (matita_basics_logic.eq
                                                          (cic.lift
                                                             (cic.type
                                                                (cic.s
                                                                   (cic.s
                                                                    cic.z)))
                                                             (cic.type
                                                                (cic.s
                                                                   (cic.s
                                                                    cic.z)))
                                                             C)
                                                          z1 z2) =>
                                                   matita_basics_logic.eq
                                                     (cic.lift
                                                        (cic.type
                                                           (cic.s
                                                              (cic.s cic.z)))
                                                        (cic.type
                                                           (cic.s
                                                              (cic.s cic.z)))
                                                        D)
                                                     (f x1 y1 z1)
                                                     (f x2 y2 z2))))))))))))))))
      :=
      A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
      B : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
      C : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
      D : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
      f :
        cic.Term (cic.type (cic.s (cic.s cic.z)))
          (cic.prod (cic.type (cic.s (cic.s cic.z)))
             (cic.type (cic.s (cic.s cic.z))) A
             (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
              cic.prod (cic.type (cic.s (cic.s cic.z)))
                (cic.type (cic.s (cic.s cic.z))) B
                (__1 : cic.Term (cic.type (cic.s (cic.s cic.z))) B =>
                 cic.prod (cic.type (cic.s (cic.s cic.z)))
                   (cic.type (cic.s (cic.s cic.z))) C
                   (__2 : cic.Term (cic.type (cic.s (cic.s cic.z))) C => D)))) =>
      x1 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
      x2 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
      y1 : cic.Term (cic.type (cic.s (cic.s cic.z))) B =>
      y2 : cic.Term (cic.type (cic.s (cic.s cic.z))) B =>
      z1 : cic.Term (cic.type (cic.s (cic.s cic.z))) C =>
      z2 : cic.Term (cic.type (cic.s (cic.s cic.z))) C =>
      E1 :
        cic.Term cic.prop
          (matita_basics_logic.eq
             (cic.lift (cic.type (cic.s (cic.s cic.z)))
                (cic.type (cic.s (cic.s cic.z))) A)
             x1 x2) =>
      E2 :
        cic.Term cic.prop
          (matita_basics_logic.eq
             (cic.lift (cic.type (cic.s (cic.s cic.z)))
                (cic.type (cic.s (cic.s cic.z))) B)
             y1 y2) =>
      E3 :
        cic.Term cic.prop
          (matita_basics_logic.eq
             (cic.lift (cic.type (cic.s (cic.s cic.z)))
                (cic.type (cic.s (cic.s cic.z))) C)
             z1 z2) =>
      matita_basics_logic.eq_ind_r
        (cic.lift (cic.type (cic.s (cic.s cic.z)))
           (cic.type (cic.s (cic.s cic.z))) A)
        x2
        (x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
         __ :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift (cic.type (cic.s (cic.s cic.z)))
                   (cic.type (cic.s (cic.s cic.z))) A)
                x x2) =>
         matita_basics_logic.eq
           (cic.lift (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s (cic.s cic.z))) D)
           (f x y1 z1) (f x2 y2 z2))
        (matita_basics_logic.eq_ind_r
           (cic.lift (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s (cic.s cic.z))) B)
           y2
           (x : cic.Term (cic.type (cic.s (cic.s cic.z))) B =>
            __ :
              cic.Term cic.prop
                (matita_basics_logic.eq
                   (cic.lift (cic.type (cic.s (cic.s cic.z)))
                      (cic.type (cic.s (cic.s cic.z))) B)
                   x y2) =>
            matita_basics_logic.eq
              (cic.lift (cic.type (cic.s (cic.s cic.z)))
                 (cic.type (cic.s (cic.s cic.z))) D)
              (f x2 x z1) (f x2 y2 z2))
           (matita_basics_logic.eq_ind_r
              (cic.lift (cic.type (cic.s (cic.s cic.z)))
                 (cic.type (cic.s (cic.s cic.z))) C)
              z2
              (x : cic.Term (cic.type (cic.s (cic.s cic.z))) C =>
               __ :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift (cic.type (cic.s (cic.s cic.z)))
                         (cic.type (cic.s (cic.s cic.z))) C)
                      x z2) =>
               matita_basics_logic.eq
                 (cic.lift (cic.type (cic.s (cic.s cic.z)))
                    (cic.type (cic.s (cic.s cic.z))) D)
                 (f x2 y2 x) (f x2 y2 z2))
              (matita_basics_logic.refl
                 (cic.lift (cic.type (cic.s (cic.s cic.z)))
                    (cic.type (cic.s (cic.s cic.z))) D)
                 (f x2 y2 z2))
              z1 E3)
           y1 E2)
        x1 E1.

True : cic.Univ cic.prop.

I : cic.Term cic.prop matita_basics_logic.True.

def match_True_Prop :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop
           (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.True
              (z : cic.Term cic.prop matita_basics_logic.True =>
               cic.univ cic.prop))
           (return_type :
              cic.Term (cic.type cic.z)
                (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.True
                   (z : cic.Term cic.prop matita_basics_logic.True =>
                    cic.univ cic.prop)) =>
            cic.prod cic.prop cic.prop (return_type matita_basics_logic.I)
              (case_I :
                 cic.Term cic.prop (return_type matita_basics_logic.I) =>
               cic.prod cic.prop cic.prop matita_basics_logic.True
                 (z : cic.Term cic.prop matita_basics_logic.True =>
                  return_type z)))).

[ return_type, case_I ]
  match_True_Prop return_type case_I matita_basics_logic.I --> case_I.

def match_True_Type5 :
      cic.Term
        (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
        (cic.prod
           (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
           (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
           (cic.prod cic.prop
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
              matita_basics_logic.True
              (z : cic.Term cic.prop matita_basics_logic.True =>
               cic.univ
                 (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))))
           (return_type :
              cic.Term
                (cic.type
                   (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                (cic.prod cic.prop
                   (cic.type
                      (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                   matita_basics_logic.True
                   (z : cic.Term cic.prop matita_basics_logic.True =>
                    cic.univ
                      (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))) =>
            cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
              (return_type matita_basics_logic.I)
              (case_I :
                 cic.Term
                   (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                   (return_type matita_basics_logic.I) =>
               cic.prod cic.prop
                 (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                 matita_basics_logic.True
                 (z : cic.Term cic.prop matita_basics_logic.True =>
                  return_type z)))).

[ return_type, case_I ]
  match_True_Type5 return_type case_I matita_basics_logic.I --> case_I.

def match_True_Type4 :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
        (cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
           (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
           (cic.prod cic.prop
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
              matita_basics_logic.True
              (z : cic.Term cic.prop matita_basics_logic.True =>
               cic.univ (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))))
           (return_type :
              cic.Term
                (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                (cic.prod cic.prop
                   (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                   matita_basics_logic.True
                   (z : cic.Term cic.prop matita_basics_logic.True =>
                    cic.univ (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))))) =>
            cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
              (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
              (return_type matita_basics_logic.I)
              (case_I :
                 cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                   (return_type matita_basics_logic.I) =>
               cic.prod cic.prop
                 (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                 matita_basics_logic.True
                 (z : cic.Term cic.prop matita_basics_logic.True =>
                  return_type z)))).

[ return_type, case_I ]
  match_True_Type4 return_type case_I matita_basics_logic.I --> case_I.

def match_True_Type3 :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
        (cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
           (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.prod cic.prop
              (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
              matita_basics_logic.True
              (z : cic.Term cic.prop matita_basics_logic.True =>
               cic.univ (cic.type (cic.s (cic.s (cic.s cic.z))))))
           (return_type :
              cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                (cic.prod cic.prop
                   (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                   matita_basics_logic.True
                   (z : cic.Term cic.prop matita_basics_logic.True =>
                    cic.univ (cic.type (cic.s (cic.s (cic.s cic.z)))))) =>
            cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
              (cic.type (cic.s (cic.s (cic.s cic.z))))
              (return_type matita_basics_logic.I)
              (case_I :
                 cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                   (return_type matita_basics_logic.I) =>
               cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
                 matita_basics_logic.True
                 (z : cic.Term cic.prop matita_basics_logic.True =>
                  return_type z)))).

[ return_type, case_I ]
  match_True_Type3 return_type case_I matita_basics_logic.I --> case_I.

def match_True_Type2 :
      cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.type (cic.s (cic.s cic.z)))
           (cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
              matita_basics_logic.True
              (z : cic.Term cic.prop matita_basics_logic.True =>
               cic.univ (cic.type (cic.s (cic.s cic.z)))))
           (return_type :
              cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                (cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
                   matita_basics_logic.True
                   (z : cic.Term cic.prop matita_basics_logic.True =>
                    cic.univ (cic.type (cic.s (cic.s cic.z))))) =>
            cic.prod (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s (cic.s cic.z)))
              (return_type matita_basics_logic.I)
              (case_I :
                 cic.Term (cic.type (cic.s (cic.s cic.z)))
                   (return_type matita_basics_logic.I) =>
               cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                 matita_basics_logic.True
                 (z : cic.Term cic.prop matita_basics_logic.True =>
                  return_type z)))).

[ return_type, case_I ]
  match_True_Type2 return_type case_I matita_basics_logic.I --> case_I.

def match_True_Type1 :
      cic.Term (cic.type (cic.s (cic.s cic.z)))
        (cic.prod (cic.type (cic.s (cic.s cic.z))) (cic.type (cic.s cic.z))
           (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
              matita_basics_logic.True
              (z : cic.Term cic.prop matita_basics_logic.True =>
               cic.univ (cic.type (cic.s cic.z))))
           (return_type :
              cic.Term (cic.type (cic.s (cic.s cic.z)))
                (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                   matita_basics_logic.True
                   (z : cic.Term cic.prop matita_basics_logic.True =>
                    cic.univ (cic.type (cic.s cic.z)))) =>
            cic.prod (cic.type (cic.s cic.z)) (cic.type (cic.s cic.z))
              (return_type matita_basics_logic.I)
              (case_I :
                 cic.Term (cic.type (cic.s cic.z))
                   (return_type matita_basics_logic.I) =>
               cic.prod cic.prop (cic.type (cic.s cic.z))
                 matita_basics_logic.True
                 (z : cic.Term cic.prop matita_basics_logic.True =>
                  return_type z)))).

[ return_type, case_I ]
  match_True_Type1 return_type case_I matita_basics_logic.I --> case_I.

def match_True_Type0 :
      cic.Term (cic.type (cic.s cic.z))
        (cic.prod (cic.type (cic.s cic.z)) (cic.type cic.z)
           (cic.prod cic.prop (cic.type (cic.s cic.z))
              matita_basics_logic.True
              (z : cic.Term cic.prop matita_basics_logic.True =>
               cic.univ (cic.type cic.z)))
           (return_type :
              cic.Term (cic.type (cic.s cic.z))
                (cic.prod cic.prop (cic.type (cic.s cic.z))
                   matita_basics_logic.True
                   (z : cic.Term cic.prop matita_basics_logic.True =>
                    cic.univ (cic.type cic.z))) =>
            cic.prod (cic.type cic.z) (cic.type cic.z)
              (return_type matita_basics_logic.I)
              (case_I :
                 cic.Term (cic.type cic.z)
                   (return_type matita_basics_logic.I) =>
               cic.prod cic.prop (cic.type cic.z) matita_basics_logic.True
                 (z : cic.Term cic.prop matita_basics_logic.True =>
                  return_type z)))).

[ return_type, case_I ]
  match_True_Type0 return_type case_I matita_basics_logic.I --> case_I.

def filter_True_Prop :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop
           (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.True
              (z : cic.Term cic.prop matita_basics_logic.True =>
               cic.univ cic.prop))
           (return_type :
              cic.Term (cic.type cic.z)
                (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.True
                   (z : cic.Term cic.prop matita_basics_logic.True =>
                    cic.univ cic.prop)) =>
            cic.prod cic.prop cic.prop
              (cic.prod cic.prop cic.prop matita_basics_logic.True
                 (z : cic.Term cic.prop matita_basics_logic.True =>
                  return_type z))
              (return :
                 cic.Term cic.prop
                   (cic.prod cic.prop cic.prop matita_basics_logic.True
                      (z : cic.Term cic.prop matita_basics_logic.True =>
                       return_type z)) =>
               cic.prod cic.prop cic.prop matita_basics_logic.True
                 (z : cic.Term cic.prop matita_basics_logic.True =>
                  return_type z)))).

[ return_type, return ]
  filter_True_Prop return_type return matita_basics_logic.I -->
  return matita_basics_logic.I.

def filter_True_Type5 :
      cic.Term
        (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
        (cic.prod
           (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
           (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
           (cic.prod cic.prop
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
              matita_basics_logic.True
              (z : cic.Term cic.prop matita_basics_logic.True =>
               cic.univ
                 (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))))
           (return_type :
              cic.Term
                (cic.type
                   (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                (cic.prod cic.prop
                   (cic.type
                      (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                   matita_basics_logic.True
                   (z : cic.Term cic.prop matita_basics_logic.True =>
                    cic.univ
                      (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))) =>
            cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
              (cic.prod cic.prop
                 (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                 matita_basics_logic.True
                 (z : cic.Term cic.prop matita_basics_logic.True =>
                  return_type z))
              (return :
                 cic.Term
                   (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                   (cic.prod cic.prop
                      (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                      matita_basics_logic.True
                      (z : cic.Term cic.prop matita_basics_logic.True =>
                       return_type z)) =>
               cic.prod cic.prop
                 (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                 matita_basics_logic.True
                 (z : cic.Term cic.prop matita_basics_logic.True =>
                  return_type z)))).

[ return_type, return ]
  filter_True_Type5 return_type return matita_basics_logic.I -->
  return matita_basics_logic.I.

def filter_True_Type4 :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
        (cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
           (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
           (cic.prod cic.prop
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
              matita_basics_logic.True
              (z : cic.Term cic.prop matita_basics_logic.True =>
               cic.univ (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))))
           (return_type :
              cic.Term
                (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                (cic.prod cic.prop
                   (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                   matita_basics_logic.True
                   (z : cic.Term cic.prop matita_basics_logic.True =>
                    cic.univ (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))))) =>
            cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
              (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
              (cic.prod cic.prop
                 (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                 matita_basics_logic.True
                 (z : cic.Term cic.prop matita_basics_logic.True =>
                  return_type z))
              (return :
                 cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                   (cic.prod cic.prop
                      (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                      matita_basics_logic.True
                      (z : cic.Term cic.prop matita_basics_logic.True =>
                       return_type z)) =>
               cic.prod cic.prop
                 (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                 matita_basics_logic.True
                 (z : cic.Term cic.prop matita_basics_logic.True =>
                  return_type z)))).

[ return_type, return ]
  filter_True_Type4 return_type return matita_basics_logic.I -->
  return matita_basics_logic.I.

def filter_True_Type3 :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
        (cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
           (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.prod cic.prop
              (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
              matita_basics_logic.True
              (z : cic.Term cic.prop matita_basics_logic.True =>
               cic.univ (cic.type (cic.s (cic.s (cic.s cic.z))))))
           (return_type :
              cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                (cic.prod cic.prop
                   (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                   matita_basics_logic.True
                   (z : cic.Term cic.prop matita_basics_logic.True =>
                    cic.univ (cic.type (cic.s (cic.s (cic.s cic.z)))))) =>
            cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
              (cic.type (cic.s (cic.s (cic.s cic.z))))
              (cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
                 matita_basics_logic.True
                 (z : cic.Term cic.prop matita_basics_logic.True =>
                  return_type z))
              (return :
                 cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                   (cic.prod cic.prop
                      (cic.type (cic.s (cic.s (cic.s cic.z))))
                      matita_basics_logic.True
                      (z : cic.Term cic.prop matita_basics_logic.True =>
                       return_type z)) =>
               cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
                 matita_basics_logic.True
                 (z : cic.Term cic.prop matita_basics_logic.True =>
                  return_type z)))).

[ return_type, return ]
  filter_True_Type3 return_type return matita_basics_logic.I -->
  return matita_basics_logic.I.

def filter_True_Type2 :
      cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.type (cic.s (cic.s cic.z)))
           (cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
              matita_basics_logic.True
              (z : cic.Term cic.prop matita_basics_logic.True =>
               cic.univ (cic.type (cic.s (cic.s cic.z)))))
           (return_type :
              cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                (cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
                   matita_basics_logic.True
                   (z : cic.Term cic.prop matita_basics_logic.True =>
                    cic.univ (cic.type (cic.s (cic.s cic.z))))) =>
            cic.prod (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s (cic.s cic.z)))
              (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                 matita_basics_logic.True
                 (z : cic.Term cic.prop matita_basics_logic.True =>
                  return_type z))
              (return :
                 cic.Term (cic.type (cic.s (cic.s cic.z)))
                   (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                      matita_basics_logic.True
                      (z : cic.Term cic.prop matita_basics_logic.True =>
                       return_type z)) =>
               cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                 matita_basics_logic.True
                 (z : cic.Term cic.prop matita_basics_logic.True =>
                  return_type z)))).

[ return_type, return ]
  filter_True_Type2 return_type return matita_basics_logic.I -->
  return matita_basics_logic.I.

def filter_True_Type1 :
      cic.Term (cic.type (cic.s (cic.s cic.z)))
        (cic.prod (cic.type (cic.s (cic.s cic.z))) (cic.type (cic.s cic.z))
           (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
              matita_basics_logic.True
              (z : cic.Term cic.prop matita_basics_logic.True =>
               cic.univ (cic.type (cic.s cic.z))))
           (return_type :
              cic.Term (cic.type (cic.s (cic.s cic.z)))
                (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                   matita_basics_logic.True
                   (z : cic.Term cic.prop matita_basics_logic.True =>
                    cic.univ (cic.type (cic.s cic.z)))) =>
            cic.prod (cic.type (cic.s cic.z)) (cic.type (cic.s cic.z))
              (cic.prod cic.prop (cic.type (cic.s cic.z))
                 matita_basics_logic.True
                 (z : cic.Term cic.prop matita_basics_logic.True =>
                  return_type z))
              (return :
                 cic.Term (cic.type (cic.s cic.z))
                   (cic.prod cic.prop (cic.type (cic.s cic.z))
                      matita_basics_logic.True
                      (z : cic.Term cic.prop matita_basics_logic.True =>
                       return_type z)) =>
               cic.prod cic.prop (cic.type (cic.s cic.z))
                 matita_basics_logic.True
                 (z : cic.Term cic.prop matita_basics_logic.True =>
                  return_type z)))).

[ return_type, return ]
  filter_True_Type1 return_type return matita_basics_logic.I -->
  return matita_basics_logic.I.

def filter_True_Type0 :
      cic.Term (cic.type (cic.s cic.z))
        (cic.prod (cic.type (cic.s cic.z)) (cic.type cic.z)
           (cic.prod cic.prop (cic.type (cic.s cic.z))
              matita_basics_logic.True
              (z : cic.Term cic.prop matita_basics_logic.True =>
               cic.univ (cic.type cic.z)))
           (return_type :
              cic.Term (cic.type (cic.s cic.z))
                (cic.prod cic.prop (cic.type (cic.s cic.z))
                   matita_basics_logic.True
                   (z : cic.Term cic.prop matita_basics_logic.True =>
                    cic.univ (cic.type cic.z))) =>
            cic.prod (cic.type cic.z) (cic.type cic.z)
              (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.True
                 (z : cic.Term cic.prop matita_basics_logic.True =>
                  return_type z))
              (return :
                 cic.Term (cic.type cic.z)
                   (cic.prod cic.prop (cic.type cic.z)
                      matita_basics_logic.True
                      (z : cic.Term cic.prop matita_basics_logic.True =>
                       return_type z)) =>
               cic.prod cic.prop (cic.type cic.z) matita_basics_logic.True
                 (z : cic.Term cic.prop matita_basics_logic.True =>
                  return_type z)))).

[ return_type, return ]
  filter_True_Type0 return_type return matita_basics_logic.I -->
  return matita_basics_logic.I.

def True_ind :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop
           (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.True
              (_x_40 : cic.Term cic.prop matita_basics_logic.True =>
               cic.univ cic.prop))
           (Q_ :
              cic.Term (cic.type cic.z)
                (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.True
                   (_x_40 : cic.Term cic.prop matita_basics_logic.True =>
                    cic.univ cic.prop)) =>
            cic.prod cic.prop cic.prop (Q_ matita_basics_logic.I)
              (_H_I : cic.Term cic.prop (Q_ matita_basics_logic.I) =>
               cic.prod cic.prop cic.prop matita_basics_logic.True
                 (x_40 : cic.Term cic.prop matita_basics_logic.True =>
                  Q_ x_40)))).

def True_ind_body :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop
           (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.True
              (_x_40 : cic.Term cic.prop matita_basics_logic.True =>
               cic.univ cic.prop))
           (Q_ :
              cic.Term (cic.type cic.z)
                (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.True
                   (_x_40 : cic.Term cic.prop matita_basics_logic.True =>
                    cic.univ cic.prop)) =>
            cic.prod cic.prop cic.prop (Q_ matita_basics_logic.I)
              (_H_I : cic.Term cic.prop (Q_ matita_basics_logic.I) =>
               cic.prod cic.prop cic.prop matita_basics_logic.True
                 (x_40 : cic.Term cic.prop matita_basics_logic.True =>
                  Q_ x_40)))).

[ Q_, _H_I, x_40 ] True_ind Q_ _H_I x_40 -->
  matita_basics_logic.filter_True_Prop
    (x_40 : cic.Term cic.prop matita_basics_logic.True => Q_ x_40)
    (matita_basics_logic.True_ind_body Q_ _H_I) x_40.

[ Q_, _H_I, x_40 ] True_ind_body Q_ _H_I x_40 -->
  matita_basics_logic.match_True_Prop Q_ _H_I x_40.

def True_rect_Type4 :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
        (cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
           (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
           (cic.prod cic.prop
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
              matita_basics_logic.True
              (_x_42 : cic.Term cic.prop matita_basics_logic.True =>
               cic.univ (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))))
           (Q_ :
              cic.Term
                (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                (cic.prod cic.prop
                   (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                   matita_basics_logic.True
                   (_x_42 : cic.Term cic.prop matita_basics_logic.True =>
                    cic.univ (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))))) =>
            cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
              (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
              (Q_ matita_basics_logic.I)
              (_H_I :
                 cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                   (Q_ matita_basics_logic.I) =>
               cic.prod cic.prop
                 (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                 matita_basics_logic.True
                 (x_42 : cic.Term cic.prop matita_basics_logic.True =>
                  Q_ x_42)))).

def True_rect_Type4_body :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
        (cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
           (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
           (cic.prod cic.prop
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
              matita_basics_logic.True
              (_x_42 : cic.Term cic.prop matita_basics_logic.True =>
               cic.univ (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))))
           (Q_ :
              cic.Term
                (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                (cic.prod cic.prop
                   (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                   matita_basics_logic.True
                   (_x_42 : cic.Term cic.prop matita_basics_logic.True =>
                    cic.univ (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))))) =>
            cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
              (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
              (Q_ matita_basics_logic.I)
              (_H_I :
                 cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                   (Q_ matita_basics_logic.I) =>
               cic.prod cic.prop
                 (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                 matita_basics_logic.True
                 (x_42 : cic.Term cic.prop matita_basics_logic.True =>
                  Q_ x_42)))).

[ Q_, _H_I, x_42 ] True_rect_Type4 Q_ _H_I x_42 -->
  matita_basics_logic.filter_True_Type4
    (x_42 : cic.Term cic.prop matita_basics_logic.True => Q_ x_42)
    (matita_basics_logic.True_rect_Type4_body Q_ _H_I) x_42.

[ Q_, _H_I, x_42 ] True_rect_Type4_body Q_ _H_I x_42 -->
  matita_basics_logic.match_True_Type4 Q_ _H_I x_42.

def True_rect_Type5 :
      cic.Term
        (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
        (cic.prod
           (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
           (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
           (cic.prod cic.prop
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
              matita_basics_logic.True
              (_x_44 : cic.Term cic.prop matita_basics_logic.True =>
               cic.univ
                 (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))))
           (Q_ :
              cic.Term
                (cic.type
                   (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                (cic.prod cic.prop
                   (cic.type
                      (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                   matita_basics_logic.True
                   (_x_44 : cic.Term cic.prop matita_basics_logic.True =>
                    cic.univ
                      (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))) =>
            cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
              (Q_ matita_basics_logic.I)
              (_H_I :
                 cic.Term
                   (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                   (Q_ matita_basics_logic.I) =>
               cic.prod cic.prop
                 (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                 matita_basics_logic.True
                 (x_44 : cic.Term cic.prop matita_basics_logic.True =>
                  Q_ x_44)))).

def True_rect_Type5_body :
      cic.Term
        (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
        (cic.prod
           (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
           (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
           (cic.prod cic.prop
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
              matita_basics_logic.True
              (_x_44 : cic.Term cic.prop matita_basics_logic.True =>
               cic.univ
                 (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))))
           (Q_ :
              cic.Term
                (cic.type
                   (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                (cic.prod cic.prop
                   (cic.type
                      (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                   matita_basics_logic.True
                   (_x_44 : cic.Term cic.prop matita_basics_logic.True =>
                    cic.univ
                      (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))) =>
            cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
              (Q_ matita_basics_logic.I)
              (_H_I :
                 cic.Term
                   (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                   (Q_ matita_basics_logic.I) =>
               cic.prod cic.prop
                 (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                 matita_basics_logic.True
                 (x_44 : cic.Term cic.prop matita_basics_logic.True =>
                  Q_ x_44)))).

[ Q_, _H_I, x_44 ] True_rect_Type5 Q_ _H_I x_44 -->
  matita_basics_logic.filter_True_Type5
    (x_44 : cic.Term cic.prop matita_basics_logic.True => Q_ x_44)
    (matita_basics_logic.True_rect_Type5_body Q_ _H_I) x_44.

[ Q_, _H_I, x_44 ] True_rect_Type5_body Q_ _H_I x_44 -->
  matita_basics_logic.match_True_Type5 Q_ _H_I x_44.

def True_rect_Type3 :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
        (cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
           (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.prod cic.prop
              (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
              matita_basics_logic.True
              (_x_46 : cic.Term cic.prop matita_basics_logic.True =>
               cic.univ (cic.type (cic.s (cic.s (cic.s cic.z))))))
           (Q_ :
              cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                (cic.prod cic.prop
                   (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                   matita_basics_logic.True
                   (_x_46 : cic.Term cic.prop matita_basics_logic.True =>
                    cic.univ (cic.type (cic.s (cic.s (cic.s cic.z)))))) =>
            cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
              (cic.type (cic.s (cic.s (cic.s cic.z))))
              (Q_ matita_basics_logic.I)
              (_H_I :
                 cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                   (Q_ matita_basics_logic.I) =>
               cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
                 matita_basics_logic.True
                 (x_46 : cic.Term cic.prop matita_basics_logic.True =>
                  Q_ x_46)))).

def True_rect_Type3_body :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
        (cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
           (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.prod cic.prop
              (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
              matita_basics_logic.True
              (_x_46 : cic.Term cic.prop matita_basics_logic.True =>
               cic.univ (cic.type (cic.s (cic.s (cic.s cic.z))))))
           (Q_ :
              cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                (cic.prod cic.prop
                   (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                   matita_basics_logic.True
                   (_x_46 : cic.Term cic.prop matita_basics_logic.True =>
                    cic.univ (cic.type (cic.s (cic.s (cic.s cic.z)))))) =>
            cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
              (cic.type (cic.s (cic.s (cic.s cic.z))))
              (Q_ matita_basics_logic.I)
              (_H_I :
                 cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                   (Q_ matita_basics_logic.I) =>
               cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
                 matita_basics_logic.True
                 (x_46 : cic.Term cic.prop matita_basics_logic.True =>
                  Q_ x_46)))).

[ Q_, _H_I, x_46 ] True_rect_Type3 Q_ _H_I x_46 -->
  matita_basics_logic.filter_True_Type3
    (x_46 : cic.Term cic.prop matita_basics_logic.True => Q_ x_46)
    (matita_basics_logic.True_rect_Type3_body Q_ _H_I) x_46.

[ Q_, _H_I, x_46 ] True_rect_Type3_body Q_ _H_I x_46 -->
  matita_basics_logic.match_True_Type3 Q_ _H_I x_46.

def True_rect_Type2 :
      cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.type (cic.s (cic.s cic.z)))
           (cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
              matita_basics_logic.True
              (_x_48 : cic.Term cic.prop matita_basics_logic.True =>
               cic.univ (cic.type (cic.s (cic.s cic.z)))))
           (Q_ :
              cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                (cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
                   matita_basics_logic.True
                   (_x_48 : cic.Term cic.prop matita_basics_logic.True =>
                    cic.univ (cic.type (cic.s (cic.s cic.z))))) =>
            cic.prod (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s (cic.s cic.z))) (Q_ matita_basics_logic.I)
              (_H_I :
                 cic.Term (cic.type (cic.s (cic.s cic.z)))
                   (Q_ matita_basics_logic.I) =>
               cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                 matita_basics_logic.True
                 (x_48 : cic.Term cic.prop matita_basics_logic.True =>
                  Q_ x_48)))).

def True_rect_Type2_body :
      cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.type (cic.s (cic.s cic.z)))
           (cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
              matita_basics_logic.True
              (_x_48 : cic.Term cic.prop matita_basics_logic.True =>
               cic.univ (cic.type (cic.s (cic.s cic.z)))))
           (Q_ :
              cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                (cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
                   matita_basics_logic.True
                   (_x_48 : cic.Term cic.prop matita_basics_logic.True =>
                    cic.univ (cic.type (cic.s (cic.s cic.z))))) =>
            cic.prod (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s (cic.s cic.z))) (Q_ matita_basics_logic.I)
              (_H_I :
                 cic.Term (cic.type (cic.s (cic.s cic.z)))
                   (Q_ matita_basics_logic.I) =>
               cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                 matita_basics_logic.True
                 (x_48 : cic.Term cic.prop matita_basics_logic.True =>
                  Q_ x_48)))).

[ Q_, _H_I, x_48 ] True_rect_Type2 Q_ _H_I x_48 -->
  matita_basics_logic.filter_True_Type2
    (x_48 : cic.Term cic.prop matita_basics_logic.True => Q_ x_48)
    (matita_basics_logic.True_rect_Type2_body Q_ _H_I) x_48.

[ Q_, _H_I, x_48 ] True_rect_Type2_body Q_ _H_I x_48 -->
  matita_basics_logic.match_True_Type2 Q_ _H_I x_48.

def True_rect_Type1 :
      cic.Term (cic.type (cic.s (cic.s cic.z)))
        (cic.prod (cic.type (cic.s (cic.s cic.z))) (cic.type (cic.s cic.z))
           (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
              matita_basics_logic.True
              (_x_50 : cic.Term cic.prop matita_basics_logic.True =>
               cic.univ (cic.type (cic.s cic.z))))
           (Q_ :
              cic.Term (cic.type (cic.s (cic.s cic.z)))
                (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                   matita_basics_logic.True
                   (_x_50 : cic.Term cic.prop matita_basics_logic.True =>
                    cic.univ (cic.type (cic.s cic.z)))) =>
            cic.prod (cic.type (cic.s cic.z)) (cic.type (cic.s cic.z))
              (Q_ matita_basics_logic.I)
              (_H_I :
                 cic.Term (cic.type (cic.s cic.z)) (Q_ matita_basics_logic.I) =>
               cic.prod cic.prop (cic.type (cic.s cic.z))
                 matita_basics_logic.True
                 (x_50 : cic.Term cic.prop matita_basics_logic.True =>
                  Q_ x_50)))).

def True_rect_Type1_body :
      cic.Term (cic.type (cic.s (cic.s cic.z)))
        (cic.prod (cic.type (cic.s (cic.s cic.z))) (cic.type (cic.s cic.z))
           (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
              matita_basics_logic.True
              (_x_50 : cic.Term cic.prop matita_basics_logic.True =>
               cic.univ (cic.type (cic.s cic.z))))
           (Q_ :
              cic.Term (cic.type (cic.s (cic.s cic.z)))
                (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                   matita_basics_logic.True
                   (_x_50 : cic.Term cic.prop matita_basics_logic.True =>
                    cic.univ (cic.type (cic.s cic.z)))) =>
            cic.prod (cic.type (cic.s cic.z)) (cic.type (cic.s cic.z))
              (Q_ matita_basics_logic.I)
              (_H_I :
                 cic.Term (cic.type (cic.s cic.z)) (Q_ matita_basics_logic.I) =>
               cic.prod cic.prop (cic.type (cic.s cic.z))
                 matita_basics_logic.True
                 (x_50 : cic.Term cic.prop matita_basics_logic.True =>
                  Q_ x_50)))).

[ Q_, _H_I, x_50 ] True_rect_Type1 Q_ _H_I x_50 -->
  matita_basics_logic.filter_True_Type1
    (x_50 : cic.Term cic.prop matita_basics_logic.True => Q_ x_50)
    (matita_basics_logic.True_rect_Type1_body Q_ _H_I) x_50.

[ Q_, _H_I, x_50 ] True_rect_Type1_body Q_ _H_I x_50 -->
  matita_basics_logic.match_True_Type1 Q_ _H_I x_50.

def True_rect_Type0 :
      cic.Term (cic.type (cic.s cic.z))
        (cic.prod (cic.type (cic.s cic.z)) (cic.type cic.z)
           (cic.prod cic.prop (cic.type (cic.s cic.z))
              matita_basics_logic.True
              (_x_52 : cic.Term cic.prop matita_basics_logic.True =>
               cic.univ (cic.type cic.z)))
           (Q_ :
              cic.Term (cic.type (cic.s cic.z))
                (cic.prod cic.prop (cic.type (cic.s cic.z))
                   matita_basics_logic.True
                   (_x_52 : cic.Term cic.prop matita_basics_logic.True =>
                    cic.univ (cic.type cic.z))) =>
            cic.prod (cic.type cic.z) (cic.type cic.z)
              (Q_ matita_basics_logic.I)
              (_H_I : cic.Term (cic.type cic.z) (Q_ matita_basics_logic.I) =>
               cic.prod cic.prop (cic.type cic.z) matita_basics_logic.True
                 (x_52 : cic.Term cic.prop matita_basics_logic.True =>
                  Q_ x_52)))).

def True_rect_Type0_body :
      cic.Term (cic.type (cic.s cic.z))
        (cic.prod (cic.type (cic.s cic.z)) (cic.type cic.z)
           (cic.prod cic.prop (cic.type (cic.s cic.z))
              matita_basics_logic.True
              (_x_52 : cic.Term cic.prop matita_basics_logic.True =>
               cic.univ (cic.type cic.z)))
           (Q_ :
              cic.Term (cic.type (cic.s cic.z))
                (cic.prod cic.prop (cic.type (cic.s cic.z))
                   matita_basics_logic.True
                   (_x_52 : cic.Term cic.prop matita_basics_logic.True =>
                    cic.univ (cic.type cic.z))) =>
            cic.prod (cic.type cic.z) (cic.type cic.z)
              (Q_ matita_basics_logic.I)
              (_H_I : cic.Term (cic.type cic.z) (Q_ matita_basics_logic.I) =>
               cic.prod cic.prop (cic.type cic.z) matita_basics_logic.True
                 (x_52 : cic.Term cic.prop matita_basics_logic.True =>
                  Q_ x_52)))).

[ Q_, _H_I, x_52 ] True_rect_Type0 Q_ _H_I x_52 -->
  matita_basics_logic.filter_True_Type0
    (x_52 : cic.Term cic.prop matita_basics_logic.True => Q_ x_52)
    (matita_basics_logic.True_rect_Type0_body Q_ _H_I) x_52.

[ Q_, _H_I, x_52 ] True_rect_Type0_body Q_ _H_I x_52 -->
  matita_basics_logic.match_True_Type0 Q_ _H_I x_52.

def True_rect_CProp4 :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop
           (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.True
              (_x_54 : cic.Term cic.prop matita_basics_logic.True =>
               cic.univ cic.prop))
           (Q_ :
              cic.Term (cic.type cic.z)
                (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.True
                   (_x_54 : cic.Term cic.prop matita_basics_logic.True =>
                    cic.univ cic.prop)) =>
            cic.prod cic.prop cic.prop (Q_ matita_basics_logic.I)
              (_H_I : cic.Term cic.prop (Q_ matita_basics_logic.I) =>
               cic.prod cic.prop cic.prop matita_basics_logic.True
                 (x_54 : cic.Term cic.prop matita_basics_logic.True =>
                  Q_ x_54)))).

def True_rect_CProp4_body :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop
           (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.True
              (_x_54 : cic.Term cic.prop matita_basics_logic.True =>
               cic.univ cic.prop))
           (Q_ :
              cic.Term (cic.type cic.z)
                (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.True
                   (_x_54 : cic.Term cic.prop matita_basics_logic.True =>
                    cic.univ cic.prop)) =>
            cic.prod cic.prop cic.prop (Q_ matita_basics_logic.I)
              (_H_I : cic.Term cic.prop (Q_ matita_basics_logic.I) =>
               cic.prod cic.prop cic.prop matita_basics_logic.True
                 (x_54 : cic.Term cic.prop matita_basics_logic.True =>
                  Q_ x_54)))).

[ Q_, _H_I, x_54 ] True_rect_CProp4 Q_ _H_I x_54 -->
  matita_basics_logic.filter_True_Prop
    (x_54 : cic.Term cic.prop matita_basics_logic.True => Q_ x_54)
    (matita_basics_logic.True_rect_CProp4_body Q_ _H_I) x_54.

[ Q_, _H_I, x_54 ] True_rect_CProp4_body Q_ _H_I x_54 -->
  matita_basics_logic.match_True_Prop Q_ _H_I x_54.

def True_rect_CProp5 :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop
           (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.True
              (_x_56 : cic.Term cic.prop matita_basics_logic.True =>
               cic.univ cic.prop))
           (Q_ :
              cic.Term (cic.type cic.z)
                (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.True
                   (_x_56 : cic.Term cic.prop matita_basics_logic.True =>
                    cic.univ cic.prop)) =>
            cic.prod cic.prop cic.prop (Q_ matita_basics_logic.I)
              (_H_I : cic.Term cic.prop (Q_ matita_basics_logic.I) =>
               cic.prod cic.prop cic.prop matita_basics_logic.True
                 (x_56 : cic.Term cic.prop matita_basics_logic.True =>
                  Q_ x_56)))).

def True_rect_CProp5_body :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop
           (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.True
              (_x_56 : cic.Term cic.prop matita_basics_logic.True =>
               cic.univ cic.prop))
           (Q_ :
              cic.Term (cic.type cic.z)
                (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.True
                   (_x_56 : cic.Term cic.prop matita_basics_logic.True =>
                    cic.univ cic.prop)) =>
            cic.prod cic.prop cic.prop (Q_ matita_basics_logic.I)
              (_H_I : cic.Term cic.prop (Q_ matita_basics_logic.I) =>
               cic.prod cic.prop cic.prop matita_basics_logic.True
                 (x_56 : cic.Term cic.prop matita_basics_logic.True =>
                  Q_ x_56)))).

[ Q_, _H_I, x_56 ] True_rect_CProp5 Q_ _H_I x_56 -->
  matita_basics_logic.filter_True_Prop
    (x_56 : cic.Term cic.prop matita_basics_logic.True => Q_ x_56)
    (matita_basics_logic.True_rect_CProp5_body Q_ _H_I) x_56.

[ Q_, _H_I, x_56 ] True_rect_CProp5_body Q_ _H_I x_56 -->
  matita_basics_logic.match_True_Prop Q_ _H_I x_56.

def True_rect_CProp3 :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop
           (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.True
              (_x_58 : cic.Term cic.prop matita_basics_logic.True =>
               cic.univ cic.prop))
           (Q_ :
              cic.Term (cic.type cic.z)
                (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.True
                   (_x_58 : cic.Term cic.prop matita_basics_logic.True =>
                    cic.univ cic.prop)) =>
            cic.prod cic.prop cic.prop (Q_ matita_basics_logic.I)
              (_H_I : cic.Term cic.prop (Q_ matita_basics_logic.I) =>
               cic.prod cic.prop cic.prop matita_basics_logic.True
                 (x_58 : cic.Term cic.prop matita_basics_logic.True =>
                  Q_ x_58)))).

def True_rect_CProp3_body :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop
           (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.True
              (_x_58 : cic.Term cic.prop matita_basics_logic.True =>
               cic.univ cic.prop))
           (Q_ :
              cic.Term (cic.type cic.z)
                (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.True
                   (_x_58 : cic.Term cic.prop matita_basics_logic.True =>
                    cic.univ cic.prop)) =>
            cic.prod cic.prop cic.prop (Q_ matita_basics_logic.I)
              (_H_I : cic.Term cic.prop (Q_ matita_basics_logic.I) =>
               cic.prod cic.prop cic.prop matita_basics_logic.True
                 (x_58 : cic.Term cic.prop matita_basics_logic.True =>
                  Q_ x_58)))).

[ Q_, _H_I, x_58 ] True_rect_CProp3 Q_ _H_I x_58 -->
  matita_basics_logic.filter_True_Prop
    (x_58 : cic.Term cic.prop matita_basics_logic.True => Q_ x_58)
    (matita_basics_logic.True_rect_CProp3_body Q_ _H_I) x_58.

[ Q_, _H_I, x_58 ] True_rect_CProp3_body Q_ _H_I x_58 -->
  matita_basics_logic.match_True_Prop Q_ _H_I x_58.

def True_rect_CProp2 :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop
           (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.True
              (_x_60 : cic.Term cic.prop matita_basics_logic.True =>
               cic.univ cic.prop))
           (Q_ :
              cic.Term (cic.type cic.z)
                (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.True
                   (_x_60 : cic.Term cic.prop matita_basics_logic.True =>
                    cic.univ cic.prop)) =>
            cic.prod cic.prop cic.prop (Q_ matita_basics_logic.I)
              (_H_I : cic.Term cic.prop (Q_ matita_basics_logic.I) =>
               cic.prod cic.prop cic.prop matita_basics_logic.True
                 (x_60 : cic.Term cic.prop matita_basics_logic.True =>
                  Q_ x_60)))).

def True_rect_CProp2_body :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop
           (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.True
              (_x_60 : cic.Term cic.prop matita_basics_logic.True =>
               cic.univ cic.prop))
           (Q_ :
              cic.Term (cic.type cic.z)
                (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.True
                   (_x_60 : cic.Term cic.prop matita_basics_logic.True =>
                    cic.univ cic.prop)) =>
            cic.prod cic.prop cic.prop (Q_ matita_basics_logic.I)
              (_H_I : cic.Term cic.prop (Q_ matita_basics_logic.I) =>
               cic.prod cic.prop cic.prop matita_basics_logic.True
                 (x_60 : cic.Term cic.prop matita_basics_logic.True =>
                  Q_ x_60)))).

[ Q_, _H_I, x_60 ] True_rect_CProp2 Q_ _H_I x_60 -->
  matita_basics_logic.filter_True_Prop
    (x_60 : cic.Term cic.prop matita_basics_logic.True => Q_ x_60)
    (matita_basics_logic.True_rect_CProp2_body Q_ _H_I) x_60.

[ Q_, _H_I, x_60 ] True_rect_CProp2_body Q_ _H_I x_60 -->
  matita_basics_logic.match_True_Prop Q_ _H_I x_60.

def True_rect_CProp1 :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop
           (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.True
              (_x_62 : cic.Term cic.prop matita_basics_logic.True =>
               cic.univ cic.prop))
           (Q_ :
              cic.Term (cic.type cic.z)
                (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.True
                   (_x_62 : cic.Term cic.prop matita_basics_logic.True =>
                    cic.univ cic.prop)) =>
            cic.prod cic.prop cic.prop (Q_ matita_basics_logic.I)
              (_H_I : cic.Term cic.prop (Q_ matita_basics_logic.I) =>
               cic.prod cic.prop cic.prop matita_basics_logic.True
                 (x_62 : cic.Term cic.prop matita_basics_logic.True =>
                  Q_ x_62)))).

def True_rect_CProp1_body :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop
           (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.True
              (_x_62 : cic.Term cic.prop matita_basics_logic.True =>
               cic.univ cic.prop))
           (Q_ :
              cic.Term (cic.type cic.z)
                (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.True
                   (_x_62 : cic.Term cic.prop matita_basics_logic.True =>
                    cic.univ cic.prop)) =>
            cic.prod cic.prop cic.prop (Q_ matita_basics_logic.I)
              (_H_I : cic.Term cic.prop (Q_ matita_basics_logic.I) =>
               cic.prod cic.prop cic.prop matita_basics_logic.True
                 (x_62 : cic.Term cic.prop matita_basics_logic.True =>
                  Q_ x_62)))).

[ Q_, _H_I, x_62 ] True_rect_CProp1 Q_ _H_I x_62 -->
  matita_basics_logic.filter_True_Prop
    (x_62 : cic.Term cic.prop matita_basics_logic.True => Q_ x_62)
    (matita_basics_logic.True_rect_CProp1_body Q_ _H_I) x_62.

[ Q_, _H_I, x_62 ] True_rect_CProp1_body Q_ _H_I x_62 -->
  matita_basics_logic.match_True_Prop Q_ _H_I x_62.

def True_rect_CProp0 :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop
           (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.True
              (_x_64 : cic.Term cic.prop matita_basics_logic.True =>
               cic.univ cic.prop))
           (Q_ :
              cic.Term (cic.type cic.z)
                (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.True
                   (_x_64 : cic.Term cic.prop matita_basics_logic.True =>
                    cic.univ cic.prop)) =>
            cic.prod cic.prop cic.prop (Q_ matita_basics_logic.I)
              (_H_I : cic.Term cic.prop (Q_ matita_basics_logic.I) =>
               cic.prod cic.prop cic.prop matita_basics_logic.True
                 (x_64 : cic.Term cic.prop matita_basics_logic.True =>
                  Q_ x_64)))).

def True_rect_CProp0_body :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop
           (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.True
              (_x_64 : cic.Term cic.prop matita_basics_logic.True =>
               cic.univ cic.prop))
           (Q_ :
              cic.Term (cic.type cic.z)
                (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.True
                   (_x_64 : cic.Term cic.prop matita_basics_logic.True =>
                    cic.univ cic.prop)) =>
            cic.prod cic.prop cic.prop (Q_ matita_basics_logic.I)
              (_H_I : cic.Term cic.prop (Q_ matita_basics_logic.I) =>
               cic.prod cic.prop cic.prop matita_basics_logic.True
                 (x_64 : cic.Term cic.prop matita_basics_logic.True =>
                  Q_ x_64)))).

[ Q_, _H_I, x_64 ] True_rect_CProp0 Q_ _H_I x_64 -->
  matita_basics_logic.filter_True_Prop
    (x_64 : cic.Term cic.prop matita_basics_logic.True => Q_ x_64)
    (matita_basics_logic.True_rect_CProp0_body Q_ _H_I) x_64.

[ Q_, _H_I, x_64 ] True_rect_CProp0_body Q_ _H_I x_64 -->
  matita_basics_logic.match_True_Prop Q_ _H_I x_64.

def True_inv_ind :
      cic.Term cic.prop
        (cic.prod cic.prop cic.prop matita_basics_logic.True
           (Hterm : cic.Term cic.prop matita_basics_logic.True =>
            cic.prod (cic.type cic.z) cic.prop
              (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.True
                 (_z125 : cic.Term cic.prop matita_basics_logic.True =>
                  cic.univ cic.prop))
              (P :
                 cic.Term (cic.type cic.z)
                   (cic.prod cic.prop (cic.type cic.z)
                      matita_basics_logic.True
                      (_z125 : cic.Term cic.prop matita_basics_logic.True =>
                       cic.univ cic.prop)) =>
               cic.prod cic.prop cic.prop
                 (cic.prod cic.prop cic.prop
                    (matita_basics_logic.eq
                       (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                          matita_basics_logic.True)
                       Hterm matita_basics_logic.I)
                    (_z126 :
                       cic.Term cic.prop
                         (matita_basics_logic.eq
                            (cic.lift cic.prop
                               (cic.type (cic.s (cic.s cic.z)))
                               matita_basics_logic.True)
                            Hterm matita_basics_logic.I) =>
                     P matita_basics_logic.I))
                 (_H1 :
                    cic.Term cic.prop
                      (cic.prod cic.prop cic.prop
                         (matita_basics_logic.eq
                            (cic.lift cic.prop
                               (cic.type (cic.s (cic.s cic.z)))
                               matita_basics_logic.True)
                            Hterm matita_basics_logic.I)
                         (_z126 :
                            cic.Term cic.prop
                              (matita_basics_logic.eq
                                 (cic.lift cic.prop
                                    (cic.type (cic.s (cic.s cic.z)))
                                    matita_basics_logic.True)
                                 Hterm matita_basics_logic.I) =>
                          P matita_basics_logic.I)) =>
                  P Hterm))))
      :=
      Hterm : cic.Term cic.prop matita_basics_logic.True =>
      P :
        cic.Term (cic.type cic.z)
          (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.True
             (_z125 : cic.Term cic.prop matita_basics_logic.True =>
              cic.univ cic.prop)) =>
      H1 :
        cic.Term cic.prop
          (cic.prod cic.prop cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                   matita_basics_logic.True)
                Hterm matita_basics_logic.I)
             (_z126 :
                cic.Term cic.prop
                  (matita_basics_logic.eq
                     (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                        matita_basics_logic.True)
                     Hterm matita_basics_logic.I) =>
              P matita_basics_logic.I)) =>
      (Hcut :
         cic.Term cic.prop
           (cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    matita_basics_logic.True)
                 Hterm Hterm)
              (_z126 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         matita_basics_logic.True)
                      Hterm Hterm) =>
               P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
               matita_basics_logic.True)
            Hterm))
        (matita_basics_logic.True_ind
           (_x_40 : cic.Term cic.prop matita_basics_logic.True =>
            cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    matita_basics_logic.True)
                 Hterm _x_40)
              (_z126 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         matita_basics_logic.True)
                      Hterm _x_40) =>
               P _x_40))
           H1 Hterm).

def True_inv_rect_Type4 :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
        (cic.prod cic.prop
           (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
           matita_basics_logic.True
           (Hterm : cic.Term cic.prop matita_basics_logic.True =>
            cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
              (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
              (cic.prod cic.prop
                 (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                 matita_basics_logic.True
                 (_z131 : cic.Term cic.prop matita_basics_logic.True =>
                  cic.univ (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))))
              (P :
                 cic.Term
                   (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                   (cic.prod cic.prop
                      (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                      matita_basics_logic.True
                      (_z131 : cic.Term cic.prop matita_basics_logic.True =>
                       cic.univ
                         (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))))) =>
               cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                 (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                 (cic.prod cic.prop
                    (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                    (matita_basics_logic.eq
                       (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                          matita_basics_logic.True)
                       Hterm matita_basics_logic.I)
                    (_z132 :
                       cic.Term cic.prop
                         (matita_basics_logic.eq
                            (cic.lift cic.prop
                               (cic.type (cic.s (cic.s cic.z)))
                               matita_basics_logic.True)
                            Hterm matita_basics_logic.I) =>
                     P matita_basics_logic.I))
                 (_H1 :
                    cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                      (cic.prod cic.prop
                         (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                         (matita_basics_logic.eq
                            (cic.lift cic.prop
                               (cic.type (cic.s (cic.s cic.z)))
                               matita_basics_logic.True)
                            Hterm matita_basics_logic.I)
                         (_z132 :
                            cic.Term cic.prop
                              (matita_basics_logic.eq
                                 (cic.lift cic.prop
                                    (cic.type (cic.s (cic.s cic.z)))
                                    matita_basics_logic.True)
                                 Hterm matita_basics_logic.I) =>
                          P matita_basics_logic.I)) =>
                  P Hterm))))
      :=
      Hterm : cic.Term cic.prop matita_basics_logic.True =>
      P :
        cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
          (cic.prod cic.prop
             (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
             matita_basics_logic.True
             (_z131 : cic.Term cic.prop matita_basics_logic.True =>
              cic.univ (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))))) =>
      H1 :
        cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
          (cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
             (matita_basics_logic.eq
                (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                   matita_basics_logic.True)
                Hterm matita_basics_logic.I)
             (_z132 :
                cic.Term cic.prop
                  (matita_basics_logic.eq
                     (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                        matita_basics_logic.True)
                     Hterm matita_basics_logic.I) =>
              P matita_basics_logic.I)) =>
      (Hcut :
         cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
           (cic.prod cic.prop
              (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    matita_basics_logic.True)
                 Hterm Hterm)
              (_z132 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         matita_basics_logic.True)
                      Hterm Hterm) =>
               P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
               matita_basics_logic.True)
            Hterm))
        (matita_basics_logic.True_rect_Type4
           (_x_42 : cic.Term cic.prop matita_basics_logic.True =>
            cic.prod cic.prop
              (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    matita_basics_logic.True)
                 Hterm _x_42)
              (_z132 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         matita_basics_logic.True)
                      Hterm _x_42) =>
               P _x_42))
           H1 Hterm).

def True_inv_rect_Type3 :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
        (cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
           matita_basics_logic.True
           (Hterm : cic.Term cic.prop matita_basics_logic.True =>
            cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
              (cic.type (cic.s (cic.s (cic.s cic.z))))
              (cic.prod cic.prop
                 (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                 matita_basics_logic.True
                 (_z137 : cic.Term cic.prop matita_basics_logic.True =>
                  cic.univ (cic.type (cic.s (cic.s (cic.s cic.z))))))
              (P :
                 cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                   (cic.prod cic.prop
                      (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                      matita_basics_logic.True
                      (_z137 : cic.Term cic.prop matita_basics_logic.True =>
                       cic.univ (cic.type (cic.s (cic.s (cic.s cic.z)))))) =>
               cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
                 (cic.type (cic.s (cic.s (cic.s cic.z))))
                 (cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
                    (matita_basics_logic.eq
                       (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                          matita_basics_logic.True)
                       Hterm matita_basics_logic.I)
                    (_z138 :
                       cic.Term cic.prop
                         (matita_basics_logic.eq
                            (cic.lift cic.prop
                               (cic.type (cic.s (cic.s cic.z)))
                               matita_basics_logic.True)
                            Hterm matita_basics_logic.I) =>
                     P matita_basics_logic.I))
                 (_H1 :
                    cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                      (cic.prod cic.prop
                         (cic.type (cic.s (cic.s (cic.s cic.z))))
                         (matita_basics_logic.eq
                            (cic.lift cic.prop
                               (cic.type (cic.s (cic.s cic.z)))
                               matita_basics_logic.True)
                            Hterm matita_basics_logic.I)
                         (_z138 :
                            cic.Term cic.prop
                              (matita_basics_logic.eq
                                 (cic.lift cic.prop
                                    (cic.type (cic.s (cic.s cic.z)))
                                    matita_basics_logic.True)
                                 Hterm matita_basics_logic.I) =>
                          P matita_basics_logic.I)) =>
                  P Hterm))))
      :=
      Hterm : cic.Term cic.prop matita_basics_logic.True =>
      P :
        cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
          (cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
             matita_basics_logic.True
             (_z137 : cic.Term cic.prop matita_basics_logic.True =>
              cic.univ (cic.type (cic.s (cic.s (cic.s cic.z)))))) =>
      H1 :
        cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
          (cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
             (matita_basics_logic.eq
                (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                   matita_basics_logic.True)
                Hterm matita_basics_logic.I)
             (_z138 :
                cic.Term cic.prop
                  (matita_basics_logic.eq
                     (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                        matita_basics_logic.True)
                     Hterm matita_basics_logic.I) =>
              P matita_basics_logic.I)) =>
      (Hcut :
         cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    matita_basics_logic.True)
                 Hterm Hterm)
              (_z138 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         matita_basics_logic.True)
                      Hterm Hterm) =>
               P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
               matita_basics_logic.True)
            Hterm))
        (matita_basics_logic.True_rect_Type3
           (_x_46 : cic.Term cic.prop matita_basics_logic.True =>
            cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    matita_basics_logic.True)
                 Hterm _x_46)
              (_z138 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         matita_basics_logic.True)
                      Hterm _x_46) =>
               P _x_46))
           H1 Hterm).

def True_inv_rect_Type2 :
      cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
        (cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
           matita_basics_logic.True
           (Hterm : cic.Term cic.prop matita_basics_logic.True =>
            cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
              (cic.type (cic.s (cic.s cic.z)))
              (cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
                 matita_basics_logic.True
                 (_z143 : cic.Term cic.prop matita_basics_logic.True =>
                  cic.univ (cic.type (cic.s (cic.s cic.z)))))
              (P :
                 cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                   (cic.prod cic.prop
                      (cic.type (cic.s (cic.s (cic.s cic.z))))
                      matita_basics_logic.True
                      (_z143 : cic.Term cic.prop matita_basics_logic.True =>
                       cic.univ (cic.type (cic.s (cic.s cic.z))))) =>
               cic.prod (cic.type (cic.s (cic.s cic.z)))
                 (cic.type (cic.s (cic.s cic.z)))
                 (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.eq
                       (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                          matita_basics_logic.True)
                       Hterm matita_basics_logic.I)
                    (_z144 :
                       cic.Term cic.prop
                         (matita_basics_logic.eq
                            (cic.lift cic.prop
                               (cic.type (cic.s (cic.s cic.z)))
                               matita_basics_logic.True)
                            Hterm matita_basics_logic.I) =>
                     P matita_basics_logic.I))
                 (_H1 :
                    cic.Term (cic.type (cic.s (cic.s cic.z)))
                      (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.eq
                            (cic.lift cic.prop
                               (cic.type (cic.s (cic.s cic.z)))
                               matita_basics_logic.True)
                            Hterm matita_basics_logic.I)
                         (_z144 :
                            cic.Term cic.prop
                              (matita_basics_logic.eq
                                 (cic.lift cic.prop
                                    (cic.type (cic.s (cic.s cic.z)))
                                    matita_basics_logic.True)
                                 Hterm matita_basics_logic.I) =>
                          P matita_basics_logic.I)) =>
                  P Hterm))))
      :=
      Hterm : cic.Term cic.prop matita_basics_logic.True =>
      P :
        cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
          (cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
             matita_basics_logic.True
             (_z143 : cic.Term cic.prop matita_basics_logic.True =>
              cic.univ (cic.type (cic.s (cic.s cic.z))))) =>
      H1 :
        cic.Term (cic.type (cic.s (cic.s cic.z)))
          (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
             (matita_basics_logic.eq
                (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                   matita_basics_logic.True)
                Hterm matita_basics_logic.I)
             (_z144 :
                cic.Term cic.prop
                  (matita_basics_logic.eq
                     (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                        matita_basics_logic.True)
                     Hterm matita_basics_logic.I) =>
              P matita_basics_logic.I)) =>
      (Hcut :
         cic.Term (cic.type (cic.s (cic.s cic.z)))
           (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    matita_basics_logic.True)
                 Hterm Hterm)
              (_z144 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         matita_basics_logic.True)
                      Hterm Hterm) =>
               P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
               matita_basics_logic.True)
            Hterm))
        (matita_basics_logic.True_rect_Type2
           (_x_48 : cic.Term cic.prop matita_basics_logic.True =>
            cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    matita_basics_logic.True)
                 Hterm _x_48)
              (_z144 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         matita_basics_logic.True)
                      Hterm _x_48) =>
               P _x_48))
           H1 Hterm).

def True_inv_rect_Type1 :
      cic.Term (cic.type (cic.s (cic.s cic.z)))
        (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
           matita_basics_logic.True
           (Hterm : cic.Term cic.prop matita_basics_logic.True =>
            cic.prod (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s cic.z))
              (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                 matita_basics_logic.True
                 (_z149 : cic.Term cic.prop matita_basics_logic.True =>
                  cic.univ (cic.type (cic.s cic.z))))
              (P :
                 cic.Term (cic.type (cic.s (cic.s cic.z)))
                   (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                      matita_basics_logic.True
                      (_z149 : cic.Term cic.prop matita_basics_logic.True =>
                       cic.univ (cic.type (cic.s cic.z)))) =>
               cic.prod (cic.type (cic.s cic.z)) (cic.type (cic.s cic.z))
                 (cic.prod cic.prop (cic.type (cic.s cic.z))
                    (matita_basics_logic.eq
                       (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                          matita_basics_logic.True)
                       Hterm matita_basics_logic.I)
                    (_z150 :
                       cic.Term cic.prop
                         (matita_basics_logic.eq
                            (cic.lift cic.prop
                               (cic.type (cic.s (cic.s cic.z)))
                               matita_basics_logic.True)
                            Hterm matita_basics_logic.I) =>
                     P matita_basics_logic.I))
                 (_H1 :
                    cic.Term (cic.type (cic.s cic.z))
                      (cic.prod cic.prop (cic.type (cic.s cic.z))
                         (matita_basics_logic.eq
                            (cic.lift cic.prop
                               (cic.type (cic.s (cic.s cic.z)))
                               matita_basics_logic.True)
                            Hterm matita_basics_logic.I)
                         (_z150 :
                            cic.Term cic.prop
                              (matita_basics_logic.eq
                                 (cic.lift cic.prop
                                    (cic.type (cic.s (cic.s cic.z)))
                                    matita_basics_logic.True)
                                 Hterm matita_basics_logic.I) =>
                          P matita_basics_logic.I)) =>
                  P Hterm))))
      :=
      Hterm : cic.Term cic.prop matita_basics_logic.True =>
      P :
        cic.Term (cic.type (cic.s (cic.s cic.z)))
          (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
             matita_basics_logic.True
             (_z149 : cic.Term cic.prop matita_basics_logic.True =>
              cic.univ (cic.type (cic.s cic.z)))) =>
      H1 :
        cic.Term (cic.type (cic.s cic.z))
          (cic.prod cic.prop (cic.type (cic.s cic.z))
             (matita_basics_logic.eq
                (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                   matita_basics_logic.True)
                Hterm matita_basics_logic.I)
             (_z150 :
                cic.Term cic.prop
                  (matita_basics_logic.eq
                     (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                        matita_basics_logic.True)
                     Hterm matita_basics_logic.I) =>
              P matita_basics_logic.I)) =>
      (Hcut :
         cic.Term (cic.type (cic.s cic.z))
           (cic.prod cic.prop (cic.type (cic.s cic.z))
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    matita_basics_logic.True)
                 Hterm Hterm)
              (_z150 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         matita_basics_logic.True)
                      Hterm Hterm) =>
               P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
               matita_basics_logic.True)
            Hterm))
        (matita_basics_logic.True_rect_Type1
           (_x_50 : cic.Term cic.prop matita_basics_logic.True =>
            cic.prod cic.prop (cic.type (cic.s cic.z))
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    matita_basics_logic.True)
                 Hterm _x_50)
              (_z150 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         matita_basics_logic.True)
                      Hterm _x_50) =>
               P _x_50))
           H1 Hterm).

def True_inv_rect_Type0 :
      cic.Term (cic.type (cic.s cic.z))
        (cic.prod cic.prop (cic.type (cic.s cic.z)) matita_basics_logic.True
           (Hterm : cic.Term cic.prop matita_basics_logic.True =>
            cic.prod (cic.type (cic.s cic.z)) (cic.type cic.z)
              (cic.prod cic.prop (cic.type (cic.s cic.z))
                 matita_basics_logic.True
                 (_z155 : cic.Term cic.prop matita_basics_logic.True =>
                  cic.univ (cic.type cic.z)))
              (P :
                 cic.Term (cic.type (cic.s cic.z))
                   (cic.prod cic.prop (cic.type (cic.s cic.z))
                      matita_basics_logic.True
                      (_z155 : cic.Term cic.prop matita_basics_logic.True =>
                       cic.univ (cic.type cic.z))) =>
               cic.prod (cic.type cic.z) (cic.type cic.z)
                 (cic.prod cic.prop (cic.type cic.z)
                    (matita_basics_logic.eq
                       (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                          matita_basics_logic.True)
                       Hterm matita_basics_logic.I)
                    (_z156 :
                       cic.Term cic.prop
                         (matita_basics_logic.eq
                            (cic.lift cic.prop
                               (cic.type (cic.s (cic.s cic.z)))
                               matita_basics_logic.True)
                            Hterm matita_basics_logic.I) =>
                     P matita_basics_logic.I))
                 (_H1 :
                    cic.Term (cic.type cic.z)
                      (cic.prod cic.prop (cic.type cic.z)
                         (matita_basics_logic.eq
                            (cic.lift cic.prop
                               (cic.type (cic.s (cic.s cic.z)))
                               matita_basics_logic.True)
                            Hterm matita_basics_logic.I)
                         (_z156 :
                            cic.Term cic.prop
                              (matita_basics_logic.eq
                                 (cic.lift cic.prop
                                    (cic.type (cic.s (cic.s cic.z)))
                                    matita_basics_logic.True)
                                 Hterm matita_basics_logic.I) =>
                          P matita_basics_logic.I)) =>
                  P Hterm))))
      :=
      Hterm : cic.Term cic.prop matita_basics_logic.True =>
      P :
        cic.Term (cic.type (cic.s cic.z))
          (cic.prod cic.prop (cic.type (cic.s cic.z))
             matita_basics_logic.True
             (_z155 : cic.Term cic.prop matita_basics_logic.True =>
              cic.univ (cic.type cic.z))) =>
      H1 :
        cic.Term (cic.type cic.z)
          (cic.prod cic.prop (cic.type cic.z)
             (matita_basics_logic.eq
                (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                   matita_basics_logic.True)
                Hterm matita_basics_logic.I)
             (_z156 :
                cic.Term cic.prop
                  (matita_basics_logic.eq
                     (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                        matita_basics_logic.True)
                     Hterm matita_basics_logic.I) =>
              P matita_basics_logic.I)) =>
      (Hcut :
         cic.Term (cic.type cic.z)
           (cic.prod cic.prop (cic.type cic.z)
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    matita_basics_logic.True)
                 Hterm Hterm)
              (_z156 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         matita_basics_logic.True)
                      Hterm Hterm) =>
               P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
               matita_basics_logic.True)
            Hterm))
        (matita_basics_logic.True_rect_Type0
           (_x_52 : cic.Term cic.prop matita_basics_logic.True =>
            cic.prod cic.prop (cic.type cic.z)
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    matita_basics_logic.True)
                 Hterm _x_52)
              (_z156 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         matita_basics_logic.True)
                      Hterm _x_52) =>
               P _x_52))
           H1 Hterm).

def True_inv_rect_CProp4 :
      cic.Term cic.prop
        (cic.prod cic.prop cic.prop matita_basics_logic.True
           (Hterm : cic.Term cic.prop matita_basics_logic.True =>
            cic.prod (cic.type cic.z) cic.prop
              (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.True
                 (_z161 : cic.Term cic.prop matita_basics_logic.True =>
                  cic.univ cic.prop))
              (P :
                 cic.Term (cic.type cic.z)
                   (cic.prod cic.prop (cic.type cic.z)
                      matita_basics_logic.True
                      (_z161 : cic.Term cic.prop matita_basics_logic.True =>
                       cic.univ cic.prop)) =>
               cic.prod cic.prop cic.prop
                 (cic.prod cic.prop cic.prop
                    (matita_basics_logic.eq
                       (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                          matita_basics_logic.True)
                       Hterm matita_basics_logic.I)
                    (_z162 :
                       cic.Term cic.prop
                         (matita_basics_logic.eq
                            (cic.lift cic.prop
                               (cic.type (cic.s (cic.s cic.z)))
                               matita_basics_logic.True)
                            Hterm matita_basics_logic.I) =>
                     P matita_basics_logic.I))
                 (_H1 :
                    cic.Term cic.prop
                      (cic.prod cic.prop cic.prop
                         (matita_basics_logic.eq
                            (cic.lift cic.prop
                               (cic.type (cic.s (cic.s cic.z)))
                               matita_basics_logic.True)
                            Hterm matita_basics_logic.I)
                         (_z162 :
                            cic.Term cic.prop
                              (matita_basics_logic.eq
                                 (cic.lift cic.prop
                                    (cic.type (cic.s (cic.s cic.z)))
                                    matita_basics_logic.True)
                                 Hterm matita_basics_logic.I) =>
                          P matita_basics_logic.I)) =>
                  P Hterm))))
      :=
      Hterm : cic.Term cic.prop matita_basics_logic.True =>
      P :
        cic.Term (cic.type cic.z)
          (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.True
             (_z161 : cic.Term cic.prop matita_basics_logic.True =>
              cic.univ cic.prop)) =>
      H1 :
        cic.Term cic.prop
          (cic.prod cic.prop cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                   matita_basics_logic.True)
                Hterm matita_basics_logic.I)
             (_z162 :
                cic.Term cic.prop
                  (matita_basics_logic.eq
                     (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                        matita_basics_logic.True)
                     Hterm matita_basics_logic.I) =>
              P matita_basics_logic.I)) =>
      (Hcut :
         cic.Term cic.prop
           (cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    matita_basics_logic.True)
                 Hterm Hterm)
              (_z162 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         matita_basics_logic.True)
                      Hterm Hterm) =>
               P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
               matita_basics_logic.True)
            Hterm))
        (matita_basics_logic.True_rect_CProp4
           (_x_54 : cic.Term cic.prop matita_basics_logic.True =>
            cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    matita_basics_logic.True)
                 Hterm _x_54)
              (_z162 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         matita_basics_logic.True)
                      Hterm _x_54) =>
               P _x_54))
           H1 Hterm).

def True_inv_rect_CProp3 :
      cic.Term cic.prop
        (cic.prod cic.prop cic.prop matita_basics_logic.True
           (Hterm : cic.Term cic.prop matita_basics_logic.True =>
            cic.prod (cic.type cic.z) cic.prop
              (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.True
                 (_z167 : cic.Term cic.prop matita_basics_logic.True =>
                  cic.univ cic.prop))
              (P :
                 cic.Term (cic.type cic.z)
                   (cic.prod cic.prop (cic.type cic.z)
                      matita_basics_logic.True
                      (_z167 : cic.Term cic.prop matita_basics_logic.True =>
                       cic.univ cic.prop)) =>
               cic.prod cic.prop cic.prop
                 (cic.prod cic.prop cic.prop
                    (matita_basics_logic.eq
                       (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                          matita_basics_logic.True)
                       Hterm matita_basics_logic.I)
                    (_z168 :
                       cic.Term cic.prop
                         (matita_basics_logic.eq
                            (cic.lift cic.prop
                               (cic.type (cic.s (cic.s cic.z)))
                               matita_basics_logic.True)
                            Hterm matita_basics_logic.I) =>
                     P matita_basics_logic.I))
                 (_H1 :
                    cic.Term cic.prop
                      (cic.prod cic.prop cic.prop
                         (matita_basics_logic.eq
                            (cic.lift cic.prop
                               (cic.type (cic.s (cic.s cic.z)))
                               matita_basics_logic.True)
                            Hterm matita_basics_logic.I)
                         (_z168 :
                            cic.Term cic.prop
                              (matita_basics_logic.eq
                                 (cic.lift cic.prop
                                    (cic.type (cic.s (cic.s cic.z)))
                                    matita_basics_logic.True)
                                 Hterm matita_basics_logic.I) =>
                          P matita_basics_logic.I)) =>
                  P Hterm))))
      :=
      Hterm : cic.Term cic.prop matita_basics_logic.True =>
      P :
        cic.Term (cic.type cic.z)
          (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.True
             (_z167 : cic.Term cic.prop matita_basics_logic.True =>
              cic.univ cic.prop)) =>
      H1 :
        cic.Term cic.prop
          (cic.prod cic.prop cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                   matita_basics_logic.True)
                Hterm matita_basics_logic.I)
             (_z168 :
                cic.Term cic.prop
                  (matita_basics_logic.eq
                     (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                        matita_basics_logic.True)
                     Hterm matita_basics_logic.I) =>
              P matita_basics_logic.I)) =>
      (Hcut :
         cic.Term cic.prop
           (cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    matita_basics_logic.True)
                 Hterm Hterm)
              (_z168 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         matita_basics_logic.True)
                      Hterm Hterm) =>
               P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
               matita_basics_logic.True)
            Hterm))
        (matita_basics_logic.True_rect_CProp3
           (_x_58 : cic.Term cic.prop matita_basics_logic.True =>
            cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    matita_basics_logic.True)
                 Hterm _x_58)
              (_z168 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         matita_basics_logic.True)
                      Hterm _x_58) =>
               P _x_58))
           H1 Hterm).

def True_inv_rect_CProp2 :
      cic.Term cic.prop
        (cic.prod cic.prop cic.prop matita_basics_logic.True
           (Hterm : cic.Term cic.prop matita_basics_logic.True =>
            cic.prod (cic.type cic.z) cic.prop
              (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.True
                 (_z173 : cic.Term cic.prop matita_basics_logic.True =>
                  cic.univ cic.prop))
              (P :
                 cic.Term (cic.type cic.z)
                   (cic.prod cic.prop (cic.type cic.z)
                      matita_basics_logic.True
                      (_z173 : cic.Term cic.prop matita_basics_logic.True =>
                       cic.univ cic.prop)) =>
               cic.prod cic.prop cic.prop
                 (cic.prod cic.prop cic.prop
                    (matita_basics_logic.eq
                       (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                          matita_basics_logic.True)
                       Hterm matita_basics_logic.I)
                    (_z174 :
                       cic.Term cic.prop
                         (matita_basics_logic.eq
                            (cic.lift cic.prop
                               (cic.type (cic.s (cic.s cic.z)))
                               matita_basics_logic.True)
                            Hterm matita_basics_logic.I) =>
                     P matita_basics_logic.I))
                 (_H1 :
                    cic.Term cic.prop
                      (cic.prod cic.prop cic.prop
                         (matita_basics_logic.eq
                            (cic.lift cic.prop
                               (cic.type (cic.s (cic.s cic.z)))
                               matita_basics_logic.True)
                            Hterm matita_basics_logic.I)
                         (_z174 :
                            cic.Term cic.prop
                              (matita_basics_logic.eq
                                 (cic.lift cic.prop
                                    (cic.type (cic.s (cic.s cic.z)))
                                    matita_basics_logic.True)
                                 Hterm matita_basics_logic.I) =>
                          P matita_basics_logic.I)) =>
                  P Hterm))))
      :=
      Hterm : cic.Term cic.prop matita_basics_logic.True =>
      P :
        cic.Term (cic.type cic.z)
          (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.True
             (_z173 : cic.Term cic.prop matita_basics_logic.True =>
              cic.univ cic.prop)) =>
      H1 :
        cic.Term cic.prop
          (cic.prod cic.prop cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                   matita_basics_logic.True)
                Hterm matita_basics_logic.I)
             (_z174 :
                cic.Term cic.prop
                  (matita_basics_logic.eq
                     (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                        matita_basics_logic.True)
                     Hterm matita_basics_logic.I) =>
              P matita_basics_logic.I)) =>
      (Hcut :
         cic.Term cic.prop
           (cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    matita_basics_logic.True)
                 Hterm Hterm)
              (_z174 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         matita_basics_logic.True)
                      Hterm Hterm) =>
               P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
               matita_basics_logic.True)
            Hterm))
        (matita_basics_logic.True_rect_CProp2
           (_x_60 : cic.Term cic.prop matita_basics_logic.True =>
            cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    matita_basics_logic.True)
                 Hterm _x_60)
              (_z174 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         matita_basics_logic.True)
                      Hterm _x_60) =>
               P _x_60))
           H1 Hterm).

def True_inv_rect_CProp1 :
      cic.Term cic.prop
        (cic.prod cic.prop cic.prop matita_basics_logic.True
           (Hterm : cic.Term cic.prop matita_basics_logic.True =>
            cic.prod (cic.type cic.z) cic.prop
              (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.True
                 (_z179 : cic.Term cic.prop matita_basics_logic.True =>
                  cic.univ cic.prop))
              (P :
                 cic.Term (cic.type cic.z)
                   (cic.prod cic.prop (cic.type cic.z)
                      matita_basics_logic.True
                      (_z179 : cic.Term cic.prop matita_basics_logic.True =>
                       cic.univ cic.prop)) =>
               cic.prod cic.prop cic.prop
                 (cic.prod cic.prop cic.prop
                    (matita_basics_logic.eq
                       (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                          matita_basics_logic.True)
                       Hterm matita_basics_logic.I)
                    (_z180 :
                       cic.Term cic.prop
                         (matita_basics_logic.eq
                            (cic.lift cic.prop
                               (cic.type (cic.s (cic.s cic.z)))
                               matita_basics_logic.True)
                            Hterm matita_basics_logic.I) =>
                     P matita_basics_logic.I))
                 (_H1 :
                    cic.Term cic.prop
                      (cic.prod cic.prop cic.prop
                         (matita_basics_logic.eq
                            (cic.lift cic.prop
                               (cic.type (cic.s (cic.s cic.z)))
                               matita_basics_logic.True)
                            Hterm matita_basics_logic.I)
                         (_z180 :
                            cic.Term cic.prop
                              (matita_basics_logic.eq
                                 (cic.lift cic.prop
                                    (cic.type (cic.s (cic.s cic.z)))
                                    matita_basics_logic.True)
                                 Hterm matita_basics_logic.I) =>
                          P matita_basics_logic.I)) =>
                  P Hterm))))
      :=
      Hterm : cic.Term cic.prop matita_basics_logic.True =>
      P :
        cic.Term (cic.type cic.z)
          (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.True
             (_z179 : cic.Term cic.prop matita_basics_logic.True =>
              cic.univ cic.prop)) =>
      H1 :
        cic.Term cic.prop
          (cic.prod cic.prop cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                   matita_basics_logic.True)
                Hterm matita_basics_logic.I)
             (_z180 :
                cic.Term cic.prop
                  (matita_basics_logic.eq
                     (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                        matita_basics_logic.True)
                     Hterm matita_basics_logic.I) =>
              P matita_basics_logic.I)) =>
      (Hcut :
         cic.Term cic.prop
           (cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    matita_basics_logic.True)
                 Hterm Hterm)
              (_z180 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         matita_basics_logic.True)
                      Hterm Hterm) =>
               P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
               matita_basics_logic.True)
            Hterm))
        (matita_basics_logic.True_rect_CProp1
           (_x_62 : cic.Term cic.prop matita_basics_logic.True =>
            cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    matita_basics_logic.True)
                 Hterm _x_62)
              (_z180 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         matita_basics_logic.True)
                      Hterm _x_62) =>
               P _x_62))
           H1 Hterm).

def True_inv_rect_CProp0 :
      cic.Term cic.prop
        (cic.prod cic.prop cic.prop matita_basics_logic.True
           (Hterm : cic.Term cic.prop matita_basics_logic.True =>
            cic.prod (cic.type cic.z) cic.prop
              (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.True
                 (_z185 : cic.Term cic.prop matita_basics_logic.True =>
                  cic.univ cic.prop))
              (P :
                 cic.Term (cic.type cic.z)
                   (cic.prod cic.prop (cic.type cic.z)
                      matita_basics_logic.True
                      (_z185 : cic.Term cic.prop matita_basics_logic.True =>
                       cic.univ cic.prop)) =>
               cic.prod cic.prop cic.prop
                 (cic.prod cic.prop cic.prop
                    (matita_basics_logic.eq
                       (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                          matita_basics_logic.True)
                       Hterm matita_basics_logic.I)
                    (_z186 :
                       cic.Term cic.prop
                         (matita_basics_logic.eq
                            (cic.lift cic.prop
                               (cic.type (cic.s (cic.s cic.z)))
                               matita_basics_logic.True)
                            Hterm matita_basics_logic.I) =>
                     P matita_basics_logic.I))
                 (_H1 :
                    cic.Term cic.prop
                      (cic.prod cic.prop cic.prop
                         (matita_basics_logic.eq
                            (cic.lift cic.prop
                               (cic.type (cic.s (cic.s cic.z)))
                               matita_basics_logic.True)
                            Hterm matita_basics_logic.I)
                         (_z186 :
                            cic.Term cic.prop
                              (matita_basics_logic.eq
                                 (cic.lift cic.prop
                                    (cic.type (cic.s (cic.s cic.z)))
                                    matita_basics_logic.True)
                                 Hterm matita_basics_logic.I) =>
                          P matita_basics_logic.I)) =>
                  P Hterm))))
      :=
      Hterm : cic.Term cic.prop matita_basics_logic.True =>
      P :
        cic.Term (cic.type cic.z)
          (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.True
             (_z185 : cic.Term cic.prop matita_basics_logic.True =>
              cic.univ cic.prop)) =>
      H1 :
        cic.Term cic.prop
          (cic.prod cic.prop cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                   matita_basics_logic.True)
                Hterm matita_basics_logic.I)
             (_z186 :
                cic.Term cic.prop
                  (matita_basics_logic.eq
                     (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                        matita_basics_logic.True)
                     Hterm matita_basics_logic.I) =>
              P matita_basics_logic.I)) =>
      (Hcut :
         cic.Term cic.prop
           (cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    matita_basics_logic.True)
                 Hterm Hterm)
              (_z186 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         matita_basics_logic.True)
                      Hterm Hterm) =>
               P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
               matita_basics_logic.True)
            Hterm))
        (matita_basics_logic.True_rect_CProp0
           (_x_64 : cic.Term cic.prop matita_basics_logic.True =>
            cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    matita_basics_logic.True)
                 Hterm _x_64)
              (_z186 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         matita_basics_logic.True)
                      Hterm _x_64) =>
               P _x_64))
           H1 Hterm).

def True_discr :
      cic.Term (cic.type (cic.s (cic.s cic.z)))
        (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
           matita_basics_logic.True
           (x : cic.Term cic.prop matita_basics_logic.True =>
            cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
              matita_basics_logic.True
              (y : cic.Term cic.prop matita_basics_logic.True =>
               cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                 (matita_basics_logic.eq
                    (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                       matita_basics_logic.True)
                    x y)
                 (_e :
                    cic.Term cic.prop
                      (matita_basics_logic.eq
                         (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                            matita_basics_logic.True)
                         x y) =>
                  matita_basics_logic.match_True_Type3
                    (__ : cic.Term cic.prop matita_basics_logic.True =>
                     cic.univ (cic.type (cic.s (cic.s cic.z))))
                    (matita_basics_logic.match_True_Type3
                       (__ : cic.Term cic.prop matita_basics_logic.True =>
                        cic.univ (cic.type (cic.s (cic.s cic.z))))
                       (cic.prod (cic.type (cic.s (cic.s cic.z)))
                          (cic.type (cic.s cic.z))
                          (cic.univ (cic.type (cic.s cic.z)))
                          (P : cic.Univ (cic.type (cic.s cic.z)) =>
                           cic.prod (cic.type (cic.s cic.z))
                             (cic.type (cic.s cic.z)) P
                             (_z5 : cic.Term (cic.type (cic.s cic.z)) P => P)))
                       y)
                    x))))
      :=
      x : cic.Term cic.prop matita_basics_logic.True =>
      y : cic.Term cic.prop matita_basics_logic.True =>
      Deq :
        cic.Term cic.prop
          (matita_basics_logic.eq
             (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                matita_basics_logic.True)
             x y) =>
      matita_basics_logic.eq_rect_Type2
        (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
           matita_basics_logic.True)
        x
        (x_13 : cic.Term cic.prop matita_basics_logic.True =>
         _x_14 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                   matita_basics_logic.True)
                x x_13) =>
         matita_basics_logic.match_True_Type3
           (__ : cic.Term cic.prop matita_basics_logic.True =>
            cic.univ (cic.type (cic.s (cic.s cic.z))))
           (matita_basics_logic.match_True_Type3
              (__ : cic.Term cic.prop matita_basics_logic.True =>
               cic.univ (cic.type (cic.s (cic.s cic.z))))
              (cic.prod (cic.type (cic.s (cic.s cic.z)))
                 (cic.type (cic.s cic.z)) (cic.univ (cic.type (cic.s cic.z)))
                 (P : cic.Univ (cic.type (cic.s cic.z)) =>
                  cic.prod (cic.type (cic.s cic.z)) (cic.type (cic.s cic.z))
                    P (_z5 : cic.Term (cic.type (cic.s cic.z)) P => P)))
              x_13)
           x)
        (matita_basics_logic.match_True_Type2
           (__ : cic.Term cic.prop matita_basics_logic.True =>
            matita_basics_logic.match_True_Type3
              (_0 : cic.Term cic.prop matita_basics_logic.True =>
               cic.univ (cic.type (cic.s (cic.s cic.z))))
              (matita_basics_logic.match_True_Type3
                 (_0 : cic.Term cic.prop matita_basics_logic.True =>
                  cic.univ (cic.type (cic.s (cic.s cic.z))))
                 (cic.prod (cic.type (cic.s (cic.s cic.z)))
                    (cic.type (cic.s cic.z))
                    (cic.univ (cic.type (cic.s cic.z)))
                    (P : cic.Univ (cic.type (cic.s cic.z)) =>
                     cic.prod (cic.type (cic.s cic.z))
                       (cic.type (cic.s cic.z)) P
                       (_z5 : cic.Term (cic.type (cic.s cic.z)) P => P)))
                 __)
              __)
           (P : cic.Univ (cic.type (cic.s cic.z)) =>
            DH : cic.Term (cic.type (cic.s cic.z)) P => DH)
           x)
        y Deq.

False : cic.Univ cic.prop.

def match_False_Prop :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop
           (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.False
              (z : cic.Term cic.prop matita_basics_logic.False =>
               cic.univ cic.prop))
           (return_type :
              cic.Term (cic.type cic.z)
                (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.False
                   (z : cic.Term cic.prop matita_basics_logic.False =>
                    cic.univ cic.prop)) =>
            cic.prod cic.prop cic.prop matita_basics_logic.False
              (z : cic.Term cic.prop matita_basics_logic.False =>
               return_type z))).

def match_False_Type5 :
      cic.Term
        (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
        (cic.prod
           (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
           (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
           (cic.prod cic.prop
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
              matita_basics_logic.False
              (z : cic.Term cic.prop matita_basics_logic.False =>
               cic.univ
                 (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))))
           (return_type :
              cic.Term
                (cic.type
                   (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                (cic.prod cic.prop
                   (cic.type
                      (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                   matita_basics_logic.False
                   (z : cic.Term cic.prop matita_basics_logic.False =>
                    cic.univ
                      (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))) =>
            cic.prod cic.prop
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
              matita_basics_logic.False
              (z : cic.Term cic.prop matita_basics_logic.False =>
               return_type z))).

def match_False_Type4 :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
        (cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
           (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
           (cic.prod cic.prop
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
              matita_basics_logic.False
              (z : cic.Term cic.prop matita_basics_logic.False =>
               cic.univ (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))))
           (return_type :
              cic.Term
                (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                (cic.prod cic.prop
                   (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                   matita_basics_logic.False
                   (z : cic.Term cic.prop matita_basics_logic.False =>
                    cic.univ (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))))) =>
            cic.prod cic.prop
              (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
              matita_basics_logic.False
              (z : cic.Term cic.prop matita_basics_logic.False =>
               return_type z))).

def match_False_Type3 :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
        (cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
           (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.prod cic.prop
              (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
              matita_basics_logic.False
              (z : cic.Term cic.prop matita_basics_logic.False =>
               cic.univ (cic.type (cic.s (cic.s (cic.s cic.z))))))
           (return_type :
              cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                (cic.prod cic.prop
                   (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                   matita_basics_logic.False
                   (z : cic.Term cic.prop matita_basics_logic.False =>
                    cic.univ (cic.type (cic.s (cic.s (cic.s cic.z)))))) =>
            cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
              matita_basics_logic.False
              (z : cic.Term cic.prop matita_basics_logic.False =>
               return_type z))).

def match_False_Type2 :
      cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.type (cic.s (cic.s cic.z)))
           (cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
              matita_basics_logic.False
              (z : cic.Term cic.prop matita_basics_logic.False =>
               cic.univ (cic.type (cic.s (cic.s cic.z)))))
           (return_type :
              cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                (cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
                   matita_basics_logic.False
                   (z : cic.Term cic.prop matita_basics_logic.False =>
                    cic.univ (cic.type (cic.s (cic.s cic.z))))) =>
            cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
              matita_basics_logic.False
              (z : cic.Term cic.prop matita_basics_logic.False =>
               return_type z))).

def match_False_Type1 :
      cic.Term (cic.type (cic.s (cic.s cic.z)))
        (cic.prod (cic.type (cic.s (cic.s cic.z))) (cic.type (cic.s cic.z))
           (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
              matita_basics_logic.False
              (z : cic.Term cic.prop matita_basics_logic.False =>
               cic.univ (cic.type (cic.s cic.z))))
           (return_type :
              cic.Term (cic.type (cic.s (cic.s cic.z)))
                (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                   matita_basics_logic.False
                   (z : cic.Term cic.prop matita_basics_logic.False =>
                    cic.univ (cic.type (cic.s cic.z)))) =>
            cic.prod cic.prop (cic.type (cic.s cic.z))
              matita_basics_logic.False
              (z : cic.Term cic.prop matita_basics_logic.False =>
               return_type z))).

def match_False_Type0 :
      cic.Term (cic.type (cic.s cic.z))
        (cic.prod (cic.type (cic.s cic.z)) (cic.type cic.z)
           (cic.prod cic.prop (cic.type (cic.s cic.z))
              matita_basics_logic.False
              (z : cic.Term cic.prop matita_basics_logic.False =>
               cic.univ (cic.type cic.z)))
           (return_type :
              cic.Term (cic.type (cic.s cic.z))
                (cic.prod cic.prop (cic.type (cic.s cic.z))
                   matita_basics_logic.False
                   (z : cic.Term cic.prop matita_basics_logic.False =>
                    cic.univ (cic.type cic.z))) =>
            cic.prod cic.prop (cic.type cic.z) matita_basics_logic.False
              (z : cic.Term cic.prop matita_basics_logic.False =>
               return_type z))).

def filter_False_Prop :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop
           (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.False
              (z : cic.Term cic.prop matita_basics_logic.False =>
               cic.univ cic.prop))
           (return_type :
              cic.Term (cic.type cic.z)
                (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.False
                   (z : cic.Term cic.prop matita_basics_logic.False =>
                    cic.univ cic.prop)) =>
            cic.prod cic.prop cic.prop
              (cic.prod cic.prop cic.prop matita_basics_logic.False
                 (z : cic.Term cic.prop matita_basics_logic.False =>
                  return_type z))
              (return :
                 cic.Term cic.prop
                   (cic.prod cic.prop cic.prop matita_basics_logic.False
                      (z : cic.Term cic.prop matita_basics_logic.False =>
                       return_type z)) =>
               cic.prod cic.prop cic.prop matita_basics_logic.False
                 (z : cic.Term cic.prop matita_basics_logic.False =>
                  return_type z)))).

def filter_False_Type5 :
      cic.Term
        (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
        (cic.prod
           (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
           (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
           (cic.prod cic.prop
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
              matita_basics_logic.False
              (z : cic.Term cic.prop matita_basics_logic.False =>
               cic.univ
                 (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))))
           (return_type :
              cic.Term
                (cic.type
                   (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                (cic.prod cic.prop
                   (cic.type
                      (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                   matita_basics_logic.False
                   (z : cic.Term cic.prop matita_basics_logic.False =>
                    cic.univ
                      (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))) =>
            cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
              (cic.prod cic.prop
                 (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                 matita_basics_logic.False
                 (z : cic.Term cic.prop matita_basics_logic.False =>
                  return_type z))
              (return :
                 cic.Term
                   (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                   (cic.prod cic.prop
                      (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                      matita_basics_logic.False
                      (z : cic.Term cic.prop matita_basics_logic.False =>
                       return_type z)) =>
               cic.prod cic.prop
                 (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                 matita_basics_logic.False
                 (z : cic.Term cic.prop matita_basics_logic.False =>
                  return_type z)))).

def filter_False_Type4 :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
        (cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
           (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
           (cic.prod cic.prop
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
              matita_basics_logic.False
              (z : cic.Term cic.prop matita_basics_logic.False =>
               cic.univ (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))))
           (return_type :
              cic.Term
                (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                (cic.prod cic.prop
                   (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                   matita_basics_logic.False
                   (z : cic.Term cic.prop matita_basics_logic.False =>
                    cic.univ (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))))) =>
            cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
              (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
              (cic.prod cic.prop
                 (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                 matita_basics_logic.False
                 (z : cic.Term cic.prop matita_basics_logic.False =>
                  return_type z))
              (return :
                 cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                   (cic.prod cic.prop
                      (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                      matita_basics_logic.False
                      (z : cic.Term cic.prop matita_basics_logic.False =>
                       return_type z)) =>
               cic.prod cic.prop
                 (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                 matita_basics_logic.False
                 (z : cic.Term cic.prop matita_basics_logic.False =>
                  return_type z)))).

def filter_False_Type3 :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
        (cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
           (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.prod cic.prop
              (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
              matita_basics_logic.False
              (z : cic.Term cic.prop matita_basics_logic.False =>
               cic.univ (cic.type (cic.s (cic.s (cic.s cic.z))))))
           (return_type :
              cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                (cic.prod cic.prop
                   (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                   matita_basics_logic.False
                   (z : cic.Term cic.prop matita_basics_logic.False =>
                    cic.univ (cic.type (cic.s (cic.s (cic.s cic.z)))))) =>
            cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
              (cic.type (cic.s (cic.s (cic.s cic.z))))
              (cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
                 matita_basics_logic.False
                 (z : cic.Term cic.prop matita_basics_logic.False =>
                  return_type z))
              (return :
                 cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                   (cic.prod cic.prop
                      (cic.type (cic.s (cic.s (cic.s cic.z))))
                      matita_basics_logic.False
                      (z : cic.Term cic.prop matita_basics_logic.False =>
                       return_type z)) =>
               cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
                 matita_basics_logic.False
                 (z : cic.Term cic.prop matita_basics_logic.False =>
                  return_type z)))).

def filter_False_Type2 :
      cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.type (cic.s (cic.s cic.z)))
           (cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
              matita_basics_logic.False
              (z : cic.Term cic.prop matita_basics_logic.False =>
               cic.univ (cic.type (cic.s (cic.s cic.z)))))
           (return_type :
              cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                (cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
                   matita_basics_logic.False
                   (z : cic.Term cic.prop matita_basics_logic.False =>
                    cic.univ (cic.type (cic.s (cic.s cic.z))))) =>
            cic.prod (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s (cic.s cic.z)))
              (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                 matita_basics_logic.False
                 (z : cic.Term cic.prop matita_basics_logic.False =>
                  return_type z))
              (return :
                 cic.Term (cic.type (cic.s (cic.s cic.z)))
                   (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                      matita_basics_logic.False
                      (z : cic.Term cic.prop matita_basics_logic.False =>
                       return_type z)) =>
               cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                 matita_basics_logic.False
                 (z : cic.Term cic.prop matita_basics_logic.False =>
                  return_type z)))).

def filter_False_Type1 :
      cic.Term (cic.type (cic.s (cic.s cic.z)))
        (cic.prod (cic.type (cic.s (cic.s cic.z))) (cic.type (cic.s cic.z))
           (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
              matita_basics_logic.False
              (z : cic.Term cic.prop matita_basics_logic.False =>
               cic.univ (cic.type (cic.s cic.z))))
           (return_type :
              cic.Term (cic.type (cic.s (cic.s cic.z)))
                (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                   matita_basics_logic.False
                   (z : cic.Term cic.prop matita_basics_logic.False =>
                    cic.univ (cic.type (cic.s cic.z)))) =>
            cic.prod (cic.type (cic.s cic.z)) (cic.type (cic.s cic.z))
              (cic.prod cic.prop (cic.type (cic.s cic.z))
                 matita_basics_logic.False
                 (z : cic.Term cic.prop matita_basics_logic.False =>
                  return_type z))
              (return :
                 cic.Term (cic.type (cic.s cic.z))
                   (cic.prod cic.prop (cic.type (cic.s cic.z))
                      matita_basics_logic.False
                      (z : cic.Term cic.prop matita_basics_logic.False =>
                       return_type z)) =>
               cic.prod cic.prop (cic.type (cic.s cic.z))
                 matita_basics_logic.False
                 (z : cic.Term cic.prop matita_basics_logic.False =>
                  return_type z)))).

def filter_False_Type0 :
      cic.Term (cic.type (cic.s cic.z))
        (cic.prod (cic.type (cic.s cic.z)) (cic.type cic.z)
           (cic.prod cic.prop (cic.type (cic.s cic.z))
              matita_basics_logic.False
              (z : cic.Term cic.prop matita_basics_logic.False =>
               cic.univ (cic.type cic.z)))
           (return_type :
              cic.Term (cic.type (cic.s cic.z))
                (cic.prod cic.prop (cic.type (cic.s cic.z))
                   matita_basics_logic.False
                   (z : cic.Term cic.prop matita_basics_logic.False =>
                    cic.univ (cic.type cic.z))) =>
            cic.prod (cic.type cic.z) (cic.type cic.z)
              (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.False
                 (z : cic.Term cic.prop matita_basics_logic.False =>
                  return_type z))
              (return :
                 cic.Term (cic.type cic.z)
                   (cic.prod cic.prop (cic.type cic.z)
                      matita_basics_logic.False
                      (z : cic.Term cic.prop matita_basics_logic.False =>
                       return_type z)) =>
               cic.prod cic.prop (cic.type cic.z) matita_basics_logic.False
                 (z : cic.Term cic.prop matita_basics_logic.False =>
                  return_type z)))).

def False_ind :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop
           (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.False
              (_x_66 : cic.Term cic.prop matita_basics_logic.False =>
               cic.univ cic.prop))
           (Q_ :
              cic.Term (cic.type cic.z)
                (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.False
                   (_x_66 : cic.Term cic.prop matita_basics_logic.False =>
                    cic.univ cic.prop)) =>
            cic.prod cic.prop cic.prop matita_basics_logic.False
              (x_66 : cic.Term cic.prop matita_basics_logic.False => Q_ x_66))).

def False_ind_body :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop
           (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.False
              (_x_66 : cic.Term cic.prop matita_basics_logic.False =>
               cic.univ cic.prop))
           (Q_ :
              cic.Term (cic.type cic.z)
                (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.False
                   (_x_66 : cic.Term cic.prop matita_basics_logic.False =>
                    cic.univ cic.prop)) =>
            cic.prod cic.prop cic.prop matita_basics_logic.False
              (x_66 : cic.Term cic.prop matita_basics_logic.False => Q_ x_66))).

[ Q_, x_66 ] False_ind Q_ x_66 -->
  matita_basics_logic.filter_False_Prop
    (x_66 : cic.Term cic.prop matita_basics_logic.False => Q_ x_66)
    (matita_basics_logic.False_ind_body Q_) x_66.

[ Q_, x_66 ] False_ind_body Q_ x_66 -->
  matita_basics_logic.match_False_Prop Q_ x_66.

def False_rect_Type4 :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
        (cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
           (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
           (cic.prod cic.prop
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
              matita_basics_logic.False
              (_x_67 : cic.Term cic.prop matita_basics_logic.False =>
               cic.univ (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))))
           (Q_ :
              cic.Term
                (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                (cic.prod cic.prop
                   (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                   matita_basics_logic.False
                   (_x_67 : cic.Term cic.prop matita_basics_logic.False =>
                    cic.univ (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))))) =>
            cic.prod cic.prop
              (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
              matita_basics_logic.False
              (x_67 : cic.Term cic.prop matita_basics_logic.False => Q_ x_67))).

def False_rect_Type4_body :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
        (cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
           (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
           (cic.prod cic.prop
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
              matita_basics_logic.False
              (_x_67 : cic.Term cic.prop matita_basics_logic.False =>
               cic.univ (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))))
           (Q_ :
              cic.Term
                (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                (cic.prod cic.prop
                   (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                   matita_basics_logic.False
                   (_x_67 : cic.Term cic.prop matita_basics_logic.False =>
                    cic.univ (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))))) =>
            cic.prod cic.prop
              (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
              matita_basics_logic.False
              (x_67 : cic.Term cic.prop matita_basics_logic.False => Q_ x_67))).

[ Q_, x_67 ] False_rect_Type4 Q_ x_67 -->
  matita_basics_logic.filter_False_Type4
    (x_67 : cic.Term cic.prop matita_basics_logic.False => Q_ x_67)
    (matita_basics_logic.False_rect_Type4_body Q_) x_67.

[ Q_, x_67 ] False_rect_Type4_body Q_ x_67 -->
  matita_basics_logic.match_False_Type4 Q_ x_67.

def False_rect_Type5 :
      cic.Term
        (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
        (cic.prod
           (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
           (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
           (cic.prod cic.prop
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
              matita_basics_logic.False
              (_x_68 : cic.Term cic.prop matita_basics_logic.False =>
               cic.univ
                 (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))))
           (Q_ :
              cic.Term
                (cic.type
                   (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                (cic.prod cic.prop
                   (cic.type
                      (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                   matita_basics_logic.False
                   (_x_68 : cic.Term cic.prop matita_basics_logic.False =>
                    cic.univ
                      (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))) =>
            cic.prod cic.prop
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
              matita_basics_logic.False
              (x_68 : cic.Term cic.prop matita_basics_logic.False => Q_ x_68))).

def False_rect_Type5_body :
      cic.Term
        (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
        (cic.prod
           (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
           (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
           (cic.prod cic.prop
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
              matita_basics_logic.False
              (_x_68 : cic.Term cic.prop matita_basics_logic.False =>
               cic.univ
                 (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))))
           (Q_ :
              cic.Term
                (cic.type
                   (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                (cic.prod cic.prop
                   (cic.type
                      (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                   matita_basics_logic.False
                   (_x_68 : cic.Term cic.prop matita_basics_logic.False =>
                    cic.univ
                      (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))) =>
            cic.prod cic.prop
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
              matita_basics_logic.False
              (x_68 : cic.Term cic.prop matita_basics_logic.False => Q_ x_68))).

[ Q_, x_68 ] False_rect_Type5 Q_ x_68 -->
  matita_basics_logic.filter_False_Type5
    (x_68 : cic.Term cic.prop matita_basics_logic.False => Q_ x_68)
    (matita_basics_logic.False_rect_Type5_body Q_) x_68.

[ Q_, x_68 ] False_rect_Type5_body Q_ x_68 -->
  matita_basics_logic.match_False_Type5 Q_ x_68.

def False_rect_Type3 :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
        (cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
           (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.prod cic.prop
              (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
              matita_basics_logic.False
              (_x_69 : cic.Term cic.prop matita_basics_logic.False =>
               cic.univ (cic.type (cic.s (cic.s (cic.s cic.z))))))
           (Q_ :
              cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                (cic.prod cic.prop
                   (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                   matita_basics_logic.False
                   (_x_69 : cic.Term cic.prop matita_basics_logic.False =>
                    cic.univ (cic.type (cic.s (cic.s (cic.s cic.z)))))) =>
            cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
              matita_basics_logic.False
              (x_69 : cic.Term cic.prop matita_basics_logic.False => Q_ x_69))).

def False_rect_Type3_body :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
        (cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
           (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.prod cic.prop
              (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
              matita_basics_logic.False
              (_x_69 : cic.Term cic.prop matita_basics_logic.False =>
               cic.univ (cic.type (cic.s (cic.s (cic.s cic.z))))))
           (Q_ :
              cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                (cic.prod cic.prop
                   (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                   matita_basics_logic.False
                   (_x_69 : cic.Term cic.prop matita_basics_logic.False =>
                    cic.univ (cic.type (cic.s (cic.s (cic.s cic.z)))))) =>
            cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
              matita_basics_logic.False
              (x_69 : cic.Term cic.prop matita_basics_logic.False => Q_ x_69))).

[ Q_, x_69 ] False_rect_Type3 Q_ x_69 -->
  matita_basics_logic.filter_False_Type3
    (x_69 : cic.Term cic.prop matita_basics_logic.False => Q_ x_69)
    (matita_basics_logic.False_rect_Type3_body Q_) x_69.

[ Q_, x_69 ] False_rect_Type3_body Q_ x_69 -->
  matita_basics_logic.match_False_Type3 Q_ x_69.

def False_rect_Type2 :
      cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.type (cic.s (cic.s cic.z)))
           (cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
              matita_basics_logic.False
              (_x_70 : cic.Term cic.prop matita_basics_logic.False =>
               cic.univ (cic.type (cic.s (cic.s cic.z)))))
           (Q_ :
              cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                (cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
                   matita_basics_logic.False
                   (_x_70 : cic.Term cic.prop matita_basics_logic.False =>
                    cic.univ (cic.type (cic.s (cic.s cic.z))))) =>
            cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
              matita_basics_logic.False
              (x_70 : cic.Term cic.prop matita_basics_logic.False => Q_ x_70))).

def False_rect_Type2_body :
      cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.type (cic.s (cic.s cic.z)))
           (cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
              matita_basics_logic.False
              (_x_70 : cic.Term cic.prop matita_basics_logic.False =>
               cic.univ (cic.type (cic.s (cic.s cic.z)))))
           (Q_ :
              cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                (cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
                   matita_basics_logic.False
                   (_x_70 : cic.Term cic.prop matita_basics_logic.False =>
                    cic.univ (cic.type (cic.s (cic.s cic.z))))) =>
            cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
              matita_basics_logic.False
              (x_70 : cic.Term cic.prop matita_basics_logic.False => Q_ x_70))).

[ Q_, x_70 ] False_rect_Type2 Q_ x_70 -->
  matita_basics_logic.filter_False_Type2
    (x_70 : cic.Term cic.prop matita_basics_logic.False => Q_ x_70)
    (matita_basics_logic.False_rect_Type2_body Q_) x_70.

[ Q_, x_70 ] False_rect_Type2_body Q_ x_70 -->
  matita_basics_logic.match_False_Type2 Q_ x_70.

def False_rect_Type1 :
      cic.Term (cic.type (cic.s (cic.s cic.z)))
        (cic.prod (cic.type (cic.s (cic.s cic.z))) (cic.type (cic.s cic.z))
           (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
              matita_basics_logic.False
              (_x_71 : cic.Term cic.prop matita_basics_logic.False =>
               cic.univ (cic.type (cic.s cic.z))))
           (Q_ :
              cic.Term (cic.type (cic.s (cic.s cic.z)))
                (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                   matita_basics_logic.False
                   (_x_71 : cic.Term cic.prop matita_basics_logic.False =>
                    cic.univ (cic.type (cic.s cic.z)))) =>
            cic.prod cic.prop (cic.type (cic.s cic.z))
              matita_basics_logic.False
              (x_71 : cic.Term cic.prop matita_basics_logic.False => Q_ x_71))).

def False_rect_Type1_body :
      cic.Term (cic.type (cic.s (cic.s cic.z)))
        (cic.prod (cic.type (cic.s (cic.s cic.z))) (cic.type (cic.s cic.z))
           (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
              matita_basics_logic.False
              (_x_71 : cic.Term cic.prop matita_basics_logic.False =>
               cic.univ (cic.type (cic.s cic.z))))
           (Q_ :
              cic.Term (cic.type (cic.s (cic.s cic.z)))
                (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                   matita_basics_logic.False
                   (_x_71 : cic.Term cic.prop matita_basics_logic.False =>
                    cic.univ (cic.type (cic.s cic.z)))) =>
            cic.prod cic.prop (cic.type (cic.s cic.z))
              matita_basics_logic.False
              (x_71 : cic.Term cic.prop matita_basics_logic.False => Q_ x_71))).

[ Q_, x_71 ] False_rect_Type1 Q_ x_71 -->
  matita_basics_logic.filter_False_Type1
    (x_71 : cic.Term cic.prop matita_basics_logic.False => Q_ x_71)
    (matita_basics_logic.False_rect_Type1_body Q_) x_71.

[ Q_, x_71 ] False_rect_Type1_body Q_ x_71 -->
  matita_basics_logic.match_False_Type1 Q_ x_71.

def False_rect_Type0 :
      cic.Term (cic.type (cic.s cic.z))
        (cic.prod (cic.type (cic.s cic.z)) (cic.type cic.z)
           (cic.prod cic.prop (cic.type (cic.s cic.z))
              matita_basics_logic.False
              (_x_72 : cic.Term cic.prop matita_basics_logic.False =>
               cic.univ (cic.type cic.z)))
           (Q_ :
              cic.Term (cic.type (cic.s cic.z))
                (cic.prod cic.prop (cic.type (cic.s cic.z))
                   matita_basics_logic.False
                   (_x_72 : cic.Term cic.prop matita_basics_logic.False =>
                    cic.univ (cic.type cic.z))) =>
            cic.prod cic.prop (cic.type cic.z) matita_basics_logic.False
              (x_72 : cic.Term cic.prop matita_basics_logic.False => Q_ x_72))).

def False_rect_Type0_body :
      cic.Term (cic.type (cic.s cic.z))
        (cic.prod (cic.type (cic.s cic.z)) (cic.type cic.z)
           (cic.prod cic.prop (cic.type (cic.s cic.z))
              matita_basics_logic.False
              (_x_72 : cic.Term cic.prop matita_basics_logic.False =>
               cic.univ (cic.type cic.z)))
           (Q_ :
              cic.Term (cic.type (cic.s cic.z))
                (cic.prod cic.prop (cic.type (cic.s cic.z))
                   matita_basics_logic.False
                   (_x_72 : cic.Term cic.prop matita_basics_logic.False =>
                    cic.univ (cic.type cic.z))) =>
            cic.prod cic.prop (cic.type cic.z) matita_basics_logic.False
              (x_72 : cic.Term cic.prop matita_basics_logic.False => Q_ x_72))).

[ Q_, x_72 ] False_rect_Type0 Q_ x_72 -->
  matita_basics_logic.filter_False_Type0
    (x_72 : cic.Term cic.prop matita_basics_logic.False => Q_ x_72)
    (matita_basics_logic.False_rect_Type0_body Q_) x_72.

[ Q_, x_72 ] False_rect_Type0_body Q_ x_72 -->
  matita_basics_logic.match_False_Type0 Q_ x_72.

def False_rect_CProp4 :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop
           (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.False
              (_x_73 : cic.Term cic.prop matita_basics_logic.False =>
               cic.univ cic.prop))
           (Q_ :
              cic.Term (cic.type cic.z)
                (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.False
                   (_x_73 : cic.Term cic.prop matita_basics_logic.False =>
                    cic.univ cic.prop)) =>
            cic.prod cic.prop cic.prop matita_basics_logic.False
              (x_73 : cic.Term cic.prop matita_basics_logic.False => Q_ x_73))).

def False_rect_CProp4_body :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop
           (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.False
              (_x_73 : cic.Term cic.prop matita_basics_logic.False =>
               cic.univ cic.prop))
           (Q_ :
              cic.Term (cic.type cic.z)
                (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.False
                   (_x_73 : cic.Term cic.prop matita_basics_logic.False =>
                    cic.univ cic.prop)) =>
            cic.prod cic.prop cic.prop matita_basics_logic.False
              (x_73 : cic.Term cic.prop matita_basics_logic.False => Q_ x_73))).

[ Q_, x_73 ] False_rect_CProp4 Q_ x_73 -->
  matita_basics_logic.filter_False_Prop
    (x_73 : cic.Term cic.prop matita_basics_logic.False => Q_ x_73)
    (matita_basics_logic.False_rect_CProp4_body Q_) x_73.

[ Q_, x_73 ] False_rect_CProp4_body Q_ x_73 -->
  matita_basics_logic.match_False_Prop Q_ x_73.

def False_rect_CProp5 :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop
           (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.False
              (_x_74 : cic.Term cic.prop matita_basics_logic.False =>
               cic.univ cic.prop))
           (Q_ :
              cic.Term (cic.type cic.z)
                (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.False
                   (_x_74 : cic.Term cic.prop matita_basics_logic.False =>
                    cic.univ cic.prop)) =>
            cic.prod cic.prop cic.prop matita_basics_logic.False
              (x_74 : cic.Term cic.prop matita_basics_logic.False => Q_ x_74))).

def False_rect_CProp5_body :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop
           (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.False
              (_x_74 : cic.Term cic.prop matita_basics_logic.False =>
               cic.univ cic.prop))
           (Q_ :
              cic.Term (cic.type cic.z)
                (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.False
                   (_x_74 : cic.Term cic.prop matita_basics_logic.False =>
                    cic.univ cic.prop)) =>
            cic.prod cic.prop cic.prop matita_basics_logic.False
              (x_74 : cic.Term cic.prop matita_basics_logic.False => Q_ x_74))).

[ Q_, x_74 ] False_rect_CProp5 Q_ x_74 -->
  matita_basics_logic.filter_False_Prop
    (x_74 : cic.Term cic.prop matita_basics_logic.False => Q_ x_74)
    (matita_basics_logic.False_rect_CProp5_body Q_) x_74.

[ Q_, x_74 ] False_rect_CProp5_body Q_ x_74 -->
  matita_basics_logic.match_False_Prop Q_ x_74.

def False_rect_CProp3 :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop
           (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.False
              (_x_75 : cic.Term cic.prop matita_basics_logic.False =>
               cic.univ cic.prop))
           (Q_ :
              cic.Term (cic.type cic.z)
                (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.False
                   (_x_75 : cic.Term cic.prop matita_basics_logic.False =>
                    cic.univ cic.prop)) =>
            cic.prod cic.prop cic.prop matita_basics_logic.False
              (x_75 : cic.Term cic.prop matita_basics_logic.False => Q_ x_75))).

def False_rect_CProp3_body :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop
           (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.False
              (_x_75 : cic.Term cic.prop matita_basics_logic.False =>
               cic.univ cic.prop))
           (Q_ :
              cic.Term (cic.type cic.z)
                (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.False
                   (_x_75 : cic.Term cic.prop matita_basics_logic.False =>
                    cic.univ cic.prop)) =>
            cic.prod cic.prop cic.prop matita_basics_logic.False
              (x_75 : cic.Term cic.prop matita_basics_logic.False => Q_ x_75))).

[ Q_, x_75 ] False_rect_CProp3 Q_ x_75 -->
  matita_basics_logic.filter_False_Prop
    (x_75 : cic.Term cic.prop matita_basics_logic.False => Q_ x_75)
    (matita_basics_logic.False_rect_CProp3_body Q_) x_75.

[ Q_, x_75 ] False_rect_CProp3_body Q_ x_75 -->
  matita_basics_logic.match_False_Prop Q_ x_75.

def False_rect_CProp2 :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop
           (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.False
              (_x_76 : cic.Term cic.prop matita_basics_logic.False =>
               cic.univ cic.prop))
           (Q_ :
              cic.Term (cic.type cic.z)
                (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.False
                   (_x_76 : cic.Term cic.prop matita_basics_logic.False =>
                    cic.univ cic.prop)) =>
            cic.prod cic.prop cic.prop matita_basics_logic.False
              (x_76 : cic.Term cic.prop matita_basics_logic.False => Q_ x_76))).

def False_rect_CProp2_body :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop
           (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.False
              (_x_76 : cic.Term cic.prop matita_basics_logic.False =>
               cic.univ cic.prop))
           (Q_ :
              cic.Term (cic.type cic.z)
                (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.False
                   (_x_76 : cic.Term cic.prop matita_basics_logic.False =>
                    cic.univ cic.prop)) =>
            cic.prod cic.prop cic.prop matita_basics_logic.False
              (x_76 : cic.Term cic.prop matita_basics_logic.False => Q_ x_76))).

[ Q_, x_76 ] False_rect_CProp2 Q_ x_76 -->
  matita_basics_logic.filter_False_Prop
    (x_76 : cic.Term cic.prop matita_basics_logic.False => Q_ x_76)
    (matita_basics_logic.False_rect_CProp2_body Q_) x_76.

[ Q_, x_76 ] False_rect_CProp2_body Q_ x_76 -->
  matita_basics_logic.match_False_Prop Q_ x_76.

def False_rect_CProp1 :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop
           (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.False
              (_x_77 : cic.Term cic.prop matita_basics_logic.False =>
               cic.univ cic.prop))
           (Q_ :
              cic.Term (cic.type cic.z)
                (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.False
                   (_x_77 : cic.Term cic.prop matita_basics_logic.False =>
                    cic.univ cic.prop)) =>
            cic.prod cic.prop cic.prop matita_basics_logic.False
              (x_77 : cic.Term cic.prop matita_basics_logic.False => Q_ x_77))).

def False_rect_CProp1_body :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop
           (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.False
              (_x_77 : cic.Term cic.prop matita_basics_logic.False =>
               cic.univ cic.prop))
           (Q_ :
              cic.Term (cic.type cic.z)
                (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.False
                   (_x_77 : cic.Term cic.prop matita_basics_logic.False =>
                    cic.univ cic.prop)) =>
            cic.prod cic.prop cic.prop matita_basics_logic.False
              (x_77 : cic.Term cic.prop matita_basics_logic.False => Q_ x_77))).

[ Q_, x_77 ] False_rect_CProp1 Q_ x_77 -->
  matita_basics_logic.filter_False_Prop
    (x_77 : cic.Term cic.prop matita_basics_logic.False => Q_ x_77)
    (matita_basics_logic.False_rect_CProp1_body Q_) x_77.

[ Q_, x_77 ] False_rect_CProp1_body Q_ x_77 -->
  matita_basics_logic.match_False_Prop Q_ x_77.

def False_rect_CProp0 :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop
           (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.False
              (_x_78 : cic.Term cic.prop matita_basics_logic.False =>
               cic.univ cic.prop))
           (Q_ :
              cic.Term (cic.type cic.z)
                (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.False
                   (_x_78 : cic.Term cic.prop matita_basics_logic.False =>
                    cic.univ cic.prop)) =>
            cic.prod cic.prop cic.prop matita_basics_logic.False
              (x_78 : cic.Term cic.prop matita_basics_logic.False => Q_ x_78))).

def False_rect_CProp0_body :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop
           (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.False
              (_x_78 : cic.Term cic.prop matita_basics_logic.False =>
               cic.univ cic.prop))
           (Q_ :
              cic.Term (cic.type cic.z)
                (cic.prod cic.prop (cic.type cic.z) matita_basics_logic.False
                   (_x_78 : cic.Term cic.prop matita_basics_logic.False =>
                    cic.univ cic.prop)) =>
            cic.prod cic.prop cic.prop matita_basics_logic.False
              (x_78 : cic.Term cic.prop matita_basics_logic.False => Q_ x_78))).

[ Q_, x_78 ] False_rect_CProp0 Q_ x_78 -->
  matita_basics_logic.filter_False_Prop
    (x_78 : cic.Term cic.prop matita_basics_logic.False => Q_ x_78)
    (matita_basics_logic.False_rect_CProp0_body Q_) x_78.

[ Q_, x_78 ] False_rect_CProp0_body Q_ x_78 -->
  matita_basics_logic.match_False_Prop Q_ x_78.

Not :
  cic.Term (cic.type cic.z)
    (cic.prod (cic.type cic.z) (cic.type cic.z) (cic.univ cic.prop)
       (_A : cic.Univ cic.prop => cic.univ cic.prop)).

nmk :
  cic.Term cic.prop
    (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
       (A : cic.Univ cic.prop =>
        cic.prod cic.prop cic.prop
          (cic.prod cic.prop cic.prop A
             (__ : cic.Term cic.prop A => matita_basics_logic.False))
          (__ :
             cic.Term cic.prop
               (cic.prod cic.prop cic.prop A
                  (__ : cic.Term cic.prop A => matita_basics_logic.False)) =>
           matita_basics_logic.Not (cic.lift cic.prop cic.prop A)))).

def match_Not_Prop :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) cic.prop
              (cic.prod cic.prop (cic.type cic.z)
                 (matita_basics_logic.Not _A)
                 (z : cic.Term cic.prop (matita_basics_logic.Not _A) =>
                  cic.univ cic.prop))
              (return_type :
                 cic.Term (cic.type cic.z)
                   (cic.prod cic.prop (cic.type cic.z)
                      (matita_basics_logic.Not _A)
                      (z : cic.Term cic.prop (matita_basics_logic.Not _A) =>
                       cic.univ cic.prop)) =>
               cic.prod cic.prop cic.prop
                 (cic.prod cic.prop cic.prop
                    (cic.prod cic.prop cic.prop _A
                       (__ : cic.Term cic.prop _A =>
                        matita_basics_logic.False))
                    (__ :
                       cic.Term cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False)) =>
                     return_type (matita_basics_logic.nmk _A __)))
                 (case_nmk :
                    cic.Term cic.prop
                      (cic.prod cic.prop cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False))
                         (__ :
                            cic.Term cic.prop
                              (cic.prod cic.prop cic.prop _A
                                 (__ : cic.Term cic.prop _A =>
                                  matita_basics_logic.False)) =>
                          return_type (matita_basics_logic.nmk _A __))) =>
                  cic.prod cic.prop cic.prop (matita_basics_logic.Not _A)
                    (z : cic.Term cic.prop (matita_basics_logic.Not _A) =>
                     return_type z))))).

[ _A, return_type, case_nmk, __ ]
  match_Not_Prop _A return_type case_nmk (matita_basics_logic.nmk _A __) -->
  case_nmk __.

def match_Not_Type5 :
      cic.Term
        (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
        (cic.prod (cic.type cic.z)
           (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
           (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
              (cic.prod cic.prop
                 (cic.type
                    (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                 (matita_basics_logic.Not _A)
                 (z : cic.Term cic.prop (matita_basics_logic.Not _A) =>
                  cic.univ
                    (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))))
              (return_type :
                 cic.Term
                   (cic.type
                      (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                   (cic.prod cic.prop
                      (cic.type
                         (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                      (matita_basics_logic.Not _A)
                      (z : cic.Term cic.prop (matita_basics_logic.Not _A) =>
                       cic.univ
                         (cic.type
                            (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))) =>
               cic.prod
                 (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                 (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                 (cic.prod cic.prop
                    (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                    (cic.prod cic.prop cic.prop _A
                       (__ : cic.Term cic.prop _A =>
                        matita_basics_logic.False))
                    (__ :
                       cic.Term cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False)) =>
                     return_type (matita_basics_logic.nmk _A __)))
                 (case_nmk :
                    cic.Term
                      (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                      (cic.prod cic.prop
                         (cic.type
                            (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False))
                         (__ :
                            cic.Term cic.prop
                              (cic.prod cic.prop cic.prop _A
                                 (__ : cic.Term cic.prop _A =>
                                  matita_basics_logic.False)) =>
                          return_type (matita_basics_logic.nmk _A __))) =>
                  cic.prod cic.prop
                    (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                    (matita_basics_logic.Not _A)
                    (z : cic.Term cic.prop (matita_basics_logic.Not _A) =>
                     return_type z))))).

[ _A, return_type, case_nmk, __ ]
  match_Not_Type5 _A return_type case_nmk (matita_basics_logic.nmk _A __) -->
  case_nmk __.

def match_Not_Type4 :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
        (cic.prod (cic.type cic.z)
           (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
           (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
              (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
              (cic.prod cic.prop
                 (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                 (matita_basics_logic.Not _A)
                 (z : cic.Term cic.prop (matita_basics_logic.Not _A) =>
                  cic.univ (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))))
              (return_type :
                 cic.Term
                   (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                   (cic.prod cic.prop
                      (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                      (matita_basics_logic.Not _A)
                      (z : cic.Term cic.prop (matita_basics_logic.Not _A) =>
                       cic.univ
                         (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))))) =>
               cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                 (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                 (cic.prod cic.prop
                    (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                    (cic.prod cic.prop cic.prop _A
                       (__ : cic.Term cic.prop _A =>
                        matita_basics_logic.False))
                    (__ :
                       cic.Term cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False)) =>
                     return_type (matita_basics_logic.nmk _A __)))
                 (case_nmk :
                    cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                      (cic.prod cic.prop
                         (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False))
                         (__ :
                            cic.Term cic.prop
                              (cic.prod cic.prop cic.prop _A
                                 (__ : cic.Term cic.prop _A =>
                                  matita_basics_logic.False)) =>
                          return_type (matita_basics_logic.nmk _A __))) =>
                  cic.prod cic.prop
                    (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                    (matita_basics_logic.Not _A)
                    (z : cic.Term cic.prop (matita_basics_logic.Not _A) =>
                     return_type z))))).

[ _A, return_type, case_nmk, __ ]
  match_Not_Type4 _A return_type case_nmk (matita_basics_logic.nmk _A __) -->
  case_nmk __.

def match_Not_Type3 :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
        (cic.prod (cic.type cic.z)
           (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
           (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
              (cic.type (cic.s (cic.s (cic.s cic.z))))
              (cic.prod cic.prop
                 (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                 (matita_basics_logic.Not _A)
                 (z : cic.Term cic.prop (matita_basics_logic.Not _A) =>
                  cic.univ (cic.type (cic.s (cic.s (cic.s cic.z))))))
              (return_type :
                 cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                   (cic.prod cic.prop
                      (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                      (matita_basics_logic.Not _A)
                      (z : cic.Term cic.prop (matita_basics_logic.Not _A) =>
                       cic.univ (cic.type (cic.s (cic.s (cic.s cic.z)))))) =>
               cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
                 (cic.type (cic.s (cic.s (cic.s cic.z))))
                 (cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
                    (cic.prod cic.prop cic.prop _A
                       (__ : cic.Term cic.prop _A =>
                        matita_basics_logic.False))
                    (__ :
                       cic.Term cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False)) =>
                     return_type (matita_basics_logic.nmk _A __)))
                 (case_nmk :
                    cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                      (cic.prod cic.prop
                         (cic.type (cic.s (cic.s (cic.s cic.z))))
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False))
                         (__ :
                            cic.Term cic.prop
                              (cic.prod cic.prop cic.prop _A
                                 (__ : cic.Term cic.prop _A =>
                                  matita_basics_logic.False)) =>
                          return_type (matita_basics_logic.nmk _A __))) =>
                  cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
                    (matita_basics_logic.Not _A)
                    (z : cic.Term cic.prop (matita_basics_logic.Not _A) =>
                     return_type z))))).

[ _A, return_type, case_nmk, __ ]
  match_Not_Type3 _A return_type case_nmk (matita_basics_logic.nmk _A __) -->
  case_nmk __.

def match_Not_Type2 :
      cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
        (cic.prod (cic.type cic.z) (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
              (cic.type (cic.s (cic.s cic.z)))
              (cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
                 (matita_basics_logic.Not _A)
                 (z : cic.Term cic.prop (matita_basics_logic.Not _A) =>
                  cic.univ (cic.type (cic.s (cic.s cic.z)))))
              (return_type :
                 cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                   (cic.prod cic.prop
                      (cic.type (cic.s (cic.s (cic.s cic.z))))
                      (matita_basics_logic.Not _A)
                      (z : cic.Term cic.prop (matita_basics_logic.Not _A) =>
                       cic.univ (cic.type (cic.s (cic.s cic.z))))) =>
               cic.prod (cic.type (cic.s (cic.s cic.z)))
                 (cic.type (cic.s (cic.s cic.z)))
                 (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (cic.prod cic.prop cic.prop _A
                       (__ : cic.Term cic.prop _A =>
                        matita_basics_logic.False))
                    (__ :
                       cic.Term cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False)) =>
                     return_type (matita_basics_logic.nmk _A __)))
                 (case_nmk :
                    cic.Term (cic.type (cic.s (cic.s cic.z)))
                      (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False))
                         (__ :
                            cic.Term cic.prop
                              (cic.prod cic.prop cic.prop _A
                                 (__ : cic.Term cic.prop _A =>
                                  matita_basics_logic.False)) =>
                          return_type (matita_basics_logic.nmk _A __))) =>
                  cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.Not _A)
                    (z : cic.Term cic.prop (matita_basics_logic.Not _A) =>
                     return_type z))))).

[ _A, return_type, case_nmk, __ ]
  match_Not_Type2 _A return_type case_nmk (matita_basics_logic.nmk _A __) -->
  case_nmk __.

def match_Not_Type1 :
      cic.Term (cic.type (cic.s (cic.s cic.z)))
        (cic.prod (cic.type cic.z) (cic.type (cic.s (cic.s cic.z)))
           (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s cic.z))
              (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                 (matita_basics_logic.Not _A)
                 (z : cic.Term cic.prop (matita_basics_logic.Not _A) =>
                  cic.univ (cic.type (cic.s cic.z))))
              (return_type :
                 cic.Term (cic.type (cic.s (cic.s cic.z)))
                   (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                      (matita_basics_logic.Not _A)
                      (z : cic.Term cic.prop (matita_basics_logic.Not _A) =>
                       cic.univ (cic.type (cic.s cic.z)))) =>
               cic.prod (cic.type (cic.s cic.z)) (cic.type (cic.s cic.z))
                 (cic.prod cic.prop (cic.type (cic.s cic.z))
                    (cic.prod cic.prop cic.prop _A
                       (__ : cic.Term cic.prop _A =>
                        matita_basics_logic.False))
                    (__ :
                       cic.Term cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False)) =>
                     return_type (matita_basics_logic.nmk _A __)))
                 (case_nmk :
                    cic.Term (cic.type (cic.s cic.z))
                      (cic.prod cic.prop (cic.type (cic.s cic.z))
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False))
                         (__ :
                            cic.Term cic.prop
                              (cic.prod cic.prop cic.prop _A
                                 (__ : cic.Term cic.prop _A =>
                                  matita_basics_logic.False)) =>
                          return_type (matita_basics_logic.nmk _A __))) =>
                  cic.prod cic.prop (cic.type (cic.s cic.z))
                    (matita_basics_logic.Not _A)
                    (z : cic.Term cic.prop (matita_basics_logic.Not _A) =>
                     return_type z))))).

[ _A, return_type, case_nmk, __ ]
  match_Not_Type1 _A return_type case_nmk (matita_basics_logic.nmk _A __) -->
  case_nmk __.

def match_Not_Type0 :
      cic.Term (cic.type (cic.s cic.z))
        (cic.prod (cic.type cic.z) (cic.type (cic.s cic.z))
           (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type (cic.s cic.z)) (cic.type cic.z)
              (cic.prod cic.prop (cic.type (cic.s cic.z))
                 (matita_basics_logic.Not _A)
                 (z : cic.Term cic.prop (matita_basics_logic.Not _A) =>
                  cic.univ (cic.type cic.z)))
              (return_type :
                 cic.Term (cic.type (cic.s cic.z))
                   (cic.prod cic.prop (cic.type (cic.s cic.z))
                      (matita_basics_logic.Not _A)
                      (z : cic.Term cic.prop (matita_basics_logic.Not _A) =>
                       cic.univ (cic.type cic.z))) =>
               cic.prod (cic.type cic.z) (cic.type cic.z)
                 (cic.prod cic.prop (cic.type cic.z)
                    (cic.prod cic.prop cic.prop _A
                       (__ : cic.Term cic.prop _A =>
                        matita_basics_logic.False))
                    (__ :
                       cic.Term cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False)) =>
                     return_type (matita_basics_logic.nmk _A __)))
                 (case_nmk :
                    cic.Term (cic.type cic.z)
                      (cic.prod cic.prop (cic.type cic.z)
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False))
                         (__ :
                            cic.Term cic.prop
                              (cic.prod cic.prop cic.prop _A
                                 (__ : cic.Term cic.prop _A =>
                                  matita_basics_logic.False)) =>
                          return_type (matita_basics_logic.nmk _A __))) =>
                  cic.prod cic.prop (cic.type cic.z)
                    (matita_basics_logic.Not _A)
                    (z : cic.Term cic.prop (matita_basics_logic.Not _A) =>
                     return_type z))))).

[ _A, return_type, case_nmk, __ ]
  match_Not_Type0 _A return_type case_nmk (matita_basics_logic.nmk _A __) -->
  case_nmk __.

def filter_Not_Prop :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) cic.prop
              (cic.prod cic.prop (cic.type cic.z)
                 (matita_basics_logic.Not _A)
                 (z : cic.Term cic.prop (matita_basics_logic.Not _A) =>
                  cic.univ cic.prop))
              (return_type :
                 cic.Term (cic.type cic.z)
                   (cic.prod cic.prop (cic.type cic.z)
                      (matita_basics_logic.Not _A)
                      (z : cic.Term cic.prop (matita_basics_logic.Not _A) =>
                       cic.univ cic.prop)) =>
               cic.prod cic.prop cic.prop
                 (cic.prod cic.prop cic.prop (matita_basics_logic.Not _A)
                    (z : cic.Term cic.prop (matita_basics_logic.Not _A) =>
                     return_type z))
                 (return :
                    cic.Term cic.prop
                      (cic.prod cic.prop cic.prop
                         (matita_basics_logic.Not _A)
                         (z :
                            cic.Term cic.prop (matita_basics_logic.Not _A) =>
                          return_type z)) =>
                  cic.prod cic.prop cic.prop (matita_basics_logic.Not _A)
                    (z : cic.Term cic.prop (matita_basics_logic.Not _A) =>
                     return_type z))))).

[ A, __, return_type, return ]
  filter_Not_Prop (A) return_type return (matita_basics_logic.nmk A __) -->
  return (matita_basics_logic.nmk A __).

def filter_Not_Type5 :
      cic.Term
        (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
        (cic.prod (cic.type cic.z)
           (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
           (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
              (cic.prod cic.prop
                 (cic.type
                    (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                 (matita_basics_logic.Not _A)
                 (z : cic.Term cic.prop (matita_basics_logic.Not _A) =>
                  cic.univ
                    (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))))
              (return_type :
                 cic.Term
                   (cic.type
                      (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                   (cic.prod cic.prop
                      (cic.type
                         (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                      (matita_basics_logic.Not _A)
                      (z : cic.Term cic.prop (matita_basics_logic.Not _A) =>
                       cic.univ
                         (cic.type
                            (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))) =>
               cic.prod
                 (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                 (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                 (cic.prod cic.prop
                    (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                    (matita_basics_logic.Not _A)
                    (z : cic.Term cic.prop (matita_basics_logic.Not _A) =>
                     return_type z))
                 (return :
                    cic.Term
                      (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                      (cic.prod cic.prop
                         (cic.type
                            (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                         (matita_basics_logic.Not _A)
                         (z :
                            cic.Term cic.prop (matita_basics_logic.Not _A) =>
                          return_type z)) =>
                  cic.prod cic.prop
                    (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                    (matita_basics_logic.Not _A)
                    (z : cic.Term cic.prop (matita_basics_logic.Not _A) =>
                     return_type z))))).

[ A, __, return_type, return ]
  filter_Not_Type5 (A) return_type return (matita_basics_logic.nmk A __) -->
  return (matita_basics_logic.nmk A __).

def filter_Not_Type4 :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
        (cic.prod (cic.type cic.z)
           (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
           (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
              (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
              (cic.prod cic.prop
                 (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                 (matita_basics_logic.Not _A)
                 (z : cic.Term cic.prop (matita_basics_logic.Not _A) =>
                  cic.univ (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))))
              (return_type :
                 cic.Term
                   (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                   (cic.prod cic.prop
                      (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                      (matita_basics_logic.Not _A)
                      (z : cic.Term cic.prop (matita_basics_logic.Not _A) =>
                       cic.univ
                         (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))))) =>
               cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                 (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                 (cic.prod cic.prop
                    (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                    (matita_basics_logic.Not _A)
                    (z : cic.Term cic.prop (matita_basics_logic.Not _A) =>
                     return_type z))
                 (return :
                    cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                      (cic.prod cic.prop
                         (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                         (matita_basics_logic.Not _A)
                         (z :
                            cic.Term cic.prop (matita_basics_logic.Not _A) =>
                          return_type z)) =>
                  cic.prod cic.prop
                    (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                    (matita_basics_logic.Not _A)
                    (z : cic.Term cic.prop (matita_basics_logic.Not _A) =>
                     return_type z))))).

[ A, __, return_type, return ]
  filter_Not_Type4 (A) return_type return (matita_basics_logic.nmk A __) -->
  return (matita_basics_logic.nmk A __).

def filter_Not_Type3 :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
        (cic.prod (cic.type cic.z)
           (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
           (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
              (cic.type (cic.s (cic.s (cic.s cic.z))))
              (cic.prod cic.prop
                 (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                 (matita_basics_logic.Not _A)
                 (z : cic.Term cic.prop (matita_basics_logic.Not _A) =>
                  cic.univ (cic.type (cic.s (cic.s (cic.s cic.z))))))
              (return_type :
                 cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                   (cic.prod cic.prop
                      (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                      (matita_basics_logic.Not _A)
                      (z : cic.Term cic.prop (matita_basics_logic.Not _A) =>
                       cic.univ (cic.type (cic.s (cic.s (cic.s cic.z)))))) =>
               cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
                 (cic.type (cic.s (cic.s (cic.s cic.z))))
                 (cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
                    (matita_basics_logic.Not _A)
                    (z : cic.Term cic.prop (matita_basics_logic.Not _A) =>
                     return_type z))
                 (return :
                    cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                      (cic.prod cic.prop
                         (cic.type (cic.s (cic.s (cic.s cic.z))))
                         (matita_basics_logic.Not _A)
                         (z :
                            cic.Term cic.prop (matita_basics_logic.Not _A) =>
                          return_type z)) =>
                  cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
                    (matita_basics_logic.Not _A)
                    (z : cic.Term cic.prop (matita_basics_logic.Not _A) =>
                     return_type z))))).

[ A, __, return_type, return ]
  filter_Not_Type3 (A) return_type return (matita_basics_logic.nmk A __) -->
  return (matita_basics_logic.nmk A __).

def filter_Not_Type2 :
      cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
        (cic.prod (cic.type cic.z) (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
              (cic.type (cic.s (cic.s cic.z)))
              (cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
                 (matita_basics_logic.Not _A)
                 (z : cic.Term cic.prop (matita_basics_logic.Not _A) =>
                  cic.univ (cic.type (cic.s (cic.s cic.z)))))
              (return_type :
                 cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                   (cic.prod cic.prop
                      (cic.type (cic.s (cic.s (cic.s cic.z))))
                      (matita_basics_logic.Not _A)
                      (z : cic.Term cic.prop (matita_basics_logic.Not _A) =>
                       cic.univ (cic.type (cic.s (cic.s cic.z))))) =>
               cic.prod (cic.type (cic.s (cic.s cic.z)))
                 (cic.type (cic.s (cic.s cic.z)))
                 (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.Not _A)
                    (z : cic.Term cic.prop (matita_basics_logic.Not _A) =>
                     return_type z))
                 (return :
                    cic.Term (cic.type (cic.s (cic.s cic.z)))
                      (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.Not _A)
                         (z :
                            cic.Term cic.prop (matita_basics_logic.Not _A) =>
                          return_type z)) =>
                  cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.Not _A)
                    (z : cic.Term cic.prop (matita_basics_logic.Not _A) =>
                     return_type z))))).

[ A, __, return_type, return ]
  filter_Not_Type2 (A) return_type return (matita_basics_logic.nmk A __) -->
  return (matita_basics_logic.nmk A __).

def filter_Not_Type1 :
      cic.Term (cic.type (cic.s (cic.s cic.z)))
        (cic.prod (cic.type cic.z) (cic.type (cic.s (cic.s cic.z)))
           (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s cic.z))
              (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                 (matita_basics_logic.Not _A)
                 (z : cic.Term cic.prop (matita_basics_logic.Not _A) =>
                  cic.univ (cic.type (cic.s cic.z))))
              (return_type :
                 cic.Term (cic.type (cic.s (cic.s cic.z)))
                   (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                      (matita_basics_logic.Not _A)
                      (z : cic.Term cic.prop (matita_basics_logic.Not _A) =>
                       cic.univ (cic.type (cic.s cic.z)))) =>
               cic.prod (cic.type (cic.s cic.z)) (cic.type (cic.s cic.z))
                 (cic.prod cic.prop (cic.type (cic.s cic.z))
                    (matita_basics_logic.Not _A)
                    (z : cic.Term cic.prop (matita_basics_logic.Not _A) =>
                     return_type z))
                 (return :
                    cic.Term (cic.type (cic.s cic.z))
                      (cic.prod cic.prop (cic.type (cic.s cic.z))
                         (matita_basics_logic.Not _A)
                         (z :
                            cic.Term cic.prop (matita_basics_logic.Not _A) =>
                          return_type z)) =>
                  cic.prod cic.prop (cic.type (cic.s cic.z))
                    (matita_basics_logic.Not _A)
                    (z : cic.Term cic.prop (matita_basics_logic.Not _A) =>
                     return_type z))))).

[ A, __, return_type, return ]
  filter_Not_Type1 (A) return_type return (matita_basics_logic.nmk A __) -->
  return (matita_basics_logic.nmk A __).

def filter_Not_Type0 :
      cic.Term (cic.type (cic.s cic.z))
        (cic.prod (cic.type cic.z) (cic.type (cic.s cic.z))
           (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type (cic.s cic.z)) (cic.type cic.z)
              (cic.prod cic.prop (cic.type (cic.s cic.z))
                 (matita_basics_logic.Not _A)
                 (z : cic.Term cic.prop (matita_basics_logic.Not _A) =>
                  cic.univ (cic.type cic.z)))
              (return_type :
                 cic.Term (cic.type (cic.s cic.z))
                   (cic.prod cic.prop (cic.type (cic.s cic.z))
                      (matita_basics_logic.Not _A)
                      (z : cic.Term cic.prop (matita_basics_logic.Not _A) =>
                       cic.univ (cic.type cic.z))) =>
               cic.prod (cic.type cic.z) (cic.type cic.z)
                 (cic.prod cic.prop (cic.type cic.z)
                    (matita_basics_logic.Not _A)
                    (z : cic.Term cic.prop (matita_basics_logic.Not _A) =>
                     return_type z))
                 (return :
                    cic.Term (cic.type cic.z)
                      (cic.prod cic.prop (cic.type cic.z)
                         (matita_basics_logic.Not _A)
                         (z :
                            cic.Term cic.prop (matita_basics_logic.Not _A) =>
                          return_type z)) =>
                  cic.prod cic.prop (cic.type cic.z)
                    (matita_basics_logic.Not _A)
                    (z : cic.Term cic.prop (matita_basics_logic.Not _A) =>
                     return_type z))))).

[ A, __, return_type, return ]
  filter_Not_Type0 (A) return_type return (matita_basics_logic.nmk A __) -->
  return (matita_basics_logic.nmk A __).

def Not_ind :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) cic.prop
              (cic.prod cic.prop (cic.type cic.z)
                 (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A))
                 (_x_79 :
                    cic.Term cic.prop
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop _A)) =>
                  cic.univ cic.prop))
              (Q_ :
                 cic.Term (cic.type cic.z)
                   (cic.prod cic.prop (cic.type cic.z)
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop _A))
                      (_x_79 :
                         cic.Term cic.prop
                           (matita_basics_logic.Not
                              (cic.lift cic.prop cic.prop _A)) =>
                       cic.univ cic.prop)) =>
               cic.prod cic.prop cic.prop
                 (cic.prod cic.prop cic.prop
                    (cic.prod cic.prop cic.prop _A
                       (__ : cic.Term cic.prop _A =>
                        matita_basics_logic.False))
                    (x_80 :
                       cic.Term cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False)) =>
                     Q_
                       (matita_basics_logic.nmk
                          (cic.lift cic.prop cic.prop _A) x_80)))
                 (_H_nmk :
                    cic.Term cic.prop
                      (cic.prod cic.prop cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False))
                         (x_80 :
                            cic.Term cic.prop
                              (cic.prod cic.prop cic.prop _A
                                 (__ : cic.Term cic.prop _A =>
                                  matita_basics_logic.False)) =>
                          Q_
                            (matita_basics_logic.nmk
                               (cic.lift cic.prop cic.prop _A) x_80))) =>
                  cic.prod cic.prop cic.prop
                    (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A))
                    (x_79 :
                       cic.Term cic.prop
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop _A)) =>
                     Q_ x_79))))).

def Not_ind_body :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) cic.prop
              (cic.prod cic.prop (cic.type cic.z)
                 (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A))
                 (_x_79 :
                    cic.Term cic.prop
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop _A)) =>
                  cic.univ cic.prop))
              (Q_ :
                 cic.Term (cic.type cic.z)
                   (cic.prod cic.prop (cic.type cic.z)
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop _A))
                      (_x_79 :
                         cic.Term cic.prop
                           (matita_basics_logic.Not
                              (cic.lift cic.prop cic.prop _A)) =>
                       cic.univ cic.prop)) =>
               cic.prod cic.prop cic.prop
                 (cic.prod cic.prop cic.prop
                    (cic.prod cic.prop cic.prop _A
                       (__ : cic.Term cic.prop _A =>
                        matita_basics_logic.False))
                    (x_80 :
                       cic.Term cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False)) =>
                     Q_
                       (matita_basics_logic.nmk
                          (cic.lift cic.prop cic.prop _A) x_80)))
                 (_H_nmk :
                    cic.Term cic.prop
                      (cic.prod cic.prop cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False))
                         (x_80 :
                            cic.Term cic.prop
                              (cic.prod cic.prop cic.prop _A
                                 (__ : cic.Term cic.prop _A =>
                                  matita_basics_logic.False)) =>
                          Q_
                            (matita_basics_logic.nmk
                               (cic.lift cic.prop cic.prop _A) x_80))) =>
                  cic.prod cic.prop cic.prop
                    (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A))
                    (x_79 :
                       cic.Term cic.prop
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop _A)) =>
                     Q_ x_79))))).

[ _A, Q_, _H_nmk, x_79 ] Not_ind _A Q_ _H_nmk x_79 -->
  matita_basics_logic.filter_Not_Prop _A
    (x_79 :
       cic.Term cic.prop
         (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A)) =>
     Q_ x_79)
    (matita_basics_logic.Not_ind_body _A Q_ _H_nmk) x_79.

[ _A, Q_, _H_nmk, x_79 ] Not_ind_body _A Q_ _H_nmk x_79 -->
  matita_basics_logic.match_Not_Prop (cic.lift cic.prop cic.prop _A) Q_
    (x_80 :
       cic.Term cic.prop
         (cic.prod cic.prop cic.prop _A
            (__ : cic.Term cic.prop _A => matita_basics_logic.False)) =>
     _H_nmk x_80)
    x_79.

def Not_rect_Type4 :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
        (cic.prod (cic.type cic.z)
           (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
           (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
              (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
              (cic.prod cic.prop
                 (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                 (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A))
                 (_x_82 :
                    cic.Term cic.prop
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop _A)) =>
                  cic.univ (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))))
              (Q_ :
                 cic.Term
                   (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                   (cic.prod cic.prop
                      (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop _A))
                      (_x_82 :
                         cic.Term cic.prop
                           (matita_basics_logic.Not
                              (cic.lift cic.prop cic.prop _A)) =>
                       cic.univ
                         (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))))) =>
               cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                 (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                 (cic.prod cic.prop
                    (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                    (cic.prod cic.prop cic.prop _A
                       (__ : cic.Term cic.prop _A =>
                        matita_basics_logic.False))
                    (x_83 :
                       cic.Term cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False)) =>
                     Q_
                       (matita_basics_logic.nmk
                          (cic.lift cic.prop cic.prop _A) x_83)))
                 (_H_nmk :
                    cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                      (cic.prod cic.prop
                         (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False))
                         (x_83 :
                            cic.Term cic.prop
                              (cic.prod cic.prop cic.prop _A
                                 (__ : cic.Term cic.prop _A =>
                                  matita_basics_logic.False)) =>
                          Q_
                            (matita_basics_logic.nmk
                               (cic.lift cic.prop cic.prop _A) x_83))) =>
                  cic.prod cic.prop
                    (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                    (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A))
                    (x_82 :
                       cic.Term cic.prop
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop _A)) =>
                     Q_ x_82))))).

def Not_rect_Type4_body :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
        (cic.prod (cic.type cic.z)
           (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
           (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
              (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
              (cic.prod cic.prop
                 (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                 (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A))
                 (_x_82 :
                    cic.Term cic.prop
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop _A)) =>
                  cic.univ (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))))
              (Q_ :
                 cic.Term
                   (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                   (cic.prod cic.prop
                      (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop _A))
                      (_x_82 :
                         cic.Term cic.prop
                           (matita_basics_logic.Not
                              (cic.lift cic.prop cic.prop _A)) =>
                       cic.univ
                         (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))))) =>
               cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                 (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                 (cic.prod cic.prop
                    (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                    (cic.prod cic.prop cic.prop _A
                       (__ : cic.Term cic.prop _A =>
                        matita_basics_logic.False))
                    (x_83 :
                       cic.Term cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False)) =>
                     Q_
                       (matita_basics_logic.nmk
                          (cic.lift cic.prop cic.prop _A) x_83)))
                 (_H_nmk :
                    cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                      (cic.prod cic.prop
                         (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False))
                         (x_83 :
                            cic.Term cic.prop
                              (cic.prod cic.prop cic.prop _A
                                 (__ : cic.Term cic.prop _A =>
                                  matita_basics_logic.False)) =>
                          Q_
                            (matita_basics_logic.nmk
                               (cic.lift cic.prop cic.prop _A) x_83))) =>
                  cic.prod cic.prop
                    (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                    (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A))
                    (x_82 :
                       cic.Term cic.prop
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop _A)) =>
                     Q_ x_82))))).

[ _A, Q_, _H_nmk, x_82 ] Not_rect_Type4 _A Q_ _H_nmk x_82 -->
  matita_basics_logic.filter_Not_Type4 _A
    (x_82 :
       cic.Term cic.prop
         (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A)) =>
     Q_ x_82)
    (matita_basics_logic.Not_rect_Type4_body _A Q_ _H_nmk) x_82.

[ _A, Q_, _H_nmk, x_82 ] Not_rect_Type4_body _A Q_ _H_nmk x_82 -->
  matita_basics_logic.match_Not_Type4 (cic.lift cic.prop cic.prop _A) Q_
    (x_83 :
       cic.Term cic.prop
         (cic.prod cic.prop cic.prop _A
            (__ : cic.Term cic.prop _A => matita_basics_logic.False)) =>
     _H_nmk x_83)
    x_82.

def Not_rect_Type5 :
      cic.Term
        (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
        (cic.prod (cic.type cic.z)
           (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
           (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
              (cic.prod cic.prop
                 (cic.type
                    (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                 (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A))
                 (_x_85 :
                    cic.Term cic.prop
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop _A)) =>
                  cic.univ
                    (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))))
              (Q_ :
                 cic.Term
                   (cic.type
                      (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                   (cic.prod cic.prop
                      (cic.type
                         (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop _A))
                      (_x_85 :
                         cic.Term cic.prop
                           (matita_basics_logic.Not
                              (cic.lift cic.prop cic.prop _A)) =>
                       cic.univ
                         (cic.type
                            (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))) =>
               cic.prod
                 (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                 (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                 (cic.prod cic.prop
                    (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                    (cic.prod cic.prop cic.prop _A
                       (__ : cic.Term cic.prop _A =>
                        matita_basics_logic.False))
                    (x_86 :
                       cic.Term cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False)) =>
                     Q_
                       (matita_basics_logic.nmk
                          (cic.lift cic.prop cic.prop _A) x_86)))
                 (_H_nmk :
                    cic.Term
                      (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                      (cic.prod cic.prop
                         (cic.type
                            (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False))
                         (x_86 :
                            cic.Term cic.prop
                              (cic.prod cic.prop cic.prop _A
                                 (__ : cic.Term cic.prop _A =>
                                  matita_basics_logic.False)) =>
                          Q_
                            (matita_basics_logic.nmk
                               (cic.lift cic.prop cic.prop _A) x_86))) =>
                  cic.prod cic.prop
                    (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                    (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A))
                    (x_85 :
                       cic.Term cic.prop
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop _A)) =>
                     Q_ x_85))))).

def Not_rect_Type5_body :
      cic.Term
        (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
        (cic.prod (cic.type cic.z)
           (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
           (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
              (cic.prod cic.prop
                 (cic.type
                    (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                 (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A))
                 (_x_85 :
                    cic.Term cic.prop
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop _A)) =>
                  cic.univ
                    (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))))
              (Q_ :
                 cic.Term
                   (cic.type
                      (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                   (cic.prod cic.prop
                      (cic.type
                         (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop _A))
                      (_x_85 :
                         cic.Term cic.prop
                           (matita_basics_logic.Not
                              (cic.lift cic.prop cic.prop _A)) =>
                       cic.univ
                         (cic.type
                            (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))) =>
               cic.prod
                 (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                 (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                 (cic.prod cic.prop
                    (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                    (cic.prod cic.prop cic.prop _A
                       (__ : cic.Term cic.prop _A =>
                        matita_basics_logic.False))
                    (x_86 :
                       cic.Term cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False)) =>
                     Q_
                       (matita_basics_logic.nmk
                          (cic.lift cic.prop cic.prop _A) x_86)))
                 (_H_nmk :
                    cic.Term
                      (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                      (cic.prod cic.prop
                         (cic.type
                            (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False))
                         (x_86 :
                            cic.Term cic.prop
                              (cic.prod cic.prop cic.prop _A
                                 (__ : cic.Term cic.prop _A =>
                                  matita_basics_logic.False)) =>
                          Q_
                            (matita_basics_logic.nmk
                               (cic.lift cic.prop cic.prop _A) x_86))) =>
                  cic.prod cic.prop
                    (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                    (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A))
                    (x_85 :
                       cic.Term cic.prop
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop _A)) =>
                     Q_ x_85))))).

[ _A, Q_, _H_nmk, x_85 ] Not_rect_Type5 _A Q_ _H_nmk x_85 -->
  matita_basics_logic.filter_Not_Type5 _A
    (x_85 :
       cic.Term cic.prop
         (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A)) =>
     Q_ x_85)
    (matita_basics_logic.Not_rect_Type5_body _A Q_ _H_nmk) x_85.

[ _A, Q_, _H_nmk, x_85 ] Not_rect_Type5_body _A Q_ _H_nmk x_85 -->
  matita_basics_logic.match_Not_Type5 (cic.lift cic.prop cic.prop _A) Q_
    (x_86 :
       cic.Term cic.prop
         (cic.prod cic.prop cic.prop _A
            (__ : cic.Term cic.prop _A => matita_basics_logic.False)) =>
     _H_nmk x_86)
    x_85.

def Not_rect_Type3 :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
        (cic.prod (cic.type cic.z)
           (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
           (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
              (cic.type (cic.s (cic.s (cic.s cic.z))))
              (cic.prod cic.prop
                 (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                 (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A))
                 (_x_88 :
                    cic.Term cic.prop
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop _A)) =>
                  cic.univ (cic.type (cic.s (cic.s (cic.s cic.z))))))
              (Q_ :
                 cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                   (cic.prod cic.prop
                      (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop _A))
                      (_x_88 :
                         cic.Term cic.prop
                           (matita_basics_logic.Not
                              (cic.lift cic.prop cic.prop _A)) =>
                       cic.univ (cic.type (cic.s (cic.s (cic.s cic.z)))))) =>
               cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
                 (cic.type (cic.s (cic.s (cic.s cic.z))))
                 (cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
                    (cic.prod cic.prop cic.prop _A
                       (__ : cic.Term cic.prop _A =>
                        matita_basics_logic.False))
                    (x_89 :
                       cic.Term cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False)) =>
                     Q_
                       (matita_basics_logic.nmk
                          (cic.lift cic.prop cic.prop _A) x_89)))
                 (_H_nmk :
                    cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                      (cic.prod cic.prop
                         (cic.type (cic.s (cic.s (cic.s cic.z))))
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False))
                         (x_89 :
                            cic.Term cic.prop
                              (cic.prod cic.prop cic.prop _A
                                 (__ : cic.Term cic.prop _A =>
                                  matita_basics_logic.False)) =>
                          Q_
                            (matita_basics_logic.nmk
                               (cic.lift cic.prop cic.prop _A) x_89))) =>
                  cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
                    (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A))
                    (x_88 :
                       cic.Term cic.prop
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop _A)) =>
                     Q_ x_88))))).

def Not_rect_Type3_body :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
        (cic.prod (cic.type cic.z)
           (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
           (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
              (cic.type (cic.s (cic.s (cic.s cic.z))))
              (cic.prod cic.prop
                 (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                 (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A))
                 (_x_88 :
                    cic.Term cic.prop
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop _A)) =>
                  cic.univ (cic.type (cic.s (cic.s (cic.s cic.z))))))
              (Q_ :
                 cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                   (cic.prod cic.prop
                      (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop _A))
                      (_x_88 :
                         cic.Term cic.prop
                           (matita_basics_logic.Not
                              (cic.lift cic.prop cic.prop _A)) =>
                       cic.univ (cic.type (cic.s (cic.s (cic.s cic.z)))))) =>
               cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
                 (cic.type (cic.s (cic.s (cic.s cic.z))))
                 (cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
                    (cic.prod cic.prop cic.prop _A
                       (__ : cic.Term cic.prop _A =>
                        matita_basics_logic.False))
                    (x_89 :
                       cic.Term cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False)) =>
                     Q_
                       (matita_basics_logic.nmk
                          (cic.lift cic.prop cic.prop _A) x_89)))
                 (_H_nmk :
                    cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                      (cic.prod cic.prop
                         (cic.type (cic.s (cic.s (cic.s cic.z))))
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False))
                         (x_89 :
                            cic.Term cic.prop
                              (cic.prod cic.prop cic.prop _A
                                 (__ : cic.Term cic.prop _A =>
                                  matita_basics_logic.False)) =>
                          Q_
                            (matita_basics_logic.nmk
                               (cic.lift cic.prop cic.prop _A) x_89))) =>
                  cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
                    (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A))
                    (x_88 :
                       cic.Term cic.prop
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop _A)) =>
                     Q_ x_88))))).

[ _A, Q_, _H_nmk, x_88 ] Not_rect_Type3 _A Q_ _H_nmk x_88 -->
  matita_basics_logic.filter_Not_Type3 _A
    (x_88 :
       cic.Term cic.prop
         (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A)) =>
     Q_ x_88)
    (matita_basics_logic.Not_rect_Type3_body _A Q_ _H_nmk) x_88.

[ _A, Q_, _H_nmk, x_88 ] Not_rect_Type3_body _A Q_ _H_nmk x_88 -->
  matita_basics_logic.match_Not_Type3 (cic.lift cic.prop cic.prop _A) Q_
    (x_89 :
       cic.Term cic.prop
         (cic.prod cic.prop cic.prop _A
            (__ : cic.Term cic.prop _A => matita_basics_logic.False)) =>
     _H_nmk x_89)
    x_88.

def Not_rect_Type2 :
      cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
        (cic.prod (cic.type cic.z) (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
              (cic.type (cic.s (cic.s cic.z)))
              (cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
                 (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A))
                 (_x_91 :
                    cic.Term cic.prop
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop _A)) =>
                  cic.univ (cic.type (cic.s (cic.s cic.z)))))
              (Q_ :
                 cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                   (cic.prod cic.prop
                      (cic.type (cic.s (cic.s (cic.s cic.z))))
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop _A))
                      (_x_91 :
                         cic.Term cic.prop
                           (matita_basics_logic.Not
                              (cic.lift cic.prop cic.prop _A)) =>
                       cic.univ (cic.type (cic.s (cic.s cic.z))))) =>
               cic.prod (cic.type (cic.s (cic.s cic.z)))
                 (cic.type (cic.s (cic.s cic.z)))
                 (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (cic.prod cic.prop cic.prop _A
                       (__ : cic.Term cic.prop _A =>
                        matita_basics_logic.False))
                    (x_92 :
                       cic.Term cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False)) =>
                     Q_
                       (matita_basics_logic.nmk
                          (cic.lift cic.prop cic.prop _A) x_92)))
                 (_H_nmk :
                    cic.Term (cic.type (cic.s (cic.s cic.z)))
                      (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False))
                         (x_92 :
                            cic.Term cic.prop
                              (cic.prod cic.prop cic.prop _A
                                 (__ : cic.Term cic.prop _A =>
                                  matita_basics_logic.False)) =>
                          Q_
                            (matita_basics_logic.nmk
                               (cic.lift cic.prop cic.prop _A) x_92))) =>
                  cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A))
                    (x_91 :
                       cic.Term cic.prop
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop _A)) =>
                     Q_ x_91))))).

def Not_rect_Type2_body :
      cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
        (cic.prod (cic.type cic.z) (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
              (cic.type (cic.s (cic.s cic.z)))
              (cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
                 (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A))
                 (_x_91 :
                    cic.Term cic.prop
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop _A)) =>
                  cic.univ (cic.type (cic.s (cic.s cic.z)))))
              (Q_ :
                 cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                   (cic.prod cic.prop
                      (cic.type (cic.s (cic.s (cic.s cic.z))))
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop _A))
                      (_x_91 :
                         cic.Term cic.prop
                           (matita_basics_logic.Not
                              (cic.lift cic.prop cic.prop _A)) =>
                       cic.univ (cic.type (cic.s (cic.s cic.z))))) =>
               cic.prod (cic.type (cic.s (cic.s cic.z)))
                 (cic.type (cic.s (cic.s cic.z)))
                 (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (cic.prod cic.prop cic.prop _A
                       (__ : cic.Term cic.prop _A =>
                        matita_basics_logic.False))
                    (x_92 :
                       cic.Term cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False)) =>
                     Q_
                       (matita_basics_logic.nmk
                          (cic.lift cic.prop cic.prop _A) x_92)))
                 (_H_nmk :
                    cic.Term (cic.type (cic.s (cic.s cic.z)))
                      (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False))
                         (x_92 :
                            cic.Term cic.prop
                              (cic.prod cic.prop cic.prop _A
                                 (__ : cic.Term cic.prop _A =>
                                  matita_basics_logic.False)) =>
                          Q_
                            (matita_basics_logic.nmk
                               (cic.lift cic.prop cic.prop _A) x_92))) =>
                  cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A))
                    (x_91 :
                       cic.Term cic.prop
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop _A)) =>
                     Q_ x_91))))).

[ _A, Q_, _H_nmk, x_91 ] Not_rect_Type2 _A Q_ _H_nmk x_91 -->
  matita_basics_logic.filter_Not_Type2 _A
    (x_91 :
       cic.Term cic.prop
         (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A)) =>
     Q_ x_91)
    (matita_basics_logic.Not_rect_Type2_body _A Q_ _H_nmk) x_91.

[ _A, Q_, _H_nmk, x_91 ] Not_rect_Type2_body _A Q_ _H_nmk x_91 -->
  matita_basics_logic.match_Not_Type2 (cic.lift cic.prop cic.prop _A) Q_
    (x_92 :
       cic.Term cic.prop
         (cic.prod cic.prop cic.prop _A
            (__ : cic.Term cic.prop _A => matita_basics_logic.False)) =>
     _H_nmk x_92)
    x_91.

def Not_rect_Type1 :
      cic.Term (cic.type (cic.s (cic.s cic.z)))
        (cic.prod (cic.type cic.z) (cic.type (cic.s (cic.s cic.z)))
           (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s cic.z))
              (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                 (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A))
                 (_x_94 :
                    cic.Term cic.prop
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop _A)) =>
                  cic.univ (cic.type (cic.s cic.z))))
              (Q_ :
                 cic.Term (cic.type (cic.s (cic.s cic.z)))
                   (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop _A))
                      (_x_94 :
                         cic.Term cic.prop
                           (matita_basics_logic.Not
                              (cic.lift cic.prop cic.prop _A)) =>
                       cic.univ (cic.type (cic.s cic.z)))) =>
               cic.prod (cic.type (cic.s cic.z)) (cic.type (cic.s cic.z))
                 (cic.prod cic.prop (cic.type (cic.s cic.z))
                    (cic.prod cic.prop cic.prop _A
                       (__ : cic.Term cic.prop _A =>
                        matita_basics_logic.False))
                    (x_95 :
                       cic.Term cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False)) =>
                     Q_
                       (matita_basics_logic.nmk
                          (cic.lift cic.prop cic.prop _A) x_95)))
                 (_H_nmk :
                    cic.Term (cic.type (cic.s cic.z))
                      (cic.prod cic.prop (cic.type (cic.s cic.z))
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False))
                         (x_95 :
                            cic.Term cic.prop
                              (cic.prod cic.prop cic.prop _A
                                 (__ : cic.Term cic.prop _A =>
                                  matita_basics_logic.False)) =>
                          Q_
                            (matita_basics_logic.nmk
                               (cic.lift cic.prop cic.prop _A) x_95))) =>
                  cic.prod cic.prop (cic.type (cic.s cic.z))
                    (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A))
                    (x_94 :
                       cic.Term cic.prop
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop _A)) =>
                     Q_ x_94))))).

def Not_rect_Type1_body :
      cic.Term (cic.type (cic.s (cic.s cic.z)))
        (cic.prod (cic.type cic.z) (cic.type (cic.s (cic.s cic.z)))
           (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s cic.z))
              (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                 (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A))
                 (_x_94 :
                    cic.Term cic.prop
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop _A)) =>
                  cic.univ (cic.type (cic.s cic.z))))
              (Q_ :
                 cic.Term (cic.type (cic.s (cic.s cic.z)))
                   (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop _A))
                      (_x_94 :
                         cic.Term cic.prop
                           (matita_basics_logic.Not
                              (cic.lift cic.prop cic.prop _A)) =>
                       cic.univ (cic.type (cic.s cic.z)))) =>
               cic.prod (cic.type (cic.s cic.z)) (cic.type (cic.s cic.z))
                 (cic.prod cic.prop (cic.type (cic.s cic.z))
                    (cic.prod cic.prop cic.prop _A
                       (__ : cic.Term cic.prop _A =>
                        matita_basics_logic.False))
                    (x_95 :
                       cic.Term cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False)) =>
                     Q_
                       (matita_basics_logic.nmk
                          (cic.lift cic.prop cic.prop _A) x_95)))
                 (_H_nmk :
                    cic.Term (cic.type (cic.s cic.z))
                      (cic.prod cic.prop (cic.type (cic.s cic.z))
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False))
                         (x_95 :
                            cic.Term cic.prop
                              (cic.prod cic.prop cic.prop _A
                                 (__ : cic.Term cic.prop _A =>
                                  matita_basics_logic.False)) =>
                          Q_
                            (matita_basics_logic.nmk
                               (cic.lift cic.prop cic.prop _A) x_95))) =>
                  cic.prod cic.prop (cic.type (cic.s cic.z))
                    (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A))
                    (x_94 :
                       cic.Term cic.prop
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop _A)) =>
                     Q_ x_94))))).

[ _A, Q_, _H_nmk, x_94 ] Not_rect_Type1 _A Q_ _H_nmk x_94 -->
  matita_basics_logic.filter_Not_Type1 _A
    (x_94 :
       cic.Term cic.prop
         (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A)) =>
     Q_ x_94)
    (matita_basics_logic.Not_rect_Type1_body _A Q_ _H_nmk) x_94.

[ _A, Q_, _H_nmk, x_94 ] Not_rect_Type1_body _A Q_ _H_nmk x_94 -->
  matita_basics_logic.match_Not_Type1 (cic.lift cic.prop cic.prop _A) Q_
    (x_95 :
       cic.Term cic.prop
         (cic.prod cic.prop cic.prop _A
            (__ : cic.Term cic.prop _A => matita_basics_logic.False)) =>
     _H_nmk x_95)
    x_94.

def Not_rect_Type0 :
      cic.Term (cic.type (cic.s cic.z))
        (cic.prod (cic.type cic.z) (cic.type (cic.s cic.z))
           (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type (cic.s cic.z)) (cic.type cic.z)
              (cic.prod cic.prop (cic.type (cic.s cic.z))
                 (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A))
                 (_x_97 :
                    cic.Term cic.prop
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop _A)) =>
                  cic.univ (cic.type cic.z)))
              (Q_ :
                 cic.Term (cic.type (cic.s cic.z))
                   (cic.prod cic.prop (cic.type (cic.s cic.z))
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop _A))
                      (_x_97 :
                         cic.Term cic.prop
                           (matita_basics_logic.Not
                              (cic.lift cic.prop cic.prop _A)) =>
                       cic.univ (cic.type cic.z))) =>
               cic.prod (cic.type cic.z) (cic.type cic.z)
                 (cic.prod cic.prop (cic.type cic.z)
                    (cic.prod cic.prop cic.prop _A
                       (__ : cic.Term cic.prop _A =>
                        matita_basics_logic.False))
                    (x_98 :
                       cic.Term cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False)) =>
                     Q_
                       (matita_basics_logic.nmk
                          (cic.lift cic.prop cic.prop _A) x_98)))
                 (_H_nmk :
                    cic.Term (cic.type cic.z)
                      (cic.prod cic.prop (cic.type cic.z)
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False))
                         (x_98 :
                            cic.Term cic.prop
                              (cic.prod cic.prop cic.prop _A
                                 (__ : cic.Term cic.prop _A =>
                                  matita_basics_logic.False)) =>
                          Q_
                            (matita_basics_logic.nmk
                               (cic.lift cic.prop cic.prop _A) x_98))) =>
                  cic.prod cic.prop (cic.type cic.z)
                    (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A))
                    (x_97 :
                       cic.Term cic.prop
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop _A)) =>
                     Q_ x_97))))).

def Not_rect_Type0_body :
      cic.Term (cic.type (cic.s cic.z))
        (cic.prod (cic.type cic.z) (cic.type (cic.s cic.z))
           (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type (cic.s cic.z)) (cic.type cic.z)
              (cic.prod cic.prop (cic.type (cic.s cic.z))
                 (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A))
                 (_x_97 :
                    cic.Term cic.prop
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop _A)) =>
                  cic.univ (cic.type cic.z)))
              (Q_ :
                 cic.Term (cic.type (cic.s cic.z))
                   (cic.prod cic.prop (cic.type (cic.s cic.z))
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop _A))
                      (_x_97 :
                         cic.Term cic.prop
                           (matita_basics_logic.Not
                              (cic.lift cic.prop cic.prop _A)) =>
                       cic.univ (cic.type cic.z))) =>
               cic.prod (cic.type cic.z) (cic.type cic.z)
                 (cic.prod cic.prop (cic.type cic.z)
                    (cic.prod cic.prop cic.prop _A
                       (__ : cic.Term cic.prop _A =>
                        matita_basics_logic.False))
                    (x_98 :
                       cic.Term cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False)) =>
                     Q_
                       (matita_basics_logic.nmk
                          (cic.lift cic.prop cic.prop _A) x_98)))
                 (_H_nmk :
                    cic.Term (cic.type cic.z)
                      (cic.prod cic.prop (cic.type cic.z)
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False))
                         (x_98 :
                            cic.Term cic.prop
                              (cic.prod cic.prop cic.prop _A
                                 (__ : cic.Term cic.prop _A =>
                                  matita_basics_logic.False)) =>
                          Q_
                            (matita_basics_logic.nmk
                               (cic.lift cic.prop cic.prop _A) x_98))) =>
                  cic.prod cic.prop (cic.type cic.z)
                    (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A))
                    (x_97 :
                       cic.Term cic.prop
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop _A)) =>
                     Q_ x_97))))).

[ _A, Q_, _H_nmk, x_97 ] Not_rect_Type0 _A Q_ _H_nmk x_97 -->
  matita_basics_logic.filter_Not_Type0 _A
    (x_97 :
       cic.Term cic.prop
         (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A)) =>
     Q_ x_97)
    (matita_basics_logic.Not_rect_Type0_body _A Q_ _H_nmk) x_97.

[ _A, Q_, _H_nmk, x_97 ] Not_rect_Type0_body _A Q_ _H_nmk x_97 -->
  matita_basics_logic.match_Not_Type0 (cic.lift cic.prop cic.prop _A) Q_
    (x_98 :
       cic.Term cic.prop
         (cic.prod cic.prop cic.prop _A
            (__ : cic.Term cic.prop _A => matita_basics_logic.False)) =>
     _H_nmk x_98)
    x_97.

def Not_rect_CProp4 :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) cic.prop
              (cic.prod cic.prop (cic.type cic.z)
                 (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A))
                 (_x_100 :
                    cic.Term cic.prop
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop _A)) =>
                  cic.univ cic.prop))
              (Q_ :
                 cic.Term (cic.type cic.z)
                   (cic.prod cic.prop (cic.type cic.z)
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop _A))
                      (_x_100 :
                         cic.Term cic.prop
                           (matita_basics_logic.Not
                              (cic.lift cic.prop cic.prop _A)) =>
                       cic.univ cic.prop)) =>
               cic.prod cic.prop cic.prop
                 (cic.prod cic.prop cic.prop
                    (cic.prod cic.prop cic.prop _A
                       (__ : cic.Term cic.prop _A =>
                        matita_basics_logic.False))
                    (x_101 :
                       cic.Term cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False)) =>
                     Q_
                       (matita_basics_logic.nmk
                          (cic.lift cic.prop cic.prop _A) x_101)))
                 (_H_nmk :
                    cic.Term cic.prop
                      (cic.prod cic.prop cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False))
                         (x_101 :
                            cic.Term cic.prop
                              (cic.prod cic.prop cic.prop _A
                                 (__ : cic.Term cic.prop _A =>
                                  matita_basics_logic.False)) =>
                          Q_
                            (matita_basics_logic.nmk
                               (cic.lift cic.prop cic.prop _A) x_101))) =>
                  cic.prod cic.prop cic.prop
                    (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A))
                    (x_100 :
                       cic.Term cic.prop
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop _A)) =>
                     Q_ x_100))))).

def Not_rect_CProp4_body :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) cic.prop
              (cic.prod cic.prop (cic.type cic.z)
                 (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A))
                 (_x_100 :
                    cic.Term cic.prop
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop _A)) =>
                  cic.univ cic.prop))
              (Q_ :
                 cic.Term (cic.type cic.z)
                   (cic.prod cic.prop (cic.type cic.z)
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop _A))
                      (_x_100 :
                         cic.Term cic.prop
                           (matita_basics_logic.Not
                              (cic.lift cic.prop cic.prop _A)) =>
                       cic.univ cic.prop)) =>
               cic.prod cic.prop cic.prop
                 (cic.prod cic.prop cic.prop
                    (cic.prod cic.prop cic.prop _A
                       (__ : cic.Term cic.prop _A =>
                        matita_basics_logic.False))
                    (x_101 :
                       cic.Term cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False)) =>
                     Q_
                       (matita_basics_logic.nmk
                          (cic.lift cic.prop cic.prop _A) x_101)))
                 (_H_nmk :
                    cic.Term cic.prop
                      (cic.prod cic.prop cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False))
                         (x_101 :
                            cic.Term cic.prop
                              (cic.prod cic.prop cic.prop _A
                                 (__ : cic.Term cic.prop _A =>
                                  matita_basics_logic.False)) =>
                          Q_
                            (matita_basics_logic.nmk
                               (cic.lift cic.prop cic.prop _A) x_101))) =>
                  cic.prod cic.prop cic.prop
                    (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A))
                    (x_100 :
                       cic.Term cic.prop
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop _A)) =>
                     Q_ x_100))))).

[ _A, Q_, _H_nmk, x_100 ] Not_rect_CProp4 _A Q_ _H_nmk x_100 -->
  matita_basics_logic.filter_Not_Prop _A
    (x_100 :
       cic.Term cic.prop
         (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A)) =>
     Q_ x_100)
    (matita_basics_logic.Not_rect_CProp4_body _A Q_ _H_nmk) x_100.

[ _A, Q_, _H_nmk, x_100 ] Not_rect_CProp4_body _A Q_ _H_nmk x_100 -->
  matita_basics_logic.match_Not_Prop (cic.lift cic.prop cic.prop _A) Q_
    (x_101 :
       cic.Term cic.prop
         (cic.prod cic.prop cic.prop _A
            (__ : cic.Term cic.prop _A => matita_basics_logic.False)) =>
     _H_nmk x_101)
    x_100.

def Not_rect_CProp5 :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) cic.prop
              (cic.prod cic.prop (cic.type cic.z)
                 (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A))
                 (_x_103 :
                    cic.Term cic.prop
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop _A)) =>
                  cic.univ cic.prop))
              (Q_ :
                 cic.Term (cic.type cic.z)
                   (cic.prod cic.prop (cic.type cic.z)
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop _A))
                      (_x_103 :
                         cic.Term cic.prop
                           (matita_basics_logic.Not
                              (cic.lift cic.prop cic.prop _A)) =>
                       cic.univ cic.prop)) =>
               cic.prod cic.prop cic.prop
                 (cic.prod cic.prop cic.prop
                    (cic.prod cic.prop cic.prop _A
                       (__ : cic.Term cic.prop _A =>
                        matita_basics_logic.False))
                    (x_104 :
                       cic.Term cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False)) =>
                     Q_
                       (matita_basics_logic.nmk
                          (cic.lift cic.prop cic.prop _A) x_104)))
                 (_H_nmk :
                    cic.Term cic.prop
                      (cic.prod cic.prop cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False))
                         (x_104 :
                            cic.Term cic.prop
                              (cic.prod cic.prop cic.prop _A
                                 (__ : cic.Term cic.prop _A =>
                                  matita_basics_logic.False)) =>
                          Q_
                            (matita_basics_logic.nmk
                               (cic.lift cic.prop cic.prop _A) x_104))) =>
                  cic.prod cic.prop cic.prop
                    (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A))
                    (x_103 :
                       cic.Term cic.prop
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop _A)) =>
                     Q_ x_103))))).

def Not_rect_CProp5_body :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) cic.prop
              (cic.prod cic.prop (cic.type cic.z)
                 (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A))
                 (_x_103 :
                    cic.Term cic.prop
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop _A)) =>
                  cic.univ cic.prop))
              (Q_ :
                 cic.Term (cic.type cic.z)
                   (cic.prod cic.prop (cic.type cic.z)
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop _A))
                      (_x_103 :
                         cic.Term cic.prop
                           (matita_basics_logic.Not
                              (cic.lift cic.prop cic.prop _A)) =>
                       cic.univ cic.prop)) =>
               cic.prod cic.prop cic.prop
                 (cic.prod cic.prop cic.prop
                    (cic.prod cic.prop cic.prop _A
                       (__ : cic.Term cic.prop _A =>
                        matita_basics_logic.False))
                    (x_104 :
                       cic.Term cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False)) =>
                     Q_
                       (matita_basics_logic.nmk
                          (cic.lift cic.prop cic.prop _A) x_104)))
                 (_H_nmk :
                    cic.Term cic.prop
                      (cic.prod cic.prop cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False))
                         (x_104 :
                            cic.Term cic.prop
                              (cic.prod cic.prop cic.prop _A
                                 (__ : cic.Term cic.prop _A =>
                                  matita_basics_logic.False)) =>
                          Q_
                            (matita_basics_logic.nmk
                               (cic.lift cic.prop cic.prop _A) x_104))) =>
                  cic.prod cic.prop cic.prop
                    (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A))
                    (x_103 :
                       cic.Term cic.prop
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop _A)) =>
                     Q_ x_103))))).

[ _A, Q_, _H_nmk, x_103 ] Not_rect_CProp5 _A Q_ _H_nmk x_103 -->
  matita_basics_logic.filter_Not_Prop _A
    (x_103 :
       cic.Term cic.prop
         (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A)) =>
     Q_ x_103)
    (matita_basics_logic.Not_rect_CProp5_body _A Q_ _H_nmk) x_103.

[ _A, Q_, _H_nmk, x_103 ] Not_rect_CProp5_body _A Q_ _H_nmk x_103 -->
  matita_basics_logic.match_Not_Prop (cic.lift cic.prop cic.prop _A) Q_
    (x_104 :
       cic.Term cic.prop
         (cic.prod cic.prop cic.prop _A
            (__ : cic.Term cic.prop _A => matita_basics_logic.False)) =>
     _H_nmk x_104)
    x_103.

def Not_rect_CProp3 :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) cic.prop
              (cic.prod cic.prop (cic.type cic.z)
                 (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A))
                 (_x_106 :
                    cic.Term cic.prop
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop _A)) =>
                  cic.univ cic.prop))
              (Q_ :
                 cic.Term (cic.type cic.z)
                   (cic.prod cic.prop (cic.type cic.z)
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop _A))
                      (_x_106 :
                         cic.Term cic.prop
                           (matita_basics_logic.Not
                              (cic.lift cic.prop cic.prop _A)) =>
                       cic.univ cic.prop)) =>
               cic.prod cic.prop cic.prop
                 (cic.prod cic.prop cic.prop
                    (cic.prod cic.prop cic.prop _A
                       (__ : cic.Term cic.prop _A =>
                        matita_basics_logic.False))
                    (x_107 :
                       cic.Term cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False)) =>
                     Q_
                       (matita_basics_logic.nmk
                          (cic.lift cic.prop cic.prop _A) x_107)))
                 (_H_nmk :
                    cic.Term cic.prop
                      (cic.prod cic.prop cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False))
                         (x_107 :
                            cic.Term cic.prop
                              (cic.prod cic.prop cic.prop _A
                                 (__ : cic.Term cic.prop _A =>
                                  matita_basics_logic.False)) =>
                          Q_
                            (matita_basics_logic.nmk
                               (cic.lift cic.prop cic.prop _A) x_107))) =>
                  cic.prod cic.prop cic.prop
                    (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A))
                    (x_106 :
                       cic.Term cic.prop
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop _A)) =>
                     Q_ x_106))))).

def Not_rect_CProp3_body :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) cic.prop
              (cic.prod cic.prop (cic.type cic.z)
                 (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A))
                 (_x_106 :
                    cic.Term cic.prop
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop _A)) =>
                  cic.univ cic.prop))
              (Q_ :
                 cic.Term (cic.type cic.z)
                   (cic.prod cic.prop (cic.type cic.z)
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop _A))
                      (_x_106 :
                         cic.Term cic.prop
                           (matita_basics_logic.Not
                              (cic.lift cic.prop cic.prop _A)) =>
                       cic.univ cic.prop)) =>
               cic.prod cic.prop cic.prop
                 (cic.prod cic.prop cic.prop
                    (cic.prod cic.prop cic.prop _A
                       (__ : cic.Term cic.prop _A =>
                        matita_basics_logic.False))
                    (x_107 :
                       cic.Term cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False)) =>
                     Q_
                       (matita_basics_logic.nmk
                          (cic.lift cic.prop cic.prop _A) x_107)))
                 (_H_nmk :
                    cic.Term cic.prop
                      (cic.prod cic.prop cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False))
                         (x_107 :
                            cic.Term cic.prop
                              (cic.prod cic.prop cic.prop _A
                                 (__ : cic.Term cic.prop _A =>
                                  matita_basics_logic.False)) =>
                          Q_
                            (matita_basics_logic.nmk
                               (cic.lift cic.prop cic.prop _A) x_107))) =>
                  cic.prod cic.prop cic.prop
                    (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A))
                    (x_106 :
                       cic.Term cic.prop
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop _A)) =>
                     Q_ x_106))))).

[ _A, Q_, _H_nmk, x_106 ] Not_rect_CProp3 _A Q_ _H_nmk x_106 -->
  matita_basics_logic.filter_Not_Prop _A
    (x_106 :
       cic.Term cic.prop
         (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A)) =>
     Q_ x_106)
    (matita_basics_logic.Not_rect_CProp3_body _A Q_ _H_nmk) x_106.

[ _A, Q_, _H_nmk, x_106 ] Not_rect_CProp3_body _A Q_ _H_nmk x_106 -->
  matita_basics_logic.match_Not_Prop (cic.lift cic.prop cic.prop _A) Q_
    (x_107 :
       cic.Term cic.prop
         (cic.prod cic.prop cic.prop _A
            (__ : cic.Term cic.prop _A => matita_basics_logic.False)) =>
     _H_nmk x_107)
    x_106.

def Not_rect_CProp2 :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) cic.prop
              (cic.prod cic.prop (cic.type cic.z)
                 (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A))
                 (_x_109 :
                    cic.Term cic.prop
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop _A)) =>
                  cic.univ cic.prop))
              (Q_ :
                 cic.Term (cic.type cic.z)
                   (cic.prod cic.prop (cic.type cic.z)
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop _A))
                      (_x_109 :
                         cic.Term cic.prop
                           (matita_basics_logic.Not
                              (cic.lift cic.prop cic.prop _A)) =>
                       cic.univ cic.prop)) =>
               cic.prod cic.prop cic.prop
                 (cic.prod cic.prop cic.prop
                    (cic.prod cic.prop cic.prop _A
                       (__ : cic.Term cic.prop _A =>
                        matita_basics_logic.False))
                    (x_110 :
                       cic.Term cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False)) =>
                     Q_
                       (matita_basics_logic.nmk
                          (cic.lift cic.prop cic.prop _A) x_110)))
                 (_H_nmk :
                    cic.Term cic.prop
                      (cic.prod cic.prop cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False))
                         (x_110 :
                            cic.Term cic.prop
                              (cic.prod cic.prop cic.prop _A
                                 (__ : cic.Term cic.prop _A =>
                                  matita_basics_logic.False)) =>
                          Q_
                            (matita_basics_logic.nmk
                               (cic.lift cic.prop cic.prop _A) x_110))) =>
                  cic.prod cic.prop cic.prop
                    (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A))
                    (x_109 :
                       cic.Term cic.prop
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop _A)) =>
                     Q_ x_109))))).

def Not_rect_CProp2_body :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) cic.prop
              (cic.prod cic.prop (cic.type cic.z)
                 (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A))
                 (_x_109 :
                    cic.Term cic.prop
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop _A)) =>
                  cic.univ cic.prop))
              (Q_ :
                 cic.Term (cic.type cic.z)
                   (cic.prod cic.prop (cic.type cic.z)
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop _A))
                      (_x_109 :
                         cic.Term cic.prop
                           (matita_basics_logic.Not
                              (cic.lift cic.prop cic.prop _A)) =>
                       cic.univ cic.prop)) =>
               cic.prod cic.prop cic.prop
                 (cic.prod cic.prop cic.prop
                    (cic.prod cic.prop cic.prop _A
                       (__ : cic.Term cic.prop _A =>
                        matita_basics_logic.False))
                    (x_110 :
                       cic.Term cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False)) =>
                     Q_
                       (matita_basics_logic.nmk
                          (cic.lift cic.prop cic.prop _A) x_110)))
                 (_H_nmk :
                    cic.Term cic.prop
                      (cic.prod cic.prop cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False))
                         (x_110 :
                            cic.Term cic.prop
                              (cic.prod cic.prop cic.prop _A
                                 (__ : cic.Term cic.prop _A =>
                                  matita_basics_logic.False)) =>
                          Q_
                            (matita_basics_logic.nmk
                               (cic.lift cic.prop cic.prop _A) x_110))) =>
                  cic.prod cic.prop cic.prop
                    (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A))
                    (x_109 :
                       cic.Term cic.prop
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop _A)) =>
                     Q_ x_109))))).

[ _A, Q_, _H_nmk, x_109 ] Not_rect_CProp2 _A Q_ _H_nmk x_109 -->
  matita_basics_logic.filter_Not_Prop _A
    (x_109 :
       cic.Term cic.prop
         (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A)) =>
     Q_ x_109)
    (matita_basics_logic.Not_rect_CProp2_body _A Q_ _H_nmk) x_109.

[ _A, Q_, _H_nmk, x_109 ] Not_rect_CProp2_body _A Q_ _H_nmk x_109 -->
  matita_basics_logic.match_Not_Prop (cic.lift cic.prop cic.prop _A) Q_
    (x_110 :
       cic.Term cic.prop
         (cic.prod cic.prop cic.prop _A
            (__ : cic.Term cic.prop _A => matita_basics_logic.False)) =>
     _H_nmk x_110)
    x_109.

def Not_rect_CProp1 :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) cic.prop
              (cic.prod cic.prop (cic.type cic.z)
                 (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A))
                 (_x_112 :
                    cic.Term cic.prop
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop _A)) =>
                  cic.univ cic.prop))
              (Q_ :
                 cic.Term (cic.type cic.z)
                   (cic.prod cic.prop (cic.type cic.z)
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop _A))
                      (_x_112 :
                         cic.Term cic.prop
                           (matita_basics_logic.Not
                              (cic.lift cic.prop cic.prop _A)) =>
                       cic.univ cic.prop)) =>
               cic.prod cic.prop cic.prop
                 (cic.prod cic.prop cic.prop
                    (cic.prod cic.prop cic.prop _A
                       (__ : cic.Term cic.prop _A =>
                        matita_basics_logic.False))
                    (x_113 :
                       cic.Term cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False)) =>
                     Q_
                       (matita_basics_logic.nmk
                          (cic.lift cic.prop cic.prop _A) x_113)))
                 (_H_nmk :
                    cic.Term cic.prop
                      (cic.prod cic.prop cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False))
                         (x_113 :
                            cic.Term cic.prop
                              (cic.prod cic.prop cic.prop _A
                                 (__ : cic.Term cic.prop _A =>
                                  matita_basics_logic.False)) =>
                          Q_
                            (matita_basics_logic.nmk
                               (cic.lift cic.prop cic.prop _A) x_113))) =>
                  cic.prod cic.prop cic.prop
                    (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A))
                    (x_112 :
                       cic.Term cic.prop
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop _A)) =>
                     Q_ x_112))))).

def Not_rect_CProp1_body :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) cic.prop
              (cic.prod cic.prop (cic.type cic.z)
                 (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A))
                 (_x_112 :
                    cic.Term cic.prop
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop _A)) =>
                  cic.univ cic.prop))
              (Q_ :
                 cic.Term (cic.type cic.z)
                   (cic.prod cic.prop (cic.type cic.z)
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop _A))
                      (_x_112 :
                         cic.Term cic.prop
                           (matita_basics_logic.Not
                              (cic.lift cic.prop cic.prop _A)) =>
                       cic.univ cic.prop)) =>
               cic.prod cic.prop cic.prop
                 (cic.prod cic.prop cic.prop
                    (cic.prod cic.prop cic.prop _A
                       (__ : cic.Term cic.prop _A =>
                        matita_basics_logic.False))
                    (x_113 :
                       cic.Term cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False)) =>
                     Q_
                       (matita_basics_logic.nmk
                          (cic.lift cic.prop cic.prop _A) x_113)))
                 (_H_nmk :
                    cic.Term cic.prop
                      (cic.prod cic.prop cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False))
                         (x_113 :
                            cic.Term cic.prop
                              (cic.prod cic.prop cic.prop _A
                                 (__ : cic.Term cic.prop _A =>
                                  matita_basics_logic.False)) =>
                          Q_
                            (matita_basics_logic.nmk
                               (cic.lift cic.prop cic.prop _A) x_113))) =>
                  cic.prod cic.prop cic.prop
                    (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A))
                    (x_112 :
                       cic.Term cic.prop
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop _A)) =>
                     Q_ x_112))))).

[ _A, Q_, _H_nmk, x_112 ] Not_rect_CProp1 _A Q_ _H_nmk x_112 -->
  matita_basics_logic.filter_Not_Prop _A
    (x_112 :
       cic.Term cic.prop
         (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A)) =>
     Q_ x_112)
    (matita_basics_logic.Not_rect_CProp1_body _A Q_ _H_nmk) x_112.

[ _A, Q_, _H_nmk, x_112 ] Not_rect_CProp1_body _A Q_ _H_nmk x_112 -->
  matita_basics_logic.match_Not_Prop (cic.lift cic.prop cic.prop _A) Q_
    (x_113 :
       cic.Term cic.prop
         (cic.prod cic.prop cic.prop _A
            (__ : cic.Term cic.prop _A => matita_basics_logic.False)) =>
     _H_nmk x_113)
    x_112.

def Not_rect_CProp0 :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) cic.prop
              (cic.prod cic.prop (cic.type cic.z)
                 (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A))
                 (_x_115 :
                    cic.Term cic.prop
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop _A)) =>
                  cic.univ cic.prop))
              (Q_ :
                 cic.Term (cic.type cic.z)
                   (cic.prod cic.prop (cic.type cic.z)
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop _A))
                      (_x_115 :
                         cic.Term cic.prop
                           (matita_basics_logic.Not
                              (cic.lift cic.prop cic.prop _A)) =>
                       cic.univ cic.prop)) =>
               cic.prod cic.prop cic.prop
                 (cic.prod cic.prop cic.prop
                    (cic.prod cic.prop cic.prop _A
                       (__ : cic.Term cic.prop _A =>
                        matita_basics_logic.False))
                    (x_116 :
                       cic.Term cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False)) =>
                     Q_
                       (matita_basics_logic.nmk
                          (cic.lift cic.prop cic.prop _A) x_116)))
                 (_H_nmk :
                    cic.Term cic.prop
                      (cic.prod cic.prop cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False))
                         (x_116 :
                            cic.Term cic.prop
                              (cic.prod cic.prop cic.prop _A
                                 (__ : cic.Term cic.prop _A =>
                                  matita_basics_logic.False)) =>
                          Q_
                            (matita_basics_logic.nmk
                               (cic.lift cic.prop cic.prop _A) x_116))) =>
                  cic.prod cic.prop cic.prop
                    (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A))
                    (x_115 :
                       cic.Term cic.prop
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop _A)) =>
                     Q_ x_115))))).

def Not_rect_CProp0_body :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) cic.prop
              (cic.prod cic.prop (cic.type cic.z)
                 (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A))
                 (_x_115 :
                    cic.Term cic.prop
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop _A)) =>
                  cic.univ cic.prop))
              (Q_ :
                 cic.Term (cic.type cic.z)
                   (cic.prod cic.prop (cic.type cic.z)
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop _A))
                      (_x_115 :
                         cic.Term cic.prop
                           (matita_basics_logic.Not
                              (cic.lift cic.prop cic.prop _A)) =>
                       cic.univ cic.prop)) =>
               cic.prod cic.prop cic.prop
                 (cic.prod cic.prop cic.prop
                    (cic.prod cic.prop cic.prop _A
                       (__ : cic.Term cic.prop _A =>
                        matita_basics_logic.False))
                    (x_116 :
                       cic.Term cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False)) =>
                     Q_
                       (matita_basics_logic.nmk
                          (cic.lift cic.prop cic.prop _A) x_116)))
                 (_H_nmk :
                    cic.Term cic.prop
                      (cic.prod cic.prop cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             matita_basics_logic.False))
                         (x_116 :
                            cic.Term cic.prop
                              (cic.prod cic.prop cic.prop _A
                                 (__ : cic.Term cic.prop _A =>
                                  matita_basics_logic.False)) =>
                          Q_
                            (matita_basics_logic.nmk
                               (cic.lift cic.prop cic.prop _A) x_116))) =>
                  cic.prod cic.prop cic.prop
                    (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A))
                    (x_115 :
                       cic.Term cic.prop
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop _A)) =>
                     Q_ x_115))))).

[ _A, Q_, _H_nmk, x_115 ] Not_rect_CProp0 _A Q_ _H_nmk x_115 -->
  matita_basics_logic.filter_Not_Prop _A
    (x_115 :
       cic.Term cic.prop
         (matita_basics_logic.Not (cic.lift cic.prop cic.prop _A)) =>
     Q_ x_115)
    (matita_basics_logic.Not_rect_CProp0_body _A Q_ _H_nmk) x_115.

[ _A, Q_, _H_nmk, x_115 ] Not_rect_CProp0_body _A Q_ _H_nmk x_115 -->
  matita_basics_logic.match_Not_Prop (cic.lift cic.prop cic.prop _A) Q_
    (x_116 :
       cic.Term cic.prop
         (cic.prod cic.prop cic.prop _A
            (__ : cic.Term cic.prop _A => matita_basics_logic.False)) =>
     _H_nmk x_116)
    x_115.

def Not_inv_ind :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
           (x1 : cic.Univ cic.prop =>
            cic.prod cic.prop cic.prop
              (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1))
              (Hterm :
                 cic.Term cic.prop
                   (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)) =>
               cic.prod (cic.type cic.z) cic.prop
                 (cic.prod cic.prop (cic.type cic.z)
                    (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1))
                    (_z257 :
                       cic.Term cic.prop
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop x1)) =>
                     cic.univ cic.prop))
                 (P :
                    cic.Term (cic.type cic.z)
                      (cic.prod cic.prop (cic.type cic.z)
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop x1))
                         (_z257 :
                            cic.Term cic.prop
                              (matita_basics_logic.Not
                                 (cic.lift cic.prop cic.prop x1)) =>
                          cic.univ cic.prop)) =>
                  cic.prod cic.prop cic.prop
                    (cic.prod cic.prop cic.prop
                       (cic.prod cic.prop cic.prop x1
                          (__ : cic.Term cic.prop x1 =>
                           matita_basics_logic.False))
                       (x_80 :
                          cic.Term cic.prop
                            (cic.prod cic.prop cic.prop x1
                               (__ : cic.Term cic.prop x1 =>
                                matita_basics_logic.False)) =>
                        cic.prod cic.prop cic.prop
                          (matita_basics_logic.eq
                             (cic.lift cic.prop
                                (cic.type (cic.s (cic.s cic.z)))
                                (matita_basics_logic.Not
                                   (cic.lift cic.prop cic.prop x1)))
                             Hterm
                             (matita_basics_logic.nmk
                                (cic.lift cic.prop cic.prop x1) x_80))
                          (_z258 :
                             cic.Term cic.prop
                               (matita_basics_logic.eq
                                  (cic.lift cic.prop
                                     (cic.type (cic.s (cic.s cic.z)))
                                     (matita_basics_logic.Not
                                        (cic.lift cic.prop cic.prop x1)))
                                  Hterm
                                  (matita_basics_logic.nmk
                                     (cic.lift cic.prop cic.prop x1) x_80)) =>
                           P
                             (matita_basics_logic.nmk
                                (cic.lift cic.prop cic.prop x1) x_80))))
                    (_H1 :
                       cic.Term cic.prop
                         (cic.prod cic.prop cic.prop
                            (cic.prod cic.prop cic.prop x1
                               (__ : cic.Term cic.prop x1 =>
                                matita_basics_logic.False))
                            (x_80 :
                               cic.Term cic.prop
                                 (cic.prod cic.prop cic.prop x1
                                    (__ : cic.Term cic.prop x1 =>
                                     matita_basics_logic.False)) =>
                             cic.prod cic.prop cic.prop
                               (matita_basics_logic.eq
                                  (cic.lift cic.prop
                                     (cic.type (cic.s (cic.s cic.z)))
                                     (matita_basics_logic.Not
                                        (cic.lift cic.prop cic.prop x1)))
                                  Hterm
                                  (matita_basics_logic.nmk
                                     (cic.lift cic.prop cic.prop x1) x_80))
                               (_z258 :
                                  cic.Term cic.prop
                                    (matita_basics_logic.eq
                                       (cic.lift cic.prop
                                          (cic.type (cic.s (cic.s cic.z)))
                                          (matita_basics_logic.Not
                                             (cic.lift cic.prop cic.prop x1)))
                                       Hterm
                                       (matita_basics_logic.nmk
                                          (cic.lift cic.prop cic.prop x1)
                                          x_80)) =>
                                P
                                  (matita_basics_logic.nmk
                                     (cic.lift cic.prop cic.prop x1) x_80)))) =>
                     P Hterm)))))
      :=
      x1 : cic.Univ cic.prop =>
      Hterm :
        cic.Term cic.prop
          (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)) =>
      P :
        cic.Term (cic.type cic.z)
          (cic.prod cic.prop (cic.type cic.z)
             (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1))
             (_z257 :
                cic.Term cic.prop
                  (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)) =>
              cic.univ cic.prop)) =>
      H1 :
        cic.Term cic.prop
          (cic.prod cic.prop cic.prop
             (cic.prod cic.prop cic.prop x1
                (__ : cic.Term cic.prop x1 => matita_basics_logic.False))
             (x_80 :
                cic.Term cic.prop
                  (cic.prod cic.prop cic.prop x1
                     (__ : cic.Term cic.prop x1 => matita_basics_logic.False)) =>
              cic.prod cic.prop cic.prop
                (matita_basics_logic.eq
                   (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop x1)))
                   Hterm
                   (matita_basics_logic.nmk (cic.lift cic.prop cic.prop x1)
                      x_80))
                (_z258 :
                   cic.Term cic.prop
                     (matita_basics_logic.eq
                        (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                           (matita_basics_logic.Not
                              (cic.lift cic.prop cic.prop x1)))
                        Hterm
                        (matita_basics_logic.nmk
                           (cic.lift cic.prop cic.prop x1) x_80)) =>
                 P
                   (matita_basics_logic.nmk (cic.lift cic.prop cic.prop x1)
                      x_80)))) =>
      (Hcut :
         cic.Term cic.prop
           (cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)))
                 Hterm Hterm)
              (_z258 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop x1)))
                      Hterm Hterm) =>
               P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
               (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)))
            Hterm))
        (matita_basics_logic.Not_ind (cic.lift cic.prop cic.prop x1)
           (_x_79 :
              cic.Term cic.prop
                (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)) =>
            cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)))
                 Hterm _x_79)
              (_z258 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop x1)))
                      Hterm _x_79) =>
               P _x_79))
           H1 Hterm).

def Not_inv_rect_Type4 :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
        (cic.prod (cic.type cic.z)
           (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
           (cic.univ cic.prop)
           (x1 : cic.Univ cic.prop =>
            cic.prod cic.prop
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
              (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1))
              (Hterm :
                 cic.Term cic.prop
                   (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)) =>
               cic.prod
                 (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                 (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                 (cic.prod cic.prop
                    (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                    (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1))
                    (_z263 :
                       cic.Term cic.prop
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop x1)) =>
                     cic.univ
                       (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                 (P :
                    cic.Term
                      (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                      (cic.prod cic.prop
                         (cic.type
                            (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop x1))
                         (_z263 :
                            cic.Term cic.prop
                              (matita_basics_logic.Not
                                 (cic.lift cic.prop cic.prop x1)) =>
                          cic.univ
                            (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))))) =>
                  cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                    (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                    (cic.prod cic.prop
                       (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                       (cic.prod cic.prop cic.prop x1
                          (__ : cic.Term cic.prop x1 =>
                           matita_basics_logic.False))
                       (x_83 :
                          cic.Term cic.prop
                            (cic.prod cic.prop cic.prop x1
                               (__ : cic.Term cic.prop x1 =>
                                matita_basics_logic.False)) =>
                        cic.prod cic.prop
                          (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                          (matita_basics_logic.eq
                             (cic.lift cic.prop
                                (cic.type (cic.s (cic.s cic.z)))
                                (matita_basics_logic.Not
                                   (cic.lift cic.prop cic.prop x1)))
                             Hterm
                             (matita_basics_logic.nmk
                                (cic.lift cic.prop cic.prop x1) x_83))
                          (_z264 :
                             cic.Term cic.prop
                               (matita_basics_logic.eq
                                  (cic.lift cic.prop
                                     (cic.type (cic.s (cic.s cic.z)))
                                     (matita_basics_logic.Not
                                        (cic.lift cic.prop cic.prop x1)))
                                  Hterm
                                  (matita_basics_logic.nmk
                                     (cic.lift cic.prop cic.prop x1) x_83)) =>
                           P
                             (matita_basics_logic.nmk
                                (cic.lift cic.prop cic.prop x1) x_83))))
                    (_H1 :
                       cic.Term
                         (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                         (cic.prod cic.prop
                            (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                            (cic.prod cic.prop cic.prop x1
                               (__ : cic.Term cic.prop x1 =>
                                matita_basics_logic.False))
                            (x_83 :
                               cic.Term cic.prop
                                 (cic.prod cic.prop cic.prop x1
                                    (__ : cic.Term cic.prop x1 =>
                                     matita_basics_logic.False)) =>
                             cic.prod cic.prop
                               (cic.type
                                  (cic.s (cic.s (cic.s (cic.s cic.z)))))
                               (matita_basics_logic.eq
                                  (cic.lift cic.prop
                                     (cic.type (cic.s (cic.s cic.z)))
                                     (matita_basics_logic.Not
                                        (cic.lift cic.prop cic.prop x1)))
                                  Hterm
                                  (matita_basics_logic.nmk
                                     (cic.lift cic.prop cic.prop x1) x_83))
                               (_z264 :
                                  cic.Term cic.prop
                                    (matita_basics_logic.eq
                                       (cic.lift cic.prop
                                          (cic.type (cic.s (cic.s cic.z)))
                                          (matita_basics_logic.Not
                                             (cic.lift cic.prop cic.prop x1)))
                                       Hterm
                                       (matita_basics_logic.nmk
                                          (cic.lift cic.prop cic.prop x1)
                                          x_83)) =>
                                P
                                  (matita_basics_logic.nmk
                                     (cic.lift cic.prop cic.prop x1) x_83)))) =>
                     P Hterm)))))
      :=
      x1 : cic.Univ cic.prop =>
      Hterm :
        cic.Term cic.prop
          (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)) =>
      P :
        cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
          (cic.prod cic.prop
             (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
             (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1))
             (_z263 :
                cic.Term cic.prop
                  (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)) =>
              cic.univ (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))))) =>
      H1 :
        cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
          (cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
             (cic.prod cic.prop cic.prop x1
                (__ : cic.Term cic.prop x1 => matita_basics_logic.False))
             (x_83 :
                cic.Term cic.prop
                  (cic.prod cic.prop cic.prop x1
                     (__ : cic.Term cic.prop x1 => matita_basics_logic.False)) =>
              cic.prod cic.prop
                (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                (matita_basics_logic.eq
                   (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop x1)))
                   Hterm
                   (matita_basics_logic.nmk (cic.lift cic.prop cic.prop x1)
                      x_83))
                (_z264 :
                   cic.Term cic.prop
                     (matita_basics_logic.eq
                        (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                           (matita_basics_logic.Not
                              (cic.lift cic.prop cic.prop x1)))
                        Hterm
                        (matita_basics_logic.nmk
                           (cic.lift cic.prop cic.prop x1) x_83)) =>
                 P
                   (matita_basics_logic.nmk (cic.lift cic.prop cic.prop x1)
                      x_83)))) =>
      (Hcut :
         cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
           (cic.prod cic.prop
              (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)))
                 Hterm Hterm)
              (_z264 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop x1)))
                      Hterm Hterm) =>
               P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
               (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)))
            Hterm))
        (matita_basics_logic.Not_rect_Type4 (cic.lift cic.prop cic.prop x1)
           (_x_82 :
              cic.Term cic.prop
                (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)) =>
            cic.prod cic.prop
              (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)))
                 Hterm _x_82)
              (_z264 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop x1)))
                      Hterm _x_82) =>
               P _x_82))
           H1 Hterm).

def Not_inv_rect_Type3 :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
        (cic.prod (cic.type cic.z)
           (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
           (cic.univ cic.prop)
           (x1 : cic.Univ cic.prop =>
            cic.prod cic.prop
              (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
              (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1))
              (Hterm :
                 cic.Term cic.prop
                   (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)) =>
               cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                 (cic.type (cic.s (cic.s (cic.s cic.z))))
                 (cic.prod cic.prop
                    (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                    (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1))
                    (_z269 :
                       cic.Term cic.prop
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop x1)) =>
                     cic.univ (cic.type (cic.s (cic.s (cic.s cic.z))))))
                 (P :
                    cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                      (cic.prod cic.prop
                         (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop x1))
                         (_z269 :
                            cic.Term cic.prop
                              (matita_basics_logic.Not
                                 (cic.lift cic.prop cic.prop x1)) =>
                          cic.univ (cic.type (cic.s (cic.s (cic.s cic.z)))))) =>
                  cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
                    (cic.type (cic.s (cic.s (cic.s cic.z))))
                    (cic.prod cic.prop
                       (cic.type (cic.s (cic.s (cic.s cic.z))))
                       (cic.prod cic.prop cic.prop x1
                          (__ : cic.Term cic.prop x1 =>
                           matita_basics_logic.False))
                       (x_89 :
                          cic.Term cic.prop
                            (cic.prod cic.prop cic.prop x1
                               (__ : cic.Term cic.prop x1 =>
                                matita_basics_logic.False)) =>
                        cic.prod cic.prop
                          (cic.type (cic.s (cic.s (cic.s cic.z))))
                          (matita_basics_logic.eq
                             (cic.lift cic.prop
                                (cic.type (cic.s (cic.s cic.z)))
                                (matita_basics_logic.Not
                                   (cic.lift cic.prop cic.prop x1)))
                             Hterm
                             (matita_basics_logic.nmk
                                (cic.lift cic.prop cic.prop x1) x_89))
                          (_z270 :
                             cic.Term cic.prop
                               (matita_basics_logic.eq
                                  (cic.lift cic.prop
                                     (cic.type (cic.s (cic.s cic.z)))
                                     (matita_basics_logic.Not
                                        (cic.lift cic.prop cic.prop x1)))
                                  Hterm
                                  (matita_basics_logic.nmk
                                     (cic.lift cic.prop cic.prop x1) x_89)) =>
                           P
                             (matita_basics_logic.nmk
                                (cic.lift cic.prop cic.prop x1) x_89))))
                    (_H1 :
                       cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                         (cic.prod cic.prop
                            (cic.type (cic.s (cic.s (cic.s cic.z))))
                            (cic.prod cic.prop cic.prop x1
                               (__ : cic.Term cic.prop x1 =>
                                matita_basics_logic.False))
                            (x_89 :
                               cic.Term cic.prop
                                 (cic.prod cic.prop cic.prop x1
                                    (__ : cic.Term cic.prop x1 =>
                                     matita_basics_logic.False)) =>
                             cic.prod cic.prop
                               (cic.type (cic.s (cic.s (cic.s cic.z))))
                               (matita_basics_logic.eq
                                  (cic.lift cic.prop
                                     (cic.type (cic.s (cic.s cic.z)))
                                     (matita_basics_logic.Not
                                        (cic.lift cic.prop cic.prop x1)))
                                  Hterm
                                  (matita_basics_logic.nmk
                                     (cic.lift cic.prop cic.prop x1) x_89))
                               (_z270 :
                                  cic.Term cic.prop
                                    (matita_basics_logic.eq
                                       (cic.lift cic.prop
                                          (cic.type (cic.s (cic.s cic.z)))
                                          (matita_basics_logic.Not
                                             (cic.lift cic.prop cic.prop x1)))
                                       Hterm
                                       (matita_basics_logic.nmk
                                          (cic.lift cic.prop cic.prop x1)
                                          x_89)) =>
                                P
                                  (matita_basics_logic.nmk
                                     (cic.lift cic.prop cic.prop x1) x_89)))) =>
                     P Hterm)))))
      :=
      x1 : cic.Univ cic.prop =>
      Hterm :
        cic.Term cic.prop
          (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)) =>
      P :
        cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
          (cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
             (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1))
             (_z269 :
                cic.Term cic.prop
                  (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)) =>
              cic.univ (cic.type (cic.s (cic.s (cic.s cic.z)))))) =>
      H1 :
        cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
          (cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
             (cic.prod cic.prop cic.prop x1
                (__ : cic.Term cic.prop x1 => matita_basics_logic.False))
             (x_89 :
                cic.Term cic.prop
                  (cic.prod cic.prop cic.prop x1
                     (__ : cic.Term cic.prop x1 => matita_basics_logic.False)) =>
              cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
                (matita_basics_logic.eq
                   (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop x1)))
                   Hterm
                   (matita_basics_logic.nmk (cic.lift cic.prop cic.prop x1)
                      x_89))
                (_z270 :
                   cic.Term cic.prop
                     (matita_basics_logic.eq
                        (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                           (matita_basics_logic.Not
                              (cic.lift cic.prop cic.prop x1)))
                        Hterm
                        (matita_basics_logic.nmk
                           (cic.lift cic.prop cic.prop x1) x_89)) =>
                 P
                   (matita_basics_logic.nmk (cic.lift cic.prop cic.prop x1)
                      x_89)))) =>
      (Hcut :
         cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)))
                 Hterm Hterm)
              (_z270 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop x1)))
                      Hterm Hterm) =>
               P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
               (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)))
            Hterm))
        (matita_basics_logic.Not_rect_Type3 (cic.lift cic.prop cic.prop x1)
           (_x_88 :
              cic.Term cic.prop
                (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)) =>
            cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)))
                 Hterm _x_88)
              (_z270 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop x1)))
                      Hterm _x_88) =>
               P _x_88))
           H1 Hterm).

def Not_inv_rect_Type2 :
      cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
        (cic.prod (cic.type cic.z) (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.univ cic.prop)
           (x1 : cic.Univ cic.prop =>
            cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
              (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1))
              (Hterm :
                 cic.Term cic.prop
                   (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)) =>
               cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
                 (cic.type (cic.s (cic.s cic.z)))
                 (cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
                    (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1))
                    (_z275 :
                       cic.Term cic.prop
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop x1)) =>
                     cic.univ (cic.type (cic.s (cic.s cic.z)))))
                 (P :
                    cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                      (cic.prod cic.prop
                         (cic.type (cic.s (cic.s (cic.s cic.z))))
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop x1))
                         (_z275 :
                            cic.Term cic.prop
                              (matita_basics_logic.Not
                                 (cic.lift cic.prop cic.prop x1)) =>
                          cic.univ (cic.type (cic.s (cic.s cic.z))))) =>
                  cic.prod (cic.type (cic.s (cic.s cic.z)))
                    (cic.type (cic.s (cic.s cic.z)))
                    (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                       (cic.prod cic.prop cic.prop x1
                          (__ : cic.Term cic.prop x1 =>
                           matita_basics_logic.False))
                       (x_92 :
                          cic.Term cic.prop
                            (cic.prod cic.prop cic.prop x1
                               (__ : cic.Term cic.prop x1 =>
                                matita_basics_logic.False)) =>
                        cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                          (matita_basics_logic.eq
                             (cic.lift cic.prop
                                (cic.type (cic.s (cic.s cic.z)))
                                (matita_basics_logic.Not
                                   (cic.lift cic.prop cic.prop x1)))
                             Hterm
                             (matita_basics_logic.nmk
                                (cic.lift cic.prop cic.prop x1) x_92))
                          (_z276 :
                             cic.Term cic.prop
                               (matita_basics_logic.eq
                                  (cic.lift cic.prop
                                     (cic.type (cic.s (cic.s cic.z)))
                                     (matita_basics_logic.Not
                                        (cic.lift cic.prop cic.prop x1)))
                                  Hterm
                                  (matita_basics_logic.nmk
                                     (cic.lift cic.prop cic.prop x1) x_92)) =>
                           P
                             (matita_basics_logic.nmk
                                (cic.lift cic.prop cic.prop x1) x_92))))
                    (_H1 :
                       cic.Term (cic.type (cic.s (cic.s cic.z)))
                         (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                            (cic.prod cic.prop cic.prop x1
                               (__ : cic.Term cic.prop x1 =>
                                matita_basics_logic.False))
                            (x_92 :
                               cic.Term cic.prop
                                 (cic.prod cic.prop cic.prop x1
                                    (__ : cic.Term cic.prop x1 =>
                                     matita_basics_logic.False)) =>
                             cic.prod cic.prop
                               (cic.type (cic.s (cic.s cic.z)))
                               (matita_basics_logic.eq
                                  (cic.lift cic.prop
                                     (cic.type (cic.s (cic.s cic.z)))
                                     (matita_basics_logic.Not
                                        (cic.lift cic.prop cic.prop x1)))
                                  Hterm
                                  (matita_basics_logic.nmk
                                     (cic.lift cic.prop cic.prop x1) x_92))
                               (_z276 :
                                  cic.Term cic.prop
                                    (matita_basics_logic.eq
                                       (cic.lift cic.prop
                                          (cic.type (cic.s (cic.s cic.z)))
                                          (matita_basics_logic.Not
                                             (cic.lift cic.prop cic.prop x1)))
                                       Hterm
                                       (matita_basics_logic.nmk
                                          (cic.lift cic.prop cic.prop x1)
                                          x_92)) =>
                                P
                                  (matita_basics_logic.nmk
                                     (cic.lift cic.prop cic.prop x1) x_92)))) =>
                     P Hterm)))))
      :=
      x1 : cic.Univ cic.prop =>
      Hterm :
        cic.Term cic.prop
          (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)) =>
      P :
        cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
          (cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
             (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1))
             (_z275 :
                cic.Term cic.prop
                  (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)) =>
              cic.univ (cic.type (cic.s (cic.s cic.z))))) =>
      H1 :
        cic.Term (cic.type (cic.s (cic.s cic.z)))
          (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
             (cic.prod cic.prop cic.prop x1
                (__ : cic.Term cic.prop x1 => matita_basics_logic.False))
             (x_92 :
                cic.Term cic.prop
                  (cic.prod cic.prop cic.prop x1
                     (__ : cic.Term cic.prop x1 => matita_basics_logic.False)) =>
              cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                (matita_basics_logic.eq
                   (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop x1)))
                   Hterm
                   (matita_basics_logic.nmk (cic.lift cic.prop cic.prop x1)
                      x_92))
                (_z276 :
                   cic.Term cic.prop
                     (matita_basics_logic.eq
                        (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                           (matita_basics_logic.Not
                              (cic.lift cic.prop cic.prop x1)))
                        Hterm
                        (matita_basics_logic.nmk
                           (cic.lift cic.prop cic.prop x1) x_92)) =>
                 P
                   (matita_basics_logic.nmk (cic.lift cic.prop cic.prop x1)
                      x_92)))) =>
      (Hcut :
         cic.Term (cic.type (cic.s (cic.s cic.z)))
           (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)))
                 Hterm Hterm)
              (_z276 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop x1)))
                      Hterm Hterm) =>
               P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
               (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)))
            Hterm))
        (matita_basics_logic.Not_rect_Type2 (cic.lift cic.prop cic.prop x1)
           (_x_91 :
              cic.Term cic.prop
                (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)) =>
            cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)))
                 Hterm _x_91)
              (_z276 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop x1)))
                      Hterm _x_91) =>
               P _x_91))
           H1 Hterm).

def Not_inv_rect_Type1 :
      cic.Term (cic.type (cic.s (cic.s cic.z)))
        (cic.prod (cic.type cic.z) (cic.type (cic.s (cic.s cic.z)))
           (cic.univ cic.prop)
           (x1 : cic.Univ cic.prop =>
            cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
              (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1))
              (Hterm :
                 cic.Term cic.prop
                   (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)) =>
               cic.prod (cic.type (cic.s (cic.s cic.z)))
                 (cic.type (cic.s cic.z))
                 (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1))
                    (_z281 :
                       cic.Term cic.prop
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop x1)) =>
                     cic.univ (cic.type (cic.s cic.z))))
                 (P :
                    cic.Term (cic.type (cic.s (cic.s cic.z)))
                      (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop x1))
                         (_z281 :
                            cic.Term cic.prop
                              (matita_basics_logic.Not
                                 (cic.lift cic.prop cic.prop x1)) =>
                          cic.univ (cic.type (cic.s cic.z)))) =>
                  cic.prod (cic.type (cic.s cic.z)) (cic.type (cic.s cic.z))
                    (cic.prod cic.prop (cic.type (cic.s cic.z))
                       (cic.prod cic.prop cic.prop x1
                          (__ : cic.Term cic.prop x1 =>
                           matita_basics_logic.False))
                       (x_95 :
                          cic.Term cic.prop
                            (cic.prod cic.prop cic.prop x1
                               (__ : cic.Term cic.prop x1 =>
                                matita_basics_logic.False)) =>
                        cic.prod cic.prop (cic.type (cic.s cic.z))
                          (matita_basics_logic.eq
                             (cic.lift cic.prop
                                (cic.type (cic.s (cic.s cic.z)))
                                (matita_basics_logic.Not
                                   (cic.lift cic.prop cic.prop x1)))
                             Hterm
                             (matita_basics_logic.nmk
                                (cic.lift cic.prop cic.prop x1) x_95))
                          (_z282 :
                             cic.Term cic.prop
                               (matita_basics_logic.eq
                                  (cic.lift cic.prop
                                     (cic.type (cic.s (cic.s cic.z)))
                                     (matita_basics_logic.Not
                                        (cic.lift cic.prop cic.prop x1)))
                                  Hterm
                                  (matita_basics_logic.nmk
                                     (cic.lift cic.prop cic.prop x1) x_95)) =>
                           P
                             (matita_basics_logic.nmk
                                (cic.lift cic.prop cic.prop x1) x_95))))
                    (_H1 :
                       cic.Term (cic.type (cic.s cic.z))
                         (cic.prod cic.prop (cic.type (cic.s cic.z))
                            (cic.prod cic.prop cic.prop x1
                               (__ : cic.Term cic.prop x1 =>
                                matita_basics_logic.False))
                            (x_95 :
                               cic.Term cic.prop
                                 (cic.prod cic.prop cic.prop x1
                                    (__ : cic.Term cic.prop x1 =>
                                     matita_basics_logic.False)) =>
                             cic.prod cic.prop (cic.type (cic.s cic.z))
                               (matita_basics_logic.eq
                                  (cic.lift cic.prop
                                     (cic.type (cic.s (cic.s cic.z)))
                                     (matita_basics_logic.Not
                                        (cic.lift cic.prop cic.prop x1)))
                                  Hterm
                                  (matita_basics_logic.nmk
                                     (cic.lift cic.prop cic.prop x1) x_95))
                               (_z282 :
                                  cic.Term cic.prop
                                    (matita_basics_logic.eq
                                       (cic.lift cic.prop
                                          (cic.type (cic.s (cic.s cic.z)))
                                          (matita_basics_logic.Not
                                             (cic.lift cic.prop cic.prop x1)))
                                       Hterm
                                       (matita_basics_logic.nmk
                                          (cic.lift cic.prop cic.prop x1)
                                          x_95)) =>
                                P
                                  (matita_basics_logic.nmk
                                     (cic.lift cic.prop cic.prop x1) x_95)))) =>
                     P Hterm)))))
      :=
      x1 : cic.Univ cic.prop =>
      Hterm :
        cic.Term cic.prop
          (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)) =>
      P :
        cic.Term (cic.type (cic.s (cic.s cic.z)))
          (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
             (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1))
             (_z281 :
                cic.Term cic.prop
                  (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)) =>
              cic.univ (cic.type (cic.s cic.z)))) =>
      H1 :
        cic.Term (cic.type (cic.s cic.z))
          (cic.prod cic.prop (cic.type (cic.s cic.z))
             (cic.prod cic.prop cic.prop x1
                (__ : cic.Term cic.prop x1 => matita_basics_logic.False))
             (x_95 :
                cic.Term cic.prop
                  (cic.prod cic.prop cic.prop x1
                     (__ : cic.Term cic.prop x1 => matita_basics_logic.False)) =>
              cic.prod cic.prop (cic.type (cic.s cic.z))
                (matita_basics_logic.eq
                   (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop x1)))
                   Hterm
                   (matita_basics_logic.nmk (cic.lift cic.prop cic.prop x1)
                      x_95))
                (_z282 :
                   cic.Term cic.prop
                     (matita_basics_logic.eq
                        (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                           (matita_basics_logic.Not
                              (cic.lift cic.prop cic.prop x1)))
                        Hterm
                        (matita_basics_logic.nmk
                           (cic.lift cic.prop cic.prop x1) x_95)) =>
                 P
                   (matita_basics_logic.nmk (cic.lift cic.prop cic.prop x1)
                      x_95)))) =>
      (Hcut :
         cic.Term (cic.type (cic.s cic.z))
           (cic.prod cic.prop (cic.type (cic.s cic.z))
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)))
                 Hterm Hterm)
              (_z282 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop x1)))
                      Hterm Hterm) =>
               P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
               (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)))
            Hterm))
        (matita_basics_logic.Not_rect_Type1 (cic.lift cic.prop cic.prop x1)
           (_x_94 :
              cic.Term cic.prop
                (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)) =>
            cic.prod cic.prop (cic.type (cic.s cic.z))
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)))
                 Hterm _x_94)
              (_z282 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop x1)))
                      Hterm _x_94) =>
               P _x_94))
           H1 Hterm).

def Not_inv_rect_Type0 :
      cic.Term (cic.type (cic.s cic.z))
        (cic.prod (cic.type cic.z) (cic.type (cic.s cic.z))
           (cic.univ cic.prop)
           (x1 : cic.Univ cic.prop =>
            cic.prod cic.prop (cic.type (cic.s cic.z))
              (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1))
              (Hterm :
                 cic.Term cic.prop
                   (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)) =>
               cic.prod (cic.type (cic.s cic.z)) (cic.type cic.z)
                 (cic.prod cic.prop (cic.type (cic.s cic.z))
                    (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1))
                    (_z287 :
                       cic.Term cic.prop
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop x1)) =>
                     cic.univ (cic.type cic.z)))
                 (P :
                    cic.Term (cic.type (cic.s cic.z))
                      (cic.prod cic.prop (cic.type (cic.s cic.z))
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop x1))
                         (_z287 :
                            cic.Term cic.prop
                              (matita_basics_logic.Not
                                 (cic.lift cic.prop cic.prop x1)) =>
                          cic.univ (cic.type cic.z))) =>
                  cic.prod (cic.type cic.z) (cic.type cic.z)
                    (cic.prod cic.prop (cic.type cic.z)
                       (cic.prod cic.prop cic.prop x1
                          (__ : cic.Term cic.prop x1 =>
                           matita_basics_logic.False))
                       (x_98 :
                          cic.Term cic.prop
                            (cic.prod cic.prop cic.prop x1
                               (__ : cic.Term cic.prop x1 =>
                                matita_basics_logic.False)) =>
                        cic.prod cic.prop (cic.type cic.z)
                          (matita_basics_logic.eq
                             (cic.lift cic.prop
                                (cic.type (cic.s (cic.s cic.z)))
                                (matita_basics_logic.Not
                                   (cic.lift cic.prop cic.prop x1)))
                             Hterm
                             (matita_basics_logic.nmk
                                (cic.lift cic.prop cic.prop x1) x_98))
                          (_z288 :
                             cic.Term cic.prop
                               (matita_basics_logic.eq
                                  (cic.lift cic.prop
                                     (cic.type (cic.s (cic.s cic.z)))
                                     (matita_basics_logic.Not
                                        (cic.lift cic.prop cic.prop x1)))
                                  Hterm
                                  (matita_basics_logic.nmk
                                     (cic.lift cic.prop cic.prop x1) x_98)) =>
                           P
                             (matita_basics_logic.nmk
                                (cic.lift cic.prop cic.prop x1) x_98))))
                    (_H1 :
                       cic.Term (cic.type cic.z)
                         (cic.prod cic.prop (cic.type cic.z)
                            (cic.prod cic.prop cic.prop x1
                               (__ : cic.Term cic.prop x1 =>
                                matita_basics_logic.False))
                            (x_98 :
                               cic.Term cic.prop
                                 (cic.prod cic.prop cic.prop x1
                                    (__ : cic.Term cic.prop x1 =>
                                     matita_basics_logic.False)) =>
                             cic.prod cic.prop (cic.type cic.z)
                               (matita_basics_logic.eq
                                  (cic.lift cic.prop
                                     (cic.type (cic.s (cic.s cic.z)))
                                     (matita_basics_logic.Not
                                        (cic.lift cic.prop cic.prop x1)))
                                  Hterm
                                  (matita_basics_logic.nmk
                                     (cic.lift cic.prop cic.prop x1) x_98))
                               (_z288 :
                                  cic.Term cic.prop
                                    (matita_basics_logic.eq
                                       (cic.lift cic.prop
                                          (cic.type (cic.s (cic.s cic.z)))
                                          (matita_basics_logic.Not
                                             (cic.lift cic.prop cic.prop x1)))
                                       Hterm
                                       (matita_basics_logic.nmk
                                          (cic.lift cic.prop cic.prop x1)
                                          x_98)) =>
                                P
                                  (matita_basics_logic.nmk
                                     (cic.lift cic.prop cic.prop x1) x_98)))) =>
                     P Hterm)))))
      :=
      x1 : cic.Univ cic.prop =>
      Hterm :
        cic.Term cic.prop
          (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)) =>
      P :
        cic.Term (cic.type (cic.s cic.z))
          (cic.prod cic.prop (cic.type (cic.s cic.z))
             (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1))
             (_z287 :
                cic.Term cic.prop
                  (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)) =>
              cic.univ (cic.type cic.z))) =>
      H1 :
        cic.Term (cic.type cic.z)
          (cic.prod cic.prop (cic.type cic.z)
             (cic.prod cic.prop cic.prop x1
                (__ : cic.Term cic.prop x1 => matita_basics_logic.False))
             (x_98 :
                cic.Term cic.prop
                  (cic.prod cic.prop cic.prop x1
                     (__ : cic.Term cic.prop x1 => matita_basics_logic.False)) =>
              cic.prod cic.prop (cic.type cic.z)
                (matita_basics_logic.eq
                   (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop x1)))
                   Hterm
                   (matita_basics_logic.nmk (cic.lift cic.prop cic.prop x1)
                      x_98))
                (_z288 :
                   cic.Term cic.prop
                     (matita_basics_logic.eq
                        (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                           (matita_basics_logic.Not
                              (cic.lift cic.prop cic.prop x1)))
                        Hterm
                        (matita_basics_logic.nmk
                           (cic.lift cic.prop cic.prop x1) x_98)) =>
                 P
                   (matita_basics_logic.nmk (cic.lift cic.prop cic.prop x1)
                      x_98)))) =>
      (Hcut :
         cic.Term (cic.type cic.z)
           (cic.prod cic.prop (cic.type cic.z)
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)))
                 Hterm Hterm)
              (_z288 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop x1)))
                      Hterm Hterm) =>
               P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
               (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)))
            Hterm))
        (matita_basics_logic.Not_rect_Type0 (cic.lift cic.prop cic.prop x1)
           (_x_97 :
              cic.Term cic.prop
                (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)) =>
            cic.prod cic.prop (cic.type cic.z)
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)))
                 Hterm _x_97)
              (_z288 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop x1)))
                      Hterm _x_97) =>
               P _x_97))
           H1 Hterm).

def Not_inv_rect_CProp4 :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
           (x1 : cic.Univ cic.prop =>
            cic.prod cic.prop cic.prop
              (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1))
              (Hterm :
                 cic.Term cic.prop
                   (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)) =>
               cic.prod (cic.type cic.z) cic.prop
                 (cic.prod cic.prop (cic.type cic.z)
                    (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1))
                    (_z293 :
                       cic.Term cic.prop
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop x1)) =>
                     cic.univ cic.prop))
                 (P :
                    cic.Term (cic.type cic.z)
                      (cic.prod cic.prop (cic.type cic.z)
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop x1))
                         (_z293 :
                            cic.Term cic.prop
                              (matita_basics_logic.Not
                                 (cic.lift cic.prop cic.prop x1)) =>
                          cic.univ cic.prop)) =>
                  cic.prod cic.prop cic.prop
                    (cic.prod cic.prop cic.prop
                       (cic.prod cic.prop cic.prop x1
                          (__ : cic.Term cic.prop x1 =>
                           matita_basics_logic.False))
                       (x_101 :
                          cic.Term cic.prop
                            (cic.prod cic.prop cic.prop x1
                               (__ : cic.Term cic.prop x1 =>
                                matita_basics_logic.False)) =>
                        cic.prod cic.prop cic.prop
                          (matita_basics_logic.eq
                             (cic.lift cic.prop
                                (cic.type (cic.s (cic.s cic.z)))
                                (matita_basics_logic.Not
                                   (cic.lift cic.prop cic.prop x1)))
                             Hterm
                             (matita_basics_logic.nmk
                                (cic.lift cic.prop cic.prop x1) x_101))
                          (_z294 :
                             cic.Term cic.prop
                               (matita_basics_logic.eq
                                  (cic.lift cic.prop
                                     (cic.type (cic.s (cic.s cic.z)))
                                     (matita_basics_logic.Not
                                        (cic.lift cic.prop cic.prop x1)))
                                  Hterm
                                  (matita_basics_logic.nmk
                                     (cic.lift cic.prop cic.prop x1) x_101)) =>
                           P
                             (matita_basics_logic.nmk
                                (cic.lift cic.prop cic.prop x1) x_101))))
                    (_H1 :
                       cic.Term cic.prop
                         (cic.prod cic.prop cic.prop
                            (cic.prod cic.prop cic.prop x1
                               (__ : cic.Term cic.prop x1 =>
                                matita_basics_logic.False))
                            (x_101 :
                               cic.Term cic.prop
                                 (cic.prod cic.prop cic.prop x1
                                    (__ : cic.Term cic.prop x1 =>
                                     matita_basics_logic.False)) =>
                             cic.prod cic.prop cic.prop
                               (matita_basics_logic.eq
                                  (cic.lift cic.prop
                                     (cic.type (cic.s (cic.s cic.z)))
                                     (matita_basics_logic.Not
                                        (cic.lift cic.prop cic.prop x1)))
                                  Hterm
                                  (matita_basics_logic.nmk
                                     (cic.lift cic.prop cic.prop x1) x_101))
                               (_z294 :
                                  cic.Term cic.prop
                                    (matita_basics_logic.eq
                                       (cic.lift cic.prop
                                          (cic.type (cic.s (cic.s cic.z)))
                                          (matita_basics_logic.Not
                                             (cic.lift cic.prop cic.prop x1)))
                                       Hterm
                                       (matita_basics_logic.nmk
                                          (cic.lift cic.prop cic.prop x1)
                                          x_101)) =>
                                P
                                  (matita_basics_logic.nmk
                                     (cic.lift cic.prop cic.prop x1) x_101)))) =>
                     P Hterm)))))
      :=
      x1 : cic.Univ cic.prop =>
      Hterm :
        cic.Term cic.prop
          (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)) =>
      P :
        cic.Term (cic.type cic.z)
          (cic.prod cic.prop (cic.type cic.z)
             (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1))
             (_z293 :
                cic.Term cic.prop
                  (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)) =>
              cic.univ cic.prop)) =>
      H1 :
        cic.Term cic.prop
          (cic.prod cic.prop cic.prop
             (cic.prod cic.prop cic.prop x1
                (__ : cic.Term cic.prop x1 => matita_basics_logic.False))
             (x_101 :
                cic.Term cic.prop
                  (cic.prod cic.prop cic.prop x1
                     (__ : cic.Term cic.prop x1 => matita_basics_logic.False)) =>
              cic.prod cic.prop cic.prop
                (matita_basics_logic.eq
                   (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop x1)))
                   Hterm
                   (matita_basics_logic.nmk (cic.lift cic.prop cic.prop x1)
                      x_101))
                (_z294 :
                   cic.Term cic.prop
                     (matita_basics_logic.eq
                        (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                           (matita_basics_logic.Not
                              (cic.lift cic.prop cic.prop x1)))
                        Hterm
                        (matita_basics_logic.nmk
                           (cic.lift cic.prop cic.prop x1) x_101)) =>
                 P
                   (matita_basics_logic.nmk (cic.lift cic.prop cic.prop x1)
                      x_101)))) =>
      (Hcut :
         cic.Term cic.prop
           (cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)))
                 Hterm Hterm)
              (_z294 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop x1)))
                      Hterm Hterm) =>
               P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
               (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)))
            Hterm))
        (matita_basics_logic.Not_rect_CProp4 (cic.lift cic.prop cic.prop x1)
           (_x_100 :
              cic.Term cic.prop
                (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)) =>
            cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)))
                 Hterm _x_100)
              (_z294 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop x1)))
                      Hterm _x_100) =>
               P _x_100))
           H1 Hterm).

def Not_inv_rect_CProp3 :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
           (x1 : cic.Univ cic.prop =>
            cic.prod cic.prop cic.prop
              (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1))
              (Hterm :
                 cic.Term cic.prop
                   (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)) =>
               cic.prod (cic.type cic.z) cic.prop
                 (cic.prod cic.prop (cic.type cic.z)
                    (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1))
                    (_z299 :
                       cic.Term cic.prop
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop x1)) =>
                     cic.univ cic.prop))
                 (P :
                    cic.Term (cic.type cic.z)
                      (cic.prod cic.prop (cic.type cic.z)
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop x1))
                         (_z299 :
                            cic.Term cic.prop
                              (matita_basics_logic.Not
                                 (cic.lift cic.prop cic.prop x1)) =>
                          cic.univ cic.prop)) =>
                  cic.prod cic.prop cic.prop
                    (cic.prod cic.prop cic.prop
                       (cic.prod cic.prop cic.prop x1
                          (__ : cic.Term cic.prop x1 =>
                           matita_basics_logic.False))
                       (x_107 :
                          cic.Term cic.prop
                            (cic.prod cic.prop cic.prop x1
                               (__ : cic.Term cic.prop x1 =>
                                matita_basics_logic.False)) =>
                        cic.prod cic.prop cic.prop
                          (matita_basics_logic.eq
                             (cic.lift cic.prop
                                (cic.type (cic.s (cic.s cic.z)))
                                (matita_basics_logic.Not
                                   (cic.lift cic.prop cic.prop x1)))
                             Hterm
                             (matita_basics_logic.nmk
                                (cic.lift cic.prop cic.prop x1) x_107))
                          (_z300 :
                             cic.Term cic.prop
                               (matita_basics_logic.eq
                                  (cic.lift cic.prop
                                     (cic.type (cic.s (cic.s cic.z)))
                                     (matita_basics_logic.Not
                                        (cic.lift cic.prop cic.prop x1)))
                                  Hterm
                                  (matita_basics_logic.nmk
                                     (cic.lift cic.prop cic.prop x1) x_107)) =>
                           P
                             (matita_basics_logic.nmk
                                (cic.lift cic.prop cic.prop x1) x_107))))
                    (_H1 :
                       cic.Term cic.prop
                         (cic.prod cic.prop cic.prop
                            (cic.prod cic.prop cic.prop x1
                               (__ : cic.Term cic.prop x1 =>
                                matita_basics_logic.False))
                            (x_107 :
                               cic.Term cic.prop
                                 (cic.prod cic.prop cic.prop x1
                                    (__ : cic.Term cic.prop x1 =>
                                     matita_basics_logic.False)) =>
                             cic.prod cic.prop cic.prop
                               (matita_basics_logic.eq
                                  (cic.lift cic.prop
                                     (cic.type (cic.s (cic.s cic.z)))
                                     (matita_basics_logic.Not
                                        (cic.lift cic.prop cic.prop x1)))
                                  Hterm
                                  (matita_basics_logic.nmk
                                     (cic.lift cic.prop cic.prop x1) x_107))
                               (_z300 :
                                  cic.Term cic.prop
                                    (matita_basics_logic.eq
                                       (cic.lift cic.prop
                                          (cic.type (cic.s (cic.s cic.z)))
                                          (matita_basics_logic.Not
                                             (cic.lift cic.prop cic.prop x1)))
                                       Hterm
                                       (matita_basics_logic.nmk
                                          (cic.lift cic.prop cic.prop x1)
                                          x_107)) =>
                                P
                                  (matita_basics_logic.nmk
                                     (cic.lift cic.prop cic.prop x1) x_107)))) =>
                     P Hterm)))))
      :=
      x1 : cic.Univ cic.prop =>
      Hterm :
        cic.Term cic.prop
          (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)) =>
      P :
        cic.Term (cic.type cic.z)
          (cic.prod cic.prop (cic.type cic.z)
             (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1))
             (_z299 :
                cic.Term cic.prop
                  (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)) =>
              cic.univ cic.prop)) =>
      H1 :
        cic.Term cic.prop
          (cic.prod cic.prop cic.prop
             (cic.prod cic.prop cic.prop x1
                (__ : cic.Term cic.prop x1 => matita_basics_logic.False))
             (x_107 :
                cic.Term cic.prop
                  (cic.prod cic.prop cic.prop x1
                     (__ : cic.Term cic.prop x1 => matita_basics_logic.False)) =>
              cic.prod cic.prop cic.prop
                (matita_basics_logic.eq
                   (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop x1)))
                   Hterm
                   (matita_basics_logic.nmk (cic.lift cic.prop cic.prop x1)
                      x_107))
                (_z300 :
                   cic.Term cic.prop
                     (matita_basics_logic.eq
                        (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                           (matita_basics_logic.Not
                              (cic.lift cic.prop cic.prop x1)))
                        Hterm
                        (matita_basics_logic.nmk
                           (cic.lift cic.prop cic.prop x1) x_107)) =>
                 P
                   (matita_basics_logic.nmk (cic.lift cic.prop cic.prop x1)
                      x_107)))) =>
      (Hcut :
         cic.Term cic.prop
           (cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)))
                 Hterm Hterm)
              (_z300 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop x1)))
                      Hterm Hterm) =>
               P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
               (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)))
            Hterm))
        (matita_basics_logic.Not_rect_CProp3 (cic.lift cic.prop cic.prop x1)
           (_x_106 :
              cic.Term cic.prop
                (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)) =>
            cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)))
                 Hterm _x_106)
              (_z300 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop x1)))
                      Hterm _x_106) =>
               P _x_106))
           H1 Hterm).

def Not_inv_rect_CProp2 :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
           (x1 : cic.Univ cic.prop =>
            cic.prod cic.prop cic.prop
              (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1))
              (Hterm :
                 cic.Term cic.prop
                   (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)) =>
               cic.prod (cic.type cic.z) cic.prop
                 (cic.prod cic.prop (cic.type cic.z)
                    (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1))
                    (_z305 :
                       cic.Term cic.prop
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop x1)) =>
                     cic.univ cic.prop))
                 (P :
                    cic.Term (cic.type cic.z)
                      (cic.prod cic.prop (cic.type cic.z)
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop x1))
                         (_z305 :
                            cic.Term cic.prop
                              (matita_basics_logic.Not
                                 (cic.lift cic.prop cic.prop x1)) =>
                          cic.univ cic.prop)) =>
                  cic.prod cic.prop cic.prop
                    (cic.prod cic.prop cic.prop
                       (cic.prod cic.prop cic.prop x1
                          (__ : cic.Term cic.prop x1 =>
                           matita_basics_logic.False))
                       (x_110 :
                          cic.Term cic.prop
                            (cic.prod cic.prop cic.prop x1
                               (__ : cic.Term cic.prop x1 =>
                                matita_basics_logic.False)) =>
                        cic.prod cic.prop cic.prop
                          (matita_basics_logic.eq
                             (cic.lift cic.prop
                                (cic.type (cic.s (cic.s cic.z)))
                                (matita_basics_logic.Not
                                   (cic.lift cic.prop cic.prop x1)))
                             Hterm
                             (matita_basics_logic.nmk
                                (cic.lift cic.prop cic.prop x1) x_110))
                          (_z306 :
                             cic.Term cic.prop
                               (matita_basics_logic.eq
                                  (cic.lift cic.prop
                                     (cic.type (cic.s (cic.s cic.z)))
                                     (matita_basics_logic.Not
                                        (cic.lift cic.prop cic.prop x1)))
                                  Hterm
                                  (matita_basics_logic.nmk
                                     (cic.lift cic.prop cic.prop x1) x_110)) =>
                           P
                             (matita_basics_logic.nmk
                                (cic.lift cic.prop cic.prop x1) x_110))))
                    (_H1 :
                       cic.Term cic.prop
                         (cic.prod cic.prop cic.prop
                            (cic.prod cic.prop cic.prop x1
                               (__ : cic.Term cic.prop x1 =>
                                matita_basics_logic.False))
                            (x_110 :
                               cic.Term cic.prop
                                 (cic.prod cic.prop cic.prop x1
                                    (__ : cic.Term cic.prop x1 =>
                                     matita_basics_logic.False)) =>
                             cic.prod cic.prop cic.prop
                               (matita_basics_logic.eq
                                  (cic.lift cic.prop
                                     (cic.type (cic.s (cic.s cic.z)))
                                     (matita_basics_logic.Not
                                        (cic.lift cic.prop cic.prop x1)))
                                  Hterm
                                  (matita_basics_logic.nmk
                                     (cic.lift cic.prop cic.prop x1) x_110))
                               (_z306 :
                                  cic.Term cic.prop
                                    (matita_basics_logic.eq
                                       (cic.lift cic.prop
                                          (cic.type (cic.s (cic.s cic.z)))
                                          (matita_basics_logic.Not
                                             (cic.lift cic.prop cic.prop x1)))
                                       Hterm
                                       (matita_basics_logic.nmk
                                          (cic.lift cic.prop cic.prop x1)
                                          x_110)) =>
                                P
                                  (matita_basics_logic.nmk
                                     (cic.lift cic.prop cic.prop x1) x_110)))) =>
                     P Hterm)))))
      :=
      x1 : cic.Univ cic.prop =>
      Hterm :
        cic.Term cic.prop
          (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)) =>
      P :
        cic.Term (cic.type cic.z)
          (cic.prod cic.prop (cic.type cic.z)
             (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1))
             (_z305 :
                cic.Term cic.prop
                  (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)) =>
              cic.univ cic.prop)) =>
      H1 :
        cic.Term cic.prop
          (cic.prod cic.prop cic.prop
             (cic.prod cic.prop cic.prop x1
                (__ : cic.Term cic.prop x1 => matita_basics_logic.False))
             (x_110 :
                cic.Term cic.prop
                  (cic.prod cic.prop cic.prop x1
                     (__ : cic.Term cic.prop x1 => matita_basics_logic.False)) =>
              cic.prod cic.prop cic.prop
                (matita_basics_logic.eq
                   (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop x1)))
                   Hterm
                   (matita_basics_logic.nmk (cic.lift cic.prop cic.prop x1)
                      x_110))
                (_z306 :
                   cic.Term cic.prop
                     (matita_basics_logic.eq
                        (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                           (matita_basics_logic.Not
                              (cic.lift cic.prop cic.prop x1)))
                        Hterm
                        (matita_basics_logic.nmk
                           (cic.lift cic.prop cic.prop x1) x_110)) =>
                 P
                   (matita_basics_logic.nmk (cic.lift cic.prop cic.prop x1)
                      x_110)))) =>
      (Hcut :
         cic.Term cic.prop
           (cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)))
                 Hterm Hterm)
              (_z306 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop x1)))
                      Hterm Hterm) =>
               P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
               (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)))
            Hterm))
        (matita_basics_logic.Not_rect_CProp2 (cic.lift cic.prop cic.prop x1)
           (_x_109 :
              cic.Term cic.prop
                (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)) =>
            cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)))
                 Hterm _x_109)
              (_z306 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop x1)))
                      Hterm _x_109) =>
               P _x_109))
           H1 Hterm).

def Not_inv_rect_CProp1 :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
           (x1 : cic.Univ cic.prop =>
            cic.prod cic.prop cic.prop
              (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1))
              (Hterm :
                 cic.Term cic.prop
                   (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)) =>
               cic.prod (cic.type cic.z) cic.prop
                 (cic.prod cic.prop (cic.type cic.z)
                    (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1))
                    (_z311 :
                       cic.Term cic.prop
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop x1)) =>
                     cic.univ cic.prop))
                 (P :
                    cic.Term (cic.type cic.z)
                      (cic.prod cic.prop (cic.type cic.z)
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop x1))
                         (_z311 :
                            cic.Term cic.prop
                              (matita_basics_logic.Not
                                 (cic.lift cic.prop cic.prop x1)) =>
                          cic.univ cic.prop)) =>
                  cic.prod cic.prop cic.prop
                    (cic.prod cic.prop cic.prop
                       (cic.prod cic.prop cic.prop x1
                          (__ : cic.Term cic.prop x1 =>
                           matita_basics_logic.False))
                       (x_113 :
                          cic.Term cic.prop
                            (cic.prod cic.prop cic.prop x1
                               (__ : cic.Term cic.prop x1 =>
                                matita_basics_logic.False)) =>
                        cic.prod cic.prop cic.prop
                          (matita_basics_logic.eq
                             (cic.lift cic.prop
                                (cic.type (cic.s (cic.s cic.z)))
                                (matita_basics_logic.Not
                                   (cic.lift cic.prop cic.prop x1)))
                             Hterm
                             (matita_basics_logic.nmk
                                (cic.lift cic.prop cic.prop x1) x_113))
                          (_z312 :
                             cic.Term cic.prop
                               (matita_basics_logic.eq
                                  (cic.lift cic.prop
                                     (cic.type (cic.s (cic.s cic.z)))
                                     (matita_basics_logic.Not
                                        (cic.lift cic.prop cic.prop x1)))
                                  Hterm
                                  (matita_basics_logic.nmk
                                     (cic.lift cic.prop cic.prop x1) x_113)) =>
                           P
                             (matita_basics_logic.nmk
                                (cic.lift cic.prop cic.prop x1) x_113))))
                    (_H1 :
                       cic.Term cic.prop
                         (cic.prod cic.prop cic.prop
                            (cic.prod cic.prop cic.prop x1
                               (__ : cic.Term cic.prop x1 =>
                                matita_basics_logic.False))
                            (x_113 :
                               cic.Term cic.prop
                                 (cic.prod cic.prop cic.prop x1
                                    (__ : cic.Term cic.prop x1 =>
                                     matita_basics_logic.False)) =>
                             cic.prod cic.prop cic.prop
                               (matita_basics_logic.eq
                                  (cic.lift cic.prop
                                     (cic.type (cic.s (cic.s cic.z)))
                                     (matita_basics_logic.Not
                                        (cic.lift cic.prop cic.prop x1)))
                                  Hterm
                                  (matita_basics_logic.nmk
                                     (cic.lift cic.prop cic.prop x1) x_113))
                               (_z312 :
                                  cic.Term cic.prop
                                    (matita_basics_logic.eq
                                       (cic.lift cic.prop
                                          (cic.type (cic.s (cic.s cic.z)))
                                          (matita_basics_logic.Not
                                             (cic.lift cic.prop cic.prop x1)))
                                       Hterm
                                       (matita_basics_logic.nmk
                                          (cic.lift cic.prop cic.prop x1)
                                          x_113)) =>
                                P
                                  (matita_basics_logic.nmk
                                     (cic.lift cic.prop cic.prop x1) x_113)))) =>
                     P Hterm)))))
      :=
      x1 : cic.Univ cic.prop =>
      Hterm :
        cic.Term cic.prop
          (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)) =>
      P :
        cic.Term (cic.type cic.z)
          (cic.prod cic.prop (cic.type cic.z)
             (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1))
             (_z311 :
                cic.Term cic.prop
                  (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)) =>
              cic.univ cic.prop)) =>
      H1 :
        cic.Term cic.prop
          (cic.prod cic.prop cic.prop
             (cic.prod cic.prop cic.prop x1
                (__ : cic.Term cic.prop x1 => matita_basics_logic.False))
             (x_113 :
                cic.Term cic.prop
                  (cic.prod cic.prop cic.prop x1
                     (__ : cic.Term cic.prop x1 => matita_basics_logic.False)) =>
              cic.prod cic.prop cic.prop
                (matita_basics_logic.eq
                   (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop x1)))
                   Hterm
                   (matita_basics_logic.nmk (cic.lift cic.prop cic.prop x1)
                      x_113))
                (_z312 :
                   cic.Term cic.prop
                     (matita_basics_logic.eq
                        (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                           (matita_basics_logic.Not
                              (cic.lift cic.prop cic.prop x1)))
                        Hterm
                        (matita_basics_logic.nmk
                           (cic.lift cic.prop cic.prop x1) x_113)) =>
                 P
                   (matita_basics_logic.nmk (cic.lift cic.prop cic.prop x1)
                      x_113)))) =>
      (Hcut :
         cic.Term cic.prop
           (cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)))
                 Hterm Hterm)
              (_z312 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop x1)))
                      Hterm Hterm) =>
               P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
               (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)))
            Hterm))
        (matita_basics_logic.Not_rect_CProp1 (cic.lift cic.prop cic.prop x1)
           (_x_112 :
              cic.Term cic.prop
                (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)) =>
            cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)))
                 Hterm _x_112)
              (_z312 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop x1)))
                      Hterm _x_112) =>
               P _x_112))
           H1 Hterm).

def Not_inv_rect_CProp0 :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
           (x1 : cic.Univ cic.prop =>
            cic.prod cic.prop cic.prop
              (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1))
              (Hterm :
                 cic.Term cic.prop
                   (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)) =>
               cic.prod (cic.type cic.z) cic.prop
                 (cic.prod cic.prop (cic.type cic.z)
                    (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1))
                    (_z317 :
                       cic.Term cic.prop
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop x1)) =>
                     cic.univ cic.prop))
                 (P :
                    cic.Term (cic.type cic.z)
                      (cic.prod cic.prop (cic.type cic.z)
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop x1))
                         (_z317 :
                            cic.Term cic.prop
                              (matita_basics_logic.Not
                                 (cic.lift cic.prop cic.prop x1)) =>
                          cic.univ cic.prop)) =>
                  cic.prod cic.prop cic.prop
                    (cic.prod cic.prop cic.prop
                       (cic.prod cic.prop cic.prop x1
                          (__ : cic.Term cic.prop x1 =>
                           matita_basics_logic.False))
                       (x_116 :
                          cic.Term cic.prop
                            (cic.prod cic.prop cic.prop x1
                               (__ : cic.Term cic.prop x1 =>
                                matita_basics_logic.False)) =>
                        cic.prod cic.prop cic.prop
                          (matita_basics_logic.eq
                             (cic.lift cic.prop
                                (cic.type (cic.s (cic.s cic.z)))
                                (matita_basics_logic.Not
                                   (cic.lift cic.prop cic.prop x1)))
                             Hterm
                             (matita_basics_logic.nmk
                                (cic.lift cic.prop cic.prop x1) x_116))
                          (_z318 :
                             cic.Term cic.prop
                               (matita_basics_logic.eq
                                  (cic.lift cic.prop
                                     (cic.type (cic.s (cic.s cic.z)))
                                     (matita_basics_logic.Not
                                        (cic.lift cic.prop cic.prop x1)))
                                  Hterm
                                  (matita_basics_logic.nmk
                                     (cic.lift cic.prop cic.prop x1) x_116)) =>
                           P
                             (matita_basics_logic.nmk
                                (cic.lift cic.prop cic.prop x1) x_116))))
                    (_H1 :
                       cic.Term cic.prop
                         (cic.prod cic.prop cic.prop
                            (cic.prod cic.prop cic.prop x1
                               (__ : cic.Term cic.prop x1 =>
                                matita_basics_logic.False))
                            (x_116 :
                               cic.Term cic.prop
                                 (cic.prod cic.prop cic.prop x1
                                    (__ : cic.Term cic.prop x1 =>
                                     matita_basics_logic.False)) =>
                             cic.prod cic.prop cic.prop
                               (matita_basics_logic.eq
                                  (cic.lift cic.prop
                                     (cic.type (cic.s (cic.s cic.z)))
                                     (matita_basics_logic.Not
                                        (cic.lift cic.prop cic.prop x1)))
                                  Hterm
                                  (matita_basics_logic.nmk
                                     (cic.lift cic.prop cic.prop x1) x_116))
                               (_z318 :
                                  cic.Term cic.prop
                                    (matita_basics_logic.eq
                                       (cic.lift cic.prop
                                          (cic.type (cic.s (cic.s cic.z)))
                                          (matita_basics_logic.Not
                                             (cic.lift cic.prop cic.prop x1)))
                                       Hterm
                                       (matita_basics_logic.nmk
                                          (cic.lift cic.prop cic.prop x1)
                                          x_116)) =>
                                P
                                  (matita_basics_logic.nmk
                                     (cic.lift cic.prop cic.prop x1) x_116)))) =>
                     P Hterm)))))
      :=
      x1 : cic.Univ cic.prop =>
      Hterm :
        cic.Term cic.prop
          (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)) =>
      P :
        cic.Term (cic.type cic.z)
          (cic.prod cic.prop (cic.type cic.z)
             (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1))
             (_z317 :
                cic.Term cic.prop
                  (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)) =>
              cic.univ cic.prop)) =>
      H1 :
        cic.Term cic.prop
          (cic.prod cic.prop cic.prop
             (cic.prod cic.prop cic.prop x1
                (__ : cic.Term cic.prop x1 => matita_basics_logic.False))
             (x_116 :
                cic.Term cic.prop
                  (cic.prod cic.prop cic.prop x1
                     (__ : cic.Term cic.prop x1 => matita_basics_logic.False)) =>
              cic.prod cic.prop cic.prop
                (matita_basics_logic.eq
                   (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                      (matita_basics_logic.Not
                         (cic.lift cic.prop cic.prop x1)))
                   Hterm
                   (matita_basics_logic.nmk (cic.lift cic.prop cic.prop x1)
                      x_116))
                (_z318 :
                   cic.Term cic.prop
                     (matita_basics_logic.eq
                        (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                           (matita_basics_logic.Not
                              (cic.lift cic.prop cic.prop x1)))
                        Hterm
                        (matita_basics_logic.nmk
                           (cic.lift cic.prop cic.prop x1) x_116)) =>
                 P
                   (matita_basics_logic.nmk (cic.lift cic.prop cic.prop x1)
                      x_116)))) =>
      (Hcut :
         cic.Term cic.prop
           (cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)))
                 Hterm Hterm)
              (_z318 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop x1)))
                      Hterm Hterm) =>
               P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
               (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)))
            Hterm))
        (matita_basics_logic.Not_rect_CProp0 (cic.lift cic.prop cic.prop x1)
           (_x_115 :
              cic.Term cic.prop
                (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)) =>
            cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.Not (cic.lift cic.prop cic.prop x1)))
                 Hterm _x_115)
              (_z318 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop x1)))
                      Hterm _x_115) =>
               P _x_115))
           H1 Hterm).

def absurd :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
           (A : cic.Univ cic.prop =>
            cic.prod cic.prop cic.prop A
              (__ : cic.Term cic.prop A =>
               cic.prod cic.prop cic.prop
                 (matita_basics_logic.Not (cic.lift cic.prop cic.prop A))
                 (__1 :
                    cic.Term cic.prop
                      (matita_basics_logic.Not (cic.lift cic.prop cic.prop A)) =>
                  matita_basics_logic.False))))
      :=
      A : cic.Univ cic.prop =>
      H : cic.Term cic.prop A =>
      Hn :
        cic.Term cic.prop
          (matita_basics_logic.Not (cic.lift cic.prop cic.prop A)) =>
      matita_basics_logic.Not_ind (cic.lift cic.prop cic.prop A)
        (_x_79 :
           cic.Term cic.prop
             (matita_basics_logic.Not (cic.lift cic.prop cic.prop A)) =>
         matita_basics_logic.False)
        (_x_80 :
           cic.Term cic.prop
             (cic.prod cic.prop cic.prop A
                (__ : cic.Term cic.prop A => matita_basics_logic.False)) =>
         _x_80 H)
        Hn.

def not_to_not :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
           (A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
              (B : cic.Univ cic.prop =>
               cic.prod cic.prop cic.prop
                 (cic.prod cic.prop cic.prop A
                    (__ : cic.Term cic.prop A => B))
                 (__ :
                    cic.Term cic.prop
                      (cic.prod cic.prop cic.prop A
                         (__ : cic.Term cic.prop A => B)) =>
                  cic.prod cic.prop cic.prop
                    (matita_basics_logic.Not (cic.lift cic.prop cic.prop B))
                    (__1 :
                       cic.Term cic.prop
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop B)) =>
                     matita_basics_logic.Not (cic.lift cic.prop cic.prop A))))))
      :=
      A : cic.Univ cic.prop =>
      B : cic.Univ cic.prop =>
      auto :
        cic.Term cic.prop
          (cic.prod cic.prop cic.prop A (__ : cic.Term cic.prop A => B)) =>
      auto' :
        cic.Term cic.prop
          (matita_basics_logic.Not (cic.lift cic.prop cic.prop B)) =>
      matita_basics_logic.nmk (cic.lift cic.prop cic.prop A)
        (auto'' : cic.Term cic.prop A =>
         matita_basics_logic.absurd (cic.lift cic.prop cic.prop B)
           (auto auto'') auto').

def sym_not_eq :
      cic.Term cic.prop
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z)))) cic.prop
           (cic.univ (cic.type (cic.s (cic.s cic.z))))
           (A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
            cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop A
              (x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop A
                 (y : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                  cic.prod cic.prop cic.prop
                    (matita_basics_logic.Not
                       (cic.lift cic.prop cic.prop
                          (matita_basics_logic.eq
                             (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                (cic.type (cic.s (cic.s cic.z))) A)
                             x y)))
                    (__ :
                       cic.Term cic.prop
                         (matita_basics_logic.Not
                            (cic.lift cic.prop cic.prop
                               (matita_basics_logic.eq
                                  (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                     (cic.type (cic.s (cic.s cic.z))) A)
                                  x y))) =>
                     matita_basics_logic.Not
                       (cic.lift cic.prop cic.prop
                          (matita_basics_logic.eq
                             (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                (cic.type (cic.s (cic.s cic.z))) A)
                             y x)))))))
      :=
      A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
      x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
      y : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
      auto :
        cic.Term cic.prop
          (matita_basics_logic.Not
             (cic.lift cic.prop cic.prop
                (matita_basics_logic.eq
                   (cic.lift (cic.type (cic.s (cic.s cic.z)))
                      (cic.type (cic.s (cic.s cic.z))) A)
                   x y))) =>
      matita_basics_logic.nmk
        (cic.lift cic.prop cic.prop
           (matita_basics_logic.eq
              (cic.lift (cic.type (cic.s (cic.s cic.z)))
                 (cic.type (cic.s (cic.s cic.z))) A)
              y x))
        (auto' :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift (cic.type (cic.s (cic.s cic.z)))
                   (cic.type (cic.s (cic.s cic.z))) A)
                y x) =>
         matita_basics_logic.absurd
           (cic.lift cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift (cic.type (cic.s (cic.s cic.z)))
                    (cic.type (cic.s (cic.s cic.z))) A)
                 x y))
           (matita_basics_logic.rewrite_r
              (cic.lift (cic.type (cic.s (cic.s cic.z)))
                 (cic.type (cic.s (cic.s cic.z))) A)
              x
              (__ : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                 ((x0 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                   matita_basics_logic.eq
                     (cic.lift (cic.type (cic.s (cic.s cic.z)))
                        (cic.type (cic.s (cic.s cic.z))) A)
                     x x0)
                    __))
              (matita_basics_logic.refl
                 (cic.lift (cic.type (cic.s (cic.s cic.z)))
                    (cic.type (cic.s (cic.s cic.z))) A)
                 x)
              y auto')
           auto).

And :
  cic.Term (cic.type cic.z)
    (cic.prod (cic.type cic.z) (cic.type cic.z) (cic.univ cic.prop)
       (_A : cic.Univ cic.prop =>
        cic.prod (cic.type cic.z) (cic.type cic.z) (cic.univ cic.prop)
          (_B : cic.Univ cic.prop => cic.univ cic.prop))).

conj :
  cic.Term cic.prop
    (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
       (A : cic.Univ cic.prop =>
        cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
          (B : cic.Univ cic.prop =>
           cic.prod cic.prop cic.prop A
             (__ : cic.Term cic.prop A =>
              cic.prod cic.prop cic.prop B
                (__1 : cic.Term cic.prop B =>
                 matita_basics_logic.And (cic.lift cic.prop cic.prop A)
                   (cic.lift cic.prop cic.prop B)))))).

def match_And_Prop :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
              (_B : cic.Univ cic.prop =>
               cic.prod (cic.type cic.z) cic.prop
                 (cic.prod cic.prop (cic.type cic.z)
                    (matita_basics_logic.And _A _B)
                    (z : cic.Term cic.prop (matita_basics_logic.And _A _B) =>
                     cic.univ cic.prop))
                 (return_type :
                    cic.Term (cic.type cic.z)
                      (cic.prod cic.prop (cic.type cic.z)
                         (matita_basics_logic.And _A _B)
                         (z :
                            cic.Term cic.prop (matita_basics_logic.And _A _B) =>
                          cic.univ cic.prop)) =>
                  cic.prod cic.prop cic.prop
                    (cic.prod cic.prop cic.prop _A
                       (__ : cic.Term cic.prop _A =>
                        cic.prod cic.prop cic.prop _B
                          (__1 : cic.Term cic.prop _B =>
                           return_type
                             (matita_basics_logic.conj _A _B __ __1))))
                    (case_conj :
                       cic.Term cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             cic.prod cic.prop cic.prop _B
                               (__1 : cic.Term cic.prop _B =>
                                return_type
                                  (matita_basics_logic.conj _A _B __ __1)))) =>
                     cic.prod cic.prop cic.prop
                       (matita_basics_logic.And _A _B)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.And _A _B) =>
                        return_type z)))))).

[ _A, _B, return_type, case_conj, __, __1 ]
  match_And_Prop _A _B return_type case_conj
    (matita_basics_logic.conj _A _B __ __1) -->
  case_conj __ __1.

def match_And_Type5 :
      cic.Term
        (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
        (cic.prod (cic.type cic.z)
           (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
           (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z)
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
              (cic.univ cic.prop)
              (_B : cic.Univ cic.prop =>
               cic.prod
                 (cic.type
                    (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                 (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                 (cic.prod cic.prop
                    (cic.type
                       (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                    (matita_basics_logic.And _A _B)
                    (z : cic.Term cic.prop (matita_basics_logic.And _A _B) =>
                     cic.univ
                       (cic.type
                          (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))))
                 (return_type :
                    cic.Term
                      (cic.type
                         (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                      (cic.prod cic.prop
                         (cic.type
                            (cic.s
                               (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                         (matita_basics_logic.And _A _B)
                         (z :
                            cic.Term cic.prop (matita_basics_logic.And _A _B) =>
                          cic.univ
                            (cic.type
                               (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))) =>
                  cic.prod
                    (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                    (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                    (cic.prod cic.prop
                       (cic.type
                          (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                       _A
                       (__ : cic.Term cic.prop _A =>
                        cic.prod cic.prop
                          (cic.type
                             (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                          _B
                          (__1 : cic.Term cic.prop _B =>
                           return_type
                             (matita_basics_logic.conj _A _B __ __1))))
                    (case_conj :
                       cic.Term
                         (cic.type
                            (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                         (cic.prod cic.prop
                            (cic.type
                               (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                            _A
                            (__ : cic.Term cic.prop _A =>
                             cic.prod cic.prop
                               (cic.type
                                  (cic.s
                                     (cic.s (cic.s (cic.s (cic.s cic.z))))))
                               _B
                               (__1 : cic.Term cic.prop _B =>
                                return_type
                                  (matita_basics_logic.conj _A _B __ __1)))) =>
                     cic.prod cic.prop
                       (cic.type
                          (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                       (matita_basics_logic.And _A _B)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.And _A _B) =>
                        return_type z)))))).

[ _A, _B, return_type, case_conj, __, __1 ]
  match_And_Type5 _A _B return_type case_conj
    (matita_basics_logic.conj _A _B __ __1) -->
  case_conj __ __1.

def match_And_Type4 :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
        (cic.prod (cic.type cic.z)
           (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
           (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z)
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
              (cic.univ cic.prop)
              (_B : cic.Univ cic.prop =>
               cic.prod
                 (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                 (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                 (cic.prod cic.prop
                    (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                    (matita_basics_logic.And _A _B)
                    (z : cic.Term cic.prop (matita_basics_logic.And _A _B) =>
                     cic.univ
                       (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                 (return_type :
                    cic.Term
                      (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                      (cic.prod cic.prop
                         (cic.type
                            (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                         (matita_basics_logic.And _A _B)
                         (z :
                            cic.Term cic.prop (matita_basics_logic.And _A _B) =>
                          cic.univ
                            (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))))) =>
                  cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                    (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                    (cic.prod cic.prop
                       (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))) _A
                       (__ : cic.Term cic.prop _A =>
                        cic.prod cic.prop
                          (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))) _B
                          (__1 : cic.Term cic.prop _B =>
                           return_type
                             (matita_basics_logic.conj _A _B __ __1))))
                    (case_conj :
                       cic.Term
                         (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                         (cic.prod cic.prop
                            (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                            _A
                            (__ : cic.Term cic.prop _A =>
                             cic.prod cic.prop
                               (cic.type
                                  (cic.s (cic.s (cic.s (cic.s cic.z)))))
                               _B
                               (__1 : cic.Term cic.prop _B =>
                                return_type
                                  (matita_basics_logic.conj _A _B __ __1)))) =>
                     cic.prod cic.prop
                       (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                       (matita_basics_logic.And _A _B)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.And _A _B) =>
                        return_type z)))))).

[ _A, _B, return_type, case_conj, __, __1 ]
  match_And_Type4 _A _B return_type case_conj
    (matita_basics_logic.conj _A _B __ __1) -->
  case_conj __ __1.

def match_And_Type3 :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
        (cic.prod (cic.type cic.z)
           (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
           (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z)
              (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
              (cic.univ cic.prop)
              (_B : cic.Univ cic.prop =>
               cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                 (cic.type (cic.s (cic.s (cic.s cic.z))))
                 (cic.prod cic.prop
                    (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                    (matita_basics_logic.And _A _B)
                    (z : cic.Term cic.prop (matita_basics_logic.And _A _B) =>
                     cic.univ (cic.type (cic.s (cic.s (cic.s cic.z))))))
                 (return_type :
                    cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                      (cic.prod cic.prop
                         (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                         (matita_basics_logic.And _A _B)
                         (z :
                            cic.Term cic.prop (matita_basics_logic.And _A _B) =>
                          cic.univ (cic.type (cic.s (cic.s (cic.s cic.z)))))) =>
                  cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
                    (cic.type (cic.s (cic.s (cic.s cic.z))))
                    (cic.prod cic.prop
                       (cic.type (cic.s (cic.s (cic.s cic.z)))) _A
                       (__ : cic.Term cic.prop _A =>
                        cic.prod cic.prop
                          (cic.type (cic.s (cic.s (cic.s cic.z)))) _B
                          (__1 : cic.Term cic.prop _B =>
                           return_type
                             (matita_basics_logic.conj _A _B __ __1))))
                    (case_conj :
                       cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                         (cic.prod cic.prop
                            (cic.type (cic.s (cic.s (cic.s cic.z)))) _A
                            (__ : cic.Term cic.prop _A =>
                             cic.prod cic.prop
                               (cic.type (cic.s (cic.s (cic.s cic.z)))) _B
                               (__1 : cic.Term cic.prop _B =>
                                return_type
                                  (matita_basics_logic.conj _A _B __ __1)))) =>
                     cic.prod cic.prop
                       (cic.type (cic.s (cic.s (cic.s cic.z))))
                       (matita_basics_logic.And _A _B)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.And _A _B) =>
                        return_type z)))))).

[ _A, _B, return_type, case_conj, __, __1 ]
  match_And_Type3 _A _B return_type case_conj
    (matita_basics_logic.conj _A _B __ __1) -->
  case_conj __ __1.

def match_And_Type2 :
      cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
        (cic.prod (cic.type cic.z) (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z)
              (cic.type (cic.s (cic.s (cic.s cic.z)))) (cic.univ cic.prop)
              (_B : cic.Univ cic.prop =>
               cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
                 (cic.type (cic.s (cic.s cic.z)))
                 (cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
                    (matita_basics_logic.And _A _B)
                    (z : cic.Term cic.prop (matita_basics_logic.And _A _B) =>
                     cic.univ (cic.type (cic.s (cic.s cic.z)))))
                 (return_type :
                    cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                      (cic.prod cic.prop
                         (cic.type (cic.s (cic.s (cic.s cic.z))))
                         (matita_basics_logic.And _A _B)
                         (z :
                            cic.Term cic.prop (matita_basics_logic.And _A _B) =>
                          cic.univ (cic.type (cic.s (cic.s cic.z))))) =>
                  cic.prod (cic.type (cic.s (cic.s cic.z)))
                    (cic.type (cic.s (cic.s cic.z)))
                    (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z))) _A
                       (__ : cic.Term cic.prop _A =>
                        cic.prod cic.prop (cic.type (cic.s (cic.s cic.z))) _B
                          (__1 : cic.Term cic.prop _B =>
                           return_type
                             (matita_basics_logic.conj _A _B __ __1))))
                    (case_conj :
                       cic.Term (cic.type (cic.s (cic.s cic.z)))
                         (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                            _A
                            (__ : cic.Term cic.prop _A =>
                             cic.prod cic.prop
                               (cic.type (cic.s (cic.s cic.z))) _B
                               (__1 : cic.Term cic.prop _B =>
                                return_type
                                  (matita_basics_logic.conj _A _B __ __1)))) =>
                     cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                       (matita_basics_logic.And _A _B)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.And _A _B) =>
                        return_type z)))))).

[ _A, _B, return_type, case_conj, __, __1 ]
  match_And_Type2 _A _B return_type case_conj
    (matita_basics_logic.conj _A _B __ __1) -->
  case_conj __ __1.

def match_And_Type1 :
      cic.Term (cic.type (cic.s (cic.s cic.z)))
        (cic.prod (cic.type cic.z) (cic.type (cic.s (cic.s cic.z)))
           (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) (cic.type (cic.s (cic.s cic.z)))
              (cic.univ cic.prop)
              (_B : cic.Univ cic.prop =>
               cic.prod (cic.type (cic.s (cic.s cic.z)))
                 (cic.type (cic.s cic.z))
                 (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.And _A _B)
                    (z : cic.Term cic.prop (matita_basics_logic.And _A _B) =>
                     cic.univ (cic.type (cic.s cic.z))))
                 (return_type :
                    cic.Term (cic.type (cic.s (cic.s cic.z)))
                      (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.And _A _B)
                         (z :
                            cic.Term cic.prop (matita_basics_logic.And _A _B) =>
                          cic.univ (cic.type (cic.s cic.z)))) =>
                  cic.prod (cic.type (cic.s cic.z)) (cic.type (cic.s cic.z))
                    (cic.prod cic.prop (cic.type (cic.s cic.z)) _A
                       (__ : cic.Term cic.prop _A =>
                        cic.prod cic.prop (cic.type (cic.s cic.z)) _B
                          (__1 : cic.Term cic.prop _B =>
                           return_type
                             (matita_basics_logic.conj _A _B __ __1))))
                    (case_conj :
                       cic.Term (cic.type (cic.s cic.z))
                         (cic.prod cic.prop (cic.type (cic.s cic.z)) _A
                            (__ : cic.Term cic.prop _A =>
                             cic.prod cic.prop (cic.type (cic.s cic.z)) _B
                               (__1 : cic.Term cic.prop _B =>
                                return_type
                                  (matita_basics_logic.conj _A _B __ __1)))) =>
                     cic.prod cic.prop (cic.type (cic.s cic.z))
                       (matita_basics_logic.And _A _B)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.And _A _B) =>
                        return_type z)))))).

[ _A, _B, return_type, case_conj, __, __1 ]
  match_And_Type1 _A _B return_type case_conj
    (matita_basics_logic.conj _A _B __ __1) -->
  case_conj __ __1.

def match_And_Type0 :
      cic.Term (cic.type (cic.s cic.z))
        (cic.prod (cic.type cic.z) (cic.type (cic.s cic.z))
           (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) (cic.type (cic.s cic.z))
              (cic.univ cic.prop)
              (_B : cic.Univ cic.prop =>
               cic.prod (cic.type (cic.s cic.z)) (cic.type cic.z)
                 (cic.prod cic.prop (cic.type (cic.s cic.z))
                    (matita_basics_logic.And _A _B)
                    (z : cic.Term cic.prop (matita_basics_logic.And _A _B) =>
                     cic.univ (cic.type cic.z)))
                 (return_type :
                    cic.Term (cic.type (cic.s cic.z))
                      (cic.prod cic.prop (cic.type (cic.s cic.z))
                         (matita_basics_logic.And _A _B)
                         (z :
                            cic.Term cic.prop (matita_basics_logic.And _A _B) =>
                          cic.univ (cic.type cic.z))) =>
                  cic.prod (cic.type cic.z) (cic.type cic.z)
                    (cic.prod cic.prop (cic.type cic.z) _A
                       (__ : cic.Term cic.prop _A =>
                        cic.prod cic.prop (cic.type cic.z) _B
                          (__1 : cic.Term cic.prop _B =>
                           return_type
                             (matita_basics_logic.conj _A _B __ __1))))
                    (case_conj :
                       cic.Term (cic.type cic.z)
                         (cic.prod cic.prop (cic.type cic.z) _A
                            (__ : cic.Term cic.prop _A =>
                             cic.prod cic.prop (cic.type cic.z) _B
                               (__1 : cic.Term cic.prop _B =>
                                return_type
                                  (matita_basics_logic.conj _A _B __ __1)))) =>
                     cic.prod cic.prop (cic.type cic.z)
                       (matita_basics_logic.And _A _B)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.And _A _B) =>
                        return_type z)))))).

[ _A, _B, return_type, case_conj, __, __1 ]
  match_And_Type0 _A _B return_type case_conj
    (matita_basics_logic.conj _A _B __ __1) -->
  case_conj __ __1.

def filter_And_Prop :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
              (_B : cic.Univ cic.prop =>
               cic.prod (cic.type cic.z) cic.prop
                 (cic.prod cic.prop (cic.type cic.z)
                    (matita_basics_logic.And _A _B)
                    (z : cic.Term cic.prop (matita_basics_logic.And _A _B) =>
                     cic.univ cic.prop))
                 (return_type :
                    cic.Term (cic.type cic.z)
                      (cic.prod cic.prop (cic.type cic.z)
                         (matita_basics_logic.And _A _B)
                         (z :
                            cic.Term cic.prop (matita_basics_logic.And _A _B) =>
                          cic.univ cic.prop)) =>
                  cic.prod cic.prop cic.prop
                    (cic.prod cic.prop cic.prop
                       (matita_basics_logic.And _A _B)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.And _A _B) =>
                        return_type z))
                    (return :
                       cic.Term cic.prop
                         (cic.prod cic.prop cic.prop
                            (matita_basics_logic.And _A _B)
                            (z :
                               cic.Term cic.prop
                                 (matita_basics_logic.And _A _B) =>
                             return_type z)) =>
                     cic.prod cic.prop cic.prop
                       (matita_basics_logic.And _A _B)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.And _A _B) =>
                        return_type z)))))).

[ A, B, __, __1, return_type, return ]
  filter_And_Prop (A) (B) return_type return
    (matita_basics_logic.conj A B __ __1) -->
  return (matita_basics_logic.conj A B __ __1).

def filter_And_Type5 :
      cic.Term
        (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
        (cic.prod (cic.type cic.z)
           (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
           (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z)
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
              (cic.univ cic.prop)
              (_B : cic.Univ cic.prop =>
               cic.prod
                 (cic.type
                    (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                 (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                 (cic.prod cic.prop
                    (cic.type
                       (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                    (matita_basics_logic.And _A _B)
                    (z : cic.Term cic.prop (matita_basics_logic.And _A _B) =>
                     cic.univ
                       (cic.type
                          (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))))
                 (return_type :
                    cic.Term
                      (cic.type
                         (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                      (cic.prod cic.prop
                         (cic.type
                            (cic.s
                               (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                         (matita_basics_logic.And _A _B)
                         (z :
                            cic.Term cic.prop (matita_basics_logic.And _A _B) =>
                          cic.univ
                            (cic.type
                               (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))) =>
                  cic.prod
                    (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                    (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                    (cic.prod cic.prop
                       (cic.type
                          (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                       (matita_basics_logic.And _A _B)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.And _A _B) =>
                        return_type z))
                    (return :
                       cic.Term
                         (cic.type
                            (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                         (cic.prod cic.prop
                            (cic.type
                               (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                            (matita_basics_logic.And _A _B)
                            (z :
                               cic.Term cic.prop
                                 (matita_basics_logic.And _A _B) =>
                             return_type z)) =>
                     cic.prod cic.prop
                       (cic.type
                          (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                       (matita_basics_logic.And _A _B)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.And _A _B) =>
                        return_type z)))))).

[ A, B, __, __1, return_type, return ]
  filter_And_Type5 (A) (B) return_type return
    (matita_basics_logic.conj A B __ __1) -->
  return (matita_basics_logic.conj A B __ __1).

def filter_And_Type4 :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
        (cic.prod (cic.type cic.z)
           (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
           (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z)
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
              (cic.univ cic.prop)
              (_B : cic.Univ cic.prop =>
               cic.prod
                 (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                 (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                 (cic.prod cic.prop
                    (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                    (matita_basics_logic.And _A _B)
                    (z : cic.Term cic.prop (matita_basics_logic.And _A _B) =>
                     cic.univ
                       (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                 (return_type :
                    cic.Term
                      (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                      (cic.prod cic.prop
                         (cic.type
                            (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                         (matita_basics_logic.And _A _B)
                         (z :
                            cic.Term cic.prop (matita_basics_logic.And _A _B) =>
                          cic.univ
                            (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))))) =>
                  cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                    (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                    (cic.prod cic.prop
                       (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                       (matita_basics_logic.And _A _B)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.And _A _B) =>
                        return_type z))
                    (return :
                       cic.Term
                         (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                         (cic.prod cic.prop
                            (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                            (matita_basics_logic.And _A _B)
                            (z :
                               cic.Term cic.prop
                                 (matita_basics_logic.And _A _B) =>
                             return_type z)) =>
                     cic.prod cic.prop
                       (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                       (matita_basics_logic.And _A _B)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.And _A _B) =>
                        return_type z)))))).

[ A, B, __, __1, return_type, return ]
  filter_And_Type4 (A) (B) return_type return
    (matita_basics_logic.conj A B __ __1) -->
  return (matita_basics_logic.conj A B __ __1).

def filter_And_Type3 :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
        (cic.prod (cic.type cic.z)
           (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
           (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z)
              (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
              (cic.univ cic.prop)
              (_B : cic.Univ cic.prop =>
               cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                 (cic.type (cic.s (cic.s (cic.s cic.z))))
                 (cic.prod cic.prop
                    (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                    (matita_basics_logic.And _A _B)
                    (z : cic.Term cic.prop (matita_basics_logic.And _A _B) =>
                     cic.univ (cic.type (cic.s (cic.s (cic.s cic.z))))))
                 (return_type :
                    cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                      (cic.prod cic.prop
                         (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                         (matita_basics_logic.And _A _B)
                         (z :
                            cic.Term cic.prop (matita_basics_logic.And _A _B) =>
                          cic.univ (cic.type (cic.s (cic.s (cic.s cic.z)))))) =>
                  cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
                    (cic.type (cic.s (cic.s (cic.s cic.z))))
                    (cic.prod cic.prop
                       (cic.type (cic.s (cic.s (cic.s cic.z))))
                       (matita_basics_logic.And _A _B)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.And _A _B) =>
                        return_type z))
                    (return :
                       cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                         (cic.prod cic.prop
                            (cic.type (cic.s (cic.s (cic.s cic.z))))
                            (matita_basics_logic.And _A _B)
                            (z :
                               cic.Term cic.prop
                                 (matita_basics_logic.And _A _B) =>
                             return_type z)) =>
                     cic.prod cic.prop
                       (cic.type (cic.s (cic.s (cic.s cic.z))))
                       (matita_basics_logic.And _A _B)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.And _A _B) =>
                        return_type z)))))).

[ A, B, __, __1, return_type, return ]
  filter_And_Type3 (A) (B) return_type return
    (matita_basics_logic.conj A B __ __1) -->
  return (matita_basics_logic.conj A B __ __1).

def filter_And_Type2 :
      cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
        (cic.prod (cic.type cic.z) (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z)
              (cic.type (cic.s (cic.s (cic.s cic.z)))) (cic.univ cic.prop)
              (_B : cic.Univ cic.prop =>
               cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
                 (cic.type (cic.s (cic.s cic.z)))
                 (cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
                    (matita_basics_logic.And _A _B)
                    (z : cic.Term cic.prop (matita_basics_logic.And _A _B) =>
                     cic.univ (cic.type (cic.s (cic.s cic.z)))))
                 (return_type :
                    cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                      (cic.prod cic.prop
                         (cic.type (cic.s (cic.s (cic.s cic.z))))
                         (matita_basics_logic.And _A _B)
                         (z :
                            cic.Term cic.prop (matita_basics_logic.And _A _B) =>
                          cic.univ (cic.type (cic.s (cic.s cic.z))))) =>
                  cic.prod (cic.type (cic.s (cic.s cic.z)))
                    (cic.type (cic.s (cic.s cic.z)))
                    (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                       (matita_basics_logic.And _A _B)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.And _A _B) =>
                        return_type z))
                    (return :
                       cic.Term (cic.type (cic.s (cic.s cic.z)))
                         (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                            (matita_basics_logic.And _A _B)
                            (z :
                               cic.Term cic.prop
                                 (matita_basics_logic.And _A _B) =>
                             return_type z)) =>
                     cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                       (matita_basics_logic.And _A _B)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.And _A _B) =>
                        return_type z)))))).

[ A, B, __, __1, return_type, return ]
  filter_And_Type2 (A) (B) return_type return
    (matita_basics_logic.conj A B __ __1) -->
  return (matita_basics_logic.conj A B __ __1).

def filter_And_Type1 :
      cic.Term (cic.type (cic.s (cic.s cic.z)))
        (cic.prod (cic.type cic.z) (cic.type (cic.s (cic.s cic.z)))
           (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) (cic.type (cic.s (cic.s cic.z)))
              (cic.univ cic.prop)
              (_B : cic.Univ cic.prop =>
               cic.prod (cic.type (cic.s (cic.s cic.z)))
                 (cic.type (cic.s cic.z))
                 (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.And _A _B)
                    (z : cic.Term cic.prop (matita_basics_logic.And _A _B) =>
                     cic.univ (cic.type (cic.s cic.z))))
                 (return_type :
                    cic.Term (cic.type (cic.s (cic.s cic.z)))
                      (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.And _A _B)
                         (z :
                            cic.Term cic.prop (matita_basics_logic.And _A _B) =>
                          cic.univ (cic.type (cic.s cic.z)))) =>
                  cic.prod (cic.type (cic.s cic.z)) (cic.type (cic.s cic.z))
                    (cic.prod cic.prop (cic.type (cic.s cic.z))
                       (matita_basics_logic.And _A _B)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.And _A _B) =>
                        return_type z))
                    (return :
                       cic.Term (cic.type (cic.s cic.z))
                         (cic.prod cic.prop (cic.type (cic.s cic.z))
                            (matita_basics_logic.And _A _B)
                            (z :
                               cic.Term cic.prop
                                 (matita_basics_logic.And _A _B) =>
                             return_type z)) =>
                     cic.prod cic.prop (cic.type (cic.s cic.z))
                       (matita_basics_logic.And _A _B)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.And _A _B) =>
                        return_type z)))))).

[ A, B, __, __1, return_type, return ]
  filter_And_Type1 (A) (B) return_type return
    (matita_basics_logic.conj A B __ __1) -->
  return (matita_basics_logic.conj A B __ __1).

def filter_And_Type0 :
      cic.Term (cic.type (cic.s cic.z))
        (cic.prod (cic.type cic.z) (cic.type (cic.s cic.z))
           (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) (cic.type (cic.s cic.z))
              (cic.univ cic.prop)
              (_B : cic.Univ cic.prop =>
               cic.prod (cic.type (cic.s cic.z)) (cic.type cic.z)
                 (cic.prod cic.prop (cic.type (cic.s cic.z))
                    (matita_basics_logic.And _A _B)
                    (z : cic.Term cic.prop (matita_basics_logic.And _A _B) =>
                     cic.univ (cic.type cic.z)))
                 (return_type :
                    cic.Term (cic.type (cic.s cic.z))
                      (cic.prod cic.prop (cic.type (cic.s cic.z))
                         (matita_basics_logic.And _A _B)
                         (z :
                            cic.Term cic.prop (matita_basics_logic.And _A _B) =>
                          cic.univ (cic.type cic.z))) =>
                  cic.prod (cic.type cic.z) (cic.type cic.z)
                    (cic.prod cic.prop (cic.type cic.z)
                       (matita_basics_logic.And _A _B)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.And _A _B) =>
                        return_type z))
                    (return :
                       cic.Term (cic.type cic.z)
                         (cic.prod cic.prop (cic.type cic.z)
                            (matita_basics_logic.And _A _B)
                            (z :
                               cic.Term cic.prop
                                 (matita_basics_logic.And _A _B) =>
                             return_type z)) =>
                     cic.prod cic.prop (cic.type cic.z)
                       (matita_basics_logic.And _A _B)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.And _A _B) =>
                        return_type z)))))).

[ A, B, __, __1, return_type, return ]
  filter_And_Type0 (A) (B) return_type return
    (matita_basics_logic.conj A B __ __1) -->
  return (matita_basics_logic.conj A B __ __1).

def And_ind :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
              (_B : cic.Univ cic.prop =>
               cic.prod (cic.type cic.z) cic.prop
                 (cic.prod cic.prop (cic.type cic.z)
                    (matita_basics_logic.And (cic.lift cic.prop cic.prop _A)
                       (cic.lift cic.prop cic.prop _B))
                    (_x_118 :
                       cic.Term cic.prop
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop _A)
                            (cic.lift cic.prop cic.prop _B)) =>
                     cic.univ cic.prop))
                 (Q_ :
                    cic.Term (cic.type cic.z)
                      (cic.prod cic.prop (cic.type cic.z)
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop _A)
                            (cic.lift cic.prop cic.prop _B))
                         (_x_118 :
                            cic.Term cic.prop
                              (matita_basics_logic.And
                                 (cic.lift cic.prop cic.prop _A)
                                 (cic.lift cic.prop cic.prop _B)) =>
                          cic.univ cic.prop)) =>
                  cic.prod cic.prop cic.prop
                    (cic.prod cic.prop cic.prop _A
                       (x_120 : cic.Term cic.prop _A =>
                        cic.prod cic.prop cic.prop _B
                          (x_119 : cic.Term cic.prop _B =>
                           Q_
                             (matita_basics_logic.conj
                                (cic.lift cic.prop cic.prop _A)
                                (cic.lift cic.prop cic.prop _B) x_120 x_119))))
                    (_H_conj :
                       cic.Term cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (x_120 : cic.Term cic.prop _A =>
                             cic.prod cic.prop cic.prop _B
                               (x_119 : cic.Term cic.prop _B =>
                                Q_
                                  (matita_basics_logic.conj
                                     (cic.lift cic.prop cic.prop _A)
                                     (cic.lift cic.prop cic.prop _B) x_120
                                     x_119)))) =>
                     cic.prod cic.prop cic.prop
                       (matita_basics_logic.And
                          (cic.lift cic.prop cic.prop _A)
                          (cic.lift cic.prop cic.prop _B))
                       (x_118 :
                          cic.Term cic.prop
                            (matita_basics_logic.And
                               (cic.lift cic.prop cic.prop _A)
                               (cic.lift cic.prop cic.prop _B)) =>
                        Q_ x_118)))))).

def And_ind_body :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
              (_B : cic.Univ cic.prop =>
               cic.prod (cic.type cic.z) cic.prop
                 (cic.prod cic.prop (cic.type cic.z)
                    (matita_basics_logic.And (cic.lift cic.prop cic.prop _A)
                       (cic.lift cic.prop cic.prop _B))
                    (_x_118 :
                       cic.Term cic.prop
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop _A)
                            (cic.lift cic.prop cic.prop _B)) =>
                     cic.univ cic.prop))
                 (Q_ :
                    cic.Term (cic.type cic.z)
                      (cic.prod cic.prop (cic.type cic.z)
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop _A)
                            (cic.lift cic.prop cic.prop _B))
                         (_x_118 :
                            cic.Term cic.prop
                              (matita_basics_logic.And
                                 (cic.lift cic.prop cic.prop _A)
                                 (cic.lift cic.prop cic.prop _B)) =>
                          cic.univ cic.prop)) =>
                  cic.prod cic.prop cic.prop
                    (cic.prod cic.prop cic.prop _A
                       (x_120 : cic.Term cic.prop _A =>
                        cic.prod cic.prop cic.prop _B
                          (x_119 : cic.Term cic.prop _B =>
                           Q_
                             (matita_basics_logic.conj
                                (cic.lift cic.prop cic.prop _A)
                                (cic.lift cic.prop cic.prop _B) x_120 x_119))))
                    (_H_conj :
                       cic.Term cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (x_120 : cic.Term cic.prop _A =>
                             cic.prod cic.prop cic.prop _B
                               (x_119 : cic.Term cic.prop _B =>
                                Q_
                                  (matita_basics_logic.conj
                                     (cic.lift cic.prop cic.prop _A)
                                     (cic.lift cic.prop cic.prop _B) x_120
                                     x_119)))) =>
                     cic.prod cic.prop cic.prop
                       (matita_basics_logic.And
                          (cic.lift cic.prop cic.prop _A)
                          (cic.lift cic.prop cic.prop _B))
                       (x_118 :
                          cic.Term cic.prop
                            (matita_basics_logic.And
                               (cic.lift cic.prop cic.prop _A)
                               (cic.lift cic.prop cic.prop _B)) =>
                        Q_ x_118)))))).

[ _A, _B, Q_, _H_conj, x_118 ] And_ind _A _B Q_ _H_conj x_118 -->
  matita_basics_logic.filter_And_Prop _A _B
    (x_118 :
       cic.Term cic.prop
         (matita_basics_logic.And (cic.lift cic.prop cic.prop _A)
            (cic.lift cic.prop cic.prop _B)) =>
     Q_ x_118)
    (matita_basics_logic.And_ind_body _A _B Q_ _H_conj) x_118.

[ _A, _B, Q_, _H_conj, x_118 ] And_ind_body _A _B Q_ _H_conj x_118 -->
  matita_basics_logic.match_And_Prop (cic.lift cic.prop cic.prop _A)
    (cic.lift cic.prop cic.prop _B) Q_
    (x_120 : cic.Term cic.prop _A =>
     x_119 : cic.Term cic.prop _B => _H_conj x_120 x_119)
    x_118.

def And_rect_Type4 :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
        (cic.prod (cic.type cic.z)
           (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
           (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z)
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
              (cic.univ cic.prop)
              (_B : cic.Univ cic.prop =>
               cic.prod
                 (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                 (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                 (cic.prod cic.prop
                    (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                    (matita_basics_logic.And (cic.lift cic.prop cic.prop _A)
                       (cic.lift cic.prop cic.prop _B))
                    (_x_122 :
                       cic.Term cic.prop
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop _A)
                            (cic.lift cic.prop cic.prop _B)) =>
                     cic.univ
                       (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                 (Q_ :
                    cic.Term
                      (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                      (cic.prod cic.prop
                         (cic.type
                            (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop _A)
                            (cic.lift cic.prop cic.prop _B))
                         (_x_122 :
                            cic.Term cic.prop
                              (matita_basics_logic.And
                                 (cic.lift cic.prop cic.prop _A)
                                 (cic.lift cic.prop cic.prop _B)) =>
                          cic.univ
                            (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))))) =>
                  cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                    (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                    (cic.prod cic.prop
                       (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))) _A
                       (x_124 : cic.Term cic.prop _A =>
                        cic.prod cic.prop
                          (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))) _B
                          (x_123 : cic.Term cic.prop _B =>
                           Q_
                             (matita_basics_logic.conj
                                (cic.lift cic.prop cic.prop _A)
                                (cic.lift cic.prop cic.prop _B) x_124 x_123))))
                    (_H_conj :
                       cic.Term
                         (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                         (cic.prod cic.prop
                            (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                            _A
                            (x_124 : cic.Term cic.prop _A =>
                             cic.prod cic.prop
                               (cic.type
                                  (cic.s (cic.s (cic.s (cic.s cic.z)))))
                               _B
                               (x_123 : cic.Term cic.prop _B =>
                                Q_
                                  (matita_basics_logic.conj
                                     (cic.lift cic.prop cic.prop _A)
                                     (cic.lift cic.prop cic.prop _B) x_124
                                     x_123)))) =>
                     cic.prod cic.prop
                       (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                       (matita_basics_logic.And
                          (cic.lift cic.prop cic.prop _A)
                          (cic.lift cic.prop cic.prop _B))
                       (x_122 :
                          cic.Term cic.prop
                            (matita_basics_logic.And
                               (cic.lift cic.prop cic.prop _A)
                               (cic.lift cic.prop cic.prop _B)) =>
                        Q_ x_122)))))).

def And_rect_Type4_body :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
        (cic.prod (cic.type cic.z)
           (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
           (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z)
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
              (cic.univ cic.prop)
              (_B : cic.Univ cic.prop =>
               cic.prod
                 (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                 (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                 (cic.prod cic.prop
                    (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                    (matita_basics_logic.And (cic.lift cic.prop cic.prop _A)
                       (cic.lift cic.prop cic.prop _B))
                    (_x_122 :
                       cic.Term cic.prop
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop _A)
                            (cic.lift cic.prop cic.prop _B)) =>
                     cic.univ
                       (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                 (Q_ :
                    cic.Term
                      (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                      (cic.prod cic.prop
                         (cic.type
                            (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop _A)
                            (cic.lift cic.prop cic.prop _B))
                         (_x_122 :
                            cic.Term cic.prop
                              (matita_basics_logic.And
                                 (cic.lift cic.prop cic.prop _A)
                                 (cic.lift cic.prop cic.prop _B)) =>
                          cic.univ
                            (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))))) =>
                  cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                    (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                    (cic.prod cic.prop
                       (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))) _A
                       (x_124 : cic.Term cic.prop _A =>
                        cic.prod cic.prop
                          (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))) _B
                          (x_123 : cic.Term cic.prop _B =>
                           Q_
                             (matita_basics_logic.conj
                                (cic.lift cic.prop cic.prop _A)
                                (cic.lift cic.prop cic.prop _B) x_124 x_123))))
                    (_H_conj :
                       cic.Term
                         (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                         (cic.prod cic.prop
                            (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                            _A
                            (x_124 : cic.Term cic.prop _A =>
                             cic.prod cic.prop
                               (cic.type
                                  (cic.s (cic.s (cic.s (cic.s cic.z)))))
                               _B
                               (x_123 : cic.Term cic.prop _B =>
                                Q_
                                  (matita_basics_logic.conj
                                     (cic.lift cic.prop cic.prop _A)
                                     (cic.lift cic.prop cic.prop _B) x_124
                                     x_123)))) =>
                     cic.prod cic.prop
                       (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                       (matita_basics_logic.And
                          (cic.lift cic.prop cic.prop _A)
                          (cic.lift cic.prop cic.prop _B))
                       (x_122 :
                          cic.Term cic.prop
                            (matita_basics_logic.And
                               (cic.lift cic.prop cic.prop _A)
                               (cic.lift cic.prop cic.prop _B)) =>
                        Q_ x_122)))))).

[ _A, _B, Q_, _H_conj, x_122 ] And_rect_Type4 _A _B Q_ _H_conj x_122 -->
  matita_basics_logic.filter_And_Type4 _A _B
    (x_122 :
       cic.Term cic.prop
         (matita_basics_logic.And (cic.lift cic.prop cic.prop _A)
            (cic.lift cic.prop cic.prop _B)) =>
     Q_ x_122)
    (matita_basics_logic.And_rect_Type4_body _A _B Q_ _H_conj) x_122.

[ _A, _B, Q_, _H_conj, x_122 ] And_rect_Type4_body _A _B Q_ _H_conj x_122 -->
  matita_basics_logic.match_And_Type4 (cic.lift cic.prop cic.prop _A)
    (cic.lift cic.prop cic.prop _B) Q_
    (x_124 : cic.Term cic.prop _A =>
     x_123 : cic.Term cic.prop _B => _H_conj x_124 x_123)
    x_122.

def And_rect_Type5 :
      cic.Term
        (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
        (cic.prod (cic.type cic.z)
           (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
           (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z)
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
              (cic.univ cic.prop)
              (_B : cic.Univ cic.prop =>
               cic.prod
                 (cic.type
                    (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                 (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                 (cic.prod cic.prop
                    (cic.type
                       (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                    (matita_basics_logic.And (cic.lift cic.prop cic.prop _A)
                       (cic.lift cic.prop cic.prop _B))
                    (_x_126 :
                       cic.Term cic.prop
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop _A)
                            (cic.lift cic.prop cic.prop _B)) =>
                     cic.univ
                       (cic.type
                          (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))))
                 (Q_ :
                    cic.Term
                      (cic.type
                         (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                      (cic.prod cic.prop
                         (cic.type
                            (cic.s
                               (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop _A)
                            (cic.lift cic.prop cic.prop _B))
                         (_x_126 :
                            cic.Term cic.prop
                              (matita_basics_logic.And
                                 (cic.lift cic.prop cic.prop _A)
                                 (cic.lift cic.prop cic.prop _B)) =>
                          cic.univ
                            (cic.type
                               (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))) =>
                  cic.prod
                    (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                    (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                    (cic.prod cic.prop
                       (cic.type
                          (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                       _A
                       (x_128 : cic.Term cic.prop _A =>
                        cic.prod cic.prop
                          (cic.type
                             (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                          _B
                          (x_127 : cic.Term cic.prop _B =>
                           Q_
                             (matita_basics_logic.conj
                                (cic.lift cic.prop cic.prop _A)
                                (cic.lift cic.prop cic.prop _B) x_128 x_127))))
                    (_H_conj :
                       cic.Term
                         (cic.type
                            (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                         (cic.prod cic.prop
                            (cic.type
                               (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                            _A
                            (x_128 : cic.Term cic.prop _A =>
                             cic.prod cic.prop
                               (cic.type
                                  (cic.s
                                     (cic.s (cic.s (cic.s (cic.s cic.z))))))
                               _B
                               (x_127 : cic.Term cic.prop _B =>
                                Q_
                                  (matita_basics_logic.conj
                                     (cic.lift cic.prop cic.prop _A)
                                     (cic.lift cic.prop cic.prop _B) x_128
                                     x_127)))) =>
                     cic.prod cic.prop
                       (cic.type
                          (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                       (matita_basics_logic.And
                          (cic.lift cic.prop cic.prop _A)
                          (cic.lift cic.prop cic.prop _B))
                       (x_126 :
                          cic.Term cic.prop
                            (matita_basics_logic.And
                               (cic.lift cic.prop cic.prop _A)
                               (cic.lift cic.prop cic.prop _B)) =>
                        Q_ x_126)))))).

def And_rect_Type5_body :
      cic.Term
        (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
        (cic.prod (cic.type cic.z)
           (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
           (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z)
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
              (cic.univ cic.prop)
              (_B : cic.Univ cic.prop =>
               cic.prod
                 (cic.type
                    (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                 (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                 (cic.prod cic.prop
                    (cic.type
                       (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                    (matita_basics_logic.And (cic.lift cic.prop cic.prop _A)
                       (cic.lift cic.prop cic.prop _B))
                    (_x_126 :
                       cic.Term cic.prop
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop _A)
                            (cic.lift cic.prop cic.prop _B)) =>
                     cic.univ
                       (cic.type
                          (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))))
                 (Q_ :
                    cic.Term
                      (cic.type
                         (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                      (cic.prod cic.prop
                         (cic.type
                            (cic.s
                               (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop _A)
                            (cic.lift cic.prop cic.prop _B))
                         (_x_126 :
                            cic.Term cic.prop
                              (matita_basics_logic.And
                                 (cic.lift cic.prop cic.prop _A)
                                 (cic.lift cic.prop cic.prop _B)) =>
                          cic.univ
                            (cic.type
                               (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))) =>
                  cic.prod
                    (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                    (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                    (cic.prod cic.prop
                       (cic.type
                          (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                       _A
                       (x_128 : cic.Term cic.prop _A =>
                        cic.prod cic.prop
                          (cic.type
                             (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                          _B
                          (x_127 : cic.Term cic.prop _B =>
                           Q_
                             (matita_basics_logic.conj
                                (cic.lift cic.prop cic.prop _A)
                                (cic.lift cic.prop cic.prop _B) x_128 x_127))))
                    (_H_conj :
                       cic.Term
                         (cic.type
                            (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                         (cic.prod cic.prop
                            (cic.type
                               (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                            _A
                            (x_128 : cic.Term cic.prop _A =>
                             cic.prod cic.prop
                               (cic.type
                                  (cic.s
                                     (cic.s (cic.s (cic.s (cic.s cic.z))))))
                               _B
                               (x_127 : cic.Term cic.prop _B =>
                                Q_
                                  (matita_basics_logic.conj
                                     (cic.lift cic.prop cic.prop _A)
                                     (cic.lift cic.prop cic.prop _B) x_128
                                     x_127)))) =>
                     cic.prod cic.prop
                       (cic.type
                          (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                       (matita_basics_logic.And
                          (cic.lift cic.prop cic.prop _A)
                          (cic.lift cic.prop cic.prop _B))
                       (x_126 :
                          cic.Term cic.prop
                            (matita_basics_logic.And
                               (cic.lift cic.prop cic.prop _A)
                               (cic.lift cic.prop cic.prop _B)) =>
                        Q_ x_126)))))).

[ _A, _B, Q_, _H_conj, x_126 ] And_rect_Type5 _A _B Q_ _H_conj x_126 -->
  matita_basics_logic.filter_And_Type5 _A _B
    (x_126 :
       cic.Term cic.prop
         (matita_basics_logic.And (cic.lift cic.prop cic.prop _A)
            (cic.lift cic.prop cic.prop _B)) =>
     Q_ x_126)
    (matita_basics_logic.And_rect_Type5_body _A _B Q_ _H_conj) x_126.

[ _A, _B, Q_, _H_conj, x_126 ] And_rect_Type5_body _A _B Q_ _H_conj x_126 -->
  matita_basics_logic.match_And_Type5 (cic.lift cic.prop cic.prop _A)
    (cic.lift cic.prop cic.prop _B) Q_
    (x_128 : cic.Term cic.prop _A =>
     x_127 : cic.Term cic.prop _B => _H_conj x_128 x_127)
    x_126.

def And_rect_Type3 :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
        (cic.prod (cic.type cic.z)
           (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
           (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z)
              (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
              (cic.univ cic.prop)
              (_B : cic.Univ cic.prop =>
               cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                 (cic.type (cic.s (cic.s (cic.s cic.z))))
                 (cic.prod cic.prop
                    (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                    (matita_basics_logic.And (cic.lift cic.prop cic.prop _A)
                       (cic.lift cic.prop cic.prop _B))
                    (_x_130 :
                       cic.Term cic.prop
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop _A)
                            (cic.lift cic.prop cic.prop _B)) =>
                     cic.univ (cic.type (cic.s (cic.s (cic.s cic.z))))))
                 (Q_ :
                    cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                      (cic.prod cic.prop
                         (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop _A)
                            (cic.lift cic.prop cic.prop _B))
                         (_x_130 :
                            cic.Term cic.prop
                              (matita_basics_logic.And
                                 (cic.lift cic.prop cic.prop _A)
                                 (cic.lift cic.prop cic.prop _B)) =>
                          cic.univ (cic.type (cic.s (cic.s (cic.s cic.z)))))) =>
                  cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
                    (cic.type (cic.s (cic.s (cic.s cic.z))))
                    (cic.prod cic.prop
                       (cic.type (cic.s (cic.s (cic.s cic.z)))) _A
                       (x_132 : cic.Term cic.prop _A =>
                        cic.prod cic.prop
                          (cic.type (cic.s (cic.s (cic.s cic.z)))) _B
                          (x_131 : cic.Term cic.prop _B =>
                           Q_
                             (matita_basics_logic.conj
                                (cic.lift cic.prop cic.prop _A)
                                (cic.lift cic.prop cic.prop _B) x_132 x_131))))
                    (_H_conj :
                       cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                         (cic.prod cic.prop
                            (cic.type (cic.s (cic.s (cic.s cic.z)))) _A
                            (x_132 : cic.Term cic.prop _A =>
                             cic.prod cic.prop
                               (cic.type (cic.s (cic.s (cic.s cic.z)))) _B
                               (x_131 : cic.Term cic.prop _B =>
                                Q_
                                  (matita_basics_logic.conj
                                     (cic.lift cic.prop cic.prop _A)
                                     (cic.lift cic.prop cic.prop _B) x_132
                                     x_131)))) =>
                     cic.prod cic.prop
                       (cic.type (cic.s (cic.s (cic.s cic.z))))
                       (matita_basics_logic.And
                          (cic.lift cic.prop cic.prop _A)
                          (cic.lift cic.prop cic.prop _B))
                       (x_130 :
                          cic.Term cic.prop
                            (matita_basics_logic.And
                               (cic.lift cic.prop cic.prop _A)
                               (cic.lift cic.prop cic.prop _B)) =>
                        Q_ x_130)))))).

def And_rect_Type3_body :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
        (cic.prod (cic.type cic.z)
           (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
           (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z)
              (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
              (cic.univ cic.prop)
              (_B : cic.Univ cic.prop =>
               cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                 (cic.type (cic.s (cic.s (cic.s cic.z))))
                 (cic.prod cic.prop
                    (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                    (matita_basics_logic.And (cic.lift cic.prop cic.prop _A)
                       (cic.lift cic.prop cic.prop _B))
                    (_x_130 :
                       cic.Term cic.prop
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop _A)
                            (cic.lift cic.prop cic.prop _B)) =>
                     cic.univ (cic.type (cic.s (cic.s (cic.s cic.z))))))
                 (Q_ :
                    cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                      (cic.prod cic.prop
                         (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop _A)
                            (cic.lift cic.prop cic.prop _B))
                         (_x_130 :
                            cic.Term cic.prop
                              (matita_basics_logic.And
                                 (cic.lift cic.prop cic.prop _A)
                                 (cic.lift cic.prop cic.prop _B)) =>
                          cic.univ (cic.type (cic.s (cic.s (cic.s cic.z)))))) =>
                  cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
                    (cic.type (cic.s (cic.s (cic.s cic.z))))
                    (cic.prod cic.prop
                       (cic.type (cic.s (cic.s (cic.s cic.z)))) _A
                       (x_132 : cic.Term cic.prop _A =>
                        cic.prod cic.prop
                          (cic.type (cic.s (cic.s (cic.s cic.z)))) _B
                          (x_131 : cic.Term cic.prop _B =>
                           Q_
                             (matita_basics_logic.conj
                                (cic.lift cic.prop cic.prop _A)
                                (cic.lift cic.prop cic.prop _B) x_132 x_131))))
                    (_H_conj :
                       cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                         (cic.prod cic.prop
                            (cic.type (cic.s (cic.s (cic.s cic.z)))) _A
                            (x_132 : cic.Term cic.prop _A =>
                             cic.prod cic.prop
                               (cic.type (cic.s (cic.s (cic.s cic.z)))) _B
                               (x_131 : cic.Term cic.prop _B =>
                                Q_
                                  (matita_basics_logic.conj
                                     (cic.lift cic.prop cic.prop _A)
                                     (cic.lift cic.prop cic.prop _B) x_132
                                     x_131)))) =>
                     cic.prod cic.prop
                       (cic.type (cic.s (cic.s (cic.s cic.z))))
                       (matita_basics_logic.And
                          (cic.lift cic.prop cic.prop _A)
                          (cic.lift cic.prop cic.prop _B))
                       (x_130 :
                          cic.Term cic.prop
                            (matita_basics_logic.And
                               (cic.lift cic.prop cic.prop _A)
                               (cic.lift cic.prop cic.prop _B)) =>
                        Q_ x_130)))))).

[ _A, _B, Q_, _H_conj, x_130 ] And_rect_Type3 _A _B Q_ _H_conj x_130 -->
  matita_basics_logic.filter_And_Type3 _A _B
    (x_130 :
       cic.Term cic.prop
         (matita_basics_logic.And (cic.lift cic.prop cic.prop _A)
            (cic.lift cic.prop cic.prop _B)) =>
     Q_ x_130)
    (matita_basics_logic.And_rect_Type3_body _A _B Q_ _H_conj) x_130.

[ _A, _B, Q_, _H_conj, x_130 ] And_rect_Type3_body _A _B Q_ _H_conj x_130 -->
  matita_basics_logic.match_And_Type3 (cic.lift cic.prop cic.prop _A)
    (cic.lift cic.prop cic.prop _B) Q_
    (x_132 : cic.Term cic.prop _A =>
     x_131 : cic.Term cic.prop _B => _H_conj x_132 x_131)
    x_130.

def And_rect_Type2 :
      cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
        (cic.prod (cic.type cic.z) (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z)
              (cic.type (cic.s (cic.s (cic.s cic.z)))) (cic.univ cic.prop)
              (_B : cic.Univ cic.prop =>
               cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
                 (cic.type (cic.s (cic.s cic.z)))
                 (cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
                    (matita_basics_logic.And (cic.lift cic.prop cic.prop _A)
                       (cic.lift cic.prop cic.prop _B))
                    (_x_134 :
                       cic.Term cic.prop
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop _A)
                            (cic.lift cic.prop cic.prop _B)) =>
                     cic.univ (cic.type (cic.s (cic.s cic.z)))))
                 (Q_ :
                    cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                      (cic.prod cic.prop
                         (cic.type (cic.s (cic.s (cic.s cic.z))))
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop _A)
                            (cic.lift cic.prop cic.prop _B))
                         (_x_134 :
                            cic.Term cic.prop
                              (matita_basics_logic.And
                                 (cic.lift cic.prop cic.prop _A)
                                 (cic.lift cic.prop cic.prop _B)) =>
                          cic.univ (cic.type (cic.s (cic.s cic.z))))) =>
                  cic.prod (cic.type (cic.s (cic.s cic.z)))
                    (cic.type (cic.s (cic.s cic.z)))
                    (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z))) _A
                       (x_136 : cic.Term cic.prop _A =>
                        cic.prod cic.prop (cic.type (cic.s (cic.s cic.z))) _B
                          (x_135 : cic.Term cic.prop _B =>
                           Q_
                             (matita_basics_logic.conj
                                (cic.lift cic.prop cic.prop _A)
                                (cic.lift cic.prop cic.prop _B) x_136 x_135))))
                    (_H_conj :
                       cic.Term (cic.type (cic.s (cic.s cic.z)))
                         (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                            _A
                            (x_136 : cic.Term cic.prop _A =>
                             cic.prod cic.prop
                               (cic.type (cic.s (cic.s cic.z))) _B
                               (x_135 : cic.Term cic.prop _B =>
                                Q_
                                  (matita_basics_logic.conj
                                     (cic.lift cic.prop cic.prop _A)
                                     (cic.lift cic.prop cic.prop _B) x_136
                                     x_135)))) =>
                     cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                       (matita_basics_logic.And
                          (cic.lift cic.prop cic.prop _A)
                          (cic.lift cic.prop cic.prop _B))
                       (x_134 :
                          cic.Term cic.prop
                            (matita_basics_logic.And
                               (cic.lift cic.prop cic.prop _A)
                               (cic.lift cic.prop cic.prop _B)) =>
                        Q_ x_134)))))).

def And_rect_Type2_body :
      cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
        (cic.prod (cic.type cic.z) (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z)
              (cic.type (cic.s (cic.s (cic.s cic.z)))) (cic.univ cic.prop)
              (_B : cic.Univ cic.prop =>
               cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
                 (cic.type (cic.s (cic.s cic.z)))
                 (cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
                    (matita_basics_logic.And (cic.lift cic.prop cic.prop _A)
                       (cic.lift cic.prop cic.prop _B))
                    (_x_134 :
                       cic.Term cic.prop
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop _A)
                            (cic.lift cic.prop cic.prop _B)) =>
                     cic.univ (cic.type (cic.s (cic.s cic.z)))))
                 (Q_ :
                    cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                      (cic.prod cic.prop
                         (cic.type (cic.s (cic.s (cic.s cic.z))))
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop _A)
                            (cic.lift cic.prop cic.prop _B))
                         (_x_134 :
                            cic.Term cic.prop
                              (matita_basics_logic.And
                                 (cic.lift cic.prop cic.prop _A)
                                 (cic.lift cic.prop cic.prop _B)) =>
                          cic.univ (cic.type (cic.s (cic.s cic.z))))) =>
                  cic.prod (cic.type (cic.s (cic.s cic.z)))
                    (cic.type (cic.s (cic.s cic.z)))
                    (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z))) _A
                       (x_136 : cic.Term cic.prop _A =>
                        cic.prod cic.prop (cic.type (cic.s (cic.s cic.z))) _B
                          (x_135 : cic.Term cic.prop _B =>
                           Q_
                             (matita_basics_logic.conj
                                (cic.lift cic.prop cic.prop _A)
                                (cic.lift cic.prop cic.prop _B) x_136 x_135))))
                    (_H_conj :
                       cic.Term (cic.type (cic.s (cic.s cic.z)))
                         (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                            _A
                            (x_136 : cic.Term cic.prop _A =>
                             cic.prod cic.prop
                               (cic.type (cic.s (cic.s cic.z))) _B
                               (x_135 : cic.Term cic.prop _B =>
                                Q_
                                  (matita_basics_logic.conj
                                     (cic.lift cic.prop cic.prop _A)
                                     (cic.lift cic.prop cic.prop _B) x_136
                                     x_135)))) =>
                     cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                       (matita_basics_logic.And
                          (cic.lift cic.prop cic.prop _A)
                          (cic.lift cic.prop cic.prop _B))
                       (x_134 :
                          cic.Term cic.prop
                            (matita_basics_logic.And
                               (cic.lift cic.prop cic.prop _A)
                               (cic.lift cic.prop cic.prop _B)) =>
                        Q_ x_134)))))).

[ _A, _B, Q_, _H_conj, x_134 ] And_rect_Type2 _A _B Q_ _H_conj x_134 -->
  matita_basics_logic.filter_And_Type2 _A _B
    (x_134 :
       cic.Term cic.prop
         (matita_basics_logic.And (cic.lift cic.prop cic.prop _A)
            (cic.lift cic.prop cic.prop _B)) =>
     Q_ x_134)
    (matita_basics_logic.And_rect_Type2_body _A _B Q_ _H_conj) x_134.

[ _A, _B, Q_, _H_conj, x_134 ] And_rect_Type2_body _A _B Q_ _H_conj x_134 -->
  matita_basics_logic.match_And_Type2 (cic.lift cic.prop cic.prop _A)
    (cic.lift cic.prop cic.prop _B) Q_
    (x_136 : cic.Term cic.prop _A =>
     x_135 : cic.Term cic.prop _B => _H_conj x_136 x_135)
    x_134.

def And_rect_Type1 :
      cic.Term (cic.type (cic.s (cic.s cic.z)))
        (cic.prod (cic.type cic.z) (cic.type (cic.s (cic.s cic.z)))
           (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) (cic.type (cic.s (cic.s cic.z)))
              (cic.univ cic.prop)
              (_B : cic.Univ cic.prop =>
               cic.prod (cic.type (cic.s (cic.s cic.z)))
                 (cic.type (cic.s cic.z))
                 (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.And (cic.lift cic.prop cic.prop _A)
                       (cic.lift cic.prop cic.prop _B))
                    (_x_138 :
                       cic.Term cic.prop
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop _A)
                            (cic.lift cic.prop cic.prop _B)) =>
                     cic.univ (cic.type (cic.s cic.z))))
                 (Q_ :
                    cic.Term (cic.type (cic.s (cic.s cic.z)))
                      (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop _A)
                            (cic.lift cic.prop cic.prop _B))
                         (_x_138 :
                            cic.Term cic.prop
                              (matita_basics_logic.And
                                 (cic.lift cic.prop cic.prop _A)
                                 (cic.lift cic.prop cic.prop _B)) =>
                          cic.univ (cic.type (cic.s cic.z)))) =>
                  cic.prod (cic.type (cic.s cic.z)) (cic.type (cic.s cic.z))
                    (cic.prod cic.prop (cic.type (cic.s cic.z)) _A
                       (x_140 : cic.Term cic.prop _A =>
                        cic.prod cic.prop (cic.type (cic.s cic.z)) _B
                          (x_139 : cic.Term cic.prop _B =>
                           Q_
                             (matita_basics_logic.conj
                                (cic.lift cic.prop cic.prop _A)
                                (cic.lift cic.prop cic.prop _B) x_140 x_139))))
                    (_H_conj :
                       cic.Term (cic.type (cic.s cic.z))
                         (cic.prod cic.prop (cic.type (cic.s cic.z)) _A
                            (x_140 : cic.Term cic.prop _A =>
                             cic.prod cic.prop (cic.type (cic.s cic.z)) _B
                               (x_139 : cic.Term cic.prop _B =>
                                Q_
                                  (matita_basics_logic.conj
                                     (cic.lift cic.prop cic.prop _A)
                                     (cic.lift cic.prop cic.prop _B) x_140
                                     x_139)))) =>
                     cic.prod cic.prop (cic.type (cic.s cic.z))
                       (matita_basics_logic.And
                          (cic.lift cic.prop cic.prop _A)
                          (cic.lift cic.prop cic.prop _B))
                       (x_138 :
                          cic.Term cic.prop
                            (matita_basics_logic.And
                               (cic.lift cic.prop cic.prop _A)
                               (cic.lift cic.prop cic.prop _B)) =>
                        Q_ x_138)))))).

def And_rect_Type1_body :
      cic.Term (cic.type (cic.s (cic.s cic.z)))
        (cic.prod (cic.type cic.z) (cic.type (cic.s (cic.s cic.z)))
           (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) (cic.type (cic.s (cic.s cic.z)))
              (cic.univ cic.prop)
              (_B : cic.Univ cic.prop =>
               cic.prod (cic.type (cic.s (cic.s cic.z)))
                 (cic.type (cic.s cic.z))
                 (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.And (cic.lift cic.prop cic.prop _A)
                       (cic.lift cic.prop cic.prop _B))
                    (_x_138 :
                       cic.Term cic.prop
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop _A)
                            (cic.lift cic.prop cic.prop _B)) =>
                     cic.univ (cic.type (cic.s cic.z))))
                 (Q_ :
                    cic.Term (cic.type (cic.s (cic.s cic.z)))
                      (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop _A)
                            (cic.lift cic.prop cic.prop _B))
                         (_x_138 :
                            cic.Term cic.prop
                              (matita_basics_logic.And
                                 (cic.lift cic.prop cic.prop _A)
                                 (cic.lift cic.prop cic.prop _B)) =>
                          cic.univ (cic.type (cic.s cic.z)))) =>
                  cic.prod (cic.type (cic.s cic.z)) (cic.type (cic.s cic.z))
                    (cic.prod cic.prop (cic.type (cic.s cic.z)) _A
                       (x_140 : cic.Term cic.prop _A =>
                        cic.prod cic.prop (cic.type (cic.s cic.z)) _B
                          (x_139 : cic.Term cic.prop _B =>
                           Q_
                             (matita_basics_logic.conj
                                (cic.lift cic.prop cic.prop _A)
                                (cic.lift cic.prop cic.prop _B) x_140 x_139))))
                    (_H_conj :
                       cic.Term (cic.type (cic.s cic.z))
                         (cic.prod cic.prop (cic.type (cic.s cic.z)) _A
                            (x_140 : cic.Term cic.prop _A =>
                             cic.prod cic.prop (cic.type (cic.s cic.z)) _B
                               (x_139 : cic.Term cic.prop _B =>
                                Q_
                                  (matita_basics_logic.conj
                                     (cic.lift cic.prop cic.prop _A)
                                     (cic.lift cic.prop cic.prop _B) x_140
                                     x_139)))) =>
                     cic.prod cic.prop (cic.type (cic.s cic.z))
                       (matita_basics_logic.And
                          (cic.lift cic.prop cic.prop _A)
                          (cic.lift cic.prop cic.prop _B))
                       (x_138 :
                          cic.Term cic.prop
                            (matita_basics_logic.And
                               (cic.lift cic.prop cic.prop _A)
                               (cic.lift cic.prop cic.prop _B)) =>
                        Q_ x_138)))))).

[ _A, _B, Q_, _H_conj, x_138 ] And_rect_Type1 _A _B Q_ _H_conj x_138 -->
  matita_basics_logic.filter_And_Type1 _A _B
    (x_138 :
       cic.Term cic.prop
         (matita_basics_logic.And (cic.lift cic.prop cic.prop _A)
            (cic.lift cic.prop cic.prop _B)) =>
     Q_ x_138)
    (matita_basics_logic.And_rect_Type1_body _A _B Q_ _H_conj) x_138.

[ _A, _B, Q_, _H_conj, x_138 ] And_rect_Type1_body _A _B Q_ _H_conj x_138 -->
  matita_basics_logic.match_And_Type1 (cic.lift cic.prop cic.prop _A)
    (cic.lift cic.prop cic.prop _B) Q_
    (x_140 : cic.Term cic.prop _A =>
     x_139 : cic.Term cic.prop _B => _H_conj x_140 x_139)
    x_138.

def And_rect_Type0 :
      cic.Term (cic.type (cic.s cic.z))
        (cic.prod (cic.type cic.z) (cic.type (cic.s cic.z))
           (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) (cic.type (cic.s cic.z))
              (cic.univ cic.prop)
              (_B : cic.Univ cic.prop =>
               cic.prod (cic.type (cic.s cic.z)) (cic.type cic.z)
                 (cic.prod cic.prop (cic.type (cic.s cic.z))
                    (matita_basics_logic.And (cic.lift cic.prop cic.prop _A)
                       (cic.lift cic.prop cic.prop _B))
                    (_x_142 :
                       cic.Term cic.prop
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop _A)
                            (cic.lift cic.prop cic.prop _B)) =>
                     cic.univ (cic.type cic.z)))
                 (Q_ :
                    cic.Term (cic.type (cic.s cic.z))
                      (cic.prod cic.prop (cic.type (cic.s cic.z))
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop _A)
                            (cic.lift cic.prop cic.prop _B))
                         (_x_142 :
                            cic.Term cic.prop
                              (matita_basics_logic.And
                                 (cic.lift cic.prop cic.prop _A)
                                 (cic.lift cic.prop cic.prop _B)) =>
                          cic.univ (cic.type cic.z))) =>
                  cic.prod (cic.type cic.z) (cic.type cic.z)
                    (cic.prod cic.prop (cic.type cic.z) _A
                       (x_144 : cic.Term cic.prop _A =>
                        cic.prod cic.prop (cic.type cic.z) _B
                          (x_143 : cic.Term cic.prop _B =>
                           Q_
                             (matita_basics_logic.conj
                                (cic.lift cic.prop cic.prop _A)
                                (cic.lift cic.prop cic.prop _B) x_144 x_143))))
                    (_H_conj :
                       cic.Term (cic.type cic.z)
                         (cic.prod cic.prop (cic.type cic.z) _A
                            (x_144 : cic.Term cic.prop _A =>
                             cic.prod cic.prop (cic.type cic.z) _B
                               (x_143 : cic.Term cic.prop _B =>
                                Q_
                                  (matita_basics_logic.conj
                                     (cic.lift cic.prop cic.prop _A)
                                     (cic.lift cic.prop cic.prop _B) x_144
                                     x_143)))) =>
                     cic.prod cic.prop (cic.type cic.z)
                       (matita_basics_logic.And
                          (cic.lift cic.prop cic.prop _A)
                          (cic.lift cic.prop cic.prop _B))
                       (x_142 :
                          cic.Term cic.prop
                            (matita_basics_logic.And
                               (cic.lift cic.prop cic.prop _A)
                               (cic.lift cic.prop cic.prop _B)) =>
                        Q_ x_142)))))).

def And_rect_Type0_body :
      cic.Term (cic.type (cic.s cic.z))
        (cic.prod (cic.type cic.z) (cic.type (cic.s cic.z))
           (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) (cic.type (cic.s cic.z))
              (cic.univ cic.prop)
              (_B : cic.Univ cic.prop =>
               cic.prod (cic.type (cic.s cic.z)) (cic.type cic.z)
                 (cic.prod cic.prop (cic.type (cic.s cic.z))
                    (matita_basics_logic.And (cic.lift cic.prop cic.prop _A)
                       (cic.lift cic.prop cic.prop _B))
                    (_x_142 :
                       cic.Term cic.prop
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop _A)
                            (cic.lift cic.prop cic.prop _B)) =>
                     cic.univ (cic.type cic.z)))
                 (Q_ :
                    cic.Term (cic.type (cic.s cic.z))
                      (cic.prod cic.prop (cic.type (cic.s cic.z))
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop _A)
                            (cic.lift cic.prop cic.prop _B))
                         (_x_142 :
                            cic.Term cic.prop
                              (matita_basics_logic.And
                                 (cic.lift cic.prop cic.prop _A)
                                 (cic.lift cic.prop cic.prop _B)) =>
                          cic.univ (cic.type cic.z))) =>
                  cic.prod (cic.type cic.z) (cic.type cic.z)
                    (cic.prod cic.prop (cic.type cic.z) _A
                       (x_144 : cic.Term cic.prop _A =>
                        cic.prod cic.prop (cic.type cic.z) _B
                          (x_143 : cic.Term cic.prop _B =>
                           Q_
                             (matita_basics_logic.conj
                                (cic.lift cic.prop cic.prop _A)
                                (cic.lift cic.prop cic.prop _B) x_144 x_143))))
                    (_H_conj :
                       cic.Term (cic.type cic.z)
                         (cic.prod cic.prop (cic.type cic.z) _A
                            (x_144 : cic.Term cic.prop _A =>
                             cic.prod cic.prop (cic.type cic.z) _B
                               (x_143 : cic.Term cic.prop _B =>
                                Q_
                                  (matita_basics_logic.conj
                                     (cic.lift cic.prop cic.prop _A)
                                     (cic.lift cic.prop cic.prop _B) x_144
                                     x_143)))) =>
                     cic.prod cic.prop (cic.type cic.z)
                       (matita_basics_logic.And
                          (cic.lift cic.prop cic.prop _A)
                          (cic.lift cic.prop cic.prop _B))
                       (x_142 :
                          cic.Term cic.prop
                            (matita_basics_logic.And
                               (cic.lift cic.prop cic.prop _A)
                               (cic.lift cic.prop cic.prop _B)) =>
                        Q_ x_142)))))).

[ _A, _B, Q_, _H_conj, x_142 ] And_rect_Type0 _A _B Q_ _H_conj x_142 -->
  matita_basics_logic.filter_And_Type0 _A _B
    (x_142 :
       cic.Term cic.prop
         (matita_basics_logic.And (cic.lift cic.prop cic.prop _A)
            (cic.lift cic.prop cic.prop _B)) =>
     Q_ x_142)
    (matita_basics_logic.And_rect_Type0_body _A _B Q_ _H_conj) x_142.

[ _A, _B, Q_, _H_conj, x_142 ] And_rect_Type0_body _A _B Q_ _H_conj x_142 -->
  matita_basics_logic.match_And_Type0 (cic.lift cic.prop cic.prop _A)
    (cic.lift cic.prop cic.prop _B) Q_
    (x_144 : cic.Term cic.prop _A =>
     x_143 : cic.Term cic.prop _B => _H_conj x_144 x_143)
    x_142.

def And_rect_CProp4 :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
              (_B : cic.Univ cic.prop =>
               cic.prod (cic.type cic.z) cic.prop
                 (cic.prod cic.prop (cic.type cic.z)
                    (matita_basics_logic.And (cic.lift cic.prop cic.prop _A)
                       (cic.lift cic.prop cic.prop _B))
                    (_x_146 :
                       cic.Term cic.prop
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop _A)
                            (cic.lift cic.prop cic.prop _B)) =>
                     cic.univ cic.prop))
                 (Q_ :
                    cic.Term (cic.type cic.z)
                      (cic.prod cic.prop (cic.type cic.z)
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop _A)
                            (cic.lift cic.prop cic.prop _B))
                         (_x_146 :
                            cic.Term cic.prop
                              (matita_basics_logic.And
                                 (cic.lift cic.prop cic.prop _A)
                                 (cic.lift cic.prop cic.prop _B)) =>
                          cic.univ cic.prop)) =>
                  cic.prod cic.prop cic.prop
                    (cic.prod cic.prop cic.prop _A
                       (x_148 : cic.Term cic.prop _A =>
                        cic.prod cic.prop cic.prop _B
                          (x_147 : cic.Term cic.prop _B =>
                           Q_
                             (matita_basics_logic.conj
                                (cic.lift cic.prop cic.prop _A)
                                (cic.lift cic.prop cic.prop _B) x_148 x_147))))
                    (_H_conj :
                       cic.Term cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (x_148 : cic.Term cic.prop _A =>
                             cic.prod cic.prop cic.prop _B
                               (x_147 : cic.Term cic.prop _B =>
                                Q_
                                  (matita_basics_logic.conj
                                     (cic.lift cic.prop cic.prop _A)
                                     (cic.lift cic.prop cic.prop _B) x_148
                                     x_147)))) =>
                     cic.prod cic.prop cic.prop
                       (matita_basics_logic.And
                          (cic.lift cic.prop cic.prop _A)
                          (cic.lift cic.prop cic.prop _B))
                       (x_146 :
                          cic.Term cic.prop
                            (matita_basics_logic.And
                               (cic.lift cic.prop cic.prop _A)
                               (cic.lift cic.prop cic.prop _B)) =>
                        Q_ x_146)))))).

def And_rect_CProp4_body :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
              (_B : cic.Univ cic.prop =>
               cic.prod (cic.type cic.z) cic.prop
                 (cic.prod cic.prop (cic.type cic.z)
                    (matita_basics_logic.And (cic.lift cic.prop cic.prop _A)
                       (cic.lift cic.prop cic.prop _B))
                    (_x_146 :
                       cic.Term cic.prop
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop _A)
                            (cic.lift cic.prop cic.prop _B)) =>
                     cic.univ cic.prop))
                 (Q_ :
                    cic.Term (cic.type cic.z)
                      (cic.prod cic.prop (cic.type cic.z)
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop _A)
                            (cic.lift cic.prop cic.prop _B))
                         (_x_146 :
                            cic.Term cic.prop
                              (matita_basics_logic.And
                                 (cic.lift cic.prop cic.prop _A)
                                 (cic.lift cic.prop cic.prop _B)) =>
                          cic.univ cic.prop)) =>
                  cic.prod cic.prop cic.prop
                    (cic.prod cic.prop cic.prop _A
                       (x_148 : cic.Term cic.prop _A =>
                        cic.prod cic.prop cic.prop _B
                          (x_147 : cic.Term cic.prop _B =>
                           Q_
                             (matita_basics_logic.conj
                                (cic.lift cic.prop cic.prop _A)
                                (cic.lift cic.prop cic.prop _B) x_148 x_147))))
                    (_H_conj :
                       cic.Term cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (x_148 : cic.Term cic.prop _A =>
                             cic.prod cic.prop cic.prop _B
                               (x_147 : cic.Term cic.prop _B =>
                                Q_
                                  (matita_basics_logic.conj
                                     (cic.lift cic.prop cic.prop _A)
                                     (cic.lift cic.prop cic.prop _B) x_148
                                     x_147)))) =>
                     cic.prod cic.prop cic.prop
                       (matita_basics_logic.And
                          (cic.lift cic.prop cic.prop _A)
                          (cic.lift cic.prop cic.prop _B))
                       (x_146 :
                          cic.Term cic.prop
                            (matita_basics_logic.And
                               (cic.lift cic.prop cic.prop _A)
                               (cic.lift cic.prop cic.prop _B)) =>
                        Q_ x_146)))))).

[ _A, _B, Q_, _H_conj, x_146 ] And_rect_CProp4 _A _B Q_ _H_conj x_146 -->
  matita_basics_logic.filter_And_Prop _A _B
    (x_146 :
       cic.Term cic.prop
         (matita_basics_logic.And (cic.lift cic.prop cic.prop _A)
            (cic.lift cic.prop cic.prop _B)) =>
     Q_ x_146)
    (matita_basics_logic.And_rect_CProp4_body _A _B Q_ _H_conj) x_146.

[ _A, _B, Q_, _H_conj, x_146 ]
  And_rect_CProp4_body _A _B Q_ _H_conj x_146 -->
  matita_basics_logic.match_And_Prop (cic.lift cic.prop cic.prop _A)
    (cic.lift cic.prop cic.prop _B) Q_
    (x_148 : cic.Term cic.prop _A =>
     x_147 : cic.Term cic.prop _B => _H_conj x_148 x_147)
    x_146.

def And_rect_CProp5 :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
              (_B : cic.Univ cic.prop =>
               cic.prod (cic.type cic.z) cic.prop
                 (cic.prod cic.prop (cic.type cic.z)
                    (matita_basics_logic.And (cic.lift cic.prop cic.prop _A)
                       (cic.lift cic.prop cic.prop _B))
                    (_x_150 :
                       cic.Term cic.prop
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop _A)
                            (cic.lift cic.prop cic.prop _B)) =>
                     cic.univ cic.prop))
                 (Q_ :
                    cic.Term (cic.type cic.z)
                      (cic.prod cic.prop (cic.type cic.z)
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop _A)
                            (cic.lift cic.prop cic.prop _B))
                         (_x_150 :
                            cic.Term cic.prop
                              (matita_basics_logic.And
                                 (cic.lift cic.prop cic.prop _A)
                                 (cic.lift cic.prop cic.prop _B)) =>
                          cic.univ cic.prop)) =>
                  cic.prod cic.prop cic.prop
                    (cic.prod cic.prop cic.prop _A
                       (x_152 : cic.Term cic.prop _A =>
                        cic.prod cic.prop cic.prop _B
                          (x_151 : cic.Term cic.prop _B =>
                           Q_
                             (matita_basics_logic.conj
                                (cic.lift cic.prop cic.prop _A)
                                (cic.lift cic.prop cic.prop _B) x_152 x_151))))
                    (_H_conj :
                       cic.Term cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (x_152 : cic.Term cic.prop _A =>
                             cic.prod cic.prop cic.prop _B
                               (x_151 : cic.Term cic.prop _B =>
                                Q_
                                  (matita_basics_logic.conj
                                     (cic.lift cic.prop cic.prop _A)
                                     (cic.lift cic.prop cic.prop _B) x_152
                                     x_151)))) =>
                     cic.prod cic.prop cic.prop
                       (matita_basics_logic.And
                          (cic.lift cic.prop cic.prop _A)
                          (cic.lift cic.prop cic.prop _B))
                       (x_150 :
                          cic.Term cic.prop
                            (matita_basics_logic.And
                               (cic.lift cic.prop cic.prop _A)
                               (cic.lift cic.prop cic.prop _B)) =>
                        Q_ x_150)))))).

def And_rect_CProp5_body :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
              (_B : cic.Univ cic.prop =>
               cic.prod (cic.type cic.z) cic.prop
                 (cic.prod cic.prop (cic.type cic.z)
                    (matita_basics_logic.And (cic.lift cic.prop cic.prop _A)
                       (cic.lift cic.prop cic.prop _B))
                    (_x_150 :
                       cic.Term cic.prop
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop _A)
                            (cic.lift cic.prop cic.prop _B)) =>
                     cic.univ cic.prop))
                 (Q_ :
                    cic.Term (cic.type cic.z)
                      (cic.prod cic.prop (cic.type cic.z)
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop _A)
                            (cic.lift cic.prop cic.prop _B))
                         (_x_150 :
                            cic.Term cic.prop
                              (matita_basics_logic.And
                                 (cic.lift cic.prop cic.prop _A)
                                 (cic.lift cic.prop cic.prop _B)) =>
                          cic.univ cic.prop)) =>
                  cic.prod cic.prop cic.prop
                    (cic.prod cic.prop cic.prop _A
                       (x_152 : cic.Term cic.prop _A =>
                        cic.prod cic.prop cic.prop _B
                          (x_151 : cic.Term cic.prop _B =>
                           Q_
                             (matita_basics_logic.conj
                                (cic.lift cic.prop cic.prop _A)
                                (cic.lift cic.prop cic.prop _B) x_152 x_151))))
                    (_H_conj :
                       cic.Term cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (x_152 : cic.Term cic.prop _A =>
                             cic.prod cic.prop cic.prop _B
                               (x_151 : cic.Term cic.prop _B =>
                                Q_
                                  (matita_basics_logic.conj
                                     (cic.lift cic.prop cic.prop _A)
                                     (cic.lift cic.prop cic.prop _B) x_152
                                     x_151)))) =>
                     cic.prod cic.prop cic.prop
                       (matita_basics_logic.And
                          (cic.lift cic.prop cic.prop _A)
                          (cic.lift cic.prop cic.prop _B))
                       (x_150 :
                          cic.Term cic.prop
                            (matita_basics_logic.And
                               (cic.lift cic.prop cic.prop _A)
                               (cic.lift cic.prop cic.prop _B)) =>
                        Q_ x_150)))))).

[ _A, _B, Q_, _H_conj, x_150 ] And_rect_CProp5 _A _B Q_ _H_conj x_150 -->
  matita_basics_logic.filter_And_Prop _A _B
    (x_150 :
       cic.Term cic.prop
         (matita_basics_logic.And (cic.lift cic.prop cic.prop _A)
            (cic.lift cic.prop cic.prop _B)) =>
     Q_ x_150)
    (matita_basics_logic.And_rect_CProp5_body _A _B Q_ _H_conj) x_150.

[ _A, _B, Q_, _H_conj, x_150 ]
  And_rect_CProp5_body _A _B Q_ _H_conj x_150 -->
  matita_basics_logic.match_And_Prop (cic.lift cic.prop cic.prop _A)
    (cic.lift cic.prop cic.prop _B) Q_
    (x_152 : cic.Term cic.prop _A =>
     x_151 : cic.Term cic.prop _B => _H_conj x_152 x_151)
    x_150.

def And_rect_CProp3 :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
              (_B : cic.Univ cic.prop =>
               cic.prod (cic.type cic.z) cic.prop
                 (cic.prod cic.prop (cic.type cic.z)
                    (matita_basics_logic.And (cic.lift cic.prop cic.prop _A)
                       (cic.lift cic.prop cic.prop _B))
                    (_x_154 :
                       cic.Term cic.prop
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop _A)
                            (cic.lift cic.prop cic.prop _B)) =>
                     cic.univ cic.prop))
                 (Q_ :
                    cic.Term (cic.type cic.z)
                      (cic.prod cic.prop (cic.type cic.z)
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop _A)
                            (cic.lift cic.prop cic.prop _B))
                         (_x_154 :
                            cic.Term cic.prop
                              (matita_basics_logic.And
                                 (cic.lift cic.prop cic.prop _A)
                                 (cic.lift cic.prop cic.prop _B)) =>
                          cic.univ cic.prop)) =>
                  cic.prod cic.prop cic.prop
                    (cic.prod cic.prop cic.prop _A
                       (x_156 : cic.Term cic.prop _A =>
                        cic.prod cic.prop cic.prop _B
                          (x_155 : cic.Term cic.prop _B =>
                           Q_
                             (matita_basics_logic.conj
                                (cic.lift cic.prop cic.prop _A)
                                (cic.lift cic.prop cic.prop _B) x_156 x_155))))
                    (_H_conj :
                       cic.Term cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (x_156 : cic.Term cic.prop _A =>
                             cic.prod cic.prop cic.prop _B
                               (x_155 : cic.Term cic.prop _B =>
                                Q_
                                  (matita_basics_logic.conj
                                     (cic.lift cic.prop cic.prop _A)
                                     (cic.lift cic.prop cic.prop _B) x_156
                                     x_155)))) =>
                     cic.prod cic.prop cic.prop
                       (matita_basics_logic.And
                          (cic.lift cic.prop cic.prop _A)
                          (cic.lift cic.prop cic.prop _B))
                       (x_154 :
                          cic.Term cic.prop
                            (matita_basics_logic.And
                               (cic.lift cic.prop cic.prop _A)
                               (cic.lift cic.prop cic.prop _B)) =>
                        Q_ x_154)))))).

def And_rect_CProp3_body :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
              (_B : cic.Univ cic.prop =>
               cic.prod (cic.type cic.z) cic.prop
                 (cic.prod cic.prop (cic.type cic.z)
                    (matita_basics_logic.And (cic.lift cic.prop cic.prop _A)
                       (cic.lift cic.prop cic.prop _B))
                    (_x_154 :
                       cic.Term cic.prop
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop _A)
                            (cic.lift cic.prop cic.prop _B)) =>
                     cic.univ cic.prop))
                 (Q_ :
                    cic.Term (cic.type cic.z)
                      (cic.prod cic.prop (cic.type cic.z)
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop _A)
                            (cic.lift cic.prop cic.prop _B))
                         (_x_154 :
                            cic.Term cic.prop
                              (matita_basics_logic.And
                                 (cic.lift cic.prop cic.prop _A)
                                 (cic.lift cic.prop cic.prop _B)) =>
                          cic.univ cic.prop)) =>
                  cic.prod cic.prop cic.prop
                    (cic.prod cic.prop cic.prop _A
                       (x_156 : cic.Term cic.prop _A =>
                        cic.prod cic.prop cic.prop _B
                          (x_155 : cic.Term cic.prop _B =>
                           Q_
                             (matita_basics_logic.conj
                                (cic.lift cic.prop cic.prop _A)
                                (cic.lift cic.prop cic.prop _B) x_156 x_155))))
                    (_H_conj :
                       cic.Term cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (x_156 : cic.Term cic.prop _A =>
                             cic.prod cic.prop cic.prop _B
                               (x_155 : cic.Term cic.prop _B =>
                                Q_
                                  (matita_basics_logic.conj
                                     (cic.lift cic.prop cic.prop _A)
                                     (cic.lift cic.prop cic.prop _B) x_156
                                     x_155)))) =>
                     cic.prod cic.prop cic.prop
                       (matita_basics_logic.And
                          (cic.lift cic.prop cic.prop _A)
                          (cic.lift cic.prop cic.prop _B))
                       (x_154 :
                          cic.Term cic.prop
                            (matita_basics_logic.And
                               (cic.lift cic.prop cic.prop _A)
                               (cic.lift cic.prop cic.prop _B)) =>
                        Q_ x_154)))))).

[ _A, _B, Q_, _H_conj, x_154 ] And_rect_CProp3 _A _B Q_ _H_conj x_154 -->
  matita_basics_logic.filter_And_Prop _A _B
    (x_154 :
       cic.Term cic.prop
         (matita_basics_logic.And (cic.lift cic.prop cic.prop _A)
            (cic.lift cic.prop cic.prop _B)) =>
     Q_ x_154)
    (matita_basics_logic.And_rect_CProp3_body _A _B Q_ _H_conj) x_154.

[ _A, _B, Q_, _H_conj, x_154 ]
  And_rect_CProp3_body _A _B Q_ _H_conj x_154 -->
  matita_basics_logic.match_And_Prop (cic.lift cic.prop cic.prop _A)
    (cic.lift cic.prop cic.prop _B) Q_
    (x_156 : cic.Term cic.prop _A =>
     x_155 : cic.Term cic.prop _B => _H_conj x_156 x_155)
    x_154.

def And_rect_CProp2 :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
              (_B : cic.Univ cic.prop =>
               cic.prod (cic.type cic.z) cic.prop
                 (cic.prod cic.prop (cic.type cic.z)
                    (matita_basics_logic.And (cic.lift cic.prop cic.prop _A)
                       (cic.lift cic.prop cic.prop _B))
                    (_x_158 :
                       cic.Term cic.prop
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop _A)
                            (cic.lift cic.prop cic.prop _B)) =>
                     cic.univ cic.prop))
                 (Q_ :
                    cic.Term (cic.type cic.z)
                      (cic.prod cic.prop (cic.type cic.z)
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop _A)
                            (cic.lift cic.prop cic.prop _B))
                         (_x_158 :
                            cic.Term cic.prop
                              (matita_basics_logic.And
                                 (cic.lift cic.prop cic.prop _A)
                                 (cic.lift cic.prop cic.prop _B)) =>
                          cic.univ cic.prop)) =>
                  cic.prod cic.prop cic.prop
                    (cic.prod cic.prop cic.prop _A
                       (x_160 : cic.Term cic.prop _A =>
                        cic.prod cic.prop cic.prop _B
                          (x_159 : cic.Term cic.prop _B =>
                           Q_
                             (matita_basics_logic.conj
                                (cic.lift cic.prop cic.prop _A)
                                (cic.lift cic.prop cic.prop _B) x_160 x_159))))
                    (_H_conj :
                       cic.Term cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (x_160 : cic.Term cic.prop _A =>
                             cic.prod cic.prop cic.prop _B
                               (x_159 : cic.Term cic.prop _B =>
                                Q_
                                  (matita_basics_logic.conj
                                     (cic.lift cic.prop cic.prop _A)
                                     (cic.lift cic.prop cic.prop _B) x_160
                                     x_159)))) =>
                     cic.prod cic.prop cic.prop
                       (matita_basics_logic.And
                          (cic.lift cic.prop cic.prop _A)
                          (cic.lift cic.prop cic.prop _B))
                       (x_158 :
                          cic.Term cic.prop
                            (matita_basics_logic.And
                               (cic.lift cic.prop cic.prop _A)
                               (cic.lift cic.prop cic.prop _B)) =>
                        Q_ x_158)))))).

def And_rect_CProp2_body :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
              (_B : cic.Univ cic.prop =>
               cic.prod (cic.type cic.z) cic.prop
                 (cic.prod cic.prop (cic.type cic.z)
                    (matita_basics_logic.And (cic.lift cic.prop cic.prop _A)
                       (cic.lift cic.prop cic.prop _B))
                    (_x_158 :
                       cic.Term cic.prop
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop _A)
                            (cic.lift cic.prop cic.prop _B)) =>
                     cic.univ cic.prop))
                 (Q_ :
                    cic.Term (cic.type cic.z)
                      (cic.prod cic.prop (cic.type cic.z)
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop _A)
                            (cic.lift cic.prop cic.prop _B))
                         (_x_158 :
                            cic.Term cic.prop
                              (matita_basics_logic.And
                                 (cic.lift cic.prop cic.prop _A)
                                 (cic.lift cic.prop cic.prop _B)) =>
                          cic.univ cic.prop)) =>
                  cic.prod cic.prop cic.prop
                    (cic.prod cic.prop cic.prop _A
                       (x_160 : cic.Term cic.prop _A =>
                        cic.prod cic.prop cic.prop _B
                          (x_159 : cic.Term cic.prop _B =>
                           Q_
                             (matita_basics_logic.conj
                                (cic.lift cic.prop cic.prop _A)
                                (cic.lift cic.prop cic.prop _B) x_160 x_159))))
                    (_H_conj :
                       cic.Term cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (x_160 : cic.Term cic.prop _A =>
                             cic.prod cic.prop cic.prop _B
                               (x_159 : cic.Term cic.prop _B =>
                                Q_
                                  (matita_basics_logic.conj
                                     (cic.lift cic.prop cic.prop _A)
                                     (cic.lift cic.prop cic.prop _B) x_160
                                     x_159)))) =>
                     cic.prod cic.prop cic.prop
                       (matita_basics_logic.And
                          (cic.lift cic.prop cic.prop _A)
                          (cic.lift cic.prop cic.prop _B))
                       (x_158 :
                          cic.Term cic.prop
                            (matita_basics_logic.And
                               (cic.lift cic.prop cic.prop _A)
                               (cic.lift cic.prop cic.prop _B)) =>
                        Q_ x_158)))))).

[ _A, _B, Q_, _H_conj, x_158 ] And_rect_CProp2 _A _B Q_ _H_conj x_158 -->
  matita_basics_logic.filter_And_Prop _A _B
    (x_158 :
       cic.Term cic.prop
         (matita_basics_logic.And (cic.lift cic.prop cic.prop _A)
            (cic.lift cic.prop cic.prop _B)) =>
     Q_ x_158)
    (matita_basics_logic.And_rect_CProp2_body _A _B Q_ _H_conj) x_158.

[ _A, _B, Q_, _H_conj, x_158 ]
  And_rect_CProp2_body _A _B Q_ _H_conj x_158 -->
  matita_basics_logic.match_And_Prop (cic.lift cic.prop cic.prop _A)
    (cic.lift cic.prop cic.prop _B) Q_
    (x_160 : cic.Term cic.prop _A =>
     x_159 : cic.Term cic.prop _B => _H_conj x_160 x_159)
    x_158.

def And_rect_CProp1 :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
              (_B : cic.Univ cic.prop =>
               cic.prod (cic.type cic.z) cic.prop
                 (cic.prod cic.prop (cic.type cic.z)
                    (matita_basics_logic.And (cic.lift cic.prop cic.prop _A)
                       (cic.lift cic.prop cic.prop _B))
                    (_x_162 :
                       cic.Term cic.prop
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop _A)
                            (cic.lift cic.prop cic.prop _B)) =>
                     cic.univ cic.prop))
                 (Q_ :
                    cic.Term (cic.type cic.z)
                      (cic.prod cic.prop (cic.type cic.z)
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop _A)
                            (cic.lift cic.prop cic.prop _B))
                         (_x_162 :
                            cic.Term cic.prop
                              (matita_basics_logic.And
                                 (cic.lift cic.prop cic.prop _A)
                                 (cic.lift cic.prop cic.prop _B)) =>
                          cic.univ cic.prop)) =>
                  cic.prod cic.prop cic.prop
                    (cic.prod cic.prop cic.prop _A
                       (x_164 : cic.Term cic.prop _A =>
                        cic.prod cic.prop cic.prop _B
                          (x_163 : cic.Term cic.prop _B =>
                           Q_
                             (matita_basics_logic.conj
                                (cic.lift cic.prop cic.prop _A)
                                (cic.lift cic.prop cic.prop _B) x_164 x_163))))
                    (_H_conj :
                       cic.Term cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (x_164 : cic.Term cic.prop _A =>
                             cic.prod cic.prop cic.prop _B
                               (x_163 : cic.Term cic.prop _B =>
                                Q_
                                  (matita_basics_logic.conj
                                     (cic.lift cic.prop cic.prop _A)
                                     (cic.lift cic.prop cic.prop _B) x_164
                                     x_163)))) =>
                     cic.prod cic.prop cic.prop
                       (matita_basics_logic.And
                          (cic.lift cic.prop cic.prop _A)
                          (cic.lift cic.prop cic.prop _B))
                       (x_162 :
                          cic.Term cic.prop
                            (matita_basics_logic.And
                               (cic.lift cic.prop cic.prop _A)
                               (cic.lift cic.prop cic.prop _B)) =>
                        Q_ x_162)))))).

def And_rect_CProp1_body :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
              (_B : cic.Univ cic.prop =>
               cic.prod (cic.type cic.z) cic.prop
                 (cic.prod cic.prop (cic.type cic.z)
                    (matita_basics_logic.And (cic.lift cic.prop cic.prop _A)
                       (cic.lift cic.prop cic.prop _B))
                    (_x_162 :
                       cic.Term cic.prop
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop _A)
                            (cic.lift cic.prop cic.prop _B)) =>
                     cic.univ cic.prop))
                 (Q_ :
                    cic.Term (cic.type cic.z)
                      (cic.prod cic.prop (cic.type cic.z)
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop _A)
                            (cic.lift cic.prop cic.prop _B))
                         (_x_162 :
                            cic.Term cic.prop
                              (matita_basics_logic.And
                                 (cic.lift cic.prop cic.prop _A)
                                 (cic.lift cic.prop cic.prop _B)) =>
                          cic.univ cic.prop)) =>
                  cic.prod cic.prop cic.prop
                    (cic.prod cic.prop cic.prop _A
                       (x_164 : cic.Term cic.prop _A =>
                        cic.prod cic.prop cic.prop _B
                          (x_163 : cic.Term cic.prop _B =>
                           Q_
                             (matita_basics_logic.conj
                                (cic.lift cic.prop cic.prop _A)
                                (cic.lift cic.prop cic.prop _B) x_164 x_163))))
                    (_H_conj :
                       cic.Term cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (x_164 : cic.Term cic.prop _A =>
                             cic.prod cic.prop cic.prop _B
                               (x_163 : cic.Term cic.prop _B =>
                                Q_
                                  (matita_basics_logic.conj
                                     (cic.lift cic.prop cic.prop _A)
                                     (cic.lift cic.prop cic.prop _B) x_164
                                     x_163)))) =>
                     cic.prod cic.prop cic.prop
                       (matita_basics_logic.And
                          (cic.lift cic.prop cic.prop _A)
                          (cic.lift cic.prop cic.prop _B))
                       (x_162 :
                          cic.Term cic.prop
                            (matita_basics_logic.And
                               (cic.lift cic.prop cic.prop _A)
                               (cic.lift cic.prop cic.prop _B)) =>
                        Q_ x_162)))))).

[ _A, _B, Q_, _H_conj, x_162 ] And_rect_CProp1 _A _B Q_ _H_conj x_162 -->
  matita_basics_logic.filter_And_Prop _A _B
    (x_162 :
       cic.Term cic.prop
         (matita_basics_logic.And (cic.lift cic.prop cic.prop _A)
            (cic.lift cic.prop cic.prop _B)) =>
     Q_ x_162)
    (matita_basics_logic.And_rect_CProp1_body _A _B Q_ _H_conj) x_162.

[ _A, _B, Q_, _H_conj, x_162 ]
  And_rect_CProp1_body _A _B Q_ _H_conj x_162 -->
  matita_basics_logic.match_And_Prop (cic.lift cic.prop cic.prop _A)
    (cic.lift cic.prop cic.prop _B) Q_
    (x_164 : cic.Term cic.prop _A =>
     x_163 : cic.Term cic.prop _B => _H_conj x_164 x_163)
    x_162.

def And_rect_CProp0 :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
              (_B : cic.Univ cic.prop =>
               cic.prod (cic.type cic.z) cic.prop
                 (cic.prod cic.prop (cic.type cic.z)
                    (matita_basics_logic.And (cic.lift cic.prop cic.prop _A)
                       (cic.lift cic.prop cic.prop _B))
                    (_x_166 :
                       cic.Term cic.prop
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop _A)
                            (cic.lift cic.prop cic.prop _B)) =>
                     cic.univ cic.prop))
                 (Q_ :
                    cic.Term (cic.type cic.z)
                      (cic.prod cic.prop (cic.type cic.z)
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop _A)
                            (cic.lift cic.prop cic.prop _B))
                         (_x_166 :
                            cic.Term cic.prop
                              (matita_basics_logic.And
                                 (cic.lift cic.prop cic.prop _A)
                                 (cic.lift cic.prop cic.prop _B)) =>
                          cic.univ cic.prop)) =>
                  cic.prod cic.prop cic.prop
                    (cic.prod cic.prop cic.prop _A
                       (x_168 : cic.Term cic.prop _A =>
                        cic.prod cic.prop cic.prop _B
                          (x_167 : cic.Term cic.prop _B =>
                           Q_
                             (matita_basics_logic.conj
                                (cic.lift cic.prop cic.prop _A)
                                (cic.lift cic.prop cic.prop _B) x_168 x_167))))
                    (_H_conj :
                       cic.Term cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (x_168 : cic.Term cic.prop _A =>
                             cic.prod cic.prop cic.prop _B
                               (x_167 : cic.Term cic.prop _B =>
                                Q_
                                  (matita_basics_logic.conj
                                     (cic.lift cic.prop cic.prop _A)
                                     (cic.lift cic.prop cic.prop _B) x_168
                                     x_167)))) =>
                     cic.prod cic.prop cic.prop
                       (matita_basics_logic.And
                          (cic.lift cic.prop cic.prop _A)
                          (cic.lift cic.prop cic.prop _B))
                       (x_166 :
                          cic.Term cic.prop
                            (matita_basics_logic.And
                               (cic.lift cic.prop cic.prop _A)
                               (cic.lift cic.prop cic.prop _B)) =>
                        Q_ x_166)))))).

def And_rect_CProp0_body :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
              (_B : cic.Univ cic.prop =>
               cic.prod (cic.type cic.z) cic.prop
                 (cic.prod cic.prop (cic.type cic.z)
                    (matita_basics_logic.And (cic.lift cic.prop cic.prop _A)
                       (cic.lift cic.prop cic.prop _B))
                    (_x_166 :
                       cic.Term cic.prop
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop _A)
                            (cic.lift cic.prop cic.prop _B)) =>
                     cic.univ cic.prop))
                 (Q_ :
                    cic.Term (cic.type cic.z)
                      (cic.prod cic.prop (cic.type cic.z)
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop _A)
                            (cic.lift cic.prop cic.prop _B))
                         (_x_166 :
                            cic.Term cic.prop
                              (matita_basics_logic.And
                                 (cic.lift cic.prop cic.prop _A)
                                 (cic.lift cic.prop cic.prop _B)) =>
                          cic.univ cic.prop)) =>
                  cic.prod cic.prop cic.prop
                    (cic.prod cic.prop cic.prop _A
                       (x_168 : cic.Term cic.prop _A =>
                        cic.prod cic.prop cic.prop _B
                          (x_167 : cic.Term cic.prop _B =>
                           Q_
                             (matita_basics_logic.conj
                                (cic.lift cic.prop cic.prop _A)
                                (cic.lift cic.prop cic.prop _B) x_168 x_167))))
                    (_H_conj :
                       cic.Term cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (x_168 : cic.Term cic.prop _A =>
                             cic.prod cic.prop cic.prop _B
                               (x_167 : cic.Term cic.prop _B =>
                                Q_
                                  (matita_basics_logic.conj
                                     (cic.lift cic.prop cic.prop _A)
                                     (cic.lift cic.prop cic.prop _B) x_168
                                     x_167)))) =>
                     cic.prod cic.prop cic.prop
                       (matita_basics_logic.And
                          (cic.lift cic.prop cic.prop _A)
                          (cic.lift cic.prop cic.prop _B))
                       (x_166 :
                          cic.Term cic.prop
                            (matita_basics_logic.And
                               (cic.lift cic.prop cic.prop _A)
                               (cic.lift cic.prop cic.prop _B)) =>
                        Q_ x_166)))))).

[ _A, _B, Q_, _H_conj, x_166 ] And_rect_CProp0 _A _B Q_ _H_conj x_166 -->
  matita_basics_logic.filter_And_Prop _A _B
    (x_166 :
       cic.Term cic.prop
         (matita_basics_logic.And (cic.lift cic.prop cic.prop _A)
            (cic.lift cic.prop cic.prop _B)) =>
     Q_ x_166)
    (matita_basics_logic.And_rect_CProp0_body _A _B Q_ _H_conj) x_166.

[ _A, _B, Q_, _H_conj, x_166 ]
  And_rect_CProp0_body _A _B Q_ _H_conj x_166 -->
  matita_basics_logic.match_And_Prop (cic.lift cic.prop cic.prop _A)
    (cic.lift cic.prop cic.prop _B) Q_
    (x_168 : cic.Term cic.prop _A =>
     x_167 : cic.Term cic.prop _B => _H_conj x_168 x_167)
    x_166.

def And_inv_ind :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
           (x1 : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
              (x2 : cic.Univ cic.prop =>
               cic.prod cic.prop cic.prop
                 (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                    (cic.lift cic.prop cic.prop x2))
                 (Hterm :
                    cic.Term cic.prop
                      (matita_basics_logic.And
                         (cic.lift cic.prop cic.prop x1)
                         (cic.lift cic.prop cic.prop x2)) =>
                  cic.prod (cic.type cic.z) cic.prop
                    (cic.prod cic.prop (cic.type cic.z)
                       (matita_basics_logic.And
                          (cic.lift cic.prop cic.prop x1)
                          (cic.lift cic.prop cic.prop x2))
                       (_z323 :
                          cic.Term cic.prop
                            (matita_basics_logic.And
                               (cic.lift cic.prop cic.prop x1)
                               (cic.lift cic.prop cic.prop x2)) =>
                        cic.univ cic.prop))
                    (P :
                       cic.Term (cic.type cic.z)
                         (cic.prod cic.prop (cic.type cic.z)
                            (matita_basics_logic.And
                               (cic.lift cic.prop cic.prop x1)
                               (cic.lift cic.prop cic.prop x2))
                            (_z323 :
                               cic.Term cic.prop
                                 (matita_basics_logic.And
                                    (cic.lift cic.prop cic.prop x1)
                                    (cic.lift cic.prop cic.prop x2)) =>
                             cic.univ cic.prop)) =>
                     cic.prod cic.prop cic.prop
                       (cic.prod cic.prop cic.prop x1
                          (x_120 : cic.Term cic.prop x1 =>
                           cic.prod cic.prop cic.prop x2
                             (x_119 : cic.Term cic.prop x2 =>
                              cic.prod cic.prop cic.prop
                                (matita_basics_logic.eq
                                   (cic.lift cic.prop
                                      (cic.type (cic.s (cic.s cic.z)))
                                      (matita_basics_logic.And
                                         (cic.lift cic.prop cic.prop x1)
                                         (cic.lift cic.prop cic.prop x2)))
                                   Hterm
                                   (matita_basics_logic.conj
                                      (cic.lift cic.prop cic.prop x1)
                                      (cic.lift cic.prop cic.prop x2) x_120
                                      x_119))
                                (_z324 :
                                   cic.Term cic.prop
                                     (matita_basics_logic.eq
                                        (cic.lift cic.prop
                                           (cic.type (cic.s (cic.s cic.z)))
                                           (matita_basics_logic.And
                                              (cic.lift cic.prop cic.prop x1)
                                              (cic.lift cic.prop cic.prop x2)))
                                        Hterm
                                        (matita_basics_logic.conj
                                           (cic.lift cic.prop cic.prop x1)
                                           (cic.lift cic.prop cic.prop x2)
                                           x_120 x_119)) =>
                                 P
                                   (matita_basics_logic.conj
                                      (cic.lift cic.prop cic.prop x1)
                                      (cic.lift cic.prop cic.prop x2) x_120
                                      x_119)))))
                       (_H1 :
                          cic.Term cic.prop
                            (cic.prod cic.prop cic.prop x1
                               (x_120 : cic.Term cic.prop x1 =>
                                cic.prod cic.prop cic.prop x2
                                  (x_119 : cic.Term cic.prop x2 =>
                                   cic.prod cic.prop cic.prop
                                     (matita_basics_logic.eq
                                        (cic.lift cic.prop
                                           (cic.type (cic.s (cic.s cic.z)))
                                           (matita_basics_logic.And
                                              (cic.lift cic.prop cic.prop x1)
                                              (cic.lift cic.prop cic.prop x2)))
                                        Hterm
                                        (matita_basics_logic.conj
                                           (cic.lift cic.prop cic.prop x1)
                                           (cic.lift cic.prop cic.prop x2)
                                           x_120 x_119))
                                     (_z324 :
                                        cic.Term cic.prop
                                          (matita_basics_logic.eq
                                             (cic.lift cic.prop
                                                (cic.type
                                                   (cic.s (cic.s cic.z)))
                                                (matita_basics_logic.And
                                                   (cic.lift cic.prop
                                                      cic.prop x1)
                                                   (cic.lift cic.prop
                                                      cic.prop x2)))
                                             Hterm
                                             (matita_basics_logic.conj
                                                (cic.lift cic.prop cic.prop
                                                   x1)
                                                (cic.lift cic.prop cic.prop
                                                   x2)
                                                x_120 x_119)) =>
                                      P
                                        (matita_basics_logic.conj
                                           (cic.lift cic.prop cic.prop x1)
                                           (cic.lift cic.prop cic.prop x2)
                                           x_120 x_119))))) =>
                        P Hterm))))))
      :=
      x1 : cic.Univ cic.prop =>
      x2 : cic.Univ cic.prop =>
      Hterm :
        cic.Term cic.prop
          (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
             (cic.lift cic.prop cic.prop x2)) =>
      P :
        cic.Term (cic.type cic.z)
          (cic.prod cic.prop (cic.type cic.z)
             (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                (cic.lift cic.prop cic.prop x2))
             (_z323 :
                cic.Term cic.prop
                  (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                     (cic.lift cic.prop cic.prop x2)) =>
              cic.univ cic.prop)) =>
      H1 :
        cic.Term cic.prop
          (cic.prod cic.prop cic.prop x1
             (x_120 : cic.Term cic.prop x1 =>
              cic.prod cic.prop cic.prop x2
                (x_119 : cic.Term cic.prop x2 =>
                 cic.prod cic.prop cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop x1)
                            (cic.lift cic.prop cic.prop x2)))
                      Hterm
                      (matita_basics_logic.conj
                         (cic.lift cic.prop cic.prop x1)
                         (cic.lift cic.prop cic.prop x2) x_120 x_119))
                   (_z324 :
                      cic.Term cic.prop
                        (matita_basics_logic.eq
                           (cic.lift cic.prop
                              (cic.type (cic.s (cic.s cic.z)))
                              (matita_basics_logic.And
                                 (cic.lift cic.prop cic.prop x1)
                                 (cic.lift cic.prop cic.prop x2)))
                           Hterm
                           (matita_basics_logic.conj
                              (cic.lift cic.prop cic.prop x1)
                              (cic.lift cic.prop cic.prop x2) x_120 x_119)) =>
                    P
                      (matita_basics_logic.conj
                         (cic.lift cic.prop cic.prop x1)
                         (cic.lift cic.prop cic.prop x2) x_120 x_119))))) =>
      (Hcut :
         cic.Term cic.prop
           (cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                       (cic.lift cic.prop cic.prop x2)))
                 Hterm Hterm)
              (_z324 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop x1)
                            (cic.lift cic.prop cic.prop x2)))
                      Hterm Hterm) =>
               P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
               (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                  (cic.lift cic.prop cic.prop x2)))
            Hterm))
        (matita_basics_logic.And_ind (cic.lift cic.prop cic.prop x1)
           (cic.lift cic.prop cic.prop x2)
           (_x_118 :
              cic.Term cic.prop
                (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                   (cic.lift cic.prop cic.prop x2)) =>
            cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                       (cic.lift cic.prop cic.prop x2)))
                 Hterm _x_118)
              (_z324 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop x1)
                            (cic.lift cic.prop cic.prop x2)))
                      Hterm _x_118) =>
               P _x_118))
           H1 Hterm).

def And_inv_rect_Type4 :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
        (cic.prod (cic.type cic.z)
           (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
           (cic.univ cic.prop)
           (x1 : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z)
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
              (cic.univ cic.prop)
              (x2 : cic.Univ cic.prop =>
               cic.prod cic.prop
                 (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                 (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                    (cic.lift cic.prop cic.prop x2))
                 (Hterm :
                    cic.Term cic.prop
                      (matita_basics_logic.And
                         (cic.lift cic.prop cic.prop x1)
                         (cic.lift cic.prop cic.prop x2)) =>
                  cic.prod
                    (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                    (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                    (cic.prod cic.prop
                       (cic.type
                          (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                       (matita_basics_logic.And
                          (cic.lift cic.prop cic.prop x1)
                          (cic.lift cic.prop cic.prop x2))
                       (_z329 :
                          cic.Term cic.prop
                            (matita_basics_logic.And
                               (cic.lift cic.prop cic.prop x1)
                               (cic.lift cic.prop cic.prop x2)) =>
                        cic.univ
                          (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                    (P :
                       cic.Term
                         (cic.type
                            (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                         (cic.prod cic.prop
                            (cic.type
                               (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                            (matita_basics_logic.And
                               (cic.lift cic.prop cic.prop x1)
                               (cic.lift cic.prop cic.prop x2))
                            (_z329 :
                               cic.Term cic.prop
                                 (matita_basics_logic.And
                                    (cic.lift cic.prop cic.prop x1)
                                    (cic.lift cic.prop cic.prop x2)) =>
                             cic.univ
                               (cic.type
                                  (cic.s (cic.s (cic.s (cic.s cic.z))))))) =>
                     cic.prod
                       (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                       (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                       (cic.prod cic.prop
                          (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))) x1
                          (x_124 : cic.Term cic.prop x1 =>
                           cic.prod cic.prop
                             (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                             x2
                             (x_123 : cic.Term cic.prop x2 =>
                              cic.prod cic.prop
                                (cic.type
                                   (cic.s (cic.s (cic.s (cic.s cic.z)))))
                                (matita_basics_logic.eq
                                   (cic.lift cic.prop
                                      (cic.type (cic.s (cic.s cic.z)))
                                      (matita_basics_logic.And
                                         (cic.lift cic.prop cic.prop x1)
                                         (cic.lift cic.prop cic.prop x2)))
                                   Hterm
                                   (matita_basics_logic.conj
                                      (cic.lift cic.prop cic.prop x1)
                                      (cic.lift cic.prop cic.prop x2) x_124
                                      x_123))
                                (_z330 :
                                   cic.Term cic.prop
                                     (matita_basics_logic.eq
                                        (cic.lift cic.prop
                                           (cic.type (cic.s (cic.s cic.z)))
                                           (matita_basics_logic.And
                                              (cic.lift cic.prop cic.prop x1)
                                              (cic.lift cic.prop cic.prop x2)))
                                        Hterm
                                        (matita_basics_logic.conj
                                           (cic.lift cic.prop cic.prop x1)
                                           (cic.lift cic.prop cic.prop x2)
                                           x_124 x_123)) =>
                                 P
                                   (matita_basics_logic.conj
                                      (cic.lift cic.prop cic.prop x1)
                                      (cic.lift cic.prop cic.prop x2) x_124
                                      x_123)))))
                       (_H1 :
                          cic.Term
                            (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                            (cic.prod cic.prop
                               (cic.type
                                  (cic.s (cic.s (cic.s (cic.s cic.z)))))
                               x1
                               (x_124 : cic.Term cic.prop x1 =>
                                cic.prod cic.prop
                                  (cic.type
                                     (cic.s (cic.s (cic.s (cic.s cic.z)))))
                                  x2
                                  (x_123 : cic.Term cic.prop x2 =>
                                   cic.prod cic.prop
                                     (cic.type
                                        (cic.s (cic.s (cic.s (cic.s cic.z)))))
                                     (matita_basics_logic.eq
                                        (cic.lift cic.prop
                                           (cic.type (cic.s (cic.s cic.z)))
                                           (matita_basics_logic.And
                                              (cic.lift cic.prop cic.prop x1)
                                              (cic.lift cic.prop cic.prop x2)))
                                        Hterm
                                        (matita_basics_logic.conj
                                           (cic.lift cic.prop cic.prop x1)
                                           (cic.lift cic.prop cic.prop x2)
                                           x_124 x_123))
                                     (_z330 :
                                        cic.Term cic.prop
                                          (matita_basics_logic.eq
                                             (cic.lift cic.prop
                                                (cic.type
                                                   (cic.s (cic.s cic.z)))
                                                (matita_basics_logic.And
                                                   (cic.lift cic.prop
                                                      cic.prop x1)
                                                   (cic.lift cic.prop
                                                      cic.prop x2)))
                                             Hterm
                                             (matita_basics_logic.conj
                                                (cic.lift cic.prop cic.prop
                                                   x1)
                                                (cic.lift cic.prop cic.prop
                                                   x2)
                                                x_124 x_123)) =>
                                      P
                                        (matita_basics_logic.conj
                                           (cic.lift cic.prop cic.prop x1)
                                           (cic.lift cic.prop cic.prop x2)
                                           x_124 x_123))))) =>
                        P Hterm))))))
      :=
      x1 : cic.Univ cic.prop =>
      x2 : cic.Univ cic.prop =>
      Hterm :
        cic.Term cic.prop
          (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
             (cic.lift cic.prop cic.prop x2)) =>
      P :
        cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
          (cic.prod cic.prop
             (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
             (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                (cic.lift cic.prop cic.prop x2))
             (_z329 :
                cic.Term cic.prop
                  (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                     (cic.lift cic.prop cic.prop x2)) =>
              cic.univ (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))))) =>
      H1 :
        cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
          (cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
             x1
             (x_124 : cic.Term cic.prop x1 =>
              cic.prod cic.prop
                (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))) x2
                (x_123 : cic.Term cic.prop x2 =>
                 cic.prod cic.prop
                   (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop x1)
                            (cic.lift cic.prop cic.prop x2)))
                      Hterm
                      (matita_basics_logic.conj
                         (cic.lift cic.prop cic.prop x1)
                         (cic.lift cic.prop cic.prop x2) x_124 x_123))
                   (_z330 :
                      cic.Term cic.prop
                        (matita_basics_logic.eq
                           (cic.lift cic.prop
                              (cic.type (cic.s (cic.s cic.z)))
                              (matita_basics_logic.And
                                 (cic.lift cic.prop cic.prop x1)
                                 (cic.lift cic.prop cic.prop x2)))
                           Hterm
                           (matita_basics_logic.conj
                              (cic.lift cic.prop cic.prop x1)
                              (cic.lift cic.prop cic.prop x2) x_124 x_123)) =>
                    P
                      (matita_basics_logic.conj
                         (cic.lift cic.prop cic.prop x1)
                         (cic.lift cic.prop cic.prop x2) x_124 x_123))))) =>
      (Hcut :
         cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
           (cic.prod cic.prop
              (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                       (cic.lift cic.prop cic.prop x2)))
                 Hterm Hterm)
              (_z330 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop x1)
                            (cic.lift cic.prop cic.prop x2)))
                      Hterm Hterm) =>
               P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
               (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                  (cic.lift cic.prop cic.prop x2)))
            Hterm))
        (matita_basics_logic.And_rect_Type4 (cic.lift cic.prop cic.prop x1)
           (cic.lift cic.prop cic.prop x2)
           (_x_122 :
              cic.Term cic.prop
                (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                   (cic.lift cic.prop cic.prop x2)) =>
            cic.prod cic.prop
              (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                       (cic.lift cic.prop cic.prop x2)))
                 Hterm _x_122)
              (_z330 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop x1)
                            (cic.lift cic.prop cic.prop x2)))
                      Hterm _x_122) =>
               P _x_122))
           H1 Hterm).

def And_inv_rect_Type3 :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
        (cic.prod (cic.type cic.z)
           (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
           (cic.univ cic.prop)
           (x1 : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z)
              (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
              (cic.univ cic.prop)
              (x2 : cic.Univ cic.prop =>
               cic.prod cic.prop
                 (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                 (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                    (cic.lift cic.prop cic.prop x2))
                 (Hterm :
                    cic.Term cic.prop
                      (matita_basics_logic.And
                         (cic.lift cic.prop cic.prop x1)
                         (cic.lift cic.prop cic.prop x2)) =>
                  cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                    (cic.type (cic.s (cic.s (cic.s cic.z))))
                    (cic.prod cic.prop
                       (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                       (matita_basics_logic.And
                          (cic.lift cic.prop cic.prop x1)
                          (cic.lift cic.prop cic.prop x2))
                       (_z335 :
                          cic.Term cic.prop
                            (matita_basics_logic.And
                               (cic.lift cic.prop cic.prop x1)
                               (cic.lift cic.prop cic.prop x2)) =>
                        cic.univ (cic.type (cic.s (cic.s (cic.s cic.z))))))
                    (P :
                       cic.Term
                         (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                         (cic.prod cic.prop
                            (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                            (matita_basics_logic.And
                               (cic.lift cic.prop cic.prop x1)
                               (cic.lift cic.prop cic.prop x2))
                            (_z335 :
                               cic.Term cic.prop
                                 (matita_basics_logic.And
                                    (cic.lift cic.prop cic.prop x1)
                                    (cic.lift cic.prop cic.prop x2)) =>
                             cic.univ
                               (cic.type (cic.s (cic.s (cic.s cic.z)))))) =>
                     cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
                       (cic.type (cic.s (cic.s (cic.s cic.z))))
                       (cic.prod cic.prop
                          (cic.type (cic.s (cic.s (cic.s cic.z)))) x1
                          (x_132 : cic.Term cic.prop x1 =>
                           cic.prod cic.prop
                             (cic.type (cic.s (cic.s (cic.s cic.z)))) x2
                             (x_131 : cic.Term cic.prop x2 =>
                              cic.prod cic.prop
                                (cic.type (cic.s (cic.s (cic.s cic.z))))
                                (matita_basics_logic.eq
                                   (cic.lift cic.prop
                                      (cic.type (cic.s (cic.s cic.z)))
                                      (matita_basics_logic.And
                                         (cic.lift cic.prop cic.prop x1)
                                         (cic.lift cic.prop cic.prop x2)))
                                   Hterm
                                   (matita_basics_logic.conj
                                      (cic.lift cic.prop cic.prop x1)
                                      (cic.lift cic.prop cic.prop x2) x_132
                                      x_131))
                                (_z336 :
                                   cic.Term cic.prop
                                     (matita_basics_logic.eq
                                        (cic.lift cic.prop
                                           (cic.type (cic.s (cic.s cic.z)))
                                           (matita_basics_logic.And
                                              (cic.lift cic.prop cic.prop x1)
                                              (cic.lift cic.prop cic.prop x2)))
                                        Hterm
                                        (matita_basics_logic.conj
                                           (cic.lift cic.prop cic.prop x1)
                                           (cic.lift cic.prop cic.prop x2)
                                           x_132 x_131)) =>
                                 P
                                   (matita_basics_logic.conj
                                      (cic.lift cic.prop cic.prop x1)
                                      (cic.lift cic.prop cic.prop x2) x_132
                                      x_131)))))
                       (_H1 :
                          cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                            (cic.prod cic.prop
                               (cic.type (cic.s (cic.s (cic.s cic.z)))) x1
                               (x_132 : cic.Term cic.prop x1 =>
                                cic.prod cic.prop
                                  (cic.type (cic.s (cic.s (cic.s cic.z)))) x2
                                  (x_131 : cic.Term cic.prop x2 =>
                                   cic.prod cic.prop
                                     (cic.type (cic.s (cic.s (cic.s cic.z))))
                                     (matita_basics_logic.eq
                                        (cic.lift cic.prop
                                           (cic.type (cic.s (cic.s cic.z)))
                                           (matita_basics_logic.And
                                              (cic.lift cic.prop cic.prop x1)
                                              (cic.lift cic.prop cic.prop x2)))
                                        Hterm
                                        (matita_basics_logic.conj
                                           (cic.lift cic.prop cic.prop x1)
                                           (cic.lift cic.prop cic.prop x2)
                                           x_132 x_131))
                                     (_z336 :
                                        cic.Term cic.prop
                                          (matita_basics_logic.eq
                                             (cic.lift cic.prop
                                                (cic.type
                                                   (cic.s (cic.s cic.z)))
                                                (matita_basics_logic.And
                                                   (cic.lift cic.prop
                                                      cic.prop x1)
                                                   (cic.lift cic.prop
                                                      cic.prop x2)))
                                             Hterm
                                             (matita_basics_logic.conj
                                                (cic.lift cic.prop cic.prop
                                                   x1)
                                                (cic.lift cic.prop cic.prop
                                                   x2)
                                                x_132 x_131)) =>
                                      P
                                        (matita_basics_logic.conj
                                           (cic.lift cic.prop cic.prop x1)
                                           (cic.lift cic.prop cic.prop x2)
                                           x_132 x_131))))) =>
                        P Hterm))))))
      :=
      x1 : cic.Univ cic.prop =>
      x2 : cic.Univ cic.prop =>
      Hterm :
        cic.Term cic.prop
          (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
             (cic.lift cic.prop cic.prop x2)) =>
      P :
        cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
          (cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
             (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                (cic.lift cic.prop cic.prop x2))
             (_z335 :
                cic.Term cic.prop
                  (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                     (cic.lift cic.prop cic.prop x2)) =>
              cic.univ (cic.type (cic.s (cic.s (cic.s cic.z)))))) =>
      H1 :
        cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
          (cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z)))) x1
             (x_132 : cic.Term cic.prop x1 =>
              cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z)))) x2
                (x_131 : cic.Term cic.prop x2 =>
                 cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop x1)
                            (cic.lift cic.prop cic.prop x2)))
                      Hterm
                      (matita_basics_logic.conj
                         (cic.lift cic.prop cic.prop x1)
                         (cic.lift cic.prop cic.prop x2) x_132 x_131))
                   (_z336 :
                      cic.Term cic.prop
                        (matita_basics_logic.eq
                           (cic.lift cic.prop
                              (cic.type (cic.s (cic.s cic.z)))
                              (matita_basics_logic.And
                                 (cic.lift cic.prop cic.prop x1)
                                 (cic.lift cic.prop cic.prop x2)))
                           Hterm
                           (matita_basics_logic.conj
                              (cic.lift cic.prop cic.prop x1)
                              (cic.lift cic.prop cic.prop x2) x_132 x_131)) =>
                    P
                      (matita_basics_logic.conj
                         (cic.lift cic.prop cic.prop x1)
                         (cic.lift cic.prop cic.prop x2) x_132 x_131))))) =>
      (Hcut :
         cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                       (cic.lift cic.prop cic.prop x2)))
                 Hterm Hterm)
              (_z336 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop x1)
                            (cic.lift cic.prop cic.prop x2)))
                      Hterm Hterm) =>
               P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
               (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                  (cic.lift cic.prop cic.prop x2)))
            Hterm))
        (matita_basics_logic.And_rect_Type3 (cic.lift cic.prop cic.prop x1)
           (cic.lift cic.prop cic.prop x2)
           (_x_130 :
              cic.Term cic.prop
                (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                   (cic.lift cic.prop cic.prop x2)) =>
            cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                       (cic.lift cic.prop cic.prop x2)))
                 Hterm _x_130)
              (_z336 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop x1)
                            (cic.lift cic.prop cic.prop x2)))
                      Hterm _x_130) =>
               P _x_130))
           H1 Hterm).

def And_inv_rect_Type2 :
      cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
        (cic.prod (cic.type cic.z) (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.univ cic.prop)
           (x1 : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z)
              (cic.type (cic.s (cic.s (cic.s cic.z)))) (cic.univ cic.prop)
              (x2 : cic.Univ cic.prop =>
               cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
                 (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                    (cic.lift cic.prop cic.prop x2))
                 (Hterm :
                    cic.Term cic.prop
                      (matita_basics_logic.And
                         (cic.lift cic.prop cic.prop x1)
                         (cic.lift cic.prop cic.prop x2)) =>
                  cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
                    (cic.type (cic.s (cic.s cic.z)))
                    (cic.prod cic.prop
                       (cic.type (cic.s (cic.s (cic.s cic.z))))
                       (matita_basics_logic.And
                          (cic.lift cic.prop cic.prop x1)
                          (cic.lift cic.prop cic.prop x2))
                       (_z341 :
                          cic.Term cic.prop
                            (matita_basics_logic.And
                               (cic.lift cic.prop cic.prop x1)
                               (cic.lift cic.prop cic.prop x2)) =>
                        cic.univ (cic.type (cic.s (cic.s cic.z)))))
                    (P :
                       cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                         (cic.prod cic.prop
                            (cic.type (cic.s (cic.s (cic.s cic.z))))
                            (matita_basics_logic.And
                               (cic.lift cic.prop cic.prop x1)
                               (cic.lift cic.prop cic.prop x2))
                            (_z341 :
                               cic.Term cic.prop
                                 (matita_basics_logic.And
                                    (cic.lift cic.prop cic.prop x1)
                                    (cic.lift cic.prop cic.prop x2)) =>
                             cic.univ (cic.type (cic.s (cic.s cic.z))))) =>
                     cic.prod (cic.type (cic.s (cic.s cic.z)))
                       (cic.type (cic.s (cic.s cic.z)))
                       (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z))) x1
                          (x_136 : cic.Term cic.prop x1 =>
                           cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                             x2
                             (x_135 : cic.Term cic.prop x2 =>
                              cic.prod cic.prop
                                (cic.type (cic.s (cic.s cic.z)))
                                (matita_basics_logic.eq
                                   (cic.lift cic.prop
                                      (cic.type (cic.s (cic.s cic.z)))
                                      (matita_basics_logic.And
                                         (cic.lift cic.prop cic.prop x1)
                                         (cic.lift cic.prop cic.prop x2)))
                                   Hterm
                                   (matita_basics_logic.conj
                                      (cic.lift cic.prop cic.prop x1)
                                      (cic.lift cic.prop cic.prop x2) x_136
                                      x_135))
                                (_z342 :
                                   cic.Term cic.prop
                                     (matita_basics_logic.eq
                                        (cic.lift cic.prop
                                           (cic.type (cic.s (cic.s cic.z)))
                                           (matita_basics_logic.And
                                              (cic.lift cic.prop cic.prop x1)
                                              (cic.lift cic.prop cic.prop x2)))
                                        Hterm
                                        (matita_basics_logic.conj
                                           (cic.lift cic.prop cic.prop x1)
                                           (cic.lift cic.prop cic.prop x2)
                                           x_136 x_135)) =>
                                 P
                                   (matita_basics_logic.conj
                                      (cic.lift cic.prop cic.prop x1)
                                      (cic.lift cic.prop cic.prop x2) x_136
                                      x_135)))))
                       (_H1 :
                          cic.Term (cic.type (cic.s (cic.s cic.z)))
                            (cic.prod cic.prop
                               (cic.type (cic.s (cic.s cic.z))) x1
                               (x_136 : cic.Term cic.prop x1 =>
                                cic.prod cic.prop
                                  (cic.type (cic.s (cic.s cic.z))) x2
                                  (x_135 : cic.Term cic.prop x2 =>
                                   cic.prod cic.prop
                                     (cic.type (cic.s (cic.s cic.z)))
                                     (matita_basics_logic.eq
                                        (cic.lift cic.prop
                                           (cic.type (cic.s (cic.s cic.z)))
                                           (matita_basics_logic.And
                                              (cic.lift cic.prop cic.prop x1)
                                              (cic.lift cic.prop cic.prop x2)))
                                        Hterm
                                        (matita_basics_logic.conj
                                           (cic.lift cic.prop cic.prop x1)
                                           (cic.lift cic.prop cic.prop x2)
                                           x_136 x_135))
                                     (_z342 :
                                        cic.Term cic.prop
                                          (matita_basics_logic.eq
                                             (cic.lift cic.prop
                                                (cic.type
                                                   (cic.s (cic.s cic.z)))
                                                (matita_basics_logic.And
                                                   (cic.lift cic.prop
                                                      cic.prop x1)
                                                   (cic.lift cic.prop
                                                      cic.prop x2)))
                                             Hterm
                                             (matita_basics_logic.conj
                                                (cic.lift cic.prop cic.prop
                                                   x1)
                                                (cic.lift cic.prop cic.prop
                                                   x2)
                                                x_136 x_135)) =>
                                      P
                                        (matita_basics_logic.conj
                                           (cic.lift cic.prop cic.prop x1)
                                           (cic.lift cic.prop cic.prop x2)
                                           x_136 x_135))))) =>
                        P Hterm))))))
      :=
      x1 : cic.Univ cic.prop =>
      x2 : cic.Univ cic.prop =>
      Hterm :
        cic.Term cic.prop
          (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
             (cic.lift cic.prop cic.prop x2)) =>
      P :
        cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
          (cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
             (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                (cic.lift cic.prop cic.prop x2))
             (_z341 :
                cic.Term cic.prop
                  (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                     (cic.lift cic.prop cic.prop x2)) =>
              cic.univ (cic.type (cic.s (cic.s cic.z))))) =>
      H1 :
        cic.Term (cic.type (cic.s (cic.s cic.z)))
          (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z))) x1
             (x_136 : cic.Term cic.prop x1 =>
              cic.prod cic.prop (cic.type (cic.s (cic.s cic.z))) x2
                (x_135 : cic.Term cic.prop x2 =>
                 cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop x1)
                            (cic.lift cic.prop cic.prop x2)))
                      Hterm
                      (matita_basics_logic.conj
                         (cic.lift cic.prop cic.prop x1)
                         (cic.lift cic.prop cic.prop x2) x_136 x_135))
                   (_z342 :
                      cic.Term cic.prop
                        (matita_basics_logic.eq
                           (cic.lift cic.prop
                              (cic.type (cic.s (cic.s cic.z)))
                              (matita_basics_logic.And
                                 (cic.lift cic.prop cic.prop x1)
                                 (cic.lift cic.prop cic.prop x2)))
                           Hterm
                           (matita_basics_logic.conj
                              (cic.lift cic.prop cic.prop x1)
                              (cic.lift cic.prop cic.prop x2) x_136 x_135)) =>
                    P
                      (matita_basics_logic.conj
                         (cic.lift cic.prop cic.prop x1)
                         (cic.lift cic.prop cic.prop x2) x_136 x_135))))) =>
      (Hcut :
         cic.Term (cic.type (cic.s (cic.s cic.z)))
           (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                       (cic.lift cic.prop cic.prop x2)))
                 Hterm Hterm)
              (_z342 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop x1)
                            (cic.lift cic.prop cic.prop x2)))
                      Hterm Hterm) =>
               P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
               (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                  (cic.lift cic.prop cic.prop x2)))
            Hterm))
        (matita_basics_logic.And_rect_Type2 (cic.lift cic.prop cic.prop x1)
           (cic.lift cic.prop cic.prop x2)
           (_x_134 :
              cic.Term cic.prop
                (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                   (cic.lift cic.prop cic.prop x2)) =>
            cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                       (cic.lift cic.prop cic.prop x2)))
                 Hterm _x_134)
              (_z342 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop x1)
                            (cic.lift cic.prop cic.prop x2)))
                      Hterm _x_134) =>
               P _x_134))
           H1 Hterm).

def And_inv_rect_Type1 :
      cic.Term (cic.type (cic.s (cic.s cic.z)))
        (cic.prod (cic.type cic.z) (cic.type (cic.s (cic.s cic.z)))
           (cic.univ cic.prop)
           (x1 : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) (cic.type (cic.s (cic.s cic.z)))
              (cic.univ cic.prop)
              (x2 : cic.Univ cic.prop =>
               cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                 (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                    (cic.lift cic.prop cic.prop x2))
                 (Hterm :
                    cic.Term cic.prop
                      (matita_basics_logic.And
                         (cic.lift cic.prop cic.prop x1)
                         (cic.lift cic.prop cic.prop x2)) =>
                  cic.prod (cic.type (cic.s (cic.s cic.z)))
                    (cic.type (cic.s cic.z))
                    (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                       (matita_basics_logic.And
                          (cic.lift cic.prop cic.prop x1)
                          (cic.lift cic.prop cic.prop x2))
                       (_z347 :
                          cic.Term cic.prop
                            (matita_basics_logic.And
                               (cic.lift cic.prop cic.prop x1)
                               (cic.lift cic.prop cic.prop x2)) =>
                        cic.univ (cic.type (cic.s cic.z))))
                    (P :
                       cic.Term (cic.type (cic.s (cic.s cic.z)))
                         (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                            (matita_basics_logic.And
                               (cic.lift cic.prop cic.prop x1)
                               (cic.lift cic.prop cic.prop x2))
                            (_z347 :
                               cic.Term cic.prop
                                 (matita_basics_logic.And
                                    (cic.lift cic.prop cic.prop x1)
                                    (cic.lift cic.prop cic.prop x2)) =>
                             cic.univ (cic.type (cic.s cic.z)))) =>
                     cic.prod (cic.type (cic.s cic.z))
                       (cic.type (cic.s cic.z))
                       (cic.prod cic.prop (cic.type (cic.s cic.z)) x1
                          (x_140 : cic.Term cic.prop x1 =>
                           cic.prod cic.prop (cic.type (cic.s cic.z)) x2
                             (x_139 : cic.Term cic.prop x2 =>
                              cic.prod cic.prop (cic.type (cic.s cic.z))
                                (matita_basics_logic.eq
                                   (cic.lift cic.prop
                                      (cic.type (cic.s (cic.s cic.z)))
                                      (matita_basics_logic.And
                                         (cic.lift cic.prop cic.prop x1)
                                         (cic.lift cic.prop cic.prop x2)))
                                   Hterm
                                   (matita_basics_logic.conj
                                      (cic.lift cic.prop cic.prop x1)
                                      (cic.lift cic.prop cic.prop x2) x_140
                                      x_139))
                                (_z348 :
                                   cic.Term cic.prop
                                     (matita_basics_logic.eq
                                        (cic.lift cic.prop
                                           (cic.type (cic.s (cic.s cic.z)))
                                           (matita_basics_logic.And
                                              (cic.lift cic.prop cic.prop x1)
                                              (cic.lift cic.prop cic.prop x2)))
                                        Hterm
                                        (matita_basics_logic.conj
                                           (cic.lift cic.prop cic.prop x1)
                                           (cic.lift cic.prop cic.prop x2)
                                           x_140 x_139)) =>
                                 P
                                   (matita_basics_logic.conj
                                      (cic.lift cic.prop cic.prop x1)
                                      (cic.lift cic.prop cic.prop x2) x_140
                                      x_139)))))
                       (_H1 :
                          cic.Term (cic.type (cic.s cic.z))
                            (cic.prod cic.prop (cic.type (cic.s cic.z)) x1
                               (x_140 : cic.Term cic.prop x1 =>
                                cic.prod cic.prop (cic.type (cic.s cic.z)) x2
                                  (x_139 : cic.Term cic.prop x2 =>
                                   cic.prod cic.prop (cic.type (cic.s cic.z))
                                     (matita_basics_logic.eq
                                        (cic.lift cic.prop
                                           (cic.type (cic.s (cic.s cic.z)))
                                           (matita_basics_logic.And
                                              (cic.lift cic.prop cic.prop x1)
                                              (cic.lift cic.prop cic.prop x2)))
                                        Hterm
                                        (matita_basics_logic.conj
                                           (cic.lift cic.prop cic.prop x1)
                                           (cic.lift cic.prop cic.prop x2)
                                           x_140 x_139))
                                     (_z348 :
                                        cic.Term cic.prop
                                          (matita_basics_logic.eq
                                             (cic.lift cic.prop
                                                (cic.type
                                                   (cic.s (cic.s cic.z)))
                                                (matita_basics_logic.And
                                                   (cic.lift cic.prop
                                                      cic.prop x1)
                                                   (cic.lift cic.prop
                                                      cic.prop x2)))
                                             Hterm
                                             (matita_basics_logic.conj
                                                (cic.lift cic.prop cic.prop
                                                   x1)
                                                (cic.lift cic.prop cic.prop
                                                   x2)
                                                x_140 x_139)) =>
                                      P
                                        (matita_basics_logic.conj
                                           (cic.lift cic.prop cic.prop x1)
                                           (cic.lift cic.prop cic.prop x2)
                                           x_140 x_139))))) =>
                        P Hterm))))))
      :=
      x1 : cic.Univ cic.prop =>
      x2 : cic.Univ cic.prop =>
      Hterm :
        cic.Term cic.prop
          (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
             (cic.lift cic.prop cic.prop x2)) =>
      P :
        cic.Term (cic.type (cic.s (cic.s cic.z)))
          (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
             (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                (cic.lift cic.prop cic.prop x2))
             (_z347 :
                cic.Term cic.prop
                  (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                     (cic.lift cic.prop cic.prop x2)) =>
              cic.univ (cic.type (cic.s cic.z)))) =>
      H1 :
        cic.Term (cic.type (cic.s cic.z))
          (cic.prod cic.prop (cic.type (cic.s cic.z)) x1
             (x_140 : cic.Term cic.prop x1 =>
              cic.prod cic.prop (cic.type (cic.s cic.z)) x2
                (x_139 : cic.Term cic.prop x2 =>
                 cic.prod cic.prop (cic.type (cic.s cic.z))
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop x1)
                            (cic.lift cic.prop cic.prop x2)))
                      Hterm
                      (matita_basics_logic.conj
                         (cic.lift cic.prop cic.prop x1)
                         (cic.lift cic.prop cic.prop x2) x_140 x_139))
                   (_z348 :
                      cic.Term cic.prop
                        (matita_basics_logic.eq
                           (cic.lift cic.prop
                              (cic.type (cic.s (cic.s cic.z)))
                              (matita_basics_logic.And
                                 (cic.lift cic.prop cic.prop x1)
                                 (cic.lift cic.prop cic.prop x2)))
                           Hterm
                           (matita_basics_logic.conj
                              (cic.lift cic.prop cic.prop x1)
                              (cic.lift cic.prop cic.prop x2) x_140 x_139)) =>
                    P
                      (matita_basics_logic.conj
                         (cic.lift cic.prop cic.prop x1)
                         (cic.lift cic.prop cic.prop x2) x_140 x_139))))) =>
      (Hcut :
         cic.Term (cic.type (cic.s cic.z))
           (cic.prod cic.prop (cic.type (cic.s cic.z))
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                       (cic.lift cic.prop cic.prop x2)))
                 Hterm Hterm)
              (_z348 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop x1)
                            (cic.lift cic.prop cic.prop x2)))
                      Hterm Hterm) =>
               P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
               (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                  (cic.lift cic.prop cic.prop x2)))
            Hterm))
        (matita_basics_logic.And_rect_Type1 (cic.lift cic.prop cic.prop x1)
           (cic.lift cic.prop cic.prop x2)
           (_x_138 :
              cic.Term cic.prop
                (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                   (cic.lift cic.prop cic.prop x2)) =>
            cic.prod cic.prop (cic.type (cic.s cic.z))
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                       (cic.lift cic.prop cic.prop x2)))
                 Hterm _x_138)
              (_z348 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop x1)
                            (cic.lift cic.prop cic.prop x2)))
                      Hterm _x_138) =>
               P _x_138))
           H1 Hterm).

def And_inv_rect_Type0 :
      cic.Term (cic.type (cic.s cic.z))
        (cic.prod (cic.type cic.z) (cic.type (cic.s cic.z))
           (cic.univ cic.prop)
           (x1 : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) (cic.type (cic.s cic.z))
              (cic.univ cic.prop)
              (x2 : cic.Univ cic.prop =>
               cic.prod cic.prop (cic.type (cic.s cic.z))
                 (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                    (cic.lift cic.prop cic.prop x2))
                 (Hterm :
                    cic.Term cic.prop
                      (matita_basics_logic.And
                         (cic.lift cic.prop cic.prop x1)
                         (cic.lift cic.prop cic.prop x2)) =>
                  cic.prod (cic.type (cic.s cic.z)) (cic.type cic.z)
                    (cic.prod cic.prop (cic.type (cic.s cic.z))
                       (matita_basics_logic.And
                          (cic.lift cic.prop cic.prop x1)
                          (cic.lift cic.prop cic.prop x2))
                       (_z353 :
                          cic.Term cic.prop
                            (matita_basics_logic.And
                               (cic.lift cic.prop cic.prop x1)
                               (cic.lift cic.prop cic.prop x2)) =>
                        cic.univ (cic.type cic.z)))
                    (P :
                       cic.Term (cic.type (cic.s cic.z))
                         (cic.prod cic.prop (cic.type (cic.s cic.z))
                            (matita_basics_logic.And
                               (cic.lift cic.prop cic.prop x1)
                               (cic.lift cic.prop cic.prop x2))
                            (_z353 :
                               cic.Term cic.prop
                                 (matita_basics_logic.And
                                    (cic.lift cic.prop cic.prop x1)
                                    (cic.lift cic.prop cic.prop x2)) =>
                             cic.univ (cic.type cic.z))) =>
                     cic.prod (cic.type cic.z) (cic.type cic.z)
                       (cic.prod cic.prop (cic.type cic.z) x1
                          (x_144 : cic.Term cic.prop x1 =>
                           cic.prod cic.prop (cic.type cic.z) x2
                             (x_143 : cic.Term cic.prop x2 =>
                              cic.prod cic.prop (cic.type cic.z)
                                (matita_basics_logic.eq
                                   (cic.lift cic.prop
                                      (cic.type (cic.s (cic.s cic.z)))
                                      (matita_basics_logic.And
                                         (cic.lift cic.prop cic.prop x1)
                                         (cic.lift cic.prop cic.prop x2)))
                                   Hterm
                                   (matita_basics_logic.conj
                                      (cic.lift cic.prop cic.prop x1)
                                      (cic.lift cic.prop cic.prop x2) x_144
                                      x_143))
                                (_z354 :
                                   cic.Term cic.prop
                                     (matita_basics_logic.eq
                                        (cic.lift cic.prop
                                           (cic.type (cic.s (cic.s cic.z)))
                                           (matita_basics_logic.And
                                              (cic.lift cic.prop cic.prop x1)
                                              (cic.lift cic.prop cic.prop x2)))
                                        Hterm
                                        (matita_basics_logic.conj
                                           (cic.lift cic.prop cic.prop x1)
                                           (cic.lift cic.prop cic.prop x2)
                                           x_144 x_143)) =>
                                 P
                                   (matita_basics_logic.conj
                                      (cic.lift cic.prop cic.prop x1)
                                      (cic.lift cic.prop cic.prop x2) x_144
                                      x_143)))))
                       (_H1 :
                          cic.Term (cic.type cic.z)
                            (cic.prod cic.prop (cic.type cic.z) x1
                               (x_144 : cic.Term cic.prop x1 =>
                                cic.prod cic.prop (cic.type cic.z) x2
                                  (x_143 : cic.Term cic.prop x2 =>
                                   cic.prod cic.prop (cic.type cic.z)
                                     (matita_basics_logic.eq
                                        (cic.lift cic.prop
                                           (cic.type (cic.s (cic.s cic.z)))
                                           (matita_basics_logic.And
                                              (cic.lift cic.prop cic.prop x1)
                                              (cic.lift cic.prop cic.prop x2)))
                                        Hterm
                                        (matita_basics_logic.conj
                                           (cic.lift cic.prop cic.prop x1)
                                           (cic.lift cic.prop cic.prop x2)
                                           x_144 x_143))
                                     (_z354 :
                                        cic.Term cic.prop
                                          (matita_basics_logic.eq
                                             (cic.lift cic.prop
                                                (cic.type
                                                   (cic.s (cic.s cic.z)))
                                                (matita_basics_logic.And
                                                   (cic.lift cic.prop
                                                      cic.prop x1)
                                                   (cic.lift cic.prop
                                                      cic.prop x2)))
                                             Hterm
                                             (matita_basics_logic.conj
                                                (cic.lift cic.prop cic.prop
                                                   x1)
                                                (cic.lift cic.prop cic.prop
                                                   x2)
                                                x_144 x_143)) =>
                                      P
                                        (matita_basics_logic.conj
                                           (cic.lift cic.prop cic.prop x1)
                                           (cic.lift cic.prop cic.prop x2)
                                           x_144 x_143))))) =>
                        P Hterm))))))
      :=
      x1 : cic.Univ cic.prop =>
      x2 : cic.Univ cic.prop =>
      Hterm :
        cic.Term cic.prop
          (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
             (cic.lift cic.prop cic.prop x2)) =>
      P :
        cic.Term (cic.type (cic.s cic.z))
          (cic.prod cic.prop (cic.type (cic.s cic.z))
             (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                (cic.lift cic.prop cic.prop x2))
             (_z353 :
                cic.Term cic.prop
                  (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                     (cic.lift cic.prop cic.prop x2)) =>
              cic.univ (cic.type cic.z))) =>
      H1 :
        cic.Term (cic.type cic.z)
          (cic.prod cic.prop (cic.type cic.z) x1
             (x_144 : cic.Term cic.prop x1 =>
              cic.prod cic.prop (cic.type cic.z) x2
                (x_143 : cic.Term cic.prop x2 =>
                 cic.prod cic.prop (cic.type cic.z)
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop x1)
                            (cic.lift cic.prop cic.prop x2)))
                      Hterm
                      (matita_basics_logic.conj
                         (cic.lift cic.prop cic.prop x1)
                         (cic.lift cic.prop cic.prop x2) x_144 x_143))
                   (_z354 :
                      cic.Term cic.prop
                        (matita_basics_logic.eq
                           (cic.lift cic.prop
                              (cic.type (cic.s (cic.s cic.z)))
                              (matita_basics_logic.And
                                 (cic.lift cic.prop cic.prop x1)
                                 (cic.lift cic.prop cic.prop x2)))
                           Hterm
                           (matita_basics_logic.conj
                              (cic.lift cic.prop cic.prop x1)
                              (cic.lift cic.prop cic.prop x2) x_144 x_143)) =>
                    P
                      (matita_basics_logic.conj
                         (cic.lift cic.prop cic.prop x1)
                         (cic.lift cic.prop cic.prop x2) x_144 x_143))))) =>
      (Hcut :
         cic.Term (cic.type cic.z)
           (cic.prod cic.prop (cic.type cic.z)
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                       (cic.lift cic.prop cic.prop x2)))
                 Hterm Hterm)
              (_z354 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop x1)
                            (cic.lift cic.prop cic.prop x2)))
                      Hterm Hterm) =>
               P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
               (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                  (cic.lift cic.prop cic.prop x2)))
            Hterm))
        (matita_basics_logic.And_rect_Type0 (cic.lift cic.prop cic.prop x1)
           (cic.lift cic.prop cic.prop x2)
           (_x_142 :
              cic.Term cic.prop
                (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                   (cic.lift cic.prop cic.prop x2)) =>
            cic.prod cic.prop (cic.type cic.z)
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                       (cic.lift cic.prop cic.prop x2)))
                 Hterm _x_142)
              (_z354 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop x1)
                            (cic.lift cic.prop cic.prop x2)))
                      Hterm _x_142) =>
               P _x_142))
           H1 Hterm).

def And_inv_rect_CProp4 :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
           (x1 : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
              (x2 : cic.Univ cic.prop =>
               cic.prod cic.prop cic.prop
                 (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                    (cic.lift cic.prop cic.prop x2))
                 (Hterm :
                    cic.Term cic.prop
                      (matita_basics_logic.And
                         (cic.lift cic.prop cic.prop x1)
                         (cic.lift cic.prop cic.prop x2)) =>
                  cic.prod (cic.type cic.z) cic.prop
                    (cic.prod cic.prop (cic.type cic.z)
                       (matita_basics_logic.And
                          (cic.lift cic.prop cic.prop x1)
                          (cic.lift cic.prop cic.prop x2))
                       (_z359 :
                          cic.Term cic.prop
                            (matita_basics_logic.And
                               (cic.lift cic.prop cic.prop x1)
                               (cic.lift cic.prop cic.prop x2)) =>
                        cic.univ cic.prop))
                    (P :
                       cic.Term (cic.type cic.z)
                         (cic.prod cic.prop (cic.type cic.z)
                            (matita_basics_logic.And
                               (cic.lift cic.prop cic.prop x1)
                               (cic.lift cic.prop cic.prop x2))
                            (_z359 :
                               cic.Term cic.prop
                                 (matita_basics_logic.And
                                    (cic.lift cic.prop cic.prop x1)
                                    (cic.lift cic.prop cic.prop x2)) =>
                             cic.univ cic.prop)) =>
                     cic.prod cic.prop cic.prop
                       (cic.prod cic.prop cic.prop x1
                          (x_148 : cic.Term cic.prop x1 =>
                           cic.prod cic.prop cic.prop x2
                             (x_147 : cic.Term cic.prop x2 =>
                              cic.prod cic.prop cic.prop
                                (matita_basics_logic.eq
                                   (cic.lift cic.prop
                                      (cic.type (cic.s (cic.s cic.z)))
                                      (matita_basics_logic.And
                                         (cic.lift cic.prop cic.prop x1)
                                         (cic.lift cic.prop cic.prop x2)))
                                   Hterm
                                   (matita_basics_logic.conj
                                      (cic.lift cic.prop cic.prop x1)
                                      (cic.lift cic.prop cic.prop x2) x_148
                                      x_147))
                                (_z360 :
                                   cic.Term cic.prop
                                     (matita_basics_logic.eq
                                        (cic.lift cic.prop
                                           (cic.type (cic.s (cic.s cic.z)))
                                           (matita_basics_logic.And
                                              (cic.lift cic.prop cic.prop x1)
                                              (cic.lift cic.prop cic.prop x2)))
                                        Hterm
                                        (matita_basics_logic.conj
                                           (cic.lift cic.prop cic.prop x1)
                                           (cic.lift cic.prop cic.prop x2)
                                           x_148 x_147)) =>
                                 P
                                   (matita_basics_logic.conj
                                      (cic.lift cic.prop cic.prop x1)
                                      (cic.lift cic.prop cic.prop x2) x_148
                                      x_147)))))
                       (_H1 :
                          cic.Term cic.prop
                            (cic.prod cic.prop cic.prop x1
                               (x_148 : cic.Term cic.prop x1 =>
                                cic.prod cic.prop cic.prop x2
                                  (x_147 : cic.Term cic.prop x2 =>
                                   cic.prod cic.prop cic.prop
                                     (matita_basics_logic.eq
                                        (cic.lift cic.prop
                                           (cic.type (cic.s (cic.s cic.z)))
                                           (matita_basics_logic.And
                                              (cic.lift cic.prop cic.prop x1)
                                              (cic.lift cic.prop cic.prop x2)))
                                        Hterm
                                        (matita_basics_logic.conj
                                           (cic.lift cic.prop cic.prop x1)
                                           (cic.lift cic.prop cic.prop x2)
                                           x_148 x_147))
                                     (_z360 :
                                        cic.Term cic.prop
                                          (matita_basics_logic.eq
                                             (cic.lift cic.prop
                                                (cic.type
                                                   (cic.s (cic.s cic.z)))
                                                (matita_basics_logic.And
                                                   (cic.lift cic.prop
                                                      cic.prop x1)
                                                   (cic.lift cic.prop
                                                      cic.prop x2)))
                                             Hterm
                                             (matita_basics_logic.conj
                                                (cic.lift cic.prop cic.prop
                                                   x1)
                                                (cic.lift cic.prop cic.prop
                                                   x2)
                                                x_148 x_147)) =>
                                      P
                                        (matita_basics_logic.conj
                                           (cic.lift cic.prop cic.prop x1)
                                           (cic.lift cic.prop cic.prop x2)
                                           x_148 x_147))))) =>
                        P Hterm))))))
      :=
      x1 : cic.Univ cic.prop =>
      x2 : cic.Univ cic.prop =>
      Hterm :
        cic.Term cic.prop
          (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
             (cic.lift cic.prop cic.prop x2)) =>
      P :
        cic.Term (cic.type cic.z)
          (cic.prod cic.prop (cic.type cic.z)
             (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                (cic.lift cic.prop cic.prop x2))
             (_z359 :
                cic.Term cic.prop
                  (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                     (cic.lift cic.prop cic.prop x2)) =>
              cic.univ cic.prop)) =>
      H1 :
        cic.Term cic.prop
          (cic.prod cic.prop cic.prop x1
             (x_148 : cic.Term cic.prop x1 =>
              cic.prod cic.prop cic.prop x2
                (x_147 : cic.Term cic.prop x2 =>
                 cic.prod cic.prop cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop x1)
                            (cic.lift cic.prop cic.prop x2)))
                      Hterm
                      (matita_basics_logic.conj
                         (cic.lift cic.prop cic.prop x1)
                         (cic.lift cic.prop cic.prop x2) x_148 x_147))
                   (_z360 :
                      cic.Term cic.prop
                        (matita_basics_logic.eq
                           (cic.lift cic.prop
                              (cic.type (cic.s (cic.s cic.z)))
                              (matita_basics_logic.And
                                 (cic.lift cic.prop cic.prop x1)
                                 (cic.lift cic.prop cic.prop x2)))
                           Hterm
                           (matita_basics_logic.conj
                              (cic.lift cic.prop cic.prop x1)
                              (cic.lift cic.prop cic.prop x2) x_148 x_147)) =>
                    P
                      (matita_basics_logic.conj
                         (cic.lift cic.prop cic.prop x1)
                         (cic.lift cic.prop cic.prop x2) x_148 x_147))))) =>
      (Hcut :
         cic.Term cic.prop
           (cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                       (cic.lift cic.prop cic.prop x2)))
                 Hterm Hterm)
              (_z360 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop x1)
                            (cic.lift cic.prop cic.prop x2)))
                      Hterm Hterm) =>
               P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
               (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                  (cic.lift cic.prop cic.prop x2)))
            Hterm))
        (matita_basics_logic.And_rect_CProp4 (cic.lift cic.prop cic.prop x1)
           (cic.lift cic.prop cic.prop x2)
           (_x_146 :
              cic.Term cic.prop
                (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                   (cic.lift cic.prop cic.prop x2)) =>
            cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                       (cic.lift cic.prop cic.prop x2)))
                 Hterm _x_146)
              (_z360 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop x1)
                            (cic.lift cic.prop cic.prop x2)))
                      Hterm _x_146) =>
               P _x_146))
           H1 Hterm).

def And_inv_rect_CProp3 :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
           (x1 : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
              (x2 : cic.Univ cic.prop =>
               cic.prod cic.prop cic.prop
                 (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                    (cic.lift cic.prop cic.prop x2))
                 (Hterm :
                    cic.Term cic.prop
                      (matita_basics_logic.And
                         (cic.lift cic.prop cic.prop x1)
                         (cic.lift cic.prop cic.prop x2)) =>
                  cic.prod (cic.type cic.z) cic.prop
                    (cic.prod cic.prop (cic.type cic.z)
                       (matita_basics_logic.And
                          (cic.lift cic.prop cic.prop x1)
                          (cic.lift cic.prop cic.prop x2))
                       (_z365 :
                          cic.Term cic.prop
                            (matita_basics_logic.And
                               (cic.lift cic.prop cic.prop x1)
                               (cic.lift cic.prop cic.prop x2)) =>
                        cic.univ cic.prop))
                    (P :
                       cic.Term (cic.type cic.z)
                         (cic.prod cic.prop (cic.type cic.z)
                            (matita_basics_logic.And
                               (cic.lift cic.prop cic.prop x1)
                               (cic.lift cic.prop cic.prop x2))
                            (_z365 :
                               cic.Term cic.prop
                                 (matita_basics_logic.And
                                    (cic.lift cic.prop cic.prop x1)
                                    (cic.lift cic.prop cic.prop x2)) =>
                             cic.univ cic.prop)) =>
                     cic.prod cic.prop cic.prop
                       (cic.prod cic.prop cic.prop x1
                          (x_156 : cic.Term cic.prop x1 =>
                           cic.prod cic.prop cic.prop x2
                             (x_155 : cic.Term cic.prop x2 =>
                              cic.prod cic.prop cic.prop
                                (matita_basics_logic.eq
                                   (cic.lift cic.prop
                                      (cic.type (cic.s (cic.s cic.z)))
                                      (matita_basics_logic.And
                                         (cic.lift cic.prop cic.prop x1)
                                         (cic.lift cic.prop cic.prop x2)))
                                   Hterm
                                   (matita_basics_logic.conj
                                      (cic.lift cic.prop cic.prop x1)
                                      (cic.lift cic.prop cic.prop x2) x_156
                                      x_155))
                                (_z366 :
                                   cic.Term cic.prop
                                     (matita_basics_logic.eq
                                        (cic.lift cic.prop
                                           (cic.type (cic.s (cic.s cic.z)))
                                           (matita_basics_logic.And
                                              (cic.lift cic.prop cic.prop x1)
                                              (cic.lift cic.prop cic.prop x2)))
                                        Hterm
                                        (matita_basics_logic.conj
                                           (cic.lift cic.prop cic.prop x1)
                                           (cic.lift cic.prop cic.prop x2)
                                           x_156 x_155)) =>
                                 P
                                   (matita_basics_logic.conj
                                      (cic.lift cic.prop cic.prop x1)
                                      (cic.lift cic.prop cic.prop x2) x_156
                                      x_155)))))
                       (_H1 :
                          cic.Term cic.prop
                            (cic.prod cic.prop cic.prop x1
                               (x_156 : cic.Term cic.prop x1 =>
                                cic.prod cic.prop cic.prop x2
                                  (x_155 : cic.Term cic.prop x2 =>
                                   cic.prod cic.prop cic.prop
                                     (matita_basics_logic.eq
                                        (cic.lift cic.prop
                                           (cic.type (cic.s (cic.s cic.z)))
                                           (matita_basics_logic.And
                                              (cic.lift cic.prop cic.prop x1)
                                              (cic.lift cic.prop cic.prop x2)))
                                        Hterm
                                        (matita_basics_logic.conj
                                           (cic.lift cic.prop cic.prop x1)
                                           (cic.lift cic.prop cic.prop x2)
                                           x_156 x_155))
                                     (_z366 :
                                        cic.Term cic.prop
                                          (matita_basics_logic.eq
                                             (cic.lift cic.prop
                                                (cic.type
                                                   (cic.s (cic.s cic.z)))
                                                (matita_basics_logic.And
                                                   (cic.lift cic.prop
                                                      cic.prop x1)
                                                   (cic.lift cic.prop
                                                      cic.prop x2)))
                                             Hterm
                                             (matita_basics_logic.conj
                                                (cic.lift cic.prop cic.prop
                                                   x1)
                                                (cic.lift cic.prop cic.prop
                                                   x2)
                                                x_156 x_155)) =>
                                      P
                                        (matita_basics_logic.conj
                                           (cic.lift cic.prop cic.prop x1)
                                           (cic.lift cic.prop cic.prop x2)
                                           x_156 x_155))))) =>
                        P Hterm))))))
      :=
      x1 : cic.Univ cic.prop =>
      x2 : cic.Univ cic.prop =>
      Hterm :
        cic.Term cic.prop
          (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
             (cic.lift cic.prop cic.prop x2)) =>
      P :
        cic.Term (cic.type cic.z)
          (cic.prod cic.prop (cic.type cic.z)
             (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                (cic.lift cic.prop cic.prop x2))
             (_z365 :
                cic.Term cic.prop
                  (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                     (cic.lift cic.prop cic.prop x2)) =>
              cic.univ cic.prop)) =>
      H1 :
        cic.Term cic.prop
          (cic.prod cic.prop cic.prop x1
             (x_156 : cic.Term cic.prop x1 =>
              cic.prod cic.prop cic.prop x2
                (x_155 : cic.Term cic.prop x2 =>
                 cic.prod cic.prop cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop x1)
                            (cic.lift cic.prop cic.prop x2)))
                      Hterm
                      (matita_basics_logic.conj
                         (cic.lift cic.prop cic.prop x1)
                         (cic.lift cic.prop cic.prop x2) x_156 x_155))
                   (_z366 :
                      cic.Term cic.prop
                        (matita_basics_logic.eq
                           (cic.lift cic.prop
                              (cic.type (cic.s (cic.s cic.z)))
                              (matita_basics_logic.And
                                 (cic.lift cic.prop cic.prop x1)
                                 (cic.lift cic.prop cic.prop x2)))
                           Hterm
                           (matita_basics_logic.conj
                              (cic.lift cic.prop cic.prop x1)
                              (cic.lift cic.prop cic.prop x2) x_156 x_155)) =>
                    P
                      (matita_basics_logic.conj
                         (cic.lift cic.prop cic.prop x1)
                         (cic.lift cic.prop cic.prop x2) x_156 x_155))))) =>
      (Hcut :
         cic.Term cic.prop
           (cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                       (cic.lift cic.prop cic.prop x2)))
                 Hterm Hterm)
              (_z366 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop x1)
                            (cic.lift cic.prop cic.prop x2)))
                      Hterm Hterm) =>
               P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
               (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                  (cic.lift cic.prop cic.prop x2)))
            Hterm))
        (matita_basics_logic.And_rect_CProp3 (cic.lift cic.prop cic.prop x1)
           (cic.lift cic.prop cic.prop x2)
           (_x_154 :
              cic.Term cic.prop
                (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                   (cic.lift cic.prop cic.prop x2)) =>
            cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                       (cic.lift cic.prop cic.prop x2)))
                 Hterm _x_154)
              (_z366 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop x1)
                            (cic.lift cic.prop cic.prop x2)))
                      Hterm _x_154) =>
               P _x_154))
           H1 Hterm).

def And_inv_rect_CProp2 :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
           (x1 : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
              (x2 : cic.Univ cic.prop =>
               cic.prod cic.prop cic.prop
                 (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                    (cic.lift cic.prop cic.prop x2))
                 (Hterm :
                    cic.Term cic.prop
                      (matita_basics_logic.And
                         (cic.lift cic.prop cic.prop x1)
                         (cic.lift cic.prop cic.prop x2)) =>
                  cic.prod (cic.type cic.z) cic.prop
                    (cic.prod cic.prop (cic.type cic.z)
                       (matita_basics_logic.And
                          (cic.lift cic.prop cic.prop x1)
                          (cic.lift cic.prop cic.prop x2))
                       (_z371 :
                          cic.Term cic.prop
                            (matita_basics_logic.And
                               (cic.lift cic.prop cic.prop x1)
                               (cic.lift cic.prop cic.prop x2)) =>
                        cic.univ cic.prop))
                    (P :
                       cic.Term (cic.type cic.z)
                         (cic.prod cic.prop (cic.type cic.z)
                            (matita_basics_logic.And
                               (cic.lift cic.prop cic.prop x1)
                               (cic.lift cic.prop cic.prop x2))
                            (_z371 :
                               cic.Term cic.prop
                                 (matita_basics_logic.And
                                    (cic.lift cic.prop cic.prop x1)
                                    (cic.lift cic.prop cic.prop x2)) =>
                             cic.univ cic.prop)) =>
                     cic.prod cic.prop cic.prop
                       (cic.prod cic.prop cic.prop x1
                          (x_160 : cic.Term cic.prop x1 =>
                           cic.prod cic.prop cic.prop x2
                             (x_159 : cic.Term cic.prop x2 =>
                              cic.prod cic.prop cic.prop
                                (matita_basics_logic.eq
                                   (cic.lift cic.prop
                                      (cic.type (cic.s (cic.s cic.z)))
                                      (matita_basics_logic.And
                                         (cic.lift cic.prop cic.prop x1)
                                         (cic.lift cic.prop cic.prop x2)))
                                   Hterm
                                   (matita_basics_logic.conj
                                      (cic.lift cic.prop cic.prop x1)
                                      (cic.lift cic.prop cic.prop x2) x_160
                                      x_159))
                                (_z372 :
                                   cic.Term cic.prop
                                     (matita_basics_logic.eq
                                        (cic.lift cic.prop
                                           (cic.type (cic.s (cic.s cic.z)))
                                           (matita_basics_logic.And
                                              (cic.lift cic.prop cic.prop x1)
                                              (cic.lift cic.prop cic.prop x2)))
                                        Hterm
                                        (matita_basics_logic.conj
                                           (cic.lift cic.prop cic.prop x1)
                                           (cic.lift cic.prop cic.prop x2)
                                           x_160 x_159)) =>
                                 P
                                   (matita_basics_logic.conj
                                      (cic.lift cic.prop cic.prop x1)
                                      (cic.lift cic.prop cic.prop x2) x_160
                                      x_159)))))
                       (_H1 :
                          cic.Term cic.prop
                            (cic.prod cic.prop cic.prop x1
                               (x_160 : cic.Term cic.prop x1 =>
                                cic.prod cic.prop cic.prop x2
                                  (x_159 : cic.Term cic.prop x2 =>
                                   cic.prod cic.prop cic.prop
                                     (matita_basics_logic.eq
                                        (cic.lift cic.prop
                                           (cic.type (cic.s (cic.s cic.z)))
                                           (matita_basics_logic.And
                                              (cic.lift cic.prop cic.prop x1)
                                              (cic.lift cic.prop cic.prop x2)))
                                        Hterm
                                        (matita_basics_logic.conj
                                           (cic.lift cic.prop cic.prop x1)
                                           (cic.lift cic.prop cic.prop x2)
                                           x_160 x_159))
                                     (_z372 :
                                        cic.Term cic.prop
                                          (matita_basics_logic.eq
                                             (cic.lift cic.prop
                                                (cic.type
                                                   (cic.s (cic.s cic.z)))
                                                (matita_basics_logic.And
                                                   (cic.lift cic.prop
                                                      cic.prop x1)
                                                   (cic.lift cic.prop
                                                      cic.prop x2)))
                                             Hterm
                                             (matita_basics_logic.conj
                                                (cic.lift cic.prop cic.prop
                                                   x1)
                                                (cic.lift cic.prop cic.prop
                                                   x2)
                                                x_160 x_159)) =>
                                      P
                                        (matita_basics_logic.conj
                                           (cic.lift cic.prop cic.prop x1)
                                           (cic.lift cic.prop cic.prop x2)
                                           x_160 x_159))))) =>
                        P Hterm))))))
      :=
      x1 : cic.Univ cic.prop =>
      x2 : cic.Univ cic.prop =>
      Hterm :
        cic.Term cic.prop
          (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
             (cic.lift cic.prop cic.prop x2)) =>
      P :
        cic.Term (cic.type cic.z)
          (cic.prod cic.prop (cic.type cic.z)
             (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                (cic.lift cic.prop cic.prop x2))
             (_z371 :
                cic.Term cic.prop
                  (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                     (cic.lift cic.prop cic.prop x2)) =>
              cic.univ cic.prop)) =>
      H1 :
        cic.Term cic.prop
          (cic.prod cic.prop cic.prop x1
             (x_160 : cic.Term cic.prop x1 =>
              cic.prod cic.prop cic.prop x2
                (x_159 : cic.Term cic.prop x2 =>
                 cic.prod cic.prop cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop x1)
                            (cic.lift cic.prop cic.prop x2)))
                      Hterm
                      (matita_basics_logic.conj
                         (cic.lift cic.prop cic.prop x1)
                         (cic.lift cic.prop cic.prop x2) x_160 x_159))
                   (_z372 :
                      cic.Term cic.prop
                        (matita_basics_logic.eq
                           (cic.lift cic.prop
                              (cic.type (cic.s (cic.s cic.z)))
                              (matita_basics_logic.And
                                 (cic.lift cic.prop cic.prop x1)
                                 (cic.lift cic.prop cic.prop x2)))
                           Hterm
                           (matita_basics_logic.conj
                              (cic.lift cic.prop cic.prop x1)
                              (cic.lift cic.prop cic.prop x2) x_160 x_159)) =>
                    P
                      (matita_basics_logic.conj
                         (cic.lift cic.prop cic.prop x1)
                         (cic.lift cic.prop cic.prop x2) x_160 x_159))))) =>
      (Hcut :
         cic.Term cic.prop
           (cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                       (cic.lift cic.prop cic.prop x2)))
                 Hterm Hterm)
              (_z372 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop x1)
                            (cic.lift cic.prop cic.prop x2)))
                      Hterm Hterm) =>
               P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
               (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                  (cic.lift cic.prop cic.prop x2)))
            Hterm))
        (matita_basics_logic.And_rect_CProp2 (cic.lift cic.prop cic.prop x1)
           (cic.lift cic.prop cic.prop x2)
           (_x_158 :
              cic.Term cic.prop
                (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                   (cic.lift cic.prop cic.prop x2)) =>
            cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                       (cic.lift cic.prop cic.prop x2)))
                 Hterm _x_158)
              (_z372 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop x1)
                            (cic.lift cic.prop cic.prop x2)))
                      Hterm _x_158) =>
               P _x_158))
           H1 Hterm).

def And_inv_rect_CProp1 :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
           (x1 : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
              (x2 : cic.Univ cic.prop =>
               cic.prod cic.prop cic.prop
                 (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                    (cic.lift cic.prop cic.prop x2))
                 (Hterm :
                    cic.Term cic.prop
                      (matita_basics_logic.And
                         (cic.lift cic.prop cic.prop x1)
                         (cic.lift cic.prop cic.prop x2)) =>
                  cic.prod (cic.type cic.z) cic.prop
                    (cic.prod cic.prop (cic.type cic.z)
                       (matita_basics_logic.And
                          (cic.lift cic.prop cic.prop x1)
                          (cic.lift cic.prop cic.prop x2))
                       (_z377 :
                          cic.Term cic.prop
                            (matita_basics_logic.And
                               (cic.lift cic.prop cic.prop x1)
                               (cic.lift cic.prop cic.prop x2)) =>
                        cic.univ cic.prop))
                    (P :
                       cic.Term (cic.type cic.z)
                         (cic.prod cic.prop (cic.type cic.z)
                            (matita_basics_logic.And
                               (cic.lift cic.prop cic.prop x1)
                               (cic.lift cic.prop cic.prop x2))
                            (_z377 :
                               cic.Term cic.prop
                                 (matita_basics_logic.And
                                    (cic.lift cic.prop cic.prop x1)
                                    (cic.lift cic.prop cic.prop x2)) =>
                             cic.univ cic.prop)) =>
                     cic.prod cic.prop cic.prop
                       (cic.prod cic.prop cic.prop x1
                          (x_164 : cic.Term cic.prop x1 =>
                           cic.prod cic.prop cic.prop x2
                             (x_163 : cic.Term cic.prop x2 =>
                              cic.prod cic.prop cic.prop
                                (matita_basics_logic.eq
                                   (cic.lift cic.prop
                                      (cic.type (cic.s (cic.s cic.z)))
                                      (matita_basics_logic.And
                                         (cic.lift cic.prop cic.prop x1)
                                         (cic.lift cic.prop cic.prop x2)))
                                   Hterm
                                   (matita_basics_logic.conj
                                      (cic.lift cic.prop cic.prop x1)
                                      (cic.lift cic.prop cic.prop x2) x_164
                                      x_163))
                                (_z378 :
                                   cic.Term cic.prop
                                     (matita_basics_logic.eq
                                        (cic.lift cic.prop
                                           (cic.type (cic.s (cic.s cic.z)))
                                           (matita_basics_logic.And
                                              (cic.lift cic.prop cic.prop x1)
                                              (cic.lift cic.prop cic.prop x2)))
                                        Hterm
                                        (matita_basics_logic.conj
                                           (cic.lift cic.prop cic.prop x1)
                                           (cic.lift cic.prop cic.prop x2)
                                           x_164 x_163)) =>
                                 P
                                   (matita_basics_logic.conj
                                      (cic.lift cic.prop cic.prop x1)
                                      (cic.lift cic.prop cic.prop x2) x_164
                                      x_163)))))
                       (_H1 :
                          cic.Term cic.prop
                            (cic.prod cic.prop cic.prop x1
                               (x_164 : cic.Term cic.prop x1 =>
                                cic.prod cic.prop cic.prop x2
                                  (x_163 : cic.Term cic.prop x2 =>
                                   cic.prod cic.prop cic.prop
                                     (matita_basics_logic.eq
                                        (cic.lift cic.prop
                                           (cic.type (cic.s (cic.s cic.z)))
                                           (matita_basics_logic.And
                                              (cic.lift cic.prop cic.prop x1)
                                              (cic.lift cic.prop cic.prop x2)))
                                        Hterm
                                        (matita_basics_logic.conj
                                           (cic.lift cic.prop cic.prop x1)
                                           (cic.lift cic.prop cic.prop x2)
                                           x_164 x_163))
                                     (_z378 :
                                        cic.Term cic.prop
                                          (matita_basics_logic.eq
                                             (cic.lift cic.prop
                                                (cic.type
                                                   (cic.s (cic.s cic.z)))
                                                (matita_basics_logic.And
                                                   (cic.lift cic.prop
                                                      cic.prop x1)
                                                   (cic.lift cic.prop
                                                      cic.prop x2)))
                                             Hterm
                                             (matita_basics_logic.conj
                                                (cic.lift cic.prop cic.prop
                                                   x1)
                                                (cic.lift cic.prop cic.prop
                                                   x2)
                                                x_164 x_163)) =>
                                      P
                                        (matita_basics_logic.conj
                                           (cic.lift cic.prop cic.prop x1)
                                           (cic.lift cic.prop cic.prop x2)
                                           x_164 x_163))))) =>
                        P Hterm))))))
      :=
      x1 : cic.Univ cic.prop =>
      x2 : cic.Univ cic.prop =>
      Hterm :
        cic.Term cic.prop
          (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
             (cic.lift cic.prop cic.prop x2)) =>
      P :
        cic.Term (cic.type cic.z)
          (cic.prod cic.prop (cic.type cic.z)
             (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                (cic.lift cic.prop cic.prop x2))
             (_z377 :
                cic.Term cic.prop
                  (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                     (cic.lift cic.prop cic.prop x2)) =>
              cic.univ cic.prop)) =>
      H1 :
        cic.Term cic.prop
          (cic.prod cic.prop cic.prop x1
             (x_164 : cic.Term cic.prop x1 =>
              cic.prod cic.prop cic.prop x2
                (x_163 : cic.Term cic.prop x2 =>
                 cic.prod cic.prop cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop x1)
                            (cic.lift cic.prop cic.prop x2)))
                      Hterm
                      (matita_basics_logic.conj
                         (cic.lift cic.prop cic.prop x1)
                         (cic.lift cic.prop cic.prop x2) x_164 x_163))
                   (_z378 :
                      cic.Term cic.prop
                        (matita_basics_logic.eq
                           (cic.lift cic.prop
                              (cic.type (cic.s (cic.s cic.z)))
                              (matita_basics_logic.And
                                 (cic.lift cic.prop cic.prop x1)
                                 (cic.lift cic.prop cic.prop x2)))
                           Hterm
                           (matita_basics_logic.conj
                              (cic.lift cic.prop cic.prop x1)
                              (cic.lift cic.prop cic.prop x2) x_164 x_163)) =>
                    P
                      (matita_basics_logic.conj
                         (cic.lift cic.prop cic.prop x1)
                         (cic.lift cic.prop cic.prop x2) x_164 x_163))))) =>
      (Hcut :
         cic.Term cic.prop
           (cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                       (cic.lift cic.prop cic.prop x2)))
                 Hterm Hterm)
              (_z378 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop x1)
                            (cic.lift cic.prop cic.prop x2)))
                      Hterm Hterm) =>
               P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
               (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                  (cic.lift cic.prop cic.prop x2)))
            Hterm))
        (matita_basics_logic.And_rect_CProp1 (cic.lift cic.prop cic.prop x1)
           (cic.lift cic.prop cic.prop x2)
           (_x_162 :
              cic.Term cic.prop
                (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                   (cic.lift cic.prop cic.prop x2)) =>
            cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                       (cic.lift cic.prop cic.prop x2)))
                 Hterm _x_162)
              (_z378 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop x1)
                            (cic.lift cic.prop cic.prop x2)))
                      Hterm _x_162) =>
               P _x_162))
           H1 Hterm).

def And_inv_rect_CProp0 :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
           (x1 : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
              (x2 : cic.Univ cic.prop =>
               cic.prod cic.prop cic.prop
                 (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                    (cic.lift cic.prop cic.prop x2))
                 (Hterm :
                    cic.Term cic.prop
                      (matita_basics_logic.And
                         (cic.lift cic.prop cic.prop x1)
                         (cic.lift cic.prop cic.prop x2)) =>
                  cic.prod (cic.type cic.z) cic.prop
                    (cic.prod cic.prop (cic.type cic.z)
                       (matita_basics_logic.And
                          (cic.lift cic.prop cic.prop x1)
                          (cic.lift cic.prop cic.prop x2))
                       (_z383 :
                          cic.Term cic.prop
                            (matita_basics_logic.And
                               (cic.lift cic.prop cic.prop x1)
                               (cic.lift cic.prop cic.prop x2)) =>
                        cic.univ cic.prop))
                    (P :
                       cic.Term (cic.type cic.z)
                         (cic.prod cic.prop (cic.type cic.z)
                            (matita_basics_logic.And
                               (cic.lift cic.prop cic.prop x1)
                               (cic.lift cic.prop cic.prop x2))
                            (_z383 :
                               cic.Term cic.prop
                                 (matita_basics_logic.And
                                    (cic.lift cic.prop cic.prop x1)
                                    (cic.lift cic.prop cic.prop x2)) =>
                             cic.univ cic.prop)) =>
                     cic.prod cic.prop cic.prop
                       (cic.prod cic.prop cic.prop x1
                          (x_168 : cic.Term cic.prop x1 =>
                           cic.prod cic.prop cic.prop x2
                             (x_167 : cic.Term cic.prop x2 =>
                              cic.prod cic.prop cic.prop
                                (matita_basics_logic.eq
                                   (cic.lift cic.prop
                                      (cic.type (cic.s (cic.s cic.z)))
                                      (matita_basics_logic.And
                                         (cic.lift cic.prop cic.prop x1)
                                         (cic.lift cic.prop cic.prop x2)))
                                   Hterm
                                   (matita_basics_logic.conj
                                      (cic.lift cic.prop cic.prop x1)
                                      (cic.lift cic.prop cic.prop x2) x_168
                                      x_167))
                                (_z384 :
                                   cic.Term cic.prop
                                     (matita_basics_logic.eq
                                        (cic.lift cic.prop
                                           (cic.type (cic.s (cic.s cic.z)))
                                           (matita_basics_logic.And
                                              (cic.lift cic.prop cic.prop x1)
                                              (cic.lift cic.prop cic.prop x2)))
                                        Hterm
                                        (matita_basics_logic.conj
                                           (cic.lift cic.prop cic.prop x1)
                                           (cic.lift cic.prop cic.prop x2)
                                           x_168 x_167)) =>
                                 P
                                   (matita_basics_logic.conj
                                      (cic.lift cic.prop cic.prop x1)
                                      (cic.lift cic.prop cic.prop x2) x_168
                                      x_167)))))
                       (_H1 :
                          cic.Term cic.prop
                            (cic.prod cic.prop cic.prop x1
                               (x_168 : cic.Term cic.prop x1 =>
                                cic.prod cic.prop cic.prop x2
                                  (x_167 : cic.Term cic.prop x2 =>
                                   cic.prod cic.prop cic.prop
                                     (matita_basics_logic.eq
                                        (cic.lift cic.prop
                                           (cic.type (cic.s (cic.s cic.z)))
                                           (matita_basics_logic.And
                                              (cic.lift cic.prop cic.prop x1)
                                              (cic.lift cic.prop cic.prop x2)))
                                        Hterm
                                        (matita_basics_logic.conj
                                           (cic.lift cic.prop cic.prop x1)
                                           (cic.lift cic.prop cic.prop x2)
                                           x_168 x_167))
                                     (_z384 :
                                        cic.Term cic.prop
                                          (matita_basics_logic.eq
                                             (cic.lift cic.prop
                                                (cic.type
                                                   (cic.s (cic.s cic.z)))
                                                (matita_basics_logic.And
                                                   (cic.lift cic.prop
                                                      cic.prop x1)
                                                   (cic.lift cic.prop
                                                      cic.prop x2)))
                                             Hterm
                                             (matita_basics_logic.conj
                                                (cic.lift cic.prop cic.prop
                                                   x1)
                                                (cic.lift cic.prop cic.prop
                                                   x2)
                                                x_168 x_167)) =>
                                      P
                                        (matita_basics_logic.conj
                                           (cic.lift cic.prop cic.prop x1)
                                           (cic.lift cic.prop cic.prop x2)
                                           x_168 x_167))))) =>
                        P Hterm))))))
      :=
      x1 : cic.Univ cic.prop =>
      x2 : cic.Univ cic.prop =>
      Hterm :
        cic.Term cic.prop
          (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
             (cic.lift cic.prop cic.prop x2)) =>
      P :
        cic.Term (cic.type cic.z)
          (cic.prod cic.prop (cic.type cic.z)
             (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                (cic.lift cic.prop cic.prop x2))
             (_z383 :
                cic.Term cic.prop
                  (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                     (cic.lift cic.prop cic.prop x2)) =>
              cic.univ cic.prop)) =>
      H1 :
        cic.Term cic.prop
          (cic.prod cic.prop cic.prop x1
             (x_168 : cic.Term cic.prop x1 =>
              cic.prod cic.prop cic.prop x2
                (x_167 : cic.Term cic.prop x2 =>
                 cic.prod cic.prop cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop x1)
                            (cic.lift cic.prop cic.prop x2)))
                      Hterm
                      (matita_basics_logic.conj
                         (cic.lift cic.prop cic.prop x1)
                         (cic.lift cic.prop cic.prop x2) x_168 x_167))
                   (_z384 :
                      cic.Term cic.prop
                        (matita_basics_logic.eq
                           (cic.lift cic.prop
                              (cic.type (cic.s (cic.s cic.z)))
                              (matita_basics_logic.And
                                 (cic.lift cic.prop cic.prop x1)
                                 (cic.lift cic.prop cic.prop x2)))
                           Hterm
                           (matita_basics_logic.conj
                              (cic.lift cic.prop cic.prop x1)
                              (cic.lift cic.prop cic.prop x2) x_168 x_167)) =>
                    P
                      (matita_basics_logic.conj
                         (cic.lift cic.prop cic.prop x1)
                         (cic.lift cic.prop cic.prop x2) x_168 x_167))))) =>
      (Hcut :
         cic.Term cic.prop
           (cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                       (cic.lift cic.prop cic.prop x2)))
                 Hterm Hterm)
              (_z384 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop x1)
                            (cic.lift cic.prop cic.prop x2)))
                      Hterm Hterm) =>
               P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
               (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                  (cic.lift cic.prop cic.prop x2)))
            Hterm))
        (matita_basics_logic.And_rect_CProp0 (cic.lift cic.prop cic.prop x1)
           (cic.lift cic.prop cic.prop x2)
           (_x_166 :
              cic.Term cic.prop
                (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                   (cic.lift cic.prop cic.prop x2)) =>
            cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.And (cic.lift cic.prop cic.prop x1)
                       (cic.lift cic.prop cic.prop x2)))
                 Hterm _x_166)
              (_z384 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.And
                            (cic.lift cic.prop cic.prop x1)
                            (cic.lift cic.prop cic.prop x2)))
                      Hterm _x_166) =>
               P _x_166))
           H1 Hterm).

def proj1 :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
           (A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
              (B : cic.Univ cic.prop =>
               cic.prod cic.prop cic.prop
                 (matita_basics_logic.And (cic.lift cic.prop cic.prop A)
                    (cic.lift cic.prop cic.prop B))
                 (__ :
                    cic.Term cic.prop
                      (matita_basics_logic.And (cic.lift cic.prop cic.prop A)
                         (cic.lift cic.prop cic.prop B)) =>
                  A))))
      :=
      A : cic.Univ cic.prop =>
      B : cic.Univ cic.prop =>
      AB :
        cic.Term cic.prop
          (matita_basics_logic.And (cic.lift cic.prop cic.prop A)
             (cic.lift cic.prop cic.prop B)) =>
      matita_basics_logic.And_ind (cic.lift cic.prop cic.prop A)
        (cic.lift cic.prop cic.prop B)
        (_x_118 :
           cic.Term cic.prop
             (matita_basics_logic.And (cic.lift cic.prop cic.prop A)
                (cic.lift cic.prop cic.prop B)) =>
         A)
        (_x_120 : cic.Term cic.prop A =>
         _x_119 : cic.Term cic.prop B => _x_120)
        AB.

def proj2 :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
           (A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
              (B : cic.Univ cic.prop =>
               cic.prod cic.prop cic.prop
                 (matita_basics_logic.And (cic.lift cic.prop cic.prop A)
                    (cic.lift cic.prop cic.prop B))
                 (__ :
                    cic.Term cic.prop
                      (matita_basics_logic.And (cic.lift cic.prop cic.prop A)
                         (cic.lift cic.prop cic.prop B)) =>
                  B))))
      :=
      A : cic.Univ cic.prop =>
      B : cic.Univ cic.prop =>
      AB :
        cic.Term cic.prop
          (matita_basics_logic.And (cic.lift cic.prop cic.prop A)
             (cic.lift cic.prop cic.prop B)) =>
      matita_basics_logic.And_ind (cic.lift cic.prop cic.prop A)
        (cic.lift cic.prop cic.prop B)
        (_x_118 :
           cic.Term cic.prop
             (matita_basics_logic.And (cic.lift cic.prop cic.prop A)
                (cic.lift cic.prop cic.prop B)) =>
         B)
        (_x_120 : cic.Term cic.prop A =>
         _x_119 : cic.Term cic.prop B => _x_119)
        AB.

Or :
  cic.Term (cic.type cic.z)
    (cic.prod (cic.type cic.z) (cic.type cic.z) (cic.univ cic.prop)
       (_A : cic.Univ cic.prop =>
        cic.prod (cic.type cic.z) (cic.type cic.z) (cic.univ cic.prop)
          (_B : cic.Univ cic.prop => cic.univ cic.prop))).

or_introl :
  cic.Term cic.prop
    (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
       (A : cic.Univ cic.prop =>
        cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
          (B : cic.Univ cic.prop =>
           cic.prod cic.prop cic.prop A
             (__ : cic.Term cic.prop A =>
              matita_basics_logic.Or (cic.lift cic.prop cic.prop A)
                (cic.lift cic.prop cic.prop B))))).

or_intror :
  cic.Term cic.prop
    (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
       (A : cic.Univ cic.prop =>
        cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
          (B : cic.Univ cic.prop =>
           cic.prod cic.prop cic.prop B
             (__ : cic.Term cic.prop B =>
              matita_basics_logic.Or (cic.lift cic.prop cic.prop A)
                (cic.lift cic.prop cic.prop B))))).

def match_Or_Prop :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
              (_B : cic.Univ cic.prop =>
               cic.prod (cic.type cic.z) cic.prop
                 (cic.prod cic.prop (cic.type cic.z)
                    (matita_basics_logic.Or _A _B)
                    (z : cic.Term cic.prop (matita_basics_logic.Or _A _B) =>
                     cic.univ cic.prop))
                 (return_type :
                    cic.Term (cic.type cic.z)
                      (cic.prod cic.prop (cic.type cic.z)
                         (matita_basics_logic.Or _A _B)
                         (z :
                            cic.Term cic.prop (matita_basics_logic.Or _A _B) =>
                          cic.univ cic.prop)) =>
                  cic.prod cic.prop cic.prop
                    (cic.prod cic.prop cic.prop _A
                       (__ : cic.Term cic.prop _A =>
                        return_type (matita_basics_logic.or_introl _A _B __)))
                    (case_or_introl :
                       cic.Term cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (__ : cic.Term cic.prop _A =>
                             return_type
                               (matita_basics_logic.or_introl _A _B __))) =>
                     cic.prod cic.prop cic.prop
                       (cic.prod cic.prop cic.prop _B
                          (__ : cic.Term cic.prop _B =>
                           return_type
                             (matita_basics_logic.or_intror _A _B __)))
                       (case_or_intror :
                          cic.Term cic.prop
                            (cic.prod cic.prop cic.prop _B
                               (__ : cic.Term cic.prop _B =>
                                return_type
                                  (matita_basics_logic.or_intror _A _B __))) =>
                        cic.prod cic.prop cic.prop
                          (matita_basics_logic.Or _A _B)
                          (z :
                             cic.Term cic.prop (matita_basics_logic.Or _A _B) =>
                           return_type z))))))).

[ _A, _B, return_type, case_or_introl, case_or_intror, __ ]
  match_Or_Prop _A _B return_type case_or_introl case_or_intror
    (matita_basics_logic.or_introl _A _B __) -->
  case_or_introl __.

[ _A, _B, return_type, case_or_introl, case_or_intror, __ ]
  match_Or_Prop _A _B return_type case_or_introl case_or_intror
    (matita_basics_logic.or_intror _A _B __) -->
  case_or_intror __.

def match_Or_Type5 :
      cic.Term
        (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
        (cic.prod (cic.type cic.z)
           (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
           (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z)
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
              (cic.univ cic.prop)
              (_B : cic.Univ cic.prop =>
               cic.prod
                 (cic.type
                    (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                 (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                 (cic.prod cic.prop
                    (cic.type
                       (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                    (matita_basics_logic.Or _A _B)
                    (z : cic.Term cic.prop (matita_basics_logic.Or _A _B) =>
                     cic.univ
                       (cic.type
                          (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))))
                 (return_type :
                    cic.Term
                      (cic.type
                         (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                      (cic.prod cic.prop
                         (cic.type
                            (cic.s
                               (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                         (matita_basics_logic.Or _A _B)
                         (z :
                            cic.Term cic.prop (matita_basics_logic.Or _A _B) =>
                          cic.univ
                            (cic.type
                               (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))) =>
                  cic.prod
                    (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                    (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                    (cic.prod cic.prop
                       (cic.type
                          (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                       _A
                       (__ : cic.Term cic.prop _A =>
                        return_type (matita_basics_logic.or_introl _A _B __)))
                    (case_or_introl :
                       cic.Term
                         (cic.type
                            (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                         (cic.prod cic.prop
                            (cic.type
                               (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                            _A
                            (__ : cic.Term cic.prop _A =>
                             return_type
                               (matita_basics_logic.or_introl _A _B __))) =>
                     cic.prod
                       (cic.type
                          (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                       (cic.type
                          (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                       (cic.prod cic.prop
                          (cic.type
                             (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                          _B
                          (__ : cic.Term cic.prop _B =>
                           return_type
                             (matita_basics_logic.or_intror _A _B __)))
                       (case_or_intror :
                          cic.Term
                            (cic.type
                               (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                            (cic.prod cic.prop
                               (cic.type
                                  (cic.s
                                     (cic.s (cic.s (cic.s (cic.s cic.z))))))
                               _B
                               (__ : cic.Term cic.prop _B =>
                                return_type
                                  (matita_basics_logic.or_intror _A _B __))) =>
                        cic.prod cic.prop
                          (cic.type
                             (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                          (matita_basics_logic.Or _A _B)
                          (z :
                             cic.Term cic.prop (matita_basics_logic.Or _A _B) =>
                           return_type z))))))).

[ _A, _B, return_type, case_or_introl, case_or_intror, __ ]
  match_Or_Type5 _A _B return_type case_or_introl case_or_intror
    (matita_basics_logic.or_introl _A _B __) -->
  case_or_introl __.

[ _A, _B, return_type, case_or_introl, case_or_intror, __ ]
  match_Or_Type5 _A _B return_type case_or_introl case_or_intror
    (matita_basics_logic.or_intror _A _B __) -->
  case_or_intror __.

def match_Or_Type4 :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
        (cic.prod (cic.type cic.z)
           (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
           (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z)
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
              (cic.univ cic.prop)
              (_B : cic.Univ cic.prop =>
               cic.prod
                 (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                 (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                 (cic.prod cic.prop
                    (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                    (matita_basics_logic.Or _A _B)
                    (z : cic.Term cic.prop (matita_basics_logic.Or _A _B) =>
                     cic.univ
                       (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                 (return_type :
                    cic.Term
                      (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                      (cic.prod cic.prop
                         (cic.type
                            (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                         (matita_basics_logic.Or _A _B)
                         (z :
                            cic.Term cic.prop (matita_basics_logic.Or _A _B) =>
                          cic.univ
                            (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))))) =>
                  cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                    (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                    (cic.prod cic.prop
                       (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))) _A
                       (__ : cic.Term cic.prop _A =>
                        return_type (matita_basics_logic.or_introl _A _B __)))
                    (case_or_introl :
                       cic.Term
                         (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                         (cic.prod cic.prop
                            (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                            _A
                            (__ : cic.Term cic.prop _A =>
                             return_type
                               (matita_basics_logic.or_introl _A _B __))) =>
                     cic.prod
                       (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                       (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                       (cic.prod cic.prop
                          (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))) _B
                          (__ : cic.Term cic.prop _B =>
                           return_type
                             (matita_basics_logic.or_intror _A _B __)))
                       (case_or_intror :
                          cic.Term
                            (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                            (cic.prod cic.prop
                               (cic.type
                                  (cic.s (cic.s (cic.s (cic.s cic.z)))))
                               _B
                               (__ : cic.Term cic.prop _B =>
                                return_type
                                  (matita_basics_logic.or_intror _A _B __))) =>
                        cic.prod cic.prop
                          (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                          (matita_basics_logic.Or _A _B)
                          (z :
                             cic.Term cic.prop (matita_basics_logic.Or _A _B) =>
                           return_type z))))))).

[ _A, _B, return_type, case_or_introl, case_or_intror, __ ]
  match_Or_Type4 _A _B return_type case_or_introl case_or_intror
    (matita_basics_logic.or_introl _A _B __) -->
  case_or_introl __.

[ _A, _B, return_type, case_or_introl, case_or_intror, __ ]
  match_Or_Type4 _A _B return_type case_or_introl case_or_intror
    (matita_basics_logic.or_intror _A _B __) -->
  case_or_intror __.

def match_Or_Type3 :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
        (cic.prod (cic.type cic.z)
           (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
           (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z)
              (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
              (cic.univ cic.prop)
              (_B : cic.Univ cic.prop =>
               cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                 (cic.type (cic.s (cic.s (cic.s cic.z))))
                 (cic.prod cic.prop
                    (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                    (matita_basics_logic.Or _A _B)
                    (z : cic.Term cic.prop (matita_basics_logic.Or _A _B) =>
                     cic.univ (cic.type (cic.s (cic.s (cic.s cic.z))))))
                 (return_type :
                    cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                      (cic.prod cic.prop
                         (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                         (matita_basics_logic.Or _A _B)
                         (z :
                            cic.Term cic.prop (matita_basics_logic.Or _A _B) =>
                          cic.univ (cic.type (cic.s (cic.s (cic.s cic.z)))))) =>
                  cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
                    (cic.type (cic.s (cic.s (cic.s cic.z))))
                    (cic.prod cic.prop
                       (cic.type (cic.s (cic.s (cic.s cic.z)))) _A
                       (__ : cic.Term cic.prop _A =>
                        return_type (matita_basics_logic.or_introl _A _B __)))
                    (case_or_introl :
                       cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                         (cic.prod cic.prop
                            (cic.type (cic.s (cic.s (cic.s cic.z)))) _A
                            (__ : cic.Term cic.prop _A =>
                             return_type
                               (matita_basics_logic.or_introl _A _B __))) =>
                     cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
                       (cic.type (cic.s (cic.s (cic.s cic.z))))
                       (cic.prod cic.prop
                          (cic.type (cic.s (cic.s (cic.s cic.z)))) _B
                          (__ : cic.Term cic.prop _B =>
                           return_type
                             (matita_basics_logic.or_intror _A _B __)))
                       (case_or_intror :
                          cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                            (cic.prod cic.prop
                               (cic.type (cic.s (cic.s (cic.s cic.z)))) _B
                               (__ : cic.Term cic.prop _B =>
                                return_type
                                  (matita_basics_logic.or_intror _A _B __))) =>
                        cic.prod cic.prop
                          (cic.type (cic.s (cic.s (cic.s cic.z))))
                          (matita_basics_logic.Or _A _B)
                          (z :
                             cic.Term cic.prop (matita_basics_logic.Or _A _B) =>
                           return_type z))))))).

[ _A, _B, return_type, case_or_introl, case_or_intror, __ ]
  match_Or_Type3 _A _B return_type case_or_introl case_or_intror
    (matita_basics_logic.or_introl _A _B __) -->
  case_or_introl __.

[ _A, _B, return_type, case_or_introl, case_or_intror, __ ]
  match_Or_Type3 _A _B return_type case_or_introl case_or_intror
    (matita_basics_logic.or_intror _A _B __) -->
  case_or_intror __.

def match_Or_Type2 :
      cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
        (cic.prod (cic.type cic.z) (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z)
              (cic.type (cic.s (cic.s (cic.s cic.z)))) (cic.univ cic.prop)
              (_B : cic.Univ cic.prop =>
               cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
                 (cic.type (cic.s (cic.s cic.z)))
                 (cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
                    (matita_basics_logic.Or _A _B)
                    (z : cic.Term cic.prop (matita_basics_logic.Or _A _B) =>
                     cic.univ (cic.type (cic.s (cic.s cic.z)))))
                 (return_type :
                    cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                      (cic.prod cic.prop
                         (cic.type (cic.s (cic.s (cic.s cic.z))))
                         (matita_basics_logic.Or _A _B)
                         (z :
                            cic.Term cic.prop (matita_basics_logic.Or _A _B) =>
                          cic.univ (cic.type (cic.s (cic.s cic.z))))) =>
                  cic.prod (cic.type (cic.s (cic.s cic.z)))
                    (cic.type (cic.s (cic.s cic.z)))
                    (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z))) _A
                       (__ : cic.Term cic.prop _A =>
                        return_type (matita_basics_logic.or_introl _A _B __)))
                    (case_or_introl :
                       cic.Term (cic.type (cic.s (cic.s cic.z)))
                         (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                            _A
                            (__ : cic.Term cic.prop _A =>
                             return_type
                               (matita_basics_logic.or_introl _A _B __))) =>
                     cic.prod (cic.type (cic.s (cic.s cic.z)))
                       (cic.type (cic.s (cic.s cic.z)))
                       (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z))) _B
                          (__ : cic.Term cic.prop _B =>
                           return_type
                             (matita_basics_logic.or_intror _A _B __)))
                       (case_or_intror :
                          cic.Term (cic.type (cic.s (cic.s cic.z)))
                            (cic.prod cic.prop
                               (cic.type (cic.s (cic.s cic.z))) _B
                               (__ : cic.Term cic.prop _B =>
                                return_type
                                  (matita_basics_logic.or_intror _A _B __))) =>
                        cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                          (matita_basics_logic.Or _A _B)
                          (z :
                             cic.Term cic.prop (matita_basics_logic.Or _A _B) =>
                           return_type z))))))).

[ _A, _B, return_type, case_or_introl, case_or_intror, __ ]
  match_Or_Type2 _A _B return_type case_or_introl case_or_intror
    (matita_basics_logic.or_introl _A _B __) -->
  case_or_introl __.

[ _A, _B, return_type, case_or_introl, case_or_intror, __ ]
  match_Or_Type2 _A _B return_type case_or_introl case_or_intror
    (matita_basics_logic.or_intror _A _B __) -->
  case_or_intror __.

def match_Or_Type1 :
      cic.Term (cic.type (cic.s (cic.s cic.z)))
        (cic.prod (cic.type cic.z) (cic.type (cic.s (cic.s cic.z)))
           (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) (cic.type (cic.s (cic.s cic.z)))
              (cic.univ cic.prop)
              (_B : cic.Univ cic.prop =>
               cic.prod (cic.type (cic.s (cic.s cic.z)))
                 (cic.type (cic.s cic.z))
                 (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.Or _A _B)
                    (z : cic.Term cic.prop (matita_basics_logic.Or _A _B) =>
                     cic.univ (cic.type (cic.s cic.z))))
                 (return_type :
                    cic.Term (cic.type (cic.s (cic.s cic.z)))
                      (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.Or _A _B)
                         (z :
                            cic.Term cic.prop (matita_basics_logic.Or _A _B) =>
                          cic.univ (cic.type (cic.s cic.z)))) =>
                  cic.prod (cic.type (cic.s cic.z)) (cic.type (cic.s cic.z))
                    (cic.prod cic.prop (cic.type (cic.s cic.z)) _A
                       (__ : cic.Term cic.prop _A =>
                        return_type (matita_basics_logic.or_introl _A _B __)))
                    (case_or_introl :
                       cic.Term (cic.type (cic.s cic.z))
                         (cic.prod cic.prop (cic.type (cic.s cic.z)) _A
                            (__ : cic.Term cic.prop _A =>
                             return_type
                               (matita_basics_logic.or_introl _A _B __))) =>
                     cic.prod (cic.type (cic.s cic.z))
                       (cic.type (cic.s cic.z))
                       (cic.prod cic.prop (cic.type (cic.s cic.z)) _B
                          (__ : cic.Term cic.prop _B =>
                           return_type
                             (matita_basics_logic.or_intror _A _B __)))
                       (case_or_intror :
                          cic.Term (cic.type (cic.s cic.z))
                            (cic.prod cic.prop (cic.type (cic.s cic.z)) _B
                               (__ : cic.Term cic.prop _B =>
                                return_type
                                  (matita_basics_logic.or_intror _A _B __))) =>
                        cic.prod cic.prop (cic.type (cic.s cic.z))
                          (matita_basics_logic.Or _A _B)
                          (z :
                             cic.Term cic.prop (matita_basics_logic.Or _A _B) =>
                           return_type z))))))).

[ _A, _B, return_type, case_or_introl, case_or_intror, __ ]
  match_Or_Type1 _A _B return_type case_or_introl case_or_intror
    (matita_basics_logic.or_introl _A _B __) -->
  case_or_introl __.

[ _A, _B, return_type, case_or_introl, case_or_intror, __ ]
  match_Or_Type1 _A _B return_type case_or_introl case_or_intror
    (matita_basics_logic.or_intror _A _B __) -->
  case_or_intror __.

def match_Or_Type0 :
      cic.Term (cic.type (cic.s cic.z))
        (cic.prod (cic.type cic.z) (cic.type (cic.s cic.z))
           (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) (cic.type (cic.s cic.z))
              (cic.univ cic.prop)
              (_B : cic.Univ cic.prop =>
               cic.prod (cic.type (cic.s cic.z)) (cic.type cic.z)
                 (cic.prod cic.prop (cic.type (cic.s cic.z))
                    (matita_basics_logic.Or _A _B)
                    (z : cic.Term cic.prop (matita_basics_logic.Or _A _B) =>
                     cic.univ (cic.type cic.z)))
                 (return_type :
                    cic.Term (cic.type (cic.s cic.z))
                      (cic.prod cic.prop (cic.type (cic.s cic.z))
                         (matita_basics_logic.Or _A _B)
                         (z :
                            cic.Term cic.prop (matita_basics_logic.Or _A _B) =>
                          cic.univ (cic.type cic.z))) =>
                  cic.prod (cic.type cic.z) (cic.type cic.z)
                    (cic.prod cic.prop (cic.type cic.z) _A
                       (__ : cic.Term cic.prop _A =>
                        return_type (matita_basics_logic.or_introl _A _B __)))
                    (case_or_introl :
                       cic.Term (cic.type cic.z)
                         (cic.prod cic.prop (cic.type cic.z) _A
                            (__ : cic.Term cic.prop _A =>
                             return_type
                               (matita_basics_logic.or_introl _A _B __))) =>
                     cic.prod (cic.type cic.z) (cic.type cic.z)
                       (cic.prod cic.prop (cic.type cic.z) _B
                          (__ : cic.Term cic.prop _B =>
                           return_type
                             (matita_basics_logic.or_intror _A _B __)))
                       (case_or_intror :
                          cic.Term (cic.type cic.z)
                            (cic.prod cic.prop (cic.type cic.z) _B
                               (__ : cic.Term cic.prop _B =>
                                return_type
                                  (matita_basics_logic.or_intror _A _B __))) =>
                        cic.prod cic.prop (cic.type cic.z)
                          (matita_basics_logic.Or _A _B)
                          (z :
                             cic.Term cic.prop (matita_basics_logic.Or _A _B) =>
                           return_type z))))))).

[ _A, _B, return_type, case_or_introl, case_or_intror, __ ]
  match_Or_Type0 _A _B return_type case_or_introl case_or_intror
    (matita_basics_logic.or_introl _A _B __) -->
  case_or_introl __.

[ _A, _B, return_type, case_or_introl, case_or_intror, __ ]
  match_Or_Type0 _A _B return_type case_or_introl case_or_intror
    (matita_basics_logic.or_intror _A _B __) -->
  case_or_intror __.

def filter_Or_Prop :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
              (_B : cic.Univ cic.prop =>
               cic.prod (cic.type cic.z) cic.prop
                 (cic.prod cic.prop (cic.type cic.z)
                    (matita_basics_logic.Or _A _B)
                    (z : cic.Term cic.prop (matita_basics_logic.Or _A _B) =>
                     cic.univ cic.prop))
                 (return_type :
                    cic.Term (cic.type cic.z)
                      (cic.prod cic.prop (cic.type cic.z)
                         (matita_basics_logic.Or _A _B)
                         (z :
                            cic.Term cic.prop (matita_basics_logic.Or _A _B) =>
                          cic.univ cic.prop)) =>
                  cic.prod cic.prop cic.prop
                    (cic.prod cic.prop cic.prop
                       (matita_basics_logic.Or _A _B)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.Or _A _B) =>
                        return_type z))
                    (return :
                       cic.Term cic.prop
                         (cic.prod cic.prop cic.prop
                            (matita_basics_logic.Or _A _B)
                            (z :
                               cic.Term cic.prop
                                 (matita_basics_logic.Or _A _B) =>
                             return_type z)) =>
                     cic.prod cic.prop cic.prop
                       (matita_basics_logic.Or _A _B)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.Or _A _B) =>
                        return_type z)))))).

[ A, B, __, return_type, return ]
  filter_Or_Prop (A) (B) return_type return
    (matita_basics_logic.or_introl A B __) -->
  return (matita_basics_logic.or_introl A B __).

[ A, B, __, return_type, return ]
  filter_Or_Prop (A) (B) return_type return
    (matita_basics_logic.or_intror A B __) -->
  return (matita_basics_logic.or_intror A B __).

def filter_Or_Type5 :
      cic.Term
        (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
        (cic.prod (cic.type cic.z)
           (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
           (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z)
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
              (cic.univ cic.prop)
              (_B : cic.Univ cic.prop =>
               cic.prod
                 (cic.type
                    (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                 (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                 (cic.prod cic.prop
                    (cic.type
                       (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                    (matita_basics_logic.Or _A _B)
                    (z : cic.Term cic.prop (matita_basics_logic.Or _A _B) =>
                     cic.univ
                       (cic.type
                          (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))))
                 (return_type :
                    cic.Term
                      (cic.type
                         (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                      (cic.prod cic.prop
                         (cic.type
                            (cic.s
                               (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                         (matita_basics_logic.Or _A _B)
                         (z :
                            cic.Term cic.prop (matita_basics_logic.Or _A _B) =>
                          cic.univ
                            (cic.type
                               (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))) =>
                  cic.prod
                    (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                    (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                    (cic.prod cic.prop
                       (cic.type
                          (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                       (matita_basics_logic.Or _A _B)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.Or _A _B) =>
                        return_type z))
                    (return :
                       cic.Term
                         (cic.type
                            (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                         (cic.prod cic.prop
                            (cic.type
                               (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                            (matita_basics_logic.Or _A _B)
                            (z :
                               cic.Term cic.prop
                                 (matita_basics_logic.Or _A _B) =>
                             return_type z)) =>
                     cic.prod cic.prop
                       (cic.type
                          (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                       (matita_basics_logic.Or _A _B)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.Or _A _B) =>
                        return_type z)))))).

[ A, B, __, return_type, return ]
  filter_Or_Type5 (A) (B) return_type return
    (matita_basics_logic.or_introl A B __) -->
  return (matita_basics_logic.or_introl A B __).

[ A, B, __, return_type, return ]
  filter_Or_Type5 (A) (B) return_type return
    (matita_basics_logic.or_intror A B __) -->
  return (matita_basics_logic.or_intror A B __).

def filter_Or_Type4 :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
        (cic.prod (cic.type cic.z)
           (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
           (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z)
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
              (cic.univ cic.prop)
              (_B : cic.Univ cic.prop =>
               cic.prod
                 (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                 (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                 (cic.prod cic.prop
                    (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                    (matita_basics_logic.Or _A _B)
                    (z : cic.Term cic.prop (matita_basics_logic.Or _A _B) =>
                     cic.univ
                       (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                 (return_type :
                    cic.Term
                      (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                      (cic.prod cic.prop
                         (cic.type
                            (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                         (matita_basics_logic.Or _A _B)
                         (z :
                            cic.Term cic.prop (matita_basics_logic.Or _A _B) =>
                          cic.univ
                            (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))))) =>
                  cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                    (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                    (cic.prod cic.prop
                       (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                       (matita_basics_logic.Or _A _B)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.Or _A _B) =>
                        return_type z))
                    (return :
                       cic.Term
                         (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                         (cic.prod cic.prop
                            (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                            (matita_basics_logic.Or _A _B)
                            (z :
                               cic.Term cic.prop
                                 (matita_basics_logic.Or _A _B) =>
                             return_type z)) =>
                     cic.prod cic.prop
                       (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                       (matita_basics_logic.Or _A _B)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.Or _A _B) =>
                        return_type z)))))).

[ A, B, __, return_type, return ]
  filter_Or_Type4 (A) (B) return_type return
    (matita_basics_logic.or_introl A B __) -->
  return (matita_basics_logic.or_introl A B __).

[ A, B, __, return_type, return ]
  filter_Or_Type4 (A) (B) return_type return
    (matita_basics_logic.or_intror A B __) -->
  return (matita_basics_logic.or_intror A B __).

def filter_Or_Type3 :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
        (cic.prod (cic.type cic.z)
           (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
           (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z)
              (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
              (cic.univ cic.prop)
              (_B : cic.Univ cic.prop =>
               cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                 (cic.type (cic.s (cic.s (cic.s cic.z))))
                 (cic.prod cic.prop
                    (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                    (matita_basics_logic.Or _A _B)
                    (z : cic.Term cic.prop (matita_basics_logic.Or _A _B) =>
                     cic.univ (cic.type (cic.s (cic.s (cic.s cic.z))))))
                 (return_type :
                    cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                      (cic.prod cic.prop
                         (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                         (matita_basics_logic.Or _A _B)
                         (z :
                            cic.Term cic.prop (matita_basics_logic.Or _A _B) =>
                          cic.univ (cic.type (cic.s (cic.s (cic.s cic.z)))))) =>
                  cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
                    (cic.type (cic.s (cic.s (cic.s cic.z))))
                    (cic.prod cic.prop
                       (cic.type (cic.s (cic.s (cic.s cic.z))))
                       (matita_basics_logic.Or _A _B)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.Or _A _B) =>
                        return_type z))
                    (return :
                       cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                         (cic.prod cic.prop
                            (cic.type (cic.s (cic.s (cic.s cic.z))))
                            (matita_basics_logic.Or _A _B)
                            (z :
                               cic.Term cic.prop
                                 (matita_basics_logic.Or _A _B) =>
                             return_type z)) =>
                     cic.prod cic.prop
                       (cic.type (cic.s (cic.s (cic.s cic.z))))
                       (matita_basics_logic.Or _A _B)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.Or _A _B) =>
                        return_type z)))))).

[ A, B, __, return_type, return ]
  filter_Or_Type3 (A) (B) return_type return
    (matita_basics_logic.or_introl A B __) -->
  return (matita_basics_logic.or_introl A B __).

[ A, B, __, return_type, return ]
  filter_Or_Type3 (A) (B) return_type return
    (matita_basics_logic.or_intror A B __) -->
  return (matita_basics_logic.or_intror A B __).

def filter_Or_Type2 :
      cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
        (cic.prod (cic.type cic.z) (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z)
              (cic.type (cic.s (cic.s (cic.s cic.z)))) (cic.univ cic.prop)
              (_B : cic.Univ cic.prop =>
               cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
                 (cic.type (cic.s (cic.s cic.z)))
                 (cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
                    (matita_basics_logic.Or _A _B)
                    (z : cic.Term cic.prop (matita_basics_logic.Or _A _B) =>
                     cic.univ (cic.type (cic.s (cic.s cic.z)))))
                 (return_type :
                    cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                      (cic.prod cic.prop
                         (cic.type (cic.s (cic.s (cic.s cic.z))))
                         (matita_basics_logic.Or _A _B)
                         (z :
                            cic.Term cic.prop (matita_basics_logic.Or _A _B) =>
                          cic.univ (cic.type (cic.s (cic.s cic.z))))) =>
                  cic.prod (cic.type (cic.s (cic.s cic.z)))
                    (cic.type (cic.s (cic.s cic.z)))
                    (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                       (matita_basics_logic.Or _A _B)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.Or _A _B) =>
                        return_type z))
                    (return :
                       cic.Term (cic.type (cic.s (cic.s cic.z)))
                         (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                            (matita_basics_logic.Or _A _B)
                            (z :
                               cic.Term cic.prop
                                 (matita_basics_logic.Or _A _B) =>
                             return_type z)) =>
                     cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                       (matita_basics_logic.Or _A _B)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.Or _A _B) =>
                        return_type z)))))).

[ A, B, __, return_type, return ]
  filter_Or_Type2 (A) (B) return_type return
    (matita_basics_logic.or_introl A B __) -->
  return (matita_basics_logic.or_introl A B __).

[ A, B, __, return_type, return ]
  filter_Or_Type2 (A) (B) return_type return
    (matita_basics_logic.or_intror A B __) -->
  return (matita_basics_logic.or_intror A B __).

def filter_Or_Type1 :
      cic.Term (cic.type (cic.s (cic.s cic.z)))
        (cic.prod (cic.type cic.z) (cic.type (cic.s (cic.s cic.z)))
           (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) (cic.type (cic.s (cic.s cic.z)))
              (cic.univ cic.prop)
              (_B : cic.Univ cic.prop =>
               cic.prod (cic.type (cic.s (cic.s cic.z)))
                 (cic.type (cic.s cic.z))
                 (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.Or _A _B)
                    (z : cic.Term cic.prop (matita_basics_logic.Or _A _B) =>
                     cic.univ (cic.type (cic.s cic.z))))
                 (return_type :
                    cic.Term (cic.type (cic.s (cic.s cic.z)))
                      (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.Or _A _B)
                         (z :
                            cic.Term cic.prop (matita_basics_logic.Or _A _B) =>
                          cic.univ (cic.type (cic.s cic.z)))) =>
                  cic.prod (cic.type (cic.s cic.z)) (cic.type (cic.s cic.z))
                    (cic.prod cic.prop (cic.type (cic.s cic.z))
                       (matita_basics_logic.Or _A _B)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.Or _A _B) =>
                        return_type z))
                    (return :
                       cic.Term (cic.type (cic.s cic.z))
                         (cic.prod cic.prop (cic.type (cic.s cic.z))
                            (matita_basics_logic.Or _A _B)
                            (z :
                               cic.Term cic.prop
                                 (matita_basics_logic.Or _A _B) =>
                             return_type z)) =>
                     cic.prod cic.prop (cic.type (cic.s cic.z))
                       (matita_basics_logic.Or _A _B)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.Or _A _B) =>
                        return_type z)))))).

[ A, B, __, return_type, return ]
  filter_Or_Type1 (A) (B) return_type return
    (matita_basics_logic.or_introl A B __) -->
  return (matita_basics_logic.or_introl A B __).

[ A, B, __, return_type, return ]
  filter_Or_Type1 (A) (B) return_type return
    (matita_basics_logic.or_intror A B __) -->
  return (matita_basics_logic.or_intror A B __).

def filter_Or_Type0 :
      cic.Term (cic.type (cic.s cic.z))
        (cic.prod (cic.type cic.z) (cic.type (cic.s cic.z))
           (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) (cic.type (cic.s cic.z))
              (cic.univ cic.prop)
              (_B : cic.Univ cic.prop =>
               cic.prod (cic.type (cic.s cic.z)) (cic.type cic.z)
                 (cic.prod cic.prop (cic.type (cic.s cic.z))
                    (matita_basics_logic.Or _A _B)
                    (z : cic.Term cic.prop (matita_basics_logic.Or _A _B) =>
                     cic.univ (cic.type cic.z)))
                 (return_type :
                    cic.Term (cic.type (cic.s cic.z))
                      (cic.prod cic.prop (cic.type (cic.s cic.z))
                         (matita_basics_logic.Or _A _B)
                         (z :
                            cic.Term cic.prop (matita_basics_logic.Or _A _B) =>
                          cic.univ (cic.type cic.z))) =>
                  cic.prod (cic.type cic.z) (cic.type cic.z)
                    (cic.prod cic.prop (cic.type cic.z)
                       (matita_basics_logic.Or _A _B)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.Or _A _B) =>
                        return_type z))
                    (return :
                       cic.Term (cic.type cic.z)
                         (cic.prod cic.prop (cic.type cic.z)
                            (matita_basics_logic.Or _A _B)
                            (z :
                               cic.Term cic.prop
                                 (matita_basics_logic.Or _A _B) =>
                             return_type z)) =>
                     cic.prod cic.prop (cic.type cic.z)
                       (matita_basics_logic.Or _A _B)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.Or _A _B) =>
                        return_type z)))))).

[ A, B, __, return_type, return ]
  filter_Or_Type0 (A) (B) return_type return
    (matita_basics_logic.or_introl A B __) -->
  return (matita_basics_logic.or_introl A B __).

[ A, B, __, return_type, return ]
  filter_Or_Type0 (A) (B) return_type return
    (matita_basics_logic.or_intror A B __) -->
  return (matita_basics_logic.or_intror A B __).

def Or_ind :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
              (_B : cic.Univ cic.prop =>
               cic.prod (cic.type cic.z) cic.prop
                 (cic.prod cic.prop (cic.type cic.z)
                    (matita_basics_logic.Or (cic.lift cic.prop cic.prop _A)
                       (cic.lift cic.prop cic.prop _B))
                    (_x_170 :
                       cic.Term cic.prop
                         (matita_basics_logic.Or
                            (cic.lift cic.prop cic.prop _A)
                            (cic.lift cic.prop cic.prop _B)) =>
                     cic.univ cic.prop))
                 (Q_ :
                    cic.Term (cic.type cic.z)
                      (cic.prod cic.prop (cic.type cic.z)
                         (matita_basics_logic.Or
                            (cic.lift cic.prop cic.prop _A)
                            (cic.lift cic.prop cic.prop _B))
                         (_x_170 :
                            cic.Term cic.prop
                              (matita_basics_logic.Or
                                 (cic.lift cic.prop cic.prop _A)
                                 (cic.lift cic.prop cic.prop _B)) =>
                          cic.univ cic.prop)) =>
                  cic.prod cic.prop cic.prop
                    (cic.prod cic.prop cic.prop _A
                       (x_171 : cic.Term cic.prop _A =>
                        Q_
                          (matita_basics_logic.or_introl
                             (cic.lift cic.prop cic.prop _A)
                             (cic.lift cic.prop cic.prop _B) x_171)))
                    (_H_or_introl :
                       cic.Term cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (x_171 : cic.Term cic.prop _A =>
                             Q_
                               (matita_basics_logic.or_introl
                                  (cic.lift cic.prop cic.prop _A)
                                  (cic.lift cic.prop cic.prop _B) x_171))) =>
                     cic.prod cic.prop cic.prop
                       (cic.prod cic.prop cic.prop _B
                          (x_172 : cic.Term cic.prop _B =>
                           Q_
                             (matita_basics_logic.or_intror
                                (cic.lift cic.prop cic.prop _A)
                                (cic.lift cic.prop cic.prop _B) x_172)))
                       (_H_or_intror :
                          cic.Term cic.prop
                            (cic.prod cic.prop cic.prop _B
                               (x_172 : cic.Term cic.prop _B =>
                                Q_
                                  (matita_basics_logic.or_intror
                                     (cic.lift cic.prop cic.prop _A)
                                     (cic.lift cic.prop cic.prop _B) x_172))) =>
                        cic.prod cic.prop cic.prop
                          (matita_basics_logic.Or
                             (cic.lift cic.prop cic.prop _A)
                             (cic.lift cic.prop cic.prop _B))
                          (x_170 :
                             cic.Term cic.prop
                               (matita_basics_logic.Or
                                  (cic.lift cic.prop cic.prop _A)
                                  (cic.lift cic.prop cic.prop _B)) =>
                           Q_ x_170))))))).

def Or_ind_body :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
              (_B : cic.Univ cic.prop =>
               cic.prod (cic.type cic.z) cic.prop
                 (cic.prod cic.prop (cic.type cic.z)
                    (matita_basics_logic.Or (cic.lift cic.prop cic.prop _A)
                       (cic.lift cic.prop cic.prop _B))
                    (_x_170 :
                       cic.Term cic.prop
                         (matita_basics_logic.Or
                            (cic.lift cic.prop cic.prop _A)
                            (cic.lift cic.prop cic.prop _B)) =>
                     cic.univ cic.prop))
                 (Q_ :
                    cic.Term (cic.type cic.z)
                      (cic.prod cic.prop (cic.type cic.z)
                         (matita_basics_logic.Or
                            (cic.lift cic.prop cic.prop _A)
                            (cic.lift cic.prop cic.prop _B))
                         (_x_170 :
                            cic.Term cic.prop
                              (matita_basics_logic.Or
                                 (cic.lift cic.prop cic.prop _A)
                                 (cic.lift cic.prop cic.prop _B)) =>
                          cic.univ cic.prop)) =>
                  cic.prod cic.prop cic.prop
                    (cic.prod cic.prop cic.prop _A
                       (x_171 : cic.Term cic.prop _A =>
                        Q_
                          (matita_basics_logic.or_introl
                             (cic.lift cic.prop cic.prop _A)
                             (cic.lift cic.prop cic.prop _B) x_171)))
                    (_H_or_introl :
                       cic.Term cic.prop
                         (cic.prod cic.prop cic.prop _A
                            (x_171 : cic.Term cic.prop _A =>
                             Q_
                               (matita_basics_logic.or_introl
                                  (cic.lift cic.prop cic.prop _A)
                                  (cic.lift cic.prop cic.prop _B) x_171))) =>
                     cic.prod cic.prop cic.prop
                       (cic.prod cic.prop cic.prop _B
                          (x_172 : cic.Term cic.prop _B =>
                           Q_
                             (matita_basics_logic.or_intror
                                (cic.lift cic.prop cic.prop _A)
                                (cic.lift cic.prop cic.prop _B) x_172)))
                       (_H_or_intror :
                          cic.Term cic.prop
                            (cic.prod cic.prop cic.prop _B
                               (x_172 : cic.Term cic.prop _B =>
                                Q_
                                  (matita_basics_logic.or_intror
                                     (cic.lift cic.prop cic.prop _A)
                                     (cic.lift cic.prop cic.prop _B) x_172))) =>
                        cic.prod cic.prop cic.prop
                          (matita_basics_logic.Or
                             (cic.lift cic.prop cic.prop _A)
                             (cic.lift cic.prop cic.prop _B))
                          (x_170 :
                             cic.Term cic.prop
                               (matita_basics_logic.Or
                                  (cic.lift cic.prop cic.prop _A)
                                  (cic.lift cic.prop cic.prop _B)) =>
                           Q_ x_170))))))).

[ _A, _B, Q_, _H_or_introl, _H_or_intror, x_170 ]
  Or_ind _A _B Q_ _H_or_introl _H_or_intror x_170 -->
  matita_basics_logic.filter_Or_Prop _A _B
    (x_170 :
       cic.Term cic.prop
         (matita_basics_logic.Or (cic.lift cic.prop cic.prop _A)
            (cic.lift cic.prop cic.prop _B)) =>
     Q_ x_170)
    (matita_basics_logic.Or_ind_body _A _B Q_ _H_or_introl _H_or_intror)
    x_170.

[ _A, _B, Q_, _H_or_introl, _H_or_intror, x_170 ]
  Or_ind_body _A _B Q_ _H_or_introl _H_or_intror x_170 -->
  matita_basics_logic.match_Or_Prop (cic.lift cic.prop cic.prop _A)
    (cic.lift cic.prop cic.prop _B) Q_
    (x_171 : cic.Term cic.prop _A => _H_or_introl x_171)
    (x_172 : cic.Term cic.prop _B => _H_or_intror x_172) x_170.

def Or_inv_ind :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
           (x1 : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
              (x2 : cic.Univ cic.prop =>
               cic.prod cic.prop cic.prop
                 (matita_basics_logic.Or (cic.lift cic.prop cic.prop x1)
                    (cic.lift cic.prop cic.prop x2))
                 (Hterm :
                    cic.Term cic.prop
                      (matita_basics_logic.Or (cic.lift cic.prop cic.prop x1)
                         (cic.lift cic.prop cic.prop x2)) =>
                  cic.prod (cic.type cic.z) cic.prop
                    (cic.prod cic.prop (cic.type cic.z)
                       (matita_basics_logic.Or
                          (cic.lift cic.prop cic.prop x1)
                          (cic.lift cic.prop cic.prop x2))
                       (_z389 :
                          cic.Term cic.prop
                            (matita_basics_logic.Or
                               (cic.lift cic.prop cic.prop x1)
                               (cic.lift cic.prop cic.prop x2)) =>
                        cic.univ cic.prop))
                    (P :
                       cic.Term (cic.type cic.z)
                         (cic.prod cic.prop (cic.type cic.z)
                            (matita_basics_logic.Or
                               (cic.lift cic.prop cic.prop x1)
                               (cic.lift cic.prop cic.prop x2))
                            (_z389 :
                               cic.Term cic.prop
                                 (matita_basics_logic.Or
                                    (cic.lift cic.prop cic.prop x1)
                                    (cic.lift cic.prop cic.prop x2)) =>
                             cic.univ cic.prop)) =>
                     cic.prod cic.prop cic.prop
                       (cic.prod cic.prop cic.prop x1
                          (x_171 : cic.Term cic.prop x1 =>
                           cic.prod cic.prop cic.prop
                             (matita_basics_logic.eq
                                (cic.lift cic.prop
                                   (cic.type (cic.s (cic.s cic.z)))
                                   (matita_basics_logic.Or
                                      (cic.lift cic.prop cic.prop x1)
                                      (cic.lift cic.prop cic.prop x2)))
                                Hterm
                                (matita_basics_logic.or_introl
                                   (cic.lift cic.prop cic.prop x1)
                                   (cic.lift cic.prop cic.prop x2) x_171))
                             (_z390 :
                                cic.Term cic.prop
                                  (matita_basics_logic.eq
                                     (cic.lift cic.prop
                                        (cic.type (cic.s (cic.s cic.z)))
                                        (matita_basics_logic.Or
                                           (cic.lift cic.prop cic.prop x1)
                                           (cic.lift cic.prop cic.prop x2)))
                                     Hterm
                                     (matita_basics_logic.or_introl
                                        (cic.lift cic.prop cic.prop x1)
                                        (cic.lift cic.prop cic.prop x2) x_171)) =>
                              P
                                (matita_basics_logic.or_introl
                                   (cic.lift cic.prop cic.prop x1)
                                   (cic.lift cic.prop cic.prop x2) x_171))))
                       (_H1 :
                          cic.Term cic.prop
                            (cic.prod cic.prop cic.prop x1
                               (x_171 : cic.Term cic.prop x1 =>
                                cic.prod cic.prop cic.prop
                                  (matita_basics_logic.eq
                                     (cic.lift cic.prop
                                        (cic.type (cic.s (cic.s cic.z)))
                                        (matita_basics_logic.Or
                                           (cic.lift cic.prop cic.prop x1)
                                           (cic.lift cic.prop cic.prop x2)))
                                     Hterm
                                     (matita_basics_logic.or_introl
                                        (cic.lift cic.prop cic.prop x1)
                                        (cic.lift cic.prop cic.prop x2) x_171))
                                  (_z390 :
                                     cic.Term cic.prop
                                       (matita_basics_logic.eq
                                          (cic.lift cic.prop
                                             (cic.type (cic.s (cic.s cic.z)))
                                             (matita_basics_logic.Or
                                                (cic.lift cic.prop cic.prop
                                                   x1)
                                                (cic.lift cic.prop cic.prop
                                                   x2)))
                                          Hterm
                                          (matita_basics_logic.or_introl
                                             (cic.lift cic.prop cic.prop x1)
                                             (cic.lift cic.prop cic.prop x2)
                                             x_171)) =>
                                   P
                                     (matita_basics_logic.or_introl
                                        (cic.lift cic.prop cic.prop x1)
                                        (cic.lift cic.prop cic.prop x2) x_171)))) =>
                        cic.prod cic.prop cic.prop
                          (cic.prod cic.prop cic.prop x2
                             (x_172 : cic.Term cic.prop x2 =>
                              cic.prod cic.prop cic.prop
                                (matita_basics_logic.eq
                                   (cic.lift cic.prop
                                      (cic.type (cic.s (cic.s cic.z)))
                                      (matita_basics_logic.Or
                                         (cic.lift cic.prop cic.prop x1)
                                         (cic.lift cic.prop cic.prop x2)))
                                   Hterm
                                   (matita_basics_logic.or_intror
                                      (cic.lift cic.prop cic.prop x1)
                                      (cic.lift cic.prop cic.prop x2) x_172))
                                (_z390 :
                                   cic.Term cic.prop
                                     (matita_basics_logic.eq
                                        (cic.lift cic.prop
                                           (cic.type (cic.s (cic.s cic.z)))
                                           (matita_basics_logic.Or
                                              (cic.lift cic.prop cic.prop x1)
                                              (cic.lift cic.prop cic.prop x2)))
                                        Hterm
                                        (matita_basics_logic.or_intror
                                           (cic.lift cic.prop cic.prop x1)
                                           (cic.lift cic.prop cic.prop x2)
                                           x_172)) =>
                                 P
                                   (matita_basics_logic.or_intror
                                      (cic.lift cic.prop cic.prop x1)
                                      (cic.lift cic.prop cic.prop x2) x_172))))
                          (_H2 :
                             cic.Term cic.prop
                               (cic.prod cic.prop cic.prop x2
                                  (x_172 : cic.Term cic.prop x2 =>
                                   cic.prod cic.prop cic.prop
                                     (matita_basics_logic.eq
                                        (cic.lift cic.prop
                                           (cic.type (cic.s (cic.s cic.z)))
                                           (matita_basics_logic.Or
                                              (cic.lift cic.prop cic.prop x1)
                                              (cic.lift cic.prop cic.prop x2)))
                                        Hterm
                                        (matita_basics_logic.or_intror
                                           (cic.lift cic.prop cic.prop x1)
                                           (cic.lift cic.prop cic.prop x2)
                                           x_172))
                                     (_z390 :
                                        cic.Term cic.prop
                                          (matita_basics_logic.eq
                                             (cic.lift cic.prop
                                                (cic.type
                                                   (cic.s (cic.s cic.z)))
                                                (matita_basics_logic.Or
                                                   (cic.lift cic.prop
                                                      cic.prop x1)
                                                   (cic.lift cic.prop
                                                      cic.prop x2)))
                                             Hterm
                                             (matita_basics_logic.or_intror
                                                (cic.lift cic.prop cic.prop
                                                   x1)
                                                (cic.lift cic.prop cic.prop
                                                   x2)
                                                x_172)) =>
                                      P
                                        (matita_basics_logic.or_intror
                                           (cic.lift cic.prop cic.prop x1)
                                           (cic.lift cic.prop cic.prop x2)
                                           x_172)))) =>
                           P Hterm)))))))
      :=
      x1 : cic.Univ cic.prop =>
      x2 : cic.Univ cic.prop =>
      Hterm :
        cic.Term cic.prop
          (matita_basics_logic.Or (cic.lift cic.prop cic.prop x1)
             (cic.lift cic.prop cic.prop x2)) =>
      P :
        cic.Term (cic.type cic.z)
          (cic.prod cic.prop (cic.type cic.z)
             (matita_basics_logic.Or (cic.lift cic.prop cic.prop x1)
                (cic.lift cic.prop cic.prop x2))
             (_z389 :
                cic.Term cic.prop
                  (matita_basics_logic.Or (cic.lift cic.prop cic.prop x1)
                     (cic.lift cic.prop cic.prop x2)) =>
              cic.univ cic.prop)) =>
      H1 :
        cic.Term cic.prop
          (cic.prod cic.prop cic.prop x1
             (x_171 : cic.Term cic.prop x1 =>
              cic.prod cic.prop cic.prop
                (matita_basics_logic.eq
                   (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                      (matita_basics_logic.Or (cic.lift cic.prop cic.prop x1)
                         (cic.lift cic.prop cic.prop x2)))
                   Hterm
                   (matita_basics_logic.or_introl
                      (cic.lift cic.prop cic.prop x1)
                      (cic.lift cic.prop cic.prop x2) x_171))
                (_z390 :
                   cic.Term cic.prop
                     (matita_basics_logic.eq
                        (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                           (matita_basics_logic.Or
                              (cic.lift cic.prop cic.prop x1)
                              (cic.lift cic.prop cic.prop x2)))
                        Hterm
                        (matita_basics_logic.or_introl
                           (cic.lift cic.prop cic.prop x1)
                           (cic.lift cic.prop cic.prop x2) x_171)) =>
                 P
                   (matita_basics_logic.or_introl
                      (cic.lift cic.prop cic.prop x1)
                      (cic.lift cic.prop cic.prop x2) x_171)))) =>
      H2 :
        cic.Term cic.prop
          (cic.prod cic.prop cic.prop x2
             (x_172 : cic.Term cic.prop x2 =>
              cic.prod cic.prop cic.prop
                (matita_basics_logic.eq
                   (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                      (matita_basics_logic.Or (cic.lift cic.prop cic.prop x1)
                         (cic.lift cic.prop cic.prop x2)))
                   Hterm
                   (matita_basics_logic.or_intror
                      (cic.lift cic.prop cic.prop x1)
                      (cic.lift cic.prop cic.prop x2) x_172))
                (_z390 :
                   cic.Term cic.prop
                     (matita_basics_logic.eq
                        (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                           (matita_basics_logic.Or
                              (cic.lift cic.prop cic.prop x1)
                              (cic.lift cic.prop cic.prop x2)))
                        Hterm
                        (matita_basics_logic.or_intror
                           (cic.lift cic.prop cic.prop x1)
                           (cic.lift cic.prop cic.prop x2) x_172)) =>
                 P
                   (matita_basics_logic.or_intror
                      (cic.lift cic.prop cic.prop x1)
                      (cic.lift cic.prop cic.prop x2) x_172)))) =>
      (Hcut :
         cic.Term cic.prop
           (cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.Or (cic.lift cic.prop cic.prop x1)
                       (cic.lift cic.prop cic.prop x2)))
                 Hterm Hterm)
              (_z390 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.Or
                            (cic.lift cic.prop cic.prop x1)
                            (cic.lift cic.prop cic.prop x2)))
                      Hterm Hterm) =>
               P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
               (matita_basics_logic.Or (cic.lift cic.prop cic.prop x1)
                  (cic.lift cic.prop cic.prop x2)))
            Hterm))
        (matita_basics_logic.Or_ind (cic.lift cic.prop cic.prop x1)
           (cic.lift cic.prop cic.prop x2)
           (_x_170 :
              cic.Term cic.prop
                (matita_basics_logic.Or (cic.lift cic.prop cic.prop x1)
                   (cic.lift cic.prop cic.prop x2)) =>
            cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.Or (cic.lift cic.prop cic.prop x1)
                       (cic.lift cic.prop cic.prop x2)))
                 Hterm _x_170)
              (_z390 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.Or
                            (cic.lift cic.prop cic.prop x1)
                            (cic.lift cic.prop cic.prop x2)))
                      Hterm _x_170) =>
               P _x_170))
           H1 H2 Hterm).

def decidable :
      cic.Term (cic.type cic.z)
        (cic.prod (cic.type cic.z) (cic.type cic.z) (cic.univ cic.prop)
           (__ : cic.Univ cic.prop => cic.univ cic.prop))
      :=
      A : cic.Univ cic.prop =>
      matita_basics_logic.Or (cic.lift cic.prop cic.prop A)
        (cic.lift cic.prop cic.prop
           (matita_basics_logic.Not (cic.lift cic.prop cic.prop A))).

ex :
  cic.Term (cic.type (cic.s cic.z))
    (cic.prod (cic.type (cic.s cic.z)) (cic.type cic.z)
       (cic.univ (cic.type cic.z))
       (A : cic.Univ (cic.type cic.z) =>
        cic.prod (cic.type cic.z) (cic.type cic.z)
          (cic.prod (cic.type cic.z) (cic.type cic.z) A
             (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop))
          (_P :
             cic.Term (cic.type cic.z)
               (cic.prod (cic.type cic.z) (cic.type cic.z) A
                  (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop)) =>
           cic.univ cic.prop))).

ex_intro :
  cic.Term cic.prop
    (cic.prod (cic.type (cic.s cic.z)) cic.prop (cic.univ (cic.type cic.z))
       (A : cic.Univ (cic.type cic.z) =>
        cic.prod (cic.type cic.z) cic.prop
          (cic.prod (cic.type cic.z) (cic.type cic.z) A
             (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop))
          (P :
             cic.Term (cic.type cic.z)
               (cic.prod (cic.type cic.z) (cic.type cic.z) A
                  (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop)) =>
           cic.prod (cic.type cic.z) cic.prop A
             (x : cic.Term (cic.type cic.z) A =>
              cic.prod cic.prop cic.prop (P x)
                (__ : cic.Term cic.prop (P x) =>
                 matita_basics_logic.ex
                   (cic.lift (cic.type cic.z) (cic.type cic.z) A) P))))).

def match_ex_Prop :
      cic.Term cic.prop
        (cic.prod (cic.type (cic.s cic.z)) cic.prop
           (cic.univ (cic.type cic.z))
           (A : cic.Univ (cic.type cic.z) =>
            cic.prod (cic.type cic.z) cic.prop
              (cic.prod (cic.type cic.z) (cic.type cic.z) A
                 (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop))
              (_P :
                 cic.Term (cic.type cic.z)
                   (cic.prod (cic.type cic.z) (cic.type cic.z) A
                      (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop)) =>
               cic.prod (cic.type cic.z) cic.prop
                 (cic.prod cic.prop (cic.type cic.z)
                    (matita_basics_logic.ex A _P)
                    (z : cic.Term cic.prop (matita_basics_logic.ex A _P) =>
                     cic.univ cic.prop))
                 (return_type :
                    cic.Term (cic.type cic.z)
                      (cic.prod cic.prop (cic.type cic.z)
                         (matita_basics_logic.ex A _P)
                         (z :
                            cic.Term cic.prop (matita_basics_logic.ex A _P) =>
                          cic.univ cic.prop)) =>
                  cic.prod cic.prop cic.prop
                    (cic.prod (cic.type cic.z) cic.prop A
                       (x : cic.Term (cic.type cic.z) A =>
                        cic.prod cic.prop cic.prop (_P x)
                          (__ : cic.Term cic.prop (_P x) =>
                           return_type
                             (matita_basics_logic.ex_intro A _P x __))))
                    (case_ex_intro :
                       cic.Term cic.prop
                         (cic.prod (cic.type cic.z) cic.prop A
                            (x : cic.Term (cic.type cic.z) A =>
                             cic.prod cic.prop cic.prop (_P x)
                               (__ : cic.Term cic.prop (_P x) =>
                                return_type
                                  (matita_basics_logic.ex_intro A _P x __)))) =>
                     cic.prod cic.prop cic.prop (matita_basics_logic.ex A _P)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.ex A _P) =>
                        return_type z)))))).

[ A, _P, return_type, case_ex_intro, x, __ ]
  match_ex_Prop A _P return_type case_ex_intro
    (matita_basics_logic.ex_intro A _P x __) -->
  case_ex_intro x __.

def match_ex_Type5 :
      cic.Term
        (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
        (cic.prod (cic.type (cic.s cic.z))
           (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
           (cic.univ (cic.type cic.z))
           (A : cic.Univ (cic.type cic.z) =>
            cic.prod (cic.type cic.z)
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
              (cic.prod (cic.type cic.z) (cic.type cic.z) A
                 (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop))
              (_P :
                 cic.Term (cic.type cic.z)
                   (cic.prod (cic.type cic.z) (cic.type cic.z) A
                      (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop)) =>
               cic.prod
                 (cic.type
                    (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                 (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                 (cic.prod cic.prop
                    (cic.type
                       (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                    (matita_basics_logic.ex A _P)
                    (z : cic.Term cic.prop (matita_basics_logic.ex A _P) =>
                     cic.univ
                       (cic.type
                          (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))))
                 (return_type :
                    cic.Term
                      (cic.type
                         (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                      (cic.prod cic.prop
                         (cic.type
                            (cic.s
                               (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                         (matita_basics_logic.ex A _P)
                         (z :
                            cic.Term cic.prop (matita_basics_logic.ex A _P) =>
                          cic.univ
                            (cic.type
                               (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))) =>
                  cic.prod
                    (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                    (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                    (cic.prod (cic.type cic.z)
                       (cic.type
                          (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                       A
                       (x : cic.Term (cic.type cic.z) A =>
                        cic.prod cic.prop
                          (cic.type
                             (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                          (_P x)
                          (__ : cic.Term cic.prop (_P x) =>
                           return_type
                             (matita_basics_logic.ex_intro A _P x __))))
                    (case_ex_intro :
                       cic.Term
                         (cic.type
                            (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                         (cic.prod (cic.type cic.z)
                            (cic.type
                               (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                            A
                            (x : cic.Term (cic.type cic.z) A =>
                             cic.prod cic.prop
                               (cic.type
                                  (cic.s
                                     (cic.s (cic.s (cic.s (cic.s cic.z))))))
                               (_P x)
                               (__ : cic.Term cic.prop (_P x) =>
                                return_type
                                  (matita_basics_logic.ex_intro A _P x __)))) =>
                     cic.prod cic.prop
                       (cic.type
                          (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                       (matita_basics_logic.ex A _P)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.ex A _P) =>
                        return_type z)))))).

[ A, _P, return_type, case_ex_intro, x, __ ]
  match_ex_Type5 A _P return_type case_ex_intro
    (matita_basics_logic.ex_intro A _P x __) -->
  case_ex_intro x __.

def match_ex_Type4 :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
        (cic.prod (cic.type (cic.s cic.z))
           (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
           (cic.univ (cic.type cic.z))
           (A : cic.Univ (cic.type cic.z) =>
            cic.prod (cic.type cic.z)
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
              (cic.prod (cic.type cic.z) (cic.type cic.z) A
                 (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop))
              (_P :
                 cic.Term (cic.type cic.z)
                   (cic.prod (cic.type cic.z) (cic.type cic.z) A
                      (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop)) =>
               cic.prod
                 (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                 (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                 (cic.prod cic.prop
                    (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                    (matita_basics_logic.ex A _P)
                    (z : cic.Term cic.prop (matita_basics_logic.ex A _P) =>
                     cic.univ
                       (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                 (return_type :
                    cic.Term
                      (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                      (cic.prod cic.prop
                         (cic.type
                            (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                         (matita_basics_logic.ex A _P)
                         (z :
                            cic.Term cic.prop (matita_basics_logic.ex A _P) =>
                          cic.univ
                            (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))))) =>
                  cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                    (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                    (cic.prod (cic.type cic.z)
                       (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))) A
                       (x : cic.Term (cic.type cic.z) A =>
                        cic.prod cic.prop
                          (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                          (_P x)
                          (__ : cic.Term cic.prop (_P x) =>
                           return_type
                             (matita_basics_logic.ex_intro A _P x __))))
                    (case_ex_intro :
                       cic.Term
                         (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                         (cic.prod (cic.type cic.z)
                            (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                            A
                            (x : cic.Term (cic.type cic.z) A =>
                             cic.prod cic.prop
                               (cic.type
                                  (cic.s (cic.s (cic.s (cic.s cic.z)))))
                               (_P x)
                               (__ : cic.Term cic.prop (_P x) =>
                                return_type
                                  (matita_basics_logic.ex_intro A _P x __)))) =>
                     cic.prod cic.prop
                       (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                       (matita_basics_logic.ex A _P)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.ex A _P) =>
                        return_type z)))))).

[ A, _P, return_type, case_ex_intro, x, __ ]
  match_ex_Type4 A _P return_type case_ex_intro
    (matita_basics_logic.ex_intro A _P x __) -->
  case_ex_intro x __.

def match_ex_Type3 :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
        (cic.prod (cic.type (cic.s cic.z))
           (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
           (cic.univ (cic.type cic.z))
           (A : cic.Univ (cic.type cic.z) =>
            cic.prod (cic.type cic.z)
              (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
              (cic.prod (cic.type cic.z) (cic.type cic.z) A
                 (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop))
              (_P :
                 cic.Term (cic.type cic.z)
                   (cic.prod (cic.type cic.z) (cic.type cic.z) A
                      (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop)) =>
               cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                 (cic.type (cic.s (cic.s (cic.s cic.z))))
                 (cic.prod cic.prop
                    (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                    (matita_basics_logic.ex A _P)
                    (z : cic.Term cic.prop (matita_basics_logic.ex A _P) =>
                     cic.univ (cic.type (cic.s (cic.s (cic.s cic.z))))))
                 (return_type :
                    cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                      (cic.prod cic.prop
                         (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                         (matita_basics_logic.ex A _P)
                         (z :
                            cic.Term cic.prop (matita_basics_logic.ex A _P) =>
                          cic.univ (cic.type (cic.s (cic.s (cic.s cic.z)))))) =>
                  cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
                    (cic.type (cic.s (cic.s (cic.s cic.z))))
                    (cic.prod (cic.type cic.z)
                       (cic.type (cic.s (cic.s (cic.s cic.z)))) A
                       (x : cic.Term (cic.type cic.z) A =>
                        cic.prod cic.prop
                          (cic.type (cic.s (cic.s (cic.s cic.z)))) (_P x)
                          (__ : cic.Term cic.prop (_P x) =>
                           return_type
                             (matita_basics_logic.ex_intro A _P x __))))
                    (case_ex_intro :
                       cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                         (cic.prod (cic.type cic.z)
                            (cic.type (cic.s (cic.s (cic.s cic.z)))) A
                            (x : cic.Term (cic.type cic.z) A =>
                             cic.prod cic.prop
                               (cic.type (cic.s (cic.s (cic.s cic.z))))
                               (_P x)
                               (__ : cic.Term cic.prop (_P x) =>
                                return_type
                                  (matita_basics_logic.ex_intro A _P x __)))) =>
                     cic.prod cic.prop
                       (cic.type (cic.s (cic.s (cic.s cic.z))))
                       (matita_basics_logic.ex A _P)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.ex A _P) =>
                        return_type z)))))).

[ A, _P, return_type, case_ex_intro, x, __ ]
  match_ex_Type3 A _P return_type case_ex_intro
    (matita_basics_logic.ex_intro A _P x __) -->
  case_ex_intro x __.

def match_ex_Type2 :
      cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
        (cic.prod (cic.type (cic.s cic.z))
           (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.univ (cic.type cic.z))
           (A : cic.Univ (cic.type cic.z) =>
            cic.prod (cic.type cic.z)
              (cic.type (cic.s (cic.s (cic.s cic.z))))
              (cic.prod (cic.type cic.z) (cic.type cic.z) A
                 (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop))
              (_P :
                 cic.Term (cic.type cic.z)
                   (cic.prod (cic.type cic.z) (cic.type cic.z) A
                      (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop)) =>
               cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
                 (cic.type (cic.s (cic.s cic.z)))
                 (cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
                    (matita_basics_logic.ex A _P)
                    (z : cic.Term cic.prop (matita_basics_logic.ex A _P) =>
                     cic.univ (cic.type (cic.s (cic.s cic.z)))))
                 (return_type :
                    cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                      (cic.prod cic.prop
                         (cic.type (cic.s (cic.s (cic.s cic.z))))
                         (matita_basics_logic.ex A _P)
                         (z :
                            cic.Term cic.prop (matita_basics_logic.ex A _P) =>
                          cic.univ (cic.type (cic.s (cic.s cic.z))))) =>
                  cic.prod (cic.type (cic.s (cic.s cic.z)))
                    (cic.type (cic.s (cic.s cic.z)))
                    (cic.prod (cic.type cic.z)
                       (cic.type (cic.s (cic.s cic.z))) A
                       (x : cic.Term (cic.type cic.z) A =>
                        cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                          (_P x)
                          (__ : cic.Term cic.prop (_P x) =>
                           return_type
                             (matita_basics_logic.ex_intro A _P x __))))
                    (case_ex_intro :
                       cic.Term (cic.type (cic.s (cic.s cic.z)))
                         (cic.prod (cic.type cic.z)
                            (cic.type (cic.s (cic.s cic.z))) A
                            (x : cic.Term (cic.type cic.z) A =>
                             cic.prod cic.prop
                               (cic.type (cic.s (cic.s cic.z))) (_P x)
                               (__ : cic.Term cic.prop (_P x) =>
                                return_type
                                  (matita_basics_logic.ex_intro A _P x __)))) =>
                     cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                       (matita_basics_logic.ex A _P)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.ex A _P) =>
                        return_type z)))))).

[ A, _P, return_type, case_ex_intro, x, __ ]
  match_ex_Type2 A _P return_type case_ex_intro
    (matita_basics_logic.ex_intro A _P x __) -->
  case_ex_intro x __.

def match_ex_Type1 :
      cic.Term (cic.type (cic.s (cic.s cic.z)))
        (cic.prod (cic.type (cic.s cic.z)) (cic.type (cic.s (cic.s cic.z)))
           (cic.univ (cic.type cic.z))
           (A : cic.Univ (cic.type cic.z) =>
            cic.prod (cic.type cic.z) (cic.type (cic.s (cic.s cic.z)))
              (cic.prod (cic.type cic.z) (cic.type cic.z) A
                 (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop))
              (_P :
                 cic.Term (cic.type cic.z)
                   (cic.prod (cic.type cic.z) (cic.type cic.z) A
                      (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop)) =>
               cic.prod (cic.type (cic.s (cic.s cic.z)))
                 (cic.type (cic.s cic.z))
                 (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.ex A _P)
                    (z : cic.Term cic.prop (matita_basics_logic.ex A _P) =>
                     cic.univ (cic.type (cic.s cic.z))))
                 (return_type :
                    cic.Term (cic.type (cic.s (cic.s cic.z)))
                      (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.ex A _P)
                         (z :
                            cic.Term cic.prop (matita_basics_logic.ex A _P) =>
                          cic.univ (cic.type (cic.s cic.z)))) =>
                  cic.prod (cic.type (cic.s cic.z)) (cic.type (cic.s cic.z))
                    (cic.prod (cic.type cic.z) (cic.type (cic.s cic.z)) A
                       (x : cic.Term (cic.type cic.z) A =>
                        cic.prod cic.prop (cic.type (cic.s cic.z)) (_P x)
                          (__ : cic.Term cic.prop (_P x) =>
                           return_type
                             (matita_basics_logic.ex_intro A _P x __))))
                    (case_ex_intro :
                       cic.Term (cic.type (cic.s cic.z))
                         (cic.prod (cic.type cic.z) (cic.type (cic.s cic.z))
                            A
                            (x : cic.Term (cic.type cic.z) A =>
                             cic.prod cic.prop (cic.type (cic.s cic.z))
                               (_P x)
                               (__ : cic.Term cic.prop (_P x) =>
                                return_type
                                  (matita_basics_logic.ex_intro A _P x __)))) =>
                     cic.prod cic.prop (cic.type (cic.s cic.z))
                       (matita_basics_logic.ex A _P)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.ex A _P) =>
                        return_type z)))))).

[ A, _P, return_type, case_ex_intro, x, __ ]
  match_ex_Type1 A _P return_type case_ex_intro
    (matita_basics_logic.ex_intro A _P x __) -->
  case_ex_intro x __.

def match_ex_Type0 :
      cic.Term (cic.type (cic.s cic.z))
        (cic.prod (cic.type (cic.s cic.z)) (cic.type (cic.s cic.z))
           (cic.univ (cic.type cic.z))
           (A : cic.Univ (cic.type cic.z) =>
            cic.prod (cic.type cic.z) (cic.type (cic.s cic.z))
              (cic.prod (cic.type cic.z) (cic.type cic.z) A
                 (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop))
              (_P :
                 cic.Term (cic.type cic.z)
                   (cic.prod (cic.type cic.z) (cic.type cic.z) A
                      (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop)) =>
               cic.prod (cic.type (cic.s cic.z)) (cic.type cic.z)
                 (cic.prod cic.prop (cic.type (cic.s cic.z))
                    (matita_basics_logic.ex A _P)
                    (z : cic.Term cic.prop (matita_basics_logic.ex A _P) =>
                     cic.univ (cic.type cic.z)))
                 (return_type :
                    cic.Term (cic.type (cic.s cic.z))
                      (cic.prod cic.prop (cic.type (cic.s cic.z))
                         (matita_basics_logic.ex A _P)
                         (z :
                            cic.Term cic.prop (matita_basics_logic.ex A _P) =>
                          cic.univ (cic.type cic.z))) =>
                  cic.prod (cic.type cic.z) (cic.type cic.z)
                    (cic.prod (cic.type cic.z) (cic.type cic.z) A
                       (x : cic.Term (cic.type cic.z) A =>
                        cic.prod cic.prop (cic.type cic.z) (_P x)
                          (__ : cic.Term cic.prop (_P x) =>
                           return_type
                             (matita_basics_logic.ex_intro A _P x __))))
                    (case_ex_intro :
                       cic.Term (cic.type cic.z)
                         (cic.prod (cic.type cic.z) (cic.type cic.z) A
                            (x : cic.Term (cic.type cic.z) A =>
                             cic.prod cic.prop (cic.type cic.z) (_P x)
                               (__ : cic.Term cic.prop (_P x) =>
                                return_type
                                  (matita_basics_logic.ex_intro A _P x __)))) =>
                     cic.prod cic.prop (cic.type cic.z)
                       (matita_basics_logic.ex A _P)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.ex A _P) =>
                        return_type z)))))).

[ A, _P, return_type, case_ex_intro, x, __ ]
  match_ex_Type0 A _P return_type case_ex_intro
    (matita_basics_logic.ex_intro A _P x __) -->
  case_ex_intro x __.

def filter_ex_Prop :
      cic.Term cic.prop
        (cic.prod (cic.type (cic.s cic.z)) cic.prop
           (cic.univ (cic.type cic.z))
           (A : cic.Univ (cic.type cic.z) =>
            cic.prod (cic.type cic.z) cic.prop
              (cic.prod (cic.type cic.z) (cic.type cic.z) A
                 (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop))
              (_P :
                 cic.Term (cic.type cic.z)
                   (cic.prod (cic.type cic.z) (cic.type cic.z) A
                      (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop)) =>
               cic.prod (cic.type cic.z) cic.prop
                 (cic.prod cic.prop (cic.type cic.z)
                    (matita_basics_logic.ex A _P)
                    (z : cic.Term cic.prop (matita_basics_logic.ex A _P) =>
                     cic.univ cic.prop))
                 (return_type :
                    cic.Term (cic.type cic.z)
                      (cic.prod cic.prop (cic.type cic.z)
                         (matita_basics_logic.ex A _P)
                         (z :
                            cic.Term cic.prop (matita_basics_logic.ex A _P) =>
                          cic.univ cic.prop)) =>
                  cic.prod cic.prop cic.prop
                    (cic.prod cic.prop cic.prop (matita_basics_logic.ex A _P)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.ex A _P) =>
                        return_type z))
                    (return :
                       cic.Term cic.prop
                         (cic.prod cic.prop cic.prop
                            (matita_basics_logic.ex A _P)
                            (z :
                               cic.Term cic.prop
                                 (matita_basics_logic.ex A _P) =>
                             return_type z)) =>
                     cic.prod cic.prop cic.prop (matita_basics_logic.ex A _P)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.ex A _P) =>
                        return_type z)))))).

[ A, P, x, __, return_type, return ]
  filter_ex_Prop (A) (P) return_type return
    (matita_basics_logic.ex_intro A P x __) -->
  return (matita_basics_logic.ex_intro A P x __).

def filter_ex_Type5 :
      cic.Term
        (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
        (cic.prod (cic.type (cic.s cic.z))
           (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
           (cic.univ (cic.type cic.z))
           (A : cic.Univ (cic.type cic.z) =>
            cic.prod (cic.type cic.z)
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
              (cic.prod (cic.type cic.z) (cic.type cic.z) A
                 (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop))
              (_P :
                 cic.Term (cic.type cic.z)
                   (cic.prod (cic.type cic.z) (cic.type cic.z) A
                      (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop)) =>
               cic.prod
                 (cic.type
                    (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                 (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                 (cic.prod cic.prop
                    (cic.type
                       (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                    (matita_basics_logic.ex A _P)
                    (z : cic.Term cic.prop (matita_basics_logic.ex A _P) =>
                     cic.univ
                       (cic.type
                          (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))))
                 (return_type :
                    cic.Term
                      (cic.type
                         (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                      (cic.prod cic.prop
                         (cic.type
                            (cic.s
                               (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                         (matita_basics_logic.ex A _P)
                         (z :
                            cic.Term cic.prop (matita_basics_logic.ex A _P) =>
                          cic.univ
                            (cic.type
                               (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))) =>
                  cic.prod
                    (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                    (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                    (cic.prod cic.prop
                       (cic.type
                          (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                       (matita_basics_logic.ex A _P)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.ex A _P) =>
                        return_type z))
                    (return :
                       cic.Term
                         (cic.type
                            (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                         (cic.prod cic.prop
                            (cic.type
                               (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                            (matita_basics_logic.ex A _P)
                            (z :
                               cic.Term cic.prop
                                 (matita_basics_logic.ex A _P) =>
                             return_type z)) =>
                     cic.prod cic.prop
                       (cic.type
                          (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                       (matita_basics_logic.ex A _P)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.ex A _P) =>
                        return_type z)))))).

[ A, P, x, __, return_type, return ]
  filter_ex_Type5 (A) (P) return_type return
    (matita_basics_logic.ex_intro A P x __) -->
  return (matita_basics_logic.ex_intro A P x __).

def filter_ex_Type4 :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
        (cic.prod (cic.type (cic.s cic.z))
           (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
           (cic.univ (cic.type cic.z))
           (A : cic.Univ (cic.type cic.z) =>
            cic.prod (cic.type cic.z)
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
              (cic.prod (cic.type cic.z) (cic.type cic.z) A
                 (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop))
              (_P :
                 cic.Term (cic.type cic.z)
                   (cic.prod (cic.type cic.z) (cic.type cic.z) A
                      (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop)) =>
               cic.prod
                 (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                 (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                 (cic.prod cic.prop
                    (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                    (matita_basics_logic.ex A _P)
                    (z : cic.Term cic.prop (matita_basics_logic.ex A _P) =>
                     cic.univ
                       (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                 (return_type :
                    cic.Term
                      (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                      (cic.prod cic.prop
                         (cic.type
                            (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                         (matita_basics_logic.ex A _P)
                         (z :
                            cic.Term cic.prop (matita_basics_logic.ex A _P) =>
                          cic.univ
                            (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))))) =>
                  cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                    (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                    (cic.prod cic.prop
                       (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                       (matita_basics_logic.ex A _P)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.ex A _P) =>
                        return_type z))
                    (return :
                       cic.Term
                         (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                         (cic.prod cic.prop
                            (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                            (matita_basics_logic.ex A _P)
                            (z :
                               cic.Term cic.prop
                                 (matita_basics_logic.ex A _P) =>
                             return_type z)) =>
                     cic.prod cic.prop
                       (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                       (matita_basics_logic.ex A _P)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.ex A _P) =>
                        return_type z)))))).

[ A, P, x, __, return_type, return ]
  filter_ex_Type4 (A) (P) return_type return
    (matita_basics_logic.ex_intro A P x __) -->
  return (matita_basics_logic.ex_intro A P x __).

def filter_ex_Type3 :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
        (cic.prod (cic.type (cic.s cic.z))
           (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
           (cic.univ (cic.type cic.z))
           (A : cic.Univ (cic.type cic.z) =>
            cic.prod (cic.type cic.z)
              (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
              (cic.prod (cic.type cic.z) (cic.type cic.z) A
                 (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop))
              (_P :
                 cic.Term (cic.type cic.z)
                   (cic.prod (cic.type cic.z) (cic.type cic.z) A
                      (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop)) =>
               cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                 (cic.type (cic.s (cic.s (cic.s cic.z))))
                 (cic.prod cic.prop
                    (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                    (matita_basics_logic.ex A _P)
                    (z : cic.Term cic.prop (matita_basics_logic.ex A _P) =>
                     cic.univ (cic.type (cic.s (cic.s (cic.s cic.z))))))
                 (return_type :
                    cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                      (cic.prod cic.prop
                         (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                         (matita_basics_logic.ex A _P)
                         (z :
                            cic.Term cic.prop (matita_basics_logic.ex A _P) =>
                          cic.univ (cic.type (cic.s (cic.s (cic.s cic.z)))))) =>
                  cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
                    (cic.type (cic.s (cic.s (cic.s cic.z))))
                    (cic.prod cic.prop
                       (cic.type (cic.s (cic.s (cic.s cic.z))))
                       (matita_basics_logic.ex A _P)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.ex A _P) =>
                        return_type z))
                    (return :
                       cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                         (cic.prod cic.prop
                            (cic.type (cic.s (cic.s (cic.s cic.z))))
                            (matita_basics_logic.ex A _P)
                            (z :
                               cic.Term cic.prop
                                 (matita_basics_logic.ex A _P) =>
                             return_type z)) =>
                     cic.prod cic.prop
                       (cic.type (cic.s (cic.s (cic.s cic.z))))
                       (matita_basics_logic.ex A _P)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.ex A _P) =>
                        return_type z)))))).

[ A, P, x, __, return_type, return ]
  filter_ex_Type3 (A) (P) return_type return
    (matita_basics_logic.ex_intro A P x __) -->
  return (matita_basics_logic.ex_intro A P x __).

def filter_ex_Type2 :
      cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
        (cic.prod (cic.type (cic.s cic.z))
           (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.univ (cic.type cic.z))
           (A : cic.Univ (cic.type cic.z) =>
            cic.prod (cic.type cic.z)
              (cic.type (cic.s (cic.s (cic.s cic.z))))
              (cic.prod (cic.type cic.z) (cic.type cic.z) A
                 (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop))
              (_P :
                 cic.Term (cic.type cic.z)
                   (cic.prod (cic.type cic.z) (cic.type cic.z) A
                      (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop)) =>
               cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
                 (cic.type (cic.s (cic.s cic.z)))
                 (cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s cic.z))))
                    (matita_basics_logic.ex A _P)
                    (z : cic.Term cic.prop (matita_basics_logic.ex A _P) =>
                     cic.univ (cic.type (cic.s (cic.s cic.z)))))
                 (return_type :
                    cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                      (cic.prod cic.prop
                         (cic.type (cic.s (cic.s (cic.s cic.z))))
                         (matita_basics_logic.ex A _P)
                         (z :
                            cic.Term cic.prop (matita_basics_logic.ex A _P) =>
                          cic.univ (cic.type (cic.s (cic.s cic.z))))) =>
                  cic.prod (cic.type (cic.s (cic.s cic.z)))
                    (cic.type (cic.s (cic.s cic.z)))
                    (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                       (matita_basics_logic.ex A _P)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.ex A _P) =>
                        return_type z))
                    (return :
                       cic.Term (cic.type (cic.s (cic.s cic.z)))
                         (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                            (matita_basics_logic.ex A _P)
                            (z :
                               cic.Term cic.prop
                                 (matita_basics_logic.ex A _P) =>
                             return_type z)) =>
                     cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                       (matita_basics_logic.ex A _P)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.ex A _P) =>
                        return_type z)))))).

[ A, P, x, __, return_type, return ]
  filter_ex_Type2 (A) (P) return_type return
    (matita_basics_logic.ex_intro A P x __) -->
  return (matita_basics_logic.ex_intro A P x __).

def filter_ex_Type1 :
      cic.Term (cic.type (cic.s (cic.s cic.z)))
        (cic.prod (cic.type (cic.s cic.z)) (cic.type (cic.s (cic.s cic.z)))
           (cic.univ (cic.type cic.z))
           (A : cic.Univ (cic.type cic.z) =>
            cic.prod (cic.type cic.z) (cic.type (cic.s (cic.s cic.z)))
              (cic.prod (cic.type cic.z) (cic.type cic.z) A
                 (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop))
              (_P :
                 cic.Term (cic.type cic.z)
                   (cic.prod (cic.type cic.z) (cic.type cic.z) A
                      (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop)) =>
               cic.prod (cic.type (cic.s (cic.s cic.z)))
                 (cic.type (cic.s cic.z))
                 (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.ex A _P)
                    (z : cic.Term cic.prop (matita_basics_logic.ex A _P) =>
                     cic.univ (cic.type (cic.s cic.z))))
                 (return_type :
                    cic.Term (cic.type (cic.s (cic.s cic.z)))
                      (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.ex A _P)
                         (z :
                            cic.Term cic.prop (matita_basics_logic.ex A _P) =>
                          cic.univ (cic.type (cic.s cic.z)))) =>
                  cic.prod (cic.type (cic.s cic.z)) (cic.type (cic.s cic.z))
                    (cic.prod cic.prop (cic.type (cic.s cic.z))
                       (matita_basics_logic.ex A _P)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.ex A _P) =>
                        return_type z))
                    (return :
                       cic.Term (cic.type (cic.s cic.z))
                         (cic.prod cic.prop (cic.type (cic.s cic.z))
                            (matita_basics_logic.ex A _P)
                            (z :
                               cic.Term cic.prop
                                 (matita_basics_logic.ex A _P) =>
                             return_type z)) =>
                     cic.prod cic.prop (cic.type (cic.s cic.z))
                       (matita_basics_logic.ex A _P)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.ex A _P) =>
                        return_type z)))))).

[ A, P, x, __, return_type, return ]
  filter_ex_Type1 (A) (P) return_type return
    (matita_basics_logic.ex_intro A P x __) -->
  return (matita_basics_logic.ex_intro A P x __).

def filter_ex_Type0 :
      cic.Term (cic.type (cic.s cic.z))
        (cic.prod (cic.type (cic.s cic.z)) (cic.type (cic.s cic.z))
           (cic.univ (cic.type cic.z))
           (A : cic.Univ (cic.type cic.z) =>
            cic.prod (cic.type cic.z) (cic.type (cic.s cic.z))
              (cic.prod (cic.type cic.z) (cic.type cic.z) A
                 (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop))
              (_P :
                 cic.Term (cic.type cic.z)
                   (cic.prod (cic.type cic.z) (cic.type cic.z) A
                      (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop)) =>
               cic.prod (cic.type (cic.s cic.z)) (cic.type cic.z)
                 (cic.prod cic.prop (cic.type (cic.s cic.z))
                    (matita_basics_logic.ex A _P)
                    (z : cic.Term cic.prop (matita_basics_logic.ex A _P) =>
                     cic.univ (cic.type cic.z)))
                 (return_type :
                    cic.Term (cic.type (cic.s cic.z))
                      (cic.prod cic.prop (cic.type (cic.s cic.z))
                         (matita_basics_logic.ex A _P)
                         (z :
                            cic.Term cic.prop (matita_basics_logic.ex A _P) =>
                          cic.univ (cic.type cic.z))) =>
                  cic.prod (cic.type cic.z) (cic.type cic.z)
                    (cic.prod cic.prop (cic.type cic.z)
                       (matita_basics_logic.ex A _P)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.ex A _P) =>
                        return_type z))
                    (return :
                       cic.Term (cic.type cic.z)
                         (cic.prod cic.prop (cic.type cic.z)
                            (matita_basics_logic.ex A _P)
                            (z :
                               cic.Term cic.prop
                                 (matita_basics_logic.ex A _P) =>
                             return_type z)) =>
                     cic.prod cic.prop (cic.type cic.z)
                       (matita_basics_logic.ex A _P)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.ex A _P) =>
                        return_type z)))))).

[ A, P, x, __, return_type, return ]
  filter_ex_Type0 (A) (P) return_type return
    (matita_basics_logic.ex_intro A P x __) -->
  return (matita_basics_logic.ex_intro A P x __).

def ex_ind :
      cic.Term cic.prop
        (cic.prod (cic.type (cic.s cic.z)) cic.prop
           (cic.univ (cic.type cic.z))
           (A : cic.Univ (cic.type cic.z) =>
            cic.prod (cic.type cic.z) cic.prop
              (cic.prod (cic.type cic.z) (cic.type cic.z) A
                 (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop))
              (_P :
                 cic.Term (cic.type cic.z)
                   (cic.prod (cic.type cic.z) (cic.type cic.z) A
                      (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop)) =>
               cic.prod (cic.type cic.z) cic.prop
                 (cic.prod cic.prop (cic.type cic.z)
                    (matita_basics_logic.ex
                       (cic.lift (cic.type cic.z) (cic.type cic.z) A) _P)
                    (_x_235 :
                       cic.Term cic.prop
                         (matita_basics_logic.ex
                            (cic.lift (cic.type cic.z) (cic.type cic.z) A) _P) =>
                     cic.univ cic.prop))
                 (Q_ :
                    cic.Term (cic.type cic.z)
                      (cic.prod cic.prop (cic.type cic.z)
                         (matita_basics_logic.ex
                            (cic.lift (cic.type cic.z) (cic.type cic.z) A) _P)
                         (_x_235 :
                            cic.Term cic.prop
                              (matita_basics_logic.ex
                                 (cic.lift (cic.type cic.z) (cic.type cic.z)
                                    A)
                                 _P) =>
                          cic.univ cic.prop)) =>
                  cic.prod cic.prop cic.prop
                    (cic.prod (cic.type cic.z) cic.prop A
                       (x : cic.Term (cic.type cic.z) A =>
                        cic.prod cic.prop cic.prop (_P x)
                          (x_236 : cic.Term cic.prop (_P x) =>
                           Q_
                             (matita_basics_logic.ex_intro
                                (cic.lift (cic.type cic.z) (cic.type cic.z) A)
                                _P x x_236))))
                    (_H_ex_intro :
                       cic.Term cic.prop
                         (cic.prod (cic.type cic.z) cic.prop A
                            (x : cic.Term (cic.type cic.z) A =>
                             cic.prod cic.prop cic.prop (_P x)
                               (x_236 : cic.Term cic.prop (_P x) =>
                                Q_
                                  (matita_basics_logic.ex_intro
                                     (cic.lift (cic.type cic.z)
                                        (cic.type cic.z) A)
                                     _P x x_236)))) =>
                     cic.prod cic.prop cic.prop
                       (matita_basics_logic.ex
                          (cic.lift (cic.type cic.z) (cic.type cic.z) A) _P)
                       (x_235 :
                          cic.Term cic.prop
                            (matita_basics_logic.ex
                               (cic.lift (cic.type cic.z) (cic.type cic.z) A)
                               _P) =>
                        Q_ x_235)))))).

def ex_ind_body :
      cic.Term cic.prop
        (cic.prod (cic.type (cic.s cic.z)) cic.prop
           (cic.univ (cic.type cic.z))
           (A : cic.Univ (cic.type cic.z) =>
            cic.prod (cic.type cic.z) cic.prop
              (cic.prod (cic.type cic.z) (cic.type cic.z) A
                 (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop))
              (_P :
                 cic.Term (cic.type cic.z)
                   (cic.prod (cic.type cic.z) (cic.type cic.z) A
                      (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop)) =>
               cic.prod (cic.type cic.z) cic.prop
                 (cic.prod cic.prop (cic.type cic.z)
                    (matita_basics_logic.ex
                       (cic.lift (cic.type cic.z) (cic.type cic.z) A) _P)
                    (_x_235 :
                       cic.Term cic.prop
                         (matita_basics_logic.ex
                            (cic.lift (cic.type cic.z) (cic.type cic.z) A) _P) =>
                     cic.univ cic.prop))
                 (Q_ :
                    cic.Term (cic.type cic.z)
                      (cic.prod cic.prop (cic.type cic.z)
                         (matita_basics_logic.ex
                            (cic.lift (cic.type cic.z) (cic.type cic.z) A) _P)
                         (_x_235 :
                            cic.Term cic.prop
                              (matita_basics_logic.ex
                                 (cic.lift (cic.type cic.z) (cic.type cic.z)
                                    A)
                                 _P) =>
                          cic.univ cic.prop)) =>
                  cic.prod cic.prop cic.prop
                    (cic.prod (cic.type cic.z) cic.prop A
                       (x : cic.Term (cic.type cic.z) A =>
                        cic.prod cic.prop cic.prop (_P x)
                          (x_236 : cic.Term cic.prop (_P x) =>
                           Q_
                             (matita_basics_logic.ex_intro
                                (cic.lift (cic.type cic.z) (cic.type cic.z) A)
                                _P x x_236))))
                    (_H_ex_intro :
                       cic.Term cic.prop
                         (cic.prod (cic.type cic.z) cic.prop A
                            (x : cic.Term (cic.type cic.z) A =>
                             cic.prod cic.prop cic.prop (_P x)
                               (x_236 : cic.Term cic.prop (_P x) =>
                                Q_
                                  (matita_basics_logic.ex_intro
                                     (cic.lift (cic.type cic.z)
                                        (cic.type cic.z) A)
                                     _P x x_236)))) =>
                     cic.prod cic.prop cic.prop
                       (matita_basics_logic.ex
                          (cic.lift (cic.type cic.z) (cic.type cic.z) A) _P)
                       (x_235 :
                          cic.Term cic.prop
                            (matita_basics_logic.ex
                               (cic.lift (cic.type cic.z) (cic.type cic.z) A)
                               _P) =>
                        Q_ x_235)))))).

[ A, _P, Q_, _H_ex_intro, x_235 ] ex_ind A _P Q_ _H_ex_intro x_235 -->
  matita_basics_logic.filter_ex_Prop A _P
    (x_235 :
       cic.Term cic.prop
         (matita_basics_logic.ex
            (cic.lift (cic.type cic.z) (cic.type cic.z) A) _P) =>
     Q_ x_235)
    (matita_basics_logic.ex_ind_body A _P Q_ _H_ex_intro) x_235.

[ A, _P, Q_, _H_ex_intro, x_235 ] ex_ind_body A _P Q_ _H_ex_intro x_235 -->
  matita_basics_logic.match_ex_Prop
    (cic.lift (cic.type cic.z) (cic.type cic.z) A) _P Q_
    (x : cic.Term (cic.type cic.z) A =>
     x_236 : cic.Term cic.prop (_P x) => _H_ex_intro x x_236)
    x_235.

def ex_inv_ind :
      cic.Term cic.prop
        (cic.prod (cic.type (cic.s cic.z)) cic.prop
           (cic.univ (cic.type cic.z))
           (x1 : cic.Univ (cic.type cic.z) =>
            cic.prod (cic.type cic.z) cic.prop
              (cic.prod (cic.type cic.z) (cic.type cic.z) x1
                 (__ : cic.Term (cic.type cic.z) x1 => cic.univ cic.prop))
              (x2 :
                 cic.Term (cic.type cic.z)
                   (cic.prod (cic.type cic.z) (cic.type cic.z) x1
                      (__ : cic.Term (cic.type cic.z) x1 => cic.univ cic.prop)) =>
               cic.prod cic.prop cic.prop
                 (matita_basics_logic.ex
                    (cic.lift (cic.type cic.z) (cic.type cic.z) x1) x2)
                 (Hterm :
                    cic.Term cic.prop
                      (matita_basics_logic.ex
                         (cic.lift (cic.type cic.z) (cic.type cic.z) x1) x2) =>
                  cic.prod (cic.type cic.z) cic.prop
                    (cic.prod cic.prop (cic.type cic.z)
                       (matita_basics_logic.ex
                          (cic.lift (cic.type cic.z) (cic.type cic.z) x1) x2)
                       (_z455 :
                          cic.Term cic.prop
                            (matita_basics_logic.ex
                               (cic.lift (cic.type cic.z) (cic.type cic.z) x1)
                               x2) =>
                        cic.univ cic.prop))
                    (P :
                       cic.Term (cic.type cic.z)
                         (cic.prod cic.prop (cic.type cic.z)
                            (matita_basics_logic.ex
                               (cic.lift (cic.type cic.z) (cic.type cic.z) x1)
                               x2)
                            (_z455 :
                               cic.Term cic.prop
                                 (matita_basics_logic.ex
                                    (cic.lift (cic.type cic.z)
                                       (cic.type cic.z) x1)
                                    x2) =>
                             cic.univ cic.prop)) =>
                     cic.prod cic.prop cic.prop
                       (cic.prod (cic.type cic.z) cic.prop x1
                          (x : cic.Term (cic.type cic.z) x1 =>
                           cic.prod cic.prop cic.prop (x2 x)
                             (x_236 : cic.Term cic.prop (x2 x) =>
                              cic.prod cic.prop cic.prop
                                (matita_basics_logic.eq
                                   (cic.lift cic.prop
                                      (cic.type (cic.s (cic.s cic.z)))
                                      (matita_basics_logic.ex
                                         (cic.lift (cic.type cic.z)
                                            (cic.type cic.z) x1)
                                         x2))
                                   Hterm
                                   (matita_basics_logic.ex_intro
                                      (cic.lift (cic.type cic.z)
                                         (cic.type cic.z) x1)
                                      x2 x x_236))
                                (_z456 :
                                   cic.Term cic.prop
                                     (matita_basics_logic.eq
                                        (cic.lift cic.prop
                                           (cic.type (cic.s (cic.s cic.z)))
                                           (matita_basics_logic.ex
                                              (cic.lift (cic.type cic.z)
                                                 (cic.type cic.z) x1)
                                              x2))
                                        Hterm
                                        (matita_basics_logic.ex_intro
                                           (cic.lift (cic.type cic.z)
                                              (cic.type cic.z) x1)
                                           x2 x x_236)) =>
                                 P
                                   (matita_basics_logic.ex_intro
                                      (cic.lift (cic.type cic.z)
                                         (cic.type cic.z) x1)
                                      x2 x x_236)))))
                       (_H1 :
                          cic.Term cic.prop
                            (cic.prod (cic.type cic.z) cic.prop x1
                               (x : cic.Term (cic.type cic.z) x1 =>
                                cic.prod cic.prop cic.prop (x2 x)
                                  (x_236 : cic.Term cic.prop (x2 x) =>
                                   cic.prod cic.prop cic.prop
                                     (matita_basics_logic.eq
                                        (cic.lift cic.prop
                                           (cic.type (cic.s (cic.s cic.z)))
                                           (matita_basics_logic.ex
                                              (cic.lift (cic.type cic.z)
                                                 (cic.type cic.z) x1)
                                              x2))
                                        Hterm
                                        (matita_basics_logic.ex_intro
                                           (cic.lift (cic.type cic.z)
                                              (cic.type cic.z) x1)
                                           x2 x x_236))
                                     (_z456 :
                                        cic.Term cic.prop
                                          (matita_basics_logic.eq
                                             (cic.lift cic.prop
                                                (cic.type
                                                   (cic.s (cic.s cic.z)))
                                                (matita_basics_logic.ex
                                                   (cic.lift (cic.type cic.z)
                                                      (cic.type cic.z) x1)
                                                   x2))
                                             Hterm
                                             (matita_basics_logic.ex_intro
                                                (cic.lift (cic.type cic.z)
                                                   (cic.type cic.z) x1)
                                                x2 x x_236)) =>
                                      P
                                        (matita_basics_logic.ex_intro
                                           (cic.lift (cic.type cic.z)
                                              (cic.type cic.z) x1)
                                           x2 x x_236))))) =>
                        P Hterm))))))
      :=
      x1 : cic.Univ (cic.type cic.z) =>
      x2 :
        cic.Term (cic.type cic.z)
          (cic.prod (cic.type cic.z) (cic.type cic.z) x1
             (__ : cic.Term (cic.type cic.z) x1 => cic.univ cic.prop)) =>
      Hterm :
        cic.Term cic.prop
          (matita_basics_logic.ex
             (cic.lift (cic.type cic.z) (cic.type cic.z) x1) x2) =>
      P :
        cic.Term (cic.type cic.z)
          (cic.prod cic.prop (cic.type cic.z)
             (matita_basics_logic.ex
                (cic.lift (cic.type cic.z) (cic.type cic.z) x1) x2)
             (_z455 :
                cic.Term cic.prop
                  (matita_basics_logic.ex
                     (cic.lift (cic.type cic.z) (cic.type cic.z) x1) x2) =>
              cic.univ cic.prop)) =>
      H1 :
        cic.Term cic.prop
          (cic.prod (cic.type cic.z) cic.prop x1
             (x : cic.Term (cic.type cic.z) x1 =>
              cic.prod cic.prop cic.prop (x2 x)
                (x_236 : cic.Term cic.prop (x2 x) =>
                 cic.prod cic.prop cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.ex
                            (cic.lift (cic.type cic.z) (cic.type cic.z) x1)
                            x2))
                      Hterm
                      (matita_basics_logic.ex_intro
                         (cic.lift (cic.type cic.z) (cic.type cic.z) x1) x2 x
                         x_236))
                   (_z456 :
                      cic.Term cic.prop
                        (matita_basics_logic.eq
                           (cic.lift cic.prop
                              (cic.type (cic.s (cic.s cic.z)))
                              (matita_basics_logic.ex
                                 (cic.lift (cic.type cic.z) (cic.type cic.z)
                                    x1)
                                 x2))
                           Hterm
                           (matita_basics_logic.ex_intro
                              (cic.lift (cic.type cic.z) (cic.type cic.z) x1)
                              x2 x x_236)) =>
                    P
                      (matita_basics_logic.ex_intro
                         (cic.lift (cic.type cic.z) (cic.type cic.z) x1) x2 x
                         x_236))))) =>
      (Hcut :
         cic.Term cic.prop
           (cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.ex
                       (cic.lift (cic.type cic.z) (cic.type cic.z) x1) x2))
                 Hterm Hterm)
              (_z456 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.ex
                            (cic.lift (cic.type cic.z) (cic.type cic.z) x1)
                            x2))
                      Hterm Hterm) =>
               P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
               (matita_basics_logic.ex
                  (cic.lift (cic.type cic.z) (cic.type cic.z) x1) x2))
            Hterm))
        (matita_basics_logic.ex_ind
           (cic.lift (cic.type cic.z) (cic.type cic.z) x1) x2
           (_x_235 :
              cic.Term cic.prop
                (matita_basics_logic.ex
                   (cic.lift (cic.type cic.z) (cic.type cic.z) x1) x2) =>
            cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.ex
                       (cic.lift (cic.type cic.z) (cic.type cic.z) x1) x2))
                 Hterm _x_235)
              (_z456 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.ex
                            (cic.lift (cic.type cic.z) (cic.type cic.z) x1)
                            x2))
                      Hterm _x_235) =>
               P _x_235))
           H1 Hterm).

ex2 :
  cic.Term (cic.type (cic.s cic.z))
    (cic.prod (cic.type (cic.s cic.z)) (cic.type cic.z)
       (cic.univ (cic.type cic.z))
       (A : cic.Univ (cic.type cic.z) =>
        cic.prod (cic.type cic.z) (cic.type cic.z)
          (cic.prod (cic.type cic.z) (cic.type cic.z) A
             (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop))
          (_P :
             cic.Term (cic.type cic.z)
               (cic.prod (cic.type cic.z) (cic.type cic.z) A
                  (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop)) =>
           cic.prod (cic.type cic.z) (cic.type cic.z)
             (cic.prod (cic.type cic.z) (cic.type cic.z) A
                (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop))
             (_Q :
                cic.Term (cic.type cic.z)
                  (cic.prod (cic.type cic.z) (cic.type cic.z) A
                     (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop)) =>
              cic.univ cic.prop)))).

ex2_intro :
  cic.Term cic.prop
    (cic.prod (cic.type (cic.s cic.z)) cic.prop (cic.univ (cic.type cic.z))
       (A : cic.Univ (cic.type cic.z) =>
        cic.prod (cic.type cic.z) cic.prop
          (cic.prod (cic.type cic.z) (cic.type cic.z) A
             (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop))
          (P :
             cic.Term (cic.type cic.z)
               (cic.prod (cic.type cic.z) (cic.type cic.z) A
                  (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop)) =>
           cic.prod (cic.type cic.z) cic.prop
             (cic.prod (cic.type cic.z) (cic.type cic.z) A
                (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop))
             (Q :
                cic.Term (cic.type cic.z)
                  (cic.prod (cic.type cic.z) (cic.type cic.z) A
                     (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop)) =>
              cic.prod (cic.type cic.z) cic.prop A
                (x : cic.Term (cic.type cic.z) A =>
                 cic.prod cic.prop cic.prop (P x)
                   (__ : cic.Term cic.prop (P x) =>
                    cic.prod cic.prop cic.prop (Q x)
                      (__1 : cic.Term cic.prop (Q x) =>
                       matita_basics_logic.ex2
                         (cic.lift (cic.type cic.z) (cic.type cic.z) A) P Q))))))).

def match_ex2_Prop :
      cic.Term cic.prop
        (cic.prod (cic.type (cic.s cic.z)) cic.prop
           (cic.univ (cic.type cic.z))
           (A : cic.Univ (cic.type cic.z) =>
            cic.prod (cic.type cic.z) cic.prop
              (cic.prod (cic.type cic.z) (cic.type cic.z) A
                 (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop))
              (_P :
                 cic.Term (cic.type cic.z)
                   (cic.prod (cic.type cic.z) (cic.type cic.z) A
                      (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop)) =>
               cic.prod (cic.type cic.z) cic.prop
                 (cic.prod (cic.type cic.z) (cic.type cic.z) A
                    (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop))
                 (_Q :
                    cic.Term (cic.type cic.z)
                      (cic.prod (cic.type cic.z) (cic.type cic.z) A
                         (__ : cic.Term (cic.type cic.z) A =>
                          cic.univ cic.prop)) =>
                  cic.prod (cic.type cic.z) cic.prop
                    (cic.prod cic.prop (cic.type cic.z)
                       (matita_basics_logic.ex2 A _P _Q)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q) =>
                        cic.univ cic.prop))
                    (return_type :
                       cic.Term (cic.type cic.z)
                         (cic.prod cic.prop (cic.type cic.z)
                            (matita_basics_logic.ex2 A _P _Q)
                            (z :
                               cic.Term cic.prop
                                 (matita_basics_logic.ex2 A _P _Q) =>
                             cic.univ cic.prop)) =>
                     cic.prod cic.prop cic.prop
                       (cic.prod (cic.type cic.z) cic.prop A
                          (x : cic.Term (cic.type cic.z) A =>
                           cic.prod cic.prop cic.prop (_P x)
                             (__ : cic.Term cic.prop (_P x) =>
                              cic.prod cic.prop cic.prop (_Q x)
                                (__1 : cic.Term cic.prop (_Q x) =>
                                 return_type
                                   (matita_basics_logic.ex2_intro A _P _Q x
                                      __ __1)))))
                       (case_ex2_intro :
                          cic.Term cic.prop
                            (cic.prod (cic.type cic.z) cic.prop A
                               (x : cic.Term (cic.type cic.z) A =>
                                cic.prod cic.prop cic.prop (_P x)
                                  (__ : cic.Term cic.prop (_P x) =>
                                   cic.prod cic.prop cic.prop (_Q x)
                                     (__1 : cic.Term cic.prop (_Q x) =>
                                      return_type
                                        (matita_basics_logic.ex2_intro A _P
                                           _Q x __ __1))))) =>
                        cic.prod cic.prop cic.prop
                          (matita_basics_logic.ex2 A _P _Q)
                          (z :
                             cic.Term cic.prop
                               (matita_basics_logic.ex2 A _P _Q) =>
                           return_type z))))))).

[ A, _P, _Q, return_type, case_ex2_intro, x, __, __1 ]
  match_ex2_Prop A _P _Q return_type case_ex2_intro
    (matita_basics_logic.ex2_intro A _P _Q x __ __1) -->
  case_ex2_intro x __ __1.

def match_ex2_Type5 :
      cic.Term
        (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
        (cic.prod (cic.type (cic.s cic.z))
           (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
           (cic.univ (cic.type cic.z))
           (A : cic.Univ (cic.type cic.z) =>
            cic.prod (cic.type cic.z)
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
              (cic.prod (cic.type cic.z) (cic.type cic.z) A
                 (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop))
              (_P :
                 cic.Term (cic.type cic.z)
                   (cic.prod (cic.type cic.z) (cic.type cic.z) A
                      (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop)) =>
               cic.prod (cic.type cic.z)
                 (cic.type
                    (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                 (cic.prod (cic.type cic.z) (cic.type cic.z) A
                    (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop))
                 (_Q :
                    cic.Term (cic.type cic.z)
                      (cic.prod (cic.type cic.z) (cic.type cic.z) A
                         (__ : cic.Term (cic.type cic.z) A =>
                          cic.univ cic.prop)) =>
                  cic.prod
                    (cic.type
                       (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                    (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                    (cic.prod cic.prop
                       (cic.type
                          (cic.s
                             (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                       (matita_basics_logic.ex2 A _P _Q)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q) =>
                        cic.univ
                          (cic.type
                             (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))))
                    (return_type :
                       cic.Term
                         (cic.type
                            (cic.s
                               (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                         (cic.prod cic.prop
                            (cic.type
                               (cic.s
                                  (cic.s
                                     (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                            (matita_basics_logic.ex2 A _P _Q)
                            (z :
                               cic.Term cic.prop
                                 (matita_basics_logic.ex2 A _P _Q) =>
                             cic.univ
                               (cic.type
                                  (cic.s
                                     (cic.s (cic.s (cic.s (cic.s cic.z)))))))) =>
                     cic.prod
                       (cic.type
                          (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                       (cic.type
                          (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                       (cic.prod (cic.type cic.z)
                          (cic.type
                             (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                          A
                          (x : cic.Term (cic.type cic.z) A =>
                           cic.prod cic.prop
                             (cic.type
                                (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                             (_P x)
                             (__ : cic.Term cic.prop (_P x) =>
                              cic.prod cic.prop
                                (cic.type
                                   (cic.s
                                      (cic.s (cic.s (cic.s (cic.s cic.z))))))
                                (_Q x)
                                (__1 : cic.Term cic.prop (_Q x) =>
                                 return_type
                                   (matita_basics_logic.ex2_intro A _P _Q x
                                      __ __1)))))
                       (case_ex2_intro :
                          cic.Term
                            (cic.type
                               (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                            (cic.prod (cic.type cic.z)
                               (cic.type
                                  (cic.s
                                     (cic.s (cic.s (cic.s (cic.s cic.z))))))
                               A
                               (x : cic.Term (cic.type cic.z) A =>
                                cic.prod cic.prop
                                  (cic.type
                                     (cic.s
                                        (cic.s (cic.s (cic.s (cic.s cic.z))))))
                                  (_P x)
                                  (__ : cic.Term cic.prop (_P x) =>
                                   cic.prod cic.prop
                                     (cic.type
                                        (cic.s
                                           (cic.s
                                              (cic.s (cic.s (cic.s cic.z))))))
                                     (_Q x)
                                     (__1 : cic.Term cic.prop (_Q x) =>
                                      return_type
                                        (matita_basics_logic.ex2_intro A _P
                                           _Q x __ __1))))) =>
                        cic.prod cic.prop
                          (cic.type
                             (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                          (matita_basics_logic.ex2 A _P _Q)
                          (z :
                             cic.Term cic.prop
                               (matita_basics_logic.ex2 A _P _Q) =>
                           return_type z))))))).

[ A, _P, _Q, return_type, case_ex2_intro, x, __, __1 ]
  match_ex2_Type5 A _P _Q return_type case_ex2_intro
    (matita_basics_logic.ex2_intro A _P _Q x __ __1) -->
  case_ex2_intro x __ __1.

def match_ex2_Type4 :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
        (cic.prod (cic.type (cic.s cic.z))
           (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
           (cic.univ (cic.type cic.z))
           (A : cic.Univ (cic.type cic.z) =>
            cic.prod (cic.type cic.z)
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
              (cic.prod (cic.type cic.z) (cic.type cic.z) A
                 (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop))
              (_P :
                 cic.Term (cic.type cic.z)
                   (cic.prod (cic.type cic.z) (cic.type cic.z) A
                      (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop)) =>
               cic.prod (cic.type cic.z)
                 (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                 (cic.prod (cic.type cic.z) (cic.type cic.z) A
                    (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop))
                 (_Q :
                    cic.Term (cic.type cic.z)
                      (cic.prod (cic.type cic.z) (cic.type cic.z) A
                         (__ : cic.Term (cic.type cic.z) A =>
                          cic.univ cic.prop)) =>
                  cic.prod
                    (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                    (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                    (cic.prod cic.prop
                       (cic.type
                          (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                       (matita_basics_logic.ex2 A _P _Q)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q) =>
                        cic.univ
                          (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                    (return_type :
                       cic.Term
                         (cic.type
                            (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                         (cic.prod cic.prop
                            (cic.type
                               (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                            (matita_basics_logic.ex2 A _P _Q)
                            (z :
                               cic.Term cic.prop
                                 (matita_basics_logic.ex2 A _P _Q) =>
                             cic.univ
                               (cic.type
                                  (cic.s (cic.s (cic.s (cic.s cic.z))))))) =>
                     cic.prod
                       (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                       (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                       (cic.prod (cic.type cic.z)
                          (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))) A
                          (x : cic.Term (cic.type cic.z) A =>
                           cic.prod cic.prop
                             (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                             (_P x)
                             (__ : cic.Term cic.prop (_P x) =>
                              cic.prod cic.prop
                                (cic.type
                                   (cic.s (cic.s (cic.s (cic.s cic.z)))))
                                (_Q x)
                                (__1 : cic.Term cic.prop (_Q x) =>
                                 return_type
                                   (matita_basics_logic.ex2_intro A _P _Q x
                                      __ __1)))))
                       (case_ex2_intro :
                          cic.Term
                            (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                            (cic.prod (cic.type cic.z)
                               (cic.type
                                  (cic.s (cic.s (cic.s (cic.s cic.z)))))
                               A
                               (x : cic.Term (cic.type cic.z) A =>
                                cic.prod cic.prop
                                  (cic.type
                                     (cic.s (cic.s (cic.s (cic.s cic.z)))))
                                  (_P x)
                                  (__ : cic.Term cic.prop (_P x) =>
                                   cic.prod cic.prop
                                     (cic.type
                                        (cic.s (cic.s (cic.s (cic.s cic.z)))))
                                     (_Q x)
                                     (__1 : cic.Term cic.prop (_Q x) =>
                                      return_type
                                        (matita_basics_logic.ex2_intro A _P
                                           _Q x __ __1))))) =>
                        cic.prod cic.prop
                          (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                          (matita_basics_logic.ex2 A _P _Q)
                          (z :
                             cic.Term cic.prop
                               (matita_basics_logic.ex2 A _P _Q) =>
                           return_type z))))))).

[ A, _P, _Q, return_type, case_ex2_intro, x, __, __1 ]
  match_ex2_Type4 A _P _Q return_type case_ex2_intro
    (matita_basics_logic.ex2_intro A _P _Q x __ __1) -->
  case_ex2_intro x __ __1.

def match_ex2_Type3 :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
        (cic.prod (cic.type (cic.s cic.z))
           (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
           (cic.univ (cic.type cic.z))
           (A : cic.Univ (cic.type cic.z) =>
            cic.prod (cic.type cic.z)
              (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
              (cic.prod (cic.type cic.z) (cic.type cic.z) A
                 (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop))
              (_P :
                 cic.Term (cic.type cic.z)
                   (cic.prod (cic.type cic.z) (cic.type cic.z) A
                      (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop)) =>
               cic.prod (cic.type cic.z)
                 (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                 (cic.prod (cic.type cic.z) (cic.type cic.z) A
                    (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop))
                 (_Q :
                    cic.Term (cic.type cic.z)
                      (cic.prod (cic.type cic.z) (cic.type cic.z) A
                         (__ : cic.Term (cic.type cic.z) A =>
                          cic.univ cic.prop)) =>
                  cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                    (cic.type (cic.s (cic.s (cic.s cic.z))))
                    (cic.prod cic.prop
                       (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                       (matita_basics_logic.ex2 A _P _Q)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q) =>
                        cic.univ (cic.type (cic.s (cic.s (cic.s cic.z))))))
                    (return_type :
                       cic.Term
                         (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                         (cic.prod cic.prop
                            (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                            (matita_basics_logic.ex2 A _P _Q)
                            (z :
                               cic.Term cic.prop
                                 (matita_basics_logic.ex2 A _P _Q) =>
                             cic.univ
                               (cic.type (cic.s (cic.s (cic.s cic.z)))))) =>
                     cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
                       (cic.type (cic.s (cic.s (cic.s cic.z))))
                       (cic.prod (cic.type cic.z)
                          (cic.type (cic.s (cic.s (cic.s cic.z)))) A
                          (x : cic.Term (cic.type cic.z) A =>
                           cic.prod cic.prop
                             (cic.type (cic.s (cic.s (cic.s cic.z)))) (
                           _P x)
                             (__ : cic.Term cic.prop (_P x) =>
                              cic.prod cic.prop
                                (cic.type (cic.s (cic.s (cic.s cic.z))))
                                (_Q x)
                                (__1 : cic.Term cic.prop (_Q x) =>
                                 return_type
                                   (matita_basics_logic.ex2_intro A _P _Q x
                                      __ __1)))))
                       (case_ex2_intro :
                          cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                            (cic.prod (cic.type cic.z)
                               (cic.type (cic.s (cic.s (cic.s cic.z)))) A
                               (x : cic.Term (cic.type cic.z) A =>
                                cic.prod cic.prop
                                  (cic.type (cic.s (cic.s (cic.s cic.z))))
                                  (_P x)
                                  (__ : cic.Term cic.prop (_P x) =>
                                   cic.prod cic.prop
                                     (cic.type (cic.s (cic.s (cic.s cic.z))))
                                     (_Q x)
                                     (__1 : cic.Term cic.prop (_Q x) =>
                                      return_type
                                        (matita_basics_logic.ex2_intro A _P
                                           _Q x __ __1))))) =>
                        cic.prod cic.prop
                          (cic.type (cic.s (cic.s (cic.s cic.z))))
                          (matita_basics_logic.ex2 A _P _Q)
                          (z :
                             cic.Term cic.prop
                               (matita_basics_logic.ex2 A _P _Q) =>
                           return_type z))))))).

[ A, _P, _Q, return_type, case_ex2_intro, x, __, __1 ]
  match_ex2_Type3 A _P _Q return_type case_ex2_intro
    (matita_basics_logic.ex2_intro A _P _Q x __ __1) -->
  case_ex2_intro x __ __1.

def match_ex2_Type2 :
      cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
        (cic.prod (cic.type (cic.s cic.z))
           (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.univ (cic.type cic.z))
           (A : cic.Univ (cic.type cic.z) =>
            cic.prod (cic.type cic.z)
              (cic.type (cic.s (cic.s (cic.s cic.z))))
              (cic.prod (cic.type cic.z) (cic.type cic.z) A
                 (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop))
              (_P :
                 cic.Term (cic.type cic.z)
                   (cic.prod (cic.type cic.z) (cic.type cic.z) A
                      (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop)) =>
               cic.prod (cic.type cic.z)
                 (cic.type (cic.s (cic.s (cic.s cic.z))))
                 (cic.prod (cic.type cic.z) (cic.type cic.z) A
                    (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop))
                 (_Q :
                    cic.Term (cic.type cic.z)
                      (cic.prod (cic.type cic.z) (cic.type cic.z) A
                         (__ : cic.Term (cic.type cic.z) A =>
                          cic.univ cic.prop)) =>
                  cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
                    (cic.type (cic.s (cic.s cic.z)))
                    (cic.prod cic.prop
                       (cic.type (cic.s (cic.s (cic.s cic.z))))
                       (matita_basics_logic.ex2 A _P _Q)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q) =>
                        cic.univ (cic.type (cic.s (cic.s cic.z)))))
                    (return_type :
                       cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                         (cic.prod cic.prop
                            (cic.type (cic.s (cic.s (cic.s cic.z))))
                            (matita_basics_logic.ex2 A _P _Q)
                            (z :
                               cic.Term cic.prop
                                 (matita_basics_logic.ex2 A _P _Q) =>
                             cic.univ (cic.type (cic.s (cic.s cic.z))))) =>
                     cic.prod (cic.type (cic.s (cic.s cic.z)))
                       (cic.type (cic.s (cic.s cic.z)))
                       (cic.prod (cic.type cic.z)
                          (cic.type (cic.s (cic.s cic.z))) A
                          (x : cic.Term (cic.type cic.z) A =>
                           cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                             (_P x)
                             (__ : cic.Term cic.prop (_P x) =>
                              cic.prod cic.prop
                                (cic.type (cic.s (cic.s cic.z))) (_Q x)
                                (__1 : cic.Term cic.prop (_Q x) =>
                                 return_type
                                   (matita_basics_logic.ex2_intro A _P _Q x
                                      __ __1)))))
                       (case_ex2_intro :
                          cic.Term (cic.type (cic.s (cic.s cic.z)))
                            (cic.prod (cic.type cic.z)
                               (cic.type (cic.s (cic.s cic.z))) A
                               (x : cic.Term (cic.type cic.z) A =>
                                cic.prod cic.prop
                                  (cic.type (cic.s (cic.s cic.z))) (_P x)
                                  (__ : cic.Term cic.prop (_P x) =>
                                   cic.prod cic.prop
                                     (cic.type (cic.s (cic.s cic.z))) (
                                   _Q x)
                                     (__1 : cic.Term cic.prop (_Q x) =>
                                      return_type
                                        (matita_basics_logic.ex2_intro A _P
                                           _Q x __ __1))))) =>
                        cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                          (matita_basics_logic.ex2 A _P _Q)
                          (z :
                             cic.Term cic.prop
                               (matita_basics_logic.ex2 A _P _Q) =>
                           return_type z))))))).

[ A, _P, _Q, return_type, case_ex2_intro, x, __, __1 ]
  match_ex2_Type2 A _P _Q return_type case_ex2_intro
    (matita_basics_logic.ex2_intro A _P _Q x __ __1) -->
  case_ex2_intro x __ __1.

def match_ex2_Type1 :
      cic.Term (cic.type (cic.s (cic.s cic.z)))
        (cic.prod (cic.type (cic.s cic.z)) (cic.type (cic.s (cic.s cic.z)))
           (cic.univ (cic.type cic.z))
           (A : cic.Univ (cic.type cic.z) =>
            cic.prod (cic.type cic.z) (cic.type (cic.s (cic.s cic.z)))
              (cic.prod (cic.type cic.z) (cic.type cic.z) A
                 (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop))
              (_P :
                 cic.Term (cic.type cic.z)
                   (cic.prod (cic.type cic.z) (cic.type cic.z) A
                      (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop)) =>
               cic.prod (cic.type cic.z) (cic.type (cic.s (cic.s cic.z)))
                 (cic.prod (cic.type cic.z) (cic.type cic.z) A
                    (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop))
                 (_Q :
                    cic.Term (cic.type cic.z)
                      (cic.prod (cic.type cic.z) (cic.type cic.z) A
                         (__ : cic.Term (cic.type cic.z) A =>
                          cic.univ cic.prop)) =>
                  cic.prod (cic.type (cic.s (cic.s cic.z)))
                    (cic.type (cic.s cic.z))
                    (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                       (matita_basics_logic.ex2 A _P _Q)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q) =>
                        cic.univ (cic.type (cic.s cic.z))))
                    (return_type :
                       cic.Term (cic.type (cic.s (cic.s cic.z)))
                         (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                            (matita_basics_logic.ex2 A _P _Q)
                            (z :
                               cic.Term cic.prop
                                 (matita_basics_logic.ex2 A _P _Q) =>
                             cic.univ (cic.type (cic.s cic.z)))) =>
                     cic.prod (cic.type (cic.s cic.z))
                       (cic.type (cic.s cic.z))
                       (cic.prod (cic.type cic.z) (cic.type (cic.s cic.z)) A
                          (x : cic.Term (cic.type cic.z) A =>
                           cic.prod cic.prop (cic.type (cic.s cic.z)) (_P x)
                             (__ : cic.Term cic.prop (_P x) =>
                              cic.prod cic.prop (cic.type (cic.s cic.z))
                                (_Q x)
                                (__1 : cic.Term cic.prop (_Q x) =>
                                 return_type
                                   (matita_basics_logic.ex2_intro A _P _Q x
                                      __ __1)))))
                       (case_ex2_intro :
                          cic.Term (cic.type (cic.s cic.z))
                            (cic.prod (cic.type cic.z)
                               (cic.type (cic.s cic.z)) A
                               (x : cic.Term (cic.type cic.z) A =>
                                cic.prod cic.prop (cic.type (cic.s cic.z))
                                  (_P x)
                                  (__ : cic.Term cic.prop (_P x) =>
                                   cic.prod cic.prop (cic.type (cic.s cic.z))
                                     (_Q x)
                                     (__1 : cic.Term cic.prop (_Q x) =>
                                      return_type
                                        (matita_basics_logic.ex2_intro A _P
                                           _Q x __ __1))))) =>
                        cic.prod cic.prop (cic.type (cic.s cic.z))
                          (matita_basics_logic.ex2 A _P _Q)
                          (z :
                             cic.Term cic.prop
                               (matita_basics_logic.ex2 A _P _Q) =>
                           return_type z))))))).

[ A, _P, _Q, return_type, case_ex2_intro, x, __, __1 ]
  match_ex2_Type1 A _P _Q return_type case_ex2_intro
    (matita_basics_logic.ex2_intro A _P _Q x __ __1) -->
  case_ex2_intro x __ __1.

def match_ex2_Type0 :
      cic.Term (cic.type (cic.s cic.z))
        (cic.prod (cic.type (cic.s cic.z)) (cic.type (cic.s cic.z))
           (cic.univ (cic.type cic.z))
           (A : cic.Univ (cic.type cic.z) =>
            cic.prod (cic.type cic.z) (cic.type (cic.s cic.z))
              (cic.prod (cic.type cic.z) (cic.type cic.z) A
                 (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop))
              (_P :
                 cic.Term (cic.type cic.z)
                   (cic.prod (cic.type cic.z) (cic.type cic.z) A
                      (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop)) =>
               cic.prod (cic.type cic.z) (cic.type (cic.s cic.z))
                 (cic.prod (cic.type cic.z) (cic.type cic.z) A
                    (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop))
                 (_Q :
                    cic.Term (cic.type cic.z)
                      (cic.prod (cic.type cic.z) (cic.type cic.z) A
                         (__ : cic.Term (cic.type cic.z) A =>
                          cic.univ cic.prop)) =>
                  cic.prod (cic.type (cic.s cic.z)) (cic.type cic.z)
                    (cic.prod cic.prop (cic.type (cic.s cic.z))
                       (matita_basics_logic.ex2 A _P _Q)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q) =>
                        cic.univ (cic.type cic.z)))
                    (return_type :
                       cic.Term (cic.type (cic.s cic.z))
                         (cic.prod cic.prop (cic.type (cic.s cic.z))
                            (matita_basics_logic.ex2 A _P _Q)
                            (z :
                               cic.Term cic.prop
                                 (matita_basics_logic.ex2 A _P _Q) =>
                             cic.univ (cic.type cic.z))) =>
                     cic.prod (cic.type cic.z) (cic.type cic.z)
                       (cic.prod (cic.type cic.z) (cic.type cic.z) A
                          (x : cic.Term (cic.type cic.z) A =>
                           cic.prod cic.prop (cic.type cic.z) (_P x)
                             (__ : cic.Term cic.prop (_P x) =>
                              cic.prod cic.prop (cic.type cic.z) (_Q x)
                                (__1 : cic.Term cic.prop (_Q x) =>
                                 return_type
                                   (matita_basics_logic.ex2_intro A _P _Q x
                                      __ __1)))))
                       (case_ex2_intro :
                          cic.Term (cic.type cic.z)
                            (cic.prod (cic.type cic.z) (cic.type cic.z) A
                               (x : cic.Term (cic.type cic.z) A =>
                                cic.prod cic.prop (cic.type cic.z) (_P x)
                                  (__ : cic.Term cic.prop (_P x) =>
                                   cic.prod cic.prop (cic.type cic.z) (_Q x)
                                     (__1 : cic.Term cic.prop (_Q x) =>
                                      return_type
                                        (matita_basics_logic.ex2_intro A _P
                                           _Q x __ __1))))) =>
                        cic.prod cic.prop (cic.type cic.z)
                          (matita_basics_logic.ex2 A _P _Q)
                          (z :
                             cic.Term cic.prop
                               (matita_basics_logic.ex2 A _P _Q) =>
                           return_type z))))))).

[ A, _P, _Q, return_type, case_ex2_intro, x, __, __1 ]
  match_ex2_Type0 A _P _Q return_type case_ex2_intro
    (matita_basics_logic.ex2_intro A _P _Q x __ __1) -->
  case_ex2_intro x __ __1.

def filter_ex2_Prop :
      cic.Term cic.prop
        (cic.prod (cic.type (cic.s cic.z)) cic.prop
           (cic.univ (cic.type cic.z))
           (A : cic.Univ (cic.type cic.z) =>
            cic.prod (cic.type cic.z) cic.prop
              (cic.prod (cic.type cic.z) (cic.type cic.z) A
                 (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop))
              (_P :
                 cic.Term (cic.type cic.z)
                   (cic.prod (cic.type cic.z) (cic.type cic.z) A
                      (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop)) =>
               cic.prod (cic.type cic.z) cic.prop
                 (cic.prod (cic.type cic.z) (cic.type cic.z) A
                    (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop))
                 (_Q :
                    cic.Term (cic.type cic.z)
                      (cic.prod (cic.type cic.z) (cic.type cic.z) A
                         (__ : cic.Term (cic.type cic.z) A =>
                          cic.univ cic.prop)) =>
                  cic.prod (cic.type cic.z) cic.prop
                    (cic.prod cic.prop (cic.type cic.z)
                       (matita_basics_logic.ex2 A _P _Q)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q) =>
                        cic.univ cic.prop))
                    (return_type :
                       cic.Term (cic.type cic.z)
                         (cic.prod cic.prop (cic.type cic.z)
                            (matita_basics_logic.ex2 A _P _Q)
                            (z :
                               cic.Term cic.prop
                                 (matita_basics_logic.ex2 A _P _Q) =>
                             cic.univ cic.prop)) =>
                     cic.prod cic.prop cic.prop
                       (cic.prod cic.prop cic.prop
                          (matita_basics_logic.ex2 A _P _Q)
                          (z :
                             cic.Term cic.prop
                               (matita_basics_logic.ex2 A _P _Q) =>
                           return_type z))
                       (return :
                          cic.Term cic.prop
                            (cic.prod cic.prop cic.prop
                               (matita_basics_logic.ex2 A _P _Q)
                               (z :
                                  cic.Term cic.prop
                                    (matita_basics_logic.ex2 A _P _Q) =>
                                return_type z)) =>
                        cic.prod cic.prop cic.prop
                          (matita_basics_logic.ex2 A _P _Q)
                          (z :
                             cic.Term cic.prop
                               (matita_basics_logic.ex2 A _P _Q) =>
                           return_type z))))))).

[ A, P, Q, x, __, __1, return_type, return ]
  filter_ex2_Prop (A) (P) (Q) return_type return
    (matita_basics_logic.ex2_intro A P Q x __ __1) -->
  return (matita_basics_logic.ex2_intro A P Q x __ __1).

def filter_ex2_Type5 :
      cic.Term
        (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
        (cic.prod (cic.type (cic.s cic.z))
           (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
           (cic.univ (cic.type cic.z))
           (A : cic.Univ (cic.type cic.z) =>
            cic.prod (cic.type cic.z)
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
              (cic.prod (cic.type cic.z) (cic.type cic.z) A
                 (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop))
              (_P :
                 cic.Term (cic.type cic.z)
                   (cic.prod (cic.type cic.z) (cic.type cic.z) A
                      (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop)) =>
               cic.prod (cic.type cic.z)
                 (cic.type
                    (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                 (cic.prod (cic.type cic.z) (cic.type cic.z) A
                    (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop))
                 (_Q :
                    cic.Term (cic.type cic.z)
                      (cic.prod (cic.type cic.z) (cic.type cic.z) A
                         (__ : cic.Term (cic.type cic.z) A =>
                          cic.univ cic.prop)) =>
                  cic.prod
                    (cic.type
                       (cic.s (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                    (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                    (cic.prod cic.prop
                       (cic.type
                          (cic.s
                             (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                       (matita_basics_logic.ex2 A _P _Q)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q) =>
                        cic.univ
                          (cic.type
                             (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))))
                    (return_type :
                       cic.Term
                         (cic.type
                            (cic.s
                               (cic.s (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                         (cic.prod cic.prop
                            (cic.type
                               (cic.s
                                  (cic.s
                                     (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                            (matita_basics_logic.ex2 A _P _Q)
                            (z :
                               cic.Term cic.prop
                                 (matita_basics_logic.ex2 A _P _Q) =>
                             cic.univ
                               (cic.type
                                  (cic.s
                                     (cic.s (cic.s (cic.s (cic.s cic.z)))))))) =>
                     cic.prod
                       (cic.type
                          (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                       (cic.type
                          (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                       (cic.prod cic.prop
                          (cic.type
                             (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                          (matita_basics_logic.ex2 A _P _Q)
                          (z :
                             cic.Term cic.prop
                               (matita_basics_logic.ex2 A _P _Q) =>
                           return_type z))
                       (return :
                          cic.Term
                            (cic.type
                               (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                            (cic.prod cic.prop
                               (cic.type
                                  (cic.s
                                     (cic.s (cic.s (cic.s (cic.s cic.z))))))
                               (matita_basics_logic.ex2 A _P _Q)
                               (z :
                                  cic.Term cic.prop
                                    (matita_basics_logic.ex2 A _P _Q) =>
                                return_type z)) =>
                        cic.prod cic.prop
                          (cic.type
                             (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                          (matita_basics_logic.ex2 A _P _Q)
                          (z :
                             cic.Term cic.prop
                               (matita_basics_logic.ex2 A _P _Q) =>
                           return_type z))))))).

[ A, P, Q, x, __, __1, return_type, return ]
  filter_ex2_Type5 (A) (P) (Q) return_type return
    (matita_basics_logic.ex2_intro A P Q x __ __1) -->
  return (matita_basics_logic.ex2_intro A P Q x __ __1).

def filter_ex2_Type4 :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
        (cic.prod (cic.type (cic.s cic.z))
           (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
           (cic.univ (cic.type cic.z))
           (A : cic.Univ (cic.type cic.z) =>
            cic.prod (cic.type cic.z)
              (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
              (cic.prod (cic.type cic.z) (cic.type cic.z) A
                 (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop))
              (_P :
                 cic.Term (cic.type cic.z)
                   (cic.prod (cic.type cic.z) (cic.type cic.z) A
                      (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop)) =>
               cic.prod (cic.type cic.z)
                 (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                 (cic.prod (cic.type cic.z) (cic.type cic.z) A
                    (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop))
                 (_Q :
                    cic.Term (cic.type cic.z)
                      (cic.prod (cic.type cic.z) (cic.type cic.z) A
                         (__ : cic.Term (cic.type cic.z) A =>
                          cic.univ cic.prop)) =>
                  cic.prod
                    (cic.type (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                    (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                    (cic.prod cic.prop
                       (cic.type
                          (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                       (matita_basics_logic.ex2 A _P _Q)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q) =>
                        cic.univ
                          (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))))
                    (return_type :
                       cic.Term
                         (cic.type
                            (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                         (cic.prod cic.prop
                            (cic.type
                               (cic.s (cic.s (cic.s (cic.s (cic.s cic.z))))))
                            (matita_basics_logic.ex2 A _P _Q)
                            (z :
                               cic.Term cic.prop
                                 (matita_basics_logic.ex2 A _P _Q) =>
                             cic.univ
                               (cic.type
                                  (cic.s (cic.s (cic.s (cic.s cic.z))))))) =>
                     cic.prod
                       (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                       (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                       (cic.prod cic.prop
                          (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                          (matita_basics_logic.ex2 A _P _Q)
                          (z :
                             cic.Term cic.prop
                               (matita_basics_logic.ex2 A _P _Q) =>
                           return_type z))
                       (return :
                          cic.Term
                            (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                            (cic.prod cic.prop
                               (cic.type
                                  (cic.s (cic.s (cic.s (cic.s cic.z)))))
                               (matita_basics_logic.ex2 A _P _Q)
                               (z :
                                  cic.Term cic.prop
                                    (matita_basics_logic.ex2 A _P _Q) =>
                                return_type z)) =>
                        cic.prod cic.prop
                          (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                          (matita_basics_logic.ex2 A _P _Q)
                          (z :
                             cic.Term cic.prop
                               (matita_basics_logic.ex2 A _P _Q) =>
                           return_type z))))))).

[ A, P, Q, x, __, __1, return_type, return ]
  filter_ex2_Type4 (A) (P) (Q) return_type return
    (matita_basics_logic.ex2_intro A P Q x __ __1) -->
  return (matita_basics_logic.ex2_intro A P Q x __ __1).

def filter_ex2_Type3 :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
        (cic.prod (cic.type (cic.s cic.z))
           (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
           (cic.univ (cic.type cic.z))
           (A : cic.Univ (cic.type cic.z) =>
            cic.prod (cic.type cic.z)
              (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
              (cic.prod (cic.type cic.z) (cic.type cic.z) A
                 (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop))
              (_P :
                 cic.Term (cic.type cic.z)
                   (cic.prod (cic.type cic.z) (cic.type cic.z) A
                      (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop)) =>
               cic.prod (cic.type cic.z)
                 (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                 (cic.prod (cic.type cic.z) (cic.type cic.z) A
                    (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop))
                 (_Q :
                    cic.Term (cic.type cic.z)
                      (cic.prod (cic.type cic.z) (cic.type cic.z) A
                         (__ : cic.Term (cic.type cic.z) A =>
                          cic.univ cic.prop)) =>
                  cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                    (cic.type (cic.s (cic.s (cic.s cic.z))))
                    (cic.prod cic.prop
                       (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                       (matita_basics_logic.ex2 A _P _Q)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q) =>
                        cic.univ (cic.type (cic.s (cic.s (cic.s cic.z))))))
                    (return_type :
                       cic.Term
                         (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                         (cic.prod cic.prop
                            (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                            (matita_basics_logic.ex2 A _P _Q)
                            (z :
                               cic.Term cic.prop
                                 (matita_basics_logic.ex2 A _P _Q) =>
                             cic.univ
                               (cic.type (cic.s (cic.s (cic.s cic.z)))))) =>
                     cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
                       (cic.type (cic.s (cic.s (cic.s cic.z))))
                       (cic.prod cic.prop
                          (cic.type (cic.s (cic.s (cic.s cic.z))))
                          (matita_basics_logic.ex2 A _P _Q)
                          (z :
                             cic.Term cic.prop
                               (matita_basics_logic.ex2 A _P _Q) =>
                           return_type z))
                       (return :
                          cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                            (cic.prod cic.prop
                               (cic.type (cic.s (cic.s (cic.s cic.z))))
                               (matita_basics_logic.ex2 A _P _Q)
                               (z :
                                  cic.Term cic.prop
                                    (matita_basics_logic.ex2 A _P _Q) =>
                                return_type z)) =>
                        cic.prod cic.prop
                          (cic.type (cic.s (cic.s (cic.s cic.z))))
                          (matita_basics_logic.ex2 A _P _Q)
                          (z :
                             cic.Term cic.prop
                               (matita_basics_logic.ex2 A _P _Q) =>
                           return_type z))))))).

[ A, P, Q, x, __, __1, return_type, return ]
  filter_ex2_Type3 (A) (P) (Q) return_type return
    (matita_basics_logic.ex2_intro A P Q x __ __1) -->
  return (matita_basics_logic.ex2_intro A P Q x __ __1).

def filter_ex2_Type2 :
      cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
        (cic.prod (cic.type (cic.s cic.z))
           (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.univ (cic.type cic.z))
           (A : cic.Univ (cic.type cic.z) =>
            cic.prod (cic.type cic.z)
              (cic.type (cic.s (cic.s (cic.s cic.z))))
              (cic.prod (cic.type cic.z) (cic.type cic.z) A
                 (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop))
              (_P :
                 cic.Term (cic.type cic.z)
                   (cic.prod (cic.type cic.z) (cic.type cic.z) A
                      (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop)) =>
               cic.prod (cic.type cic.z)
                 (cic.type (cic.s (cic.s (cic.s cic.z))))
                 (cic.prod (cic.type cic.z) (cic.type cic.z) A
                    (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop))
                 (_Q :
                    cic.Term (cic.type cic.z)
                      (cic.prod (cic.type cic.z) (cic.type cic.z) A
                         (__ : cic.Term (cic.type cic.z) A =>
                          cic.univ cic.prop)) =>
                  cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
                    (cic.type (cic.s (cic.s cic.z)))
                    (cic.prod cic.prop
                       (cic.type (cic.s (cic.s (cic.s cic.z))))
                       (matita_basics_logic.ex2 A _P _Q)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q) =>
                        cic.univ (cic.type (cic.s (cic.s cic.z)))))
                    (return_type :
                       cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                         (cic.prod cic.prop
                            (cic.type (cic.s (cic.s (cic.s cic.z))))
                            (matita_basics_logic.ex2 A _P _Q)
                            (z :
                               cic.Term cic.prop
                                 (matita_basics_logic.ex2 A _P _Q) =>
                             cic.univ (cic.type (cic.s (cic.s cic.z))))) =>
                     cic.prod (cic.type (cic.s (cic.s cic.z)))
                       (cic.type (cic.s (cic.s cic.z)))
                       (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                          (matita_basics_logic.ex2 A _P _Q)
                          (z :
                             cic.Term cic.prop
                               (matita_basics_logic.ex2 A _P _Q) =>
                           return_type z))
                       (return :
                          cic.Term (cic.type (cic.s (cic.s cic.z)))
                            (cic.prod cic.prop
                               (cic.type (cic.s (cic.s cic.z)))
                               (matita_basics_logic.ex2 A _P _Q)
                               (z :
                                  cic.Term cic.prop
                                    (matita_basics_logic.ex2 A _P _Q) =>
                                return_type z)) =>
                        cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                          (matita_basics_logic.ex2 A _P _Q)
                          (z :
                             cic.Term cic.prop
                               (matita_basics_logic.ex2 A _P _Q) =>
                           return_type z))))))).

[ A, P, Q, x, __, __1, return_type, return ]
  filter_ex2_Type2 (A) (P) (Q) return_type return
    (matita_basics_logic.ex2_intro A P Q x __ __1) -->
  return (matita_basics_logic.ex2_intro A P Q x __ __1).

def filter_ex2_Type1 :
      cic.Term (cic.type (cic.s (cic.s cic.z)))
        (cic.prod (cic.type (cic.s cic.z)) (cic.type (cic.s (cic.s cic.z)))
           (cic.univ (cic.type cic.z))
           (A : cic.Univ (cic.type cic.z) =>
            cic.prod (cic.type cic.z) (cic.type (cic.s (cic.s cic.z)))
              (cic.prod (cic.type cic.z) (cic.type cic.z) A
                 (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop))
              (_P :
                 cic.Term (cic.type cic.z)
                   (cic.prod (cic.type cic.z) (cic.type cic.z) A
                      (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop)) =>
               cic.prod (cic.type cic.z) (cic.type (cic.s (cic.s cic.z)))
                 (cic.prod (cic.type cic.z) (cic.type cic.z) A
                    (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop))
                 (_Q :
                    cic.Term (cic.type cic.z)
                      (cic.prod (cic.type cic.z) (cic.type cic.z) A
                         (__ : cic.Term (cic.type cic.z) A =>
                          cic.univ cic.prop)) =>
                  cic.prod (cic.type (cic.s (cic.s cic.z)))
                    (cic.type (cic.s cic.z))
                    (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                       (matita_basics_logic.ex2 A _P _Q)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q) =>
                        cic.univ (cic.type (cic.s cic.z))))
                    (return_type :
                       cic.Term (cic.type (cic.s (cic.s cic.z)))
                         (cic.prod cic.prop (cic.type (cic.s (cic.s cic.z)))
                            (matita_basics_logic.ex2 A _P _Q)
                            (z :
                               cic.Term cic.prop
                                 (matita_basics_logic.ex2 A _P _Q) =>
                             cic.univ (cic.type (cic.s cic.z)))) =>
                     cic.prod (cic.type (cic.s cic.z))
                       (cic.type (cic.s cic.z))
                       (cic.prod cic.prop (cic.type (cic.s cic.z))
                          (matita_basics_logic.ex2 A _P _Q)
                          (z :
                             cic.Term cic.prop
                               (matita_basics_logic.ex2 A _P _Q) =>
                           return_type z))
                       (return :
                          cic.Term (cic.type (cic.s cic.z))
                            (cic.prod cic.prop (cic.type (cic.s cic.z))
                               (matita_basics_logic.ex2 A _P _Q)
                               (z :
                                  cic.Term cic.prop
                                    (matita_basics_logic.ex2 A _P _Q) =>
                                return_type z)) =>
                        cic.prod cic.prop (cic.type (cic.s cic.z))
                          (matita_basics_logic.ex2 A _P _Q)
                          (z :
                             cic.Term cic.prop
                               (matita_basics_logic.ex2 A _P _Q) =>
                           return_type z))))))).

[ A, P, Q, x, __, __1, return_type, return ]
  filter_ex2_Type1 (A) (P) (Q) return_type return
    (matita_basics_logic.ex2_intro A P Q x __ __1) -->
  return (matita_basics_logic.ex2_intro A P Q x __ __1).

def filter_ex2_Type0 :
      cic.Term (cic.type (cic.s cic.z))
        (cic.prod (cic.type (cic.s cic.z)) (cic.type (cic.s cic.z))
           (cic.univ (cic.type cic.z))
           (A : cic.Univ (cic.type cic.z) =>
            cic.prod (cic.type cic.z) (cic.type (cic.s cic.z))
              (cic.prod (cic.type cic.z) (cic.type cic.z) A
                 (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop))
              (_P :
                 cic.Term (cic.type cic.z)
                   (cic.prod (cic.type cic.z) (cic.type cic.z) A
                      (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop)) =>
               cic.prod (cic.type cic.z) (cic.type (cic.s cic.z))
                 (cic.prod (cic.type cic.z) (cic.type cic.z) A
                    (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop))
                 (_Q :
                    cic.Term (cic.type cic.z)
                      (cic.prod (cic.type cic.z) (cic.type cic.z) A
                         (__ : cic.Term (cic.type cic.z) A =>
                          cic.univ cic.prop)) =>
                  cic.prod (cic.type (cic.s cic.z)) (cic.type cic.z)
                    (cic.prod cic.prop (cic.type (cic.s cic.z))
                       (matita_basics_logic.ex2 A _P _Q)
                       (z :
                          cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q) =>
                        cic.univ (cic.type cic.z)))
                    (return_type :
                       cic.Term (cic.type (cic.s cic.z))
                         (cic.prod cic.prop (cic.type (cic.s cic.z))
                            (matita_basics_logic.ex2 A _P _Q)
                            (z :
                               cic.Term cic.prop
                                 (matita_basics_logic.ex2 A _P _Q) =>
                             cic.univ (cic.type cic.z))) =>
                     cic.prod (cic.type cic.z) (cic.type cic.z)
                       (cic.prod cic.prop (cic.type cic.z)
                          (matita_basics_logic.ex2 A _P _Q)
                          (z :
                             cic.Term cic.prop
                               (matita_basics_logic.ex2 A _P _Q) =>
                           return_type z))
                       (return :
                          cic.Term (cic.type cic.z)
                            (cic.prod cic.prop (cic.type cic.z)
                               (matita_basics_logic.ex2 A _P _Q)
                               (z :
                                  cic.Term cic.prop
                                    (matita_basics_logic.ex2 A _P _Q) =>
                                return_type z)) =>
                        cic.prod cic.prop (cic.type cic.z)
                          (matita_basics_logic.ex2 A _P _Q)
                          (z :
                             cic.Term cic.prop
                               (matita_basics_logic.ex2 A _P _Q) =>
                           return_type z))))))).

[ A, P, Q, x, __, __1, return_type, return ]
  filter_ex2_Type0 (A) (P) (Q) return_type return
    (matita_basics_logic.ex2_intro A P Q x __ __1) -->
  return (matita_basics_logic.ex2_intro A P Q x __ __1).

def ex2_ind :
      cic.Term cic.prop
        (cic.prod (cic.type (cic.s cic.z)) cic.prop
           (cic.univ (cic.type cic.z))
           (A : cic.Univ (cic.type cic.z) =>
            cic.prod (cic.type cic.z) cic.prop
              (cic.prod (cic.type cic.z) (cic.type cic.z) A
                 (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop))
              (_P :
                 cic.Term (cic.type cic.z)
                   (cic.prod (cic.type cic.z) (cic.type cic.z) A
                      (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop)) =>
               cic.prod (cic.type cic.z) cic.prop
                 (cic.prod (cic.type cic.z) (cic.type cic.z) A
                    (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop))
                 (_Q :
                    cic.Term (cic.type cic.z)
                      (cic.prod (cic.type cic.z) (cic.type cic.z) A
                         (__ : cic.Term (cic.type cic.z) A =>
                          cic.univ cic.prop)) =>
                  cic.prod (cic.type cic.z) cic.prop
                    (cic.prod cic.prop (cic.type cic.z)
                       (matita_basics_logic.ex2
                          (cic.lift (cic.type cic.z) (cic.type cic.z) A) _P
                          _Q)
                       (_x_274 :
                          cic.Term cic.prop
                            (matita_basics_logic.ex2
                               (cic.lift (cic.type cic.z) (cic.type cic.z) A)
                               _P _Q) =>
                        cic.univ cic.prop))
                    (Q_ :
                       cic.Term (cic.type cic.z)
                         (cic.prod cic.prop (cic.type cic.z)
                            (matita_basics_logic.ex2
                               (cic.lift (cic.type cic.z) (cic.type cic.z) A)
                               _P _Q)
                            (_x_274 :
                               cic.Term cic.prop
                                 (matita_basics_logic.ex2
                                    (cic.lift (cic.type cic.z)
                                       (cic.type cic.z) A)
                                    _P _Q) =>
                             cic.univ cic.prop)) =>
                     cic.prod cic.prop cic.prop
                       (cic.prod (cic.type cic.z) cic.prop A
                          (x : cic.Term (cic.type cic.z) A =>
                           cic.prod cic.prop cic.prop (_P x)
                             (x_276 : cic.Term cic.prop (_P x) =>
                              cic.prod cic.prop cic.prop (_Q x)
                                (x_275 : cic.Term cic.prop (_Q x) =>
                                 Q_
                                   (matita_basics_logic.ex2_intro
                                      (cic.lift (cic.type cic.z)
                                         (cic.type cic.z) A)
                                      _P _Q x x_276 x_275)))))
                       (_H_ex2_intro :
                          cic.Term cic.prop
                            (cic.prod (cic.type cic.z) cic.prop A
                               (x : cic.Term (cic.type cic.z) A =>
                                cic.prod cic.prop cic.prop (_P x)
                                  (x_276 : cic.Term cic.prop (_P x) =>
                                   cic.prod cic.prop cic.prop (_Q x)
                                     (x_275 : cic.Term cic.prop (_Q x) =>
                                      Q_
                                        (matita_basics_logic.ex2_intro
                                           (cic.lift (cic.type cic.z)
                                              (cic.type cic.z) A)
                                           _P _Q x x_276 x_275))))) =>
                        cic.prod cic.prop cic.prop
                          (matita_basics_logic.ex2
                             (cic.lift (cic.type cic.z) (cic.type cic.z) A)
                             _P _Q)
                          (x_274 :
                             cic.Term cic.prop
                               (matita_basics_logic.ex2
                                  (cic.lift (cic.type cic.z) (cic.type cic.z)
                                     A)
                                  _P _Q) =>
                           Q_ x_274))))))).

def ex2_ind_body :
      cic.Term cic.prop
        (cic.prod (cic.type (cic.s cic.z)) cic.prop
           (cic.univ (cic.type cic.z))
           (A : cic.Univ (cic.type cic.z) =>
            cic.prod (cic.type cic.z) cic.prop
              (cic.prod (cic.type cic.z) (cic.type cic.z) A
                 (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop))
              (_P :
                 cic.Term (cic.type cic.z)
                   (cic.prod (cic.type cic.z) (cic.type cic.z) A
                      (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop)) =>
               cic.prod (cic.type cic.z) cic.prop
                 (cic.prod (cic.type cic.z) (cic.type cic.z) A
                    (__ : cic.Term (cic.type cic.z) A => cic.univ cic.prop))
                 (_Q :
                    cic.Term (cic.type cic.z)
                      (cic.prod (cic.type cic.z) (cic.type cic.z) A
                         (__ : cic.Term (cic.type cic.z) A =>
                          cic.univ cic.prop)) =>
                  cic.prod (cic.type cic.z) cic.prop
                    (cic.prod cic.prop (cic.type cic.z)
                       (matita_basics_logic.ex2
                          (cic.lift (cic.type cic.z) (cic.type cic.z) A) _P
                          _Q)
                       (_x_274 :
                          cic.Term cic.prop
                            (matita_basics_logic.ex2
                               (cic.lift (cic.type cic.z) (cic.type cic.z) A)
                               _P _Q) =>
                        cic.univ cic.prop))
                    (Q_ :
                       cic.Term (cic.type cic.z)
                         (cic.prod cic.prop (cic.type cic.z)
                            (matita_basics_logic.ex2
                               (cic.lift (cic.type cic.z) (cic.type cic.z) A)
                               _P _Q)
                            (_x_274 :
                               cic.Term cic.prop
                                 (matita_basics_logic.ex2
                                    (cic.lift (cic.type cic.z)
                                       (cic.type cic.z) A)
                                    _P _Q) =>
                             cic.univ cic.prop)) =>
                     cic.prod cic.prop cic.prop
                       (cic.prod (cic.type cic.z) cic.prop A
                          (x : cic.Term (cic.type cic.z) A =>
                           cic.prod cic.prop cic.prop (_P x)
                             (x_276 : cic.Term cic.prop (_P x) =>
                              cic.prod cic.prop cic.prop (_Q x)
                                (x_275 : cic.Term cic.prop (_Q x) =>
                                 Q_
                                   (matita_basics_logic.ex2_intro
                                      (cic.lift (cic.type cic.z)
                                         (cic.type cic.z) A)
                                      _P _Q x x_276 x_275)))))
                       (_H_ex2_intro :
                          cic.Term cic.prop
                            (cic.prod (cic.type cic.z) cic.prop A
                               (x : cic.Term (cic.type cic.z) A =>
                                cic.prod cic.prop cic.prop (_P x)
                                  (x_276 : cic.Term cic.prop (_P x) =>
                                   cic.prod cic.prop cic.prop (_Q x)
                                     (x_275 : cic.Term cic.prop (_Q x) =>
                                      Q_
                                        (matita_basics_logic.ex2_intro
                                           (cic.lift (cic.type cic.z)
                                              (cic.type cic.z) A)
                                           _P _Q x x_276 x_275))))) =>
                        cic.prod cic.prop cic.prop
                          (matita_basics_logic.ex2
                             (cic.lift (cic.type cic.z) (cic.type cic.z) A)
                             _P _Q)
                          (x_274 :
                             cic.Term cic.prop
                               (matita_basics_logic.ex2
                                  (cic.lift (cic.type cic.z) (cic.type cic.z)
                                     A)
                                  _P _Q) =>
                           Q_ x_274))))))).

[ A, _P, _Q, Q_, _H_ex2_intro, x_274 ]
  ex2_ind A _P _Q Q_ _H_ex2_intro x_274 -->
  matita_basics_logic.filter_ex2_Prop A _P _Q
    (x_274 :
       cic.Term cic.prop
         (matita_basics_logic.ex2
            (cic.lift (cic.type cic.z) (cic.type cic.z) A) _P _Q) =>
     Q_ x_274)
    (matita_basics_logic.ex2_ind_body A _P _Q Q_ _H_ex2_intro) x_274.

[ A, _P, _Q, Q_, _H_ex2_intro, x_274 ]
  ex2_ind_body A _P _Q Q_ _H_ex2_intro x_274 -->
  matita_basics_logic.match_ex2_Prop
    (cic.lift (cic.type cic.z) (cic.type cic.z) A) _P _Q Q_
    (x : cic.Term (cic.type cic.z) A =>
     x_276 : cic.Term cic.prop (_P x) =>
     x_275 : cic.Term cic.prop (_Q x) => _H_ex2_intro x x_276 x_275)
    x_274.

def ex2_inv_ind :
      cic.Term cic.prop
        (cic.prod (cic.type (cic.s cic.z)) cic.prop
           (cic.univ (cic.type cic.z))
           (x1 : cic.Univ (cic.type cic.z) =>
            cic.prod (cic.type cic.z) cic.prop
              (cic.prod (cic.type cic.z) (cic.type cic.z) x1
                 (__ : cic.Term (cic.type cic.z) x1 => cic.univ cic.prop))
              (x2 :
                 cic.Term (cic.type cic.z)
                   (cic.prod (cic.type cic.z) (cic.type cic.z) x1
                      (__ : cic.Term (cic.type cic.z) x1 => cic.univ cic.prop)) =>
               cic.prod (cic.type cic.z) cic.prop
                 (cic.prod (cic.type cic.z) (cic.type cic.z) x1
                    (__ : cic.Term (cic.type cic.z) x1 => cic.univ cic.prop))
                 (x3 :
                    cic.Term (cic.type cic.z)
                      (cic.prod (cic.type cic.z) (cic.type cic.z) x1
                         (__ : cic.Term (cic.type cic.z) x1 =>
                          cic.univ cic.prop)) =>
                  cic.prod cic.prop cic.prop
                    (matita_basics_logic.ex2
                       (cic.lift (cic.type cic.z) (cic.type cic.z) x1) x2 x3)
                    (Hterm :
                       cic.Term cic.prop
                         (matita_basics_logic.ex2
                            (cic.lift (cic.type cic.z) (cic.type cic.z) x1)
                            x2 x3) =>
                     cic.prod (cic.type cic.z) cic.prop
                       (cic.prod cic.prop (cic.type cic.z)
                          (matita_basics_logic.ex2
                             (cic.lift (cic.type cic.z) (cic.type cic.z) x1)
                             x2 x3)
                          (_z521 :
                             cic.Term cic.prop
                               (matita_basics_logic.ex2
                                  (cic.lift (cic.type cic.z) (cic.type cic.z)
                                     x1)
                                  x2 x3) =>
                           cic.univ cic.prop))
                       (P :
                          cic.Term (cic.type cic.z)
                            (cic.prod cic.prop (cic.type cic.z)
                               (matita_basics_logic.ex2
                                  (cic.lift (cic.type cic.z) (cic.type cic.z)
                                     x1)
                                  x2 x3)
                               (_z521 :
                                  cic.Term cic.prop
                                    (matita_basics_logic.ex2
                                       (cic.lift (cic.type cic.z)
                                          (cic.type cic.z) x1)
                                       x2 x3) =>
                                cic.univ cic.prop)) =>
                        cic.prod cic.prop cic.prop
                          (cic.prod (cic.type cic.z) cic.prop x1
                             (x : cic.Term (cic.type cic.z) x1 =>
                              cic.prod cic.prop cic.prop (x2 x)
                                (x_276 : cic.Term cic.prop (x2 x) =>
                                 cic.prod cic.prop cic.prop (x3 x)
                                   (x_275 : cic.Term cic.prop (x3 x) =>
                                    cic.prod cic.prop cic.prop
                                      (matita_basics_logic.eq
                                         (cic.lift cic.prop
                                            (cic.type (cic.s (cic.s cic.z)))
                                            (matita_basics_logic.ex2
                                               (cic.lift (cic.type cic.z)
                                                  (cic.type cic.z) x1)
                                               x2 x3))
                                         Hterm
                                         (matita_basics_logic.ex2_intro
                                            (cic.lift (cic.type cic.z)
                                               (cic.type cic.z) x1)
                                            x2 x3 x x_276 x_275))
                                      (_z522 :
                                         cic.Term cic.prop
                                           (matita_basics_logic.eq
                                              (cic.lift cic.prop
                                                 (cic.type
                                                    (cic.s (cic.s cic.z)))
                                                 (matita_basics_logic.ex2
                                                    (cic.lift
                                                       (cic.type cic.z)
                                                       (cic.type cic.z) x1)
                                                    x2 x3))
                                              Hterm
                                              (matita_basics_logic.ex2_intro
                                                 (cic.lift (cic.type cic.z)
                                                    (cic.type cic.z) x1)
                                                 x2 x3 x x_276 x_275)) =>
                                       P
                                         (matita_basics_logic.ex2_intro
                                            (cic.lift (cic.type cic.z)
                                               (cic.type cic.z) x1)
                                            x2 x3 x x_276 x_275))))))
                          (_H1 :
                             cic.Term cic.prop
                               (cic.prod (cic.type cic.z) cic.prop x1
                                  (x : cic.Term (cic.type cic.z) x1 =>
                                   cic.prod cic.prop cic.prop (x2 x)
                                     (x_276 : cic.Term cic.prop (x2 x) =>
                                      cic.prod cic.prop cic.prop (x3 x)
                                        (x_275 : cic.Term cic.prop (x3 x) =>
                                         cic.prod cic.prop cic.prop
                                           (matita_basics_logic.eq
                                              (cic.lift cic.prop
                                                 (cic.type
                                                    (cic.s (cic.s cic.z)))
                                                 (matita_basics_logic.ex2
                                                    (cic.lift
                                                       (cic.type cic.z)
                                                       (cic.type cic.z) x1)
                                                    x2 x3))
                                              Hterm
                                              (matita_basics_logic.ex2_intro
                                                 (cic.lift (cic.type cic.z)
                                                    (cic.type cic.z) x1)
                                                 x2 x3 x x_276 x_275))
                                           (_z522 :
                                              cic.Term cic.prop
                                                (matita_basics_logic.eq
                                                   (cic.lift cic.prop
                                                      (cic.type
                                                         (cic.s (cic.s cic.z)))
                                                      (matita_basics_logic.ex2
                                                         (cic.lift
                                                            (cic.type cic.z)
                                                            (cic.type cic.z)
                                                            x1)
                                                         x2 x3))
                                                   Hterm
                                                   (matita_basics_logic.ex2_intro
                                                      (cic.lift
                                                         (cic.type cic.z)
                                                         (cic.type cic.z) x1)
                                                      x2 x3 x x_276 x_275)) =>
                                            P
                                              (matita_basics_logic.ex2_intro
                                                 (cic.lift (cic.type cic.z)
                                                    (cic.type cic.z) x1)
                                                 x2 x3 x x_276 x_275)))))) =>
                           P Hterm)))))))
      :=
      x1 : cic.Univ (cic.type cic.z) =>
      x2 :
        cic.Term (cic.type cic.z)
          (cic.prod (cic.type cic.z) (cic.type cic.z) x1
             (__ : cic.Term (cic.type cic.z) x1 => cic.univ cic.prop)) =>
      x3 :
        cic.Term (cic.type cic.z)
          (cic.prod (cic.type cic.z) (cic.type cic.z) x1
             (__ : cic.Term (cic.type cic.z) x1 => cic.univ cic.prop)) =>
      Hterm :
        cic.Term cic.prop
          (matita_basics_logic.ex2
             (cic.lift (cic.type cic.z) (cic.type cic.z) x1) x2 x3) =>
      P :
        cic.Term (cic.type cic.z)
          (cic.prod cic.prop (cic.type cic.z)
             (matita_basics_logic.ex2
                (cic.lift (cic.type cic.z) (cic.type cic.z) x1) x2 x3)
             (_z521 :
                cic.Term cic.prop
                  (matita_basics_logic.ex2
                     (cic.lift (cic.type cic.z) (cic.type cic.z) x1) x2 x3) =>
              cic.univ cic.prop)) =>
      H1 :
        cic.Term cic.prop
          (cic.prod (cic.type cic.z) cic.prop x1
             (x : cic.Term (cic.type cic.z) x1 =>
              cic.prod cic.prop cic.prop (x2 x)
                (x_276 : cic.Term cic.prop (x2 x) =>
                 cic.prod cic.prop cic.prop (x3 x)
                   (x_275 : cic.Term cic.prop (x3 x) =>
                    cic.prod cic.prop cic.prop
                      (matita_basics_logic.eq
                         (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                            (matita_basics_logic.ex2
                               (cic.lift (cic.type cic.z) (cic.type cic.z) x1)
                               x2 x3))
                         Hterm
                         (matita_basics_logic.ex2_intro
                            (cic.lift (cic.type cic.z) (cic.type cic.z) x1)
                            x2 x3 x x_276 x_275))
                      (_z522 :
                         cic.Term cic.prop
                           (matita_basics_logic.eq
                              (cic.lift cic.prop
                                 (cic.type (cic.s (cic.s cic.z)))
                                 (matita_basics_logic.ex2
                                    (cic.lift (cic.type cic.z)
                                       (cic.type cic.z) x1)
                                    x2 x3))
                              Hterm
                              (matita_basics_logic.ex2_intro
                                 (cic.lift (cic.type cic.z) (cic.type cic.z)
                                    x1)
                                 x2 x3 x x_276 x_275)) =>
                       P
                         (matita_basics_logic.ex2_intro
                            (cic.lift (cic.type cic.z) (cic.type cic.z) x1)
                            x2 x3 x x_276 x_275)))))) =>
      (Hcut :
         cic.Term cic.prop
           (cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.ex2
                       (cic.lift (cic.type cic.z) (cic.type cic.z) x1) x2 x3))
                 Hterm Hterm)
              (_z522 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.ex2
                            (cic.lift (cic.type cic.z) (cic.type cic.z) x1)
                            x2 x3))
                      Hterm Hterm) =>
               P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
               (matita_basics_logic.ex2
                  (cic.lift (cic.type cic.z) (cic.type cic.z) x1) x2 x3))
            Hterm))
        (matita_basics_logic.ex2_ind
           (cic.lift (cic.type cic.z) (cic.type cic.z) x1) x2 x3
           (_x_274 :
              cic.Term cic.prop
                (matita_basics_logic.ex2
                   (cic.lift (cic.type cic.z) (cic.type cic.z) x1) x2 x3) =>
            cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                    (matita_basics_logic.ex2
                       (cic.lift (cic.type cic.z) (cic.type cic.z) x1) x2 x3))
                 Hterm _x_274)
              (_z522 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                         (matita_basics_logic.ex2
                            (cic.lift (cic.type cic.z) (cic.type cic.z) x1)
                            x2 x3))
                      Hterm _x_274) =>
               P _x_274))
           H1 Hterm).

def ex2_commute :
      cic.Term cic.prop
        (cic.prod (cic.type (cic.s cic.z)) cic.prop
           (cic.univ (cic.type cic.z))
           (A0 : cic.Univ (cic.type cic.z) =>
            cic.prod (cic.type cic.z) cic.prop
              (cic.prod (cic.type cic.z) (cic.type cic.z) A0
                 (__ : cic.Term (cic.type cic.z) A0 => cic.univ cic.prop))
              (P0 :
                 cic.Term (cic.type cic.z)
                   (cic.prod (cic.type cic.z) (cic.type cic.z) A0
                      (__ : cic.Term (cic.type cic.z) A0 => cic.univ cic.prop)) =>
               cic.prod (cic.type cic.z) cic.prop
                 (cic.prod (cic.type cic.z) (cic.type cic.z) A0
                    (__ : cic.Term (cic.type cic.z) A0 => cic.univ cic.prop))
                 (P1 :
                    cic.Term (cic.type cic.z)
                      (cic.prod (cic.type cic.z) (cic.type cic.z) A0
                         (__ : cic.Term (cic.type cic.z) A0 =>
                          cic.univ cic.prop)) =>
                  cic.prod cic.prop cic.prop
                    (matita_basics_logic.ex2
                       (cic.lift (cic.type cic.z) (cic.type cic.z) A0)
                       (x0 : cic.Term (cic.type cic.z) A0 => P0 x0)
                       (x0 : cic.Term (cic.type cic.z) A0 => P1 x0))
                    (__ :
                       cic.Term cic.prop
                         (matita_basics_logic.ex2
                            (cic.lift (cic.type cic.z) (cic.type cic.z) A0)
                            (x0 : cic.Term (cic.type cic.z) A0 => P0 x0)
                            (x0 : cic.Term (cic.type cic.z) A0 => P1 x0)) =>
                     matita_basics_logic.ex2
                       (cic.lift (cic.type cic.z) (cic.type cic.z) A0)
                       (x0 : cic.Term (cic.type cic.z) A0 => P1 x0)
                       (x0 : cic.Term (cic.type cic.z) A0 => P0 x0))))))
      :=
      A0 : cic.Univ (cic.type cic.z) =>
      P0 :
        cic.Term (cic.type cic.z)
          (cic.prod (cic.type cic.z) (cic.type cic.z) A0
             (__ : cic.Term (cic.type cic.z) A0 => cic.univ cic.prop)) =>
      P1 :
        cic.Term (cic.type cic.z)
          (cic.prod (cic.type cic.z) (cic.type cic.z) A0
             (__ : cic.Term (cic.type cic.z) A0 => cic.univ cic.prop)) =>
      _clearme :
        cic.Term cic.prop
          (matita_basics_logic.ex2
             (cic.lift (cic.type cic.z) (cic.type cic.z) A0)
             (x0 : cic.Term (cic.type cic.z) A0 => P0 x0)
             (x0 : cic.Term (cic.type cic.z) A0 => P1 x0)) =>
      matita_basics_logic.match_ex2_Prop
        (cic.lift (cic.type cic.z) (cic.type cic.z) A0)
        (x0 : cic.Term (cic.type cic.z) A0 => P0 x0)
        (x0 : cic.Term (cic.type cic.z) A0 => P1 x0)
        (__ :
           cic.Term cic.prop
             (matita_basics_logic.ex2
                (cic.lift (cic.type cic.z) (cic.type cic.z) A0)
                (x0 : cic.Term (cic.type cic.z) A0 => P0 x0)
                (x0 : cic.Term (cic.type cic.z) A0 => P1 x0)) =>
         matita_basics_logic.ex2
           (cic.lift (cic.type cic.z) (cic.type cic.z) A0)
           (x0 : cic.Term (cic.type cic.z) A0 => P1 x0)
           (x0 : cic.Term (cic.type cic.z) A0 => P0 x0))
        (x : cic.Term (cic.type cic.z) A0 =>
         auto : cic.Term cic.prop (P0 x) =>
         auto' : cic.Term cic.prop (P1 x) =>
         matita_basics_logic.ex2_intro
           (cic.lift (cic.type cic.z) (cic.type cic.z) A0)
           (x0 : cic.Term (cic.type cic.z) A0 => P1 x0)
           (x0 : cic.Term (cic.type cic.z) A0 => P0 x0) x auto' auto)
        _clearme.

def iff :
      cic.Term (cic.type cic.z)
        (cic.prod (cic.type cic.z) (cic.type cic.z) (cic.univ cic.prop)
           (_A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) (cic.type cic.z) (cic.univ cic.prop)
              (_B : cic.Univ cic.prop => cic.univ cic.prop)))
      :=
      A : cic.Univ cic.prop =>
      B : cic.Univ cic.prop =>
      matita_basics_logic.And
        (cic.lift cic.prop cic.prop
           (cic.prod cic.prop cic.prop A (__ : cic.Term cic.prop A => B)))
        (cic.lift cic.prop cic.prop
           (cic.prod cic.prop cic.prop B (__ : cic.Term cic.prop B => A))).

def iff_sym :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
           (A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
              (B : cic.Univ cic.prop =>
               cic.prod cic.prop cic.prop
                 (matita_basics_logic.iff (cic.lift cic.prop cic.prop A)
                    (cic.lift cic.prop cic.prop B))
                 (__ :
                    cic.Term cic.prop
                      (matita_basics_logic.iff (cic.lift cic.prop cic.prop A)
                         (cic.lift cic.prop cic.prop B)) =>
                  matita_basics_logic.iff (cic.lift cic.prop cic.prop B)
                    (cic.lift cic.prop cic.prop A)))))
      :=
      A : cic.Univ cic.prop =>
      B : cic.Univ cic.prop =>
      _clearme :
        cic.Term cic.prop
          (matita_basics_logic.iff (cic.lift cic.prop cic.prop A)
             (cic.lift cic.prop cic.prop B)) =>
      matita_basics_logic.match_And_Prop
        (cic.lift cic.prop cic.prop
           (cic.prod cic.prop cic.prop A (__ : cic.Term cic.prop A => B)))
        (cic.lift cic.prop cic.prop
           (cic.prod cic.prop cic.prop B (__ : cic.Term cic.prop B => A)))
        (__ :
           cic.Term cic.prop
             (matita_basics_logic.And
                (cic.lift cic.prop cic.prop
                   (cic.prod cic.prop cic.prop A
                      (__ : cic.Term cic.prop A => B)))
                (cic.lift cic.prop cic.prop
                   (cic.prod cic.prop cic.prop B
                      (__ : cic.Term cic.prop B => A)))) =>
         matita_basics_logic.iff (cic.lift cic.prop cic.prop B)
           (cic.lift cic.prop cic.prop A))
        (auto :
           cic.Term cic.prop
             (cic.prod cic.prop cic.prop A (__ : cic.Term cic.prop A => B)) =>
         auto' :
           cic.Term cic.prop
             (cic.prod cic.prop cic.prop B (__ : cic.Term cic.prop B => A)) =>
         matita_basics_logic.conj
           (cic.lift cic.prop cic.prop
              (cic.prod cic.prop cic.prop B (__ : cic.Term cic.prop B => A)))
           (cic.lift cic.prop cic.prop
              (cic.prod cic.prop cic.prop A (__ : cic.Term cic.prop A => B)))
           (auto'' : cic.Term cic.prop B => auto' auto'')
           (auto'' : cic.Term cic.prop A => auto auto''))
        _clearme.

def iff_trans :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
           (A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
              (B : cic.Univ cic.prop =>
               cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
                 (C : cic.Univ cic.prop =>
                  cic.prod cic.prop cic.prop
                    (matita_basics_logic.iff (cic.lift cic.prop cic.prop A)
                       (cic.lift cic.prop cic.prop B))
                    (__ :
                       cic.Term cic.prop
                         (matita_basics_logic.iff
                            (cic.lift cic.prop cic.prop A)
                            (cic.lift cic.prop cic.prop B)) =>
                     cic.prod cic.prop cic.prop
                       (matita_basics_logic.iff
                          (cic.lift cic.prop cic.prop B)
                          (cic.lift cic.prop cic.prop C))
                       (__1 :
                          cic.Term cic.prop
                            (matita_basics_logic.iff
                               (cic.lift cic.prop cic.prop B)
                               (cic.lift cic.prop cic.prop C)) =>
                        matita_basics_logic.iff
                          (cic.lift cic.prop cic.prop A)
                          (cic.lift cic.prop cic.prop C)))))))
      :=
      A : cic.Univ cic.prop =>
      B : cic.Univ cic.prop =>
      C : cic.Univ cic.prop =>
      _clearme :
        cic.Term cic.prop
          (matita_basics_logic.iff (cic.lift cic.prop cic.prop A)
             (cic.lift cic.prop cic.prop B)) =>
      matita_basics_logic.match_And_Prop
        (cic.lift cic.prop cic.prop
           (cic.prod cic.prop cic.prop A (__ : cic.Term cic.prop A => B)))
        (cic.lift cic.prop cic.prop
           (cic.prod cic.prop cic.prop B (__ : cic.Term cic.prop B => A)))
        (__ :
           cic.Term cic.prop
             (matita_basics_logic.And
                (cic.lift cic.prop cic.prop
                   (cic.prod cic.prop cic.prop A
                      (__ : cic.Term cic.prop A => B)))
                (cic.lift cic.prop cic.prop
                   (cic.prod cic.prop cic.prop B
                      (__ : cic.Term cic.prop B => A)))) =>
         cic.prod cic.prop cic.prop
           (matita_basics_logic.iff (cic.lift cic.prop cic.prop B)
              (cic.lift cic.prop cic.prop C))
           (__1 :
              cic.Term cic.prop
                (matita_basics_logic.iff (cic.lift cic.prop cic.prop B)
                   (cic.lift cic.prop cic.prop C)) =>
            matita_basics_logic.iff (cic.lift cic.prop cic.prop A)
              (cic.lift cic.prop cic.prop C)))
        (H1 :
           cic.Term cic.prop
             (cic.prod cic.prop cic.prop A (__ : cic.Term cic.prop A => B)) =>
         H2 :
           cic.Term cic.prop
             (cic.prod cic.prop cic.prop B (__ : cic.Term cic.prop B => A)) =>
         _clearme0 :
           cic.Term cic.prop
             (matita_basics_logic.iff (cic.lift cic.prop cic.prop B)
                (cic.lift cic.prop cic.prop C)) =>
         matita_basics_logic.match_And_Prop
           (cic.lift cic.prop cic.prop
              (cic.prod cic.prop cic.prop B (__ : cic.Term cic.prop B => C)))
           (cic.lift cic.prop cic.prop
              (cic.prod cic.prop cic.prop C (__ : cic.Term cic.prop C => B)))
           (__ :
              cic.Term cic.prop
                (matita_basics_logic.And
                   (cic.lift cic.prop cic.prop
                      (cic.prod cic.prop cic.prop B
                         (__ : cic.Term cic.prop B => C)))
                   (cic.lift cic.prop cic.prop
                      (cic.prod cic.prop cic.prop C
                         (__ : cic.Term cic.prop C => B)))) =>
            matita_basics_logic.iff (cic.lift cic.prop cic.prop A)
              (cic.lift cic.prop cic.prop C))
           (H3 :
              cic.Term cic.prop
                (cic.prod cic.prop cic.prop B (__ : cic.Term cic.prop B => C)) =>
            H4 :
              cic.Term cic.prop
                (cic.prod cic.prop cic.prop C (__ : cic.Term cic.prop C => B)) =>
            matita_basics_logic.conj
              (cic.lift cic.prop cic.prop
                 (cic.prod cic.prop cic.prop A
                    (__ : cic.Term cic.prop A => C)))
              (cic.lift cic.prop cic.prop
                 (cic.prod cic.prop cic.prop C
                    (__ : cic.Term cic.prop C => A)))
              (auto : cic.Term cic.prop A => H3 (H1 auto))
              (auto : cic.Term cic.prop C => H2 (H4 auto)))
           _clearme0)
        _clearme.

def iff_not :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
           (A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
              (B : cic.Univ cic.prop =>
               cic.prod cic.prop cic.prop
                 (matita_basics_logic.iff (cic.lift cic.prop cic.prop A)
                    (cic.lift cic.prop cic.prop B))
                 (__ :
                    cic.Term cic.prop
                      (matita_basics_logic.iff (cic.lift cic.prop cic.prop A)
                         (cic.lift cic.prop cic.prop B)) =>
                  matita_basics_logic.iff
                    (cic.lift cic.prop cic.prop
                       (matita_basics_logic.Not
                          (cic.lift cic.prop cic.prop A)))
                    (cic.lift cic.prop cic.prop
                       (matita_basics_logic.Not
                          (cic.lift cic.prop cic.prop B)))))))
      :=
      A : cic.Univ cic.prop =>
      B : cic.Univ cic.prop =>
      _clearme :
        cic.Term cic.prop
          (matita_basics_logic.iff (cic.lift cic.prop cic.prop A)
             (cic.lift cic.prop cic.prop B)) =>
      matita_basics_logic.match_And_Prop
        (cic.lift cic.prop cic.prop
           (cic.prod cic.prop cic.prop A (__ : cic.Term cic.prop A => B)))
        (cic.lift cic.prop cic.prop
           (cic.prod cic.prop cic.prop B (__ : cic.Term cic.prop B => A)))
        (__ :
           cic.Term cic.prop
             (matita_basics_logic.And
                (cic.lift cic.prop cic.prop
                   (cic.prod cic.prop cic.prop A
                      (__ : cic.Term cic.prop A => B)))
                (cic.lift cic.prop cic.prop
                   (cic.prod cic.prop cic.prop B
                      (__ : cic.Term cic.prop B => A)))) =>
         matita_basics_logic.iff
           (cic.lift cic.prop cic.prop
              (matita_basics_logic.Not (cic.lift cic.prop cic.prop A)))
           (cic.lift cic.prop cic.prop
              (matita_basics_logic.Not (cic.lift cic.prop cic.prop B))))
        (H1 :
           cic.Term cic.prop
             (cic.prod cic.prop cic.prop A (__ : cic.Term cic.prop A => B)) =>
         H2 :
           cic.Term cic.prop
             (cic.prod cic.prop cic.prop B (__ : cic.Term cic.prop B => A)) =>
         matita_basics_logic.conj
           (cic.lift cic.prop cic.prop
              (cic.prod cic.prop cic.prop
                 (matita_basics_logic.Not (cic.lift cic.prop cic.prop A))
                 (__ :
                    cic.Term cic.prop
                      (matita_basics_logic.Not (cic.lift cic.prop cic.prop A)) =>
                  matita_basics_logic.Not (cic.lift cic.prop cic.prop B))))
           (cic.lift cic.prop cic.prop
              (cic.prod cic.prop cic.prop
                 (matita_basics_logic.Not (cic.lift cic.prop cic.prop B))
                 (__ :
                    cic.Term cic.prop
                      (matita_basics_logic.Not (cic.lift cic.prop cic.prop B)) =>
                  matita_basics_logic.Not (cic.lift cic.prop cic.prop A))))
           (auto :
              cic.Term cic.prop
                (matita_basics_logic.Not (cic.lift cic.prop cic.prop A)) =>
            matita_basics_logic.not_to_not (cic.lift cic.prop cic.prop B)
              (cic.lift cic.prop cic.prop A)
              (auto' : cic.Term cic.prop B => H2 auto') auto)
           (auto :
              cic.Term cic.prop
                (matita_basics_logic.Not (cic.lift cic.prop cic.prop B)) =>
            matita_basics_logic.not_to_not (cic.lift cic.prop cic.prop A)
              (cic.lift cic.prop cic.prop B)
              (auto' : cic.Term cic.prop A => H1 auto') auto))
        _clearme.

def iff_and_l :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
           (A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
              (B : cic.Univ cic.prop =>
               cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
                 (C : cic.Univ cic.prop =>
                  cic.prod cic.prop cic.prop
                    (matita_basics_logic.iff (cic.lift cic.prop cic.prop A)
                       (cic.lift cic.prop cic.prop B))
                    (__ :
                       cic.Term cic.prop
                         (matita_basics_logic.iff
                            (cic.lift cic.prop cic.prop A)
                            (cic.lift cic.prop cic.prop B)) =>
                     matita_basics_logic.iff
                       (cic.lift cic.prop cic.prop
                          (matita_basics_logic.And
                             (cic.lift cic.prop cic.prop C)
                             (cic.lift cic.prop cic.prop A)))
                       (cic.lift cic.prop cic.prop
                          (matita_basics_logic.And
                             (cic.lift cic.prop cic.prop C)
                             (cic.lift cic.prop cic.prop B))))))))
      :=
      A : cic.Univ cic.prop =>
      B : cic.Univ cic.prop =>
      C : cic.Univ cic.prop =>
      _clearme :
        cic.Term cic.prop
          (matita_basics_logic.iff (cic.lift cic.prop cic.prop A)
             (cic.lift cic.prop cic.prop B)) =>
      matita_basics_logic.match_And_Prop
        (cic.lift cic.prop cic.prop
           (cic.prod cic.prop cic.prop A (__ : cic.Term cic.prop A => B)))
        (cic.lift cic.prop cic.prop
           (cic.prod cic.prop cic.prop B (__ : cic.Term cic.prop B => A)))
        (__ :
           cic.Term cic.prop
             (matita_basics_logic.And
                (cic.lift cic.prop cic.prop
                   (cic.prod cic.prop cic.prop A
                      (__ : cic.Term cic.prop A => B)))
                (cic.lift cic.prop cic.prop
                   (cic.prod cic.prop cic.prop B
                      (__ : cic.Term cic.prop B => A)))) =>
         matita_basics_logic.iff
           (cic.lift cic.prop cic.prop
              (matita_basics_logic.And (cic.lift cic.prop cic.prop C)
                 (cic.lift cic.prop cic.prop A)))
           (cic.lift cic.prop cic.prop
              (matita_basics_logic.And (cic.lift cic.prop cic.prop C)
                 (cic.lift cic.prop cic.prop B))))
        (H1 :
           cic.Term cic.prop
             (cic.prod cic.prop cic.prop A (__ : cic.Term cic.prop A => B)) =>
         H2 :
           cic.Term cic.prop
             (cic.prod cic.prop cic.prop B (__ : cic.Term cic.prop B => A)) =>
         matita_basics_logic.conj
           (cic.lift cic.prop cic.prop
              (cic.prod cic.prop cic.prop
                 (matita_basics_logic.And (cic.lift cic.prop cic.prop C)
                    (cic.lift cic.prop cic.prop A))
                 (__ :
                    cic.Term cic.prop
                      (matita_basics_logic.And (cic.lift cic.prop cic.prop C)
                         (cic.lift cic.prop cic.prop A)) =>
                  matita_basics_logic.And (cic.lift cic.prop cic.prop C)
                    (cic.lift cic.prop cic.prop B))))
           (cic.lift cic.prop cic.prop
              (cic.prod cic.prop cic.prop
                 (matita_basics_logic.And (cic.lift cic.prop cic.prop C)
                    (cic.lift cic.prop cic.prop B))
                 (__ :
                    cic.Term cic.prop
                      (matita_basics_logic.And (cic.lift cic.prop cic.prop C)
                         (cic.lift cic.prop cic.prop B)) =>
                  matita_basics_logic.And (cic.lift cic.prop cic.prop C)
                    (cic.lift cic.prop cic.prop A))))
           (_clearme0 :
              cic.Term cic.prop
                (matita_basics_logic.And (cic.lift cic.prop cic.prop C)
                   (cic.lift cic.prop cic.prop A)) =>
            matita_basics_logic.match_And_Prop (cic.lift cic.prop cic.prop C)
              (cic.lift cic.prop cic.prop A)
              (__ :
                 cic.Term cic.prop
                   (matita_basics_logic.And (cic.lift cic.prop cic.prop C)
                      (cic.lift cic.prop cic.prop A)) =>
               matita_basics_logic.And (cic.lift cic.prop cic.prop C)
                 (cic.lift cic.prop cic.prop B))
              (auto : cic.Term cic.prop C =>
               auto' : cic.Term cic.prop A =>
               matita_basics_logic.conj (cic.lift cic.prop cic.prop C)
                 (cic.lift cic.prop cic.prop B) auto (H1 auto'))
              _clearme0)
           (_clearme0 :
              cic.Term cic.prop
                (matita_basics_logic.And (cic.lift cic.prop cic.prop C)
                   (cic.lift cic.prop cic.prop B)) =>
            matita_basics_logic.match_And_Prop (cic.lift cic.prop cic.prop C)
              (cic.lift cic.prop cic.prop B)
              (__ :
                 cic.Term cic.prop
                   (matita_basics_logic.And (cic.lift cic.prop cic.prop C)
                      (cic.lift cic.prop cic.prop B)) =>
               matita_basics_logic.And (cic.lift cic.prop cic.prop C)
                 (cic.lift cic.prop cic.prop A))
              (auto : cic.Term cic.prop C =>
               auto' : cic.Term cic.prop B =>
               matita_basics_logic.conj (cic.lift cic.prop cic.prop C)
                 (cic.lift cic.prop cic.prop A) auto (H2 auto'))
              _clearme0))
        _clearme.

def iff_and_r :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
           (A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
              (B : cic.Univ cic.prop =>
               cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
                 (C : cic.Univ cic.prop =>
                  cic.prod cic.prop cic.prop
                    (matita_basics_logic.iff (cic.lift cic.prop cic.prop A)
                       (cic.lift cic.prop cic.prop B))
                    (__ :
                       cic.Term cic.prop
                         (matita_basics_logic.iff
                            (cic.lift cic.prop cic.prop A)
                            (cic.lift cic.prop cic.prop B)) =>
                     matita_basics_logic.iff
                       (cic.lift cic.prop cic.prop
                          (matita_basics_logic.And
                             (cic.lift cic.prop cic.prop A)
                             (cic.lift cic.prop cic.prop C)))
                       (cic.lift cic.prop cic.prop
                          (matita_basics_logic.And
                             (cic.lift cic.prop cic.prop B)
                             (cic.lift cic.prop cic.prop C))))))))
      :=
      A : cic.Univ cic.prop =>
      B : cic.Univ cic.prop =>
      C : cic.Univ cic.prop =>
      _clearme :
        cic.Term cic.prop
          (matita_basics_logic.iff (cic.lift cic.prop cic.prop A)
             (cic.lift cic.prop cic.prop B)) =>
      matita_basics_logic.match_And_Prop
        (cic.lift cic.prop cic.prop
           (cic.prod cic.prop cic.prop A (__ : cic.Term cic.prop A => B)))
        (cic.lift cic.prop cic.prop
           (cic.prod cic.prop cic.prop B (__ : cic.Term cic.prop B => A)))
        (__ :
           cic.Term cic.prop
             (matita_basics_logic.And
                (cic.lift cic.prop cic.prop
                   (cic.prod cic.prop cic.prop A
                      (__ : cic.Term cic.prop A => B)))
                (cic.lift cic.prop cic.prop
                   (cic.prod cic.prop cic.prop B
                      (__ : cic.Term cic.prop B => A)))) =>
         matita_basics_logic.iff
           (cic.lift cic.prop cic.prop
              (matita_basics_logic.And (cic.lift cic.prop cic.prop A)
                 (cic.lift cic.prop cic.prop C)))
           (cic.lift cic.prop cic.prop
              (matita_basics_logic.And (cic.lift cic.prop cic.prop B)
                 (cic.lift cic.prop cic.prop C))))
        (H1 :
           cic.Term cic.prop
             (cic.prod cic.prop cic.prop A (__ : cic.Term cic.prop A => B)) =>
         H2 :
           cic.Term cic.prop
             (cic.prod cic.prop cic.prop B (__ : cic.Term cic.prop B => A)) =>
         matita_basics_logic.conj
           (cic.lift cic.prop cic.prop
              (cic.prod cic.prop cic.prop
                 (matita_basics_logic.And (cic.lift cic.prop cic.prop A)
                    (cic.lift cic.prop cic.prop C))
                 (__ :
                    cic.Term cic.prop
                      (matita_basics_logic.And (cic.lift cic.prop cic.prop A)
                         (cic.lift cic.prop cic.prop C)) =>
                  matita_basics_logic.And (cic.lift cic.prop cic.prop B)
                    (cic.lift cic.prop cic.prop C))))
           (cic.lift cic.prop cic.prop
              (cic.prod cic.prop cic.prop
                 (matita_basics_logic.And (cic.lift cic.prop cic.prop B)
                    (cic.lift cic.prop cic.prop C))
                 (__ :
                    cic.Term cic.prop
                      (matita_basics_logic.And (cic.lift cic.prop cic.prop B)
                         (cic.lift cic.prop cic.prop C)) =>
                  matita_basics_logic.And (cic.lift cic.prop cic.prop A)
                    (cic.lift cic.prop cic.prop C))))
           (_clearme0 :
              cic.Term cic.prop
                (matita_basics_logic.And (cic.lift cic.prop cic.prop A)
                   (cic.lift cic.prop cic.prop C)) =>
            matita_basics_logic.match_And_Prop (cic.lift cic.prop cic.prop A)
              (cic.lift cic.prop cic.prop C)
              (__ :
                 cic.Term cic.prop
                   (matita_basics_logic.And (cic.lift cic.prop cic.prop A)
                      (cic.lift cic.prop cic.prop C)) =>
               matita_basics_logic.And (cic.lift cic.prop cic.prop B)
                 (cic.lift cic.prop cic.prop C))
              (auto : cic.Term cic.prop A =>
               auto' : cic.Term cic.prop C =>
               matita_basics_logic.conj (cic.lift cic.prop cic.prop B)
                 (cic.lift cic.prop cic.prop C) (H1 auto) auto')
              _clearme0)
           (_clearme0 :
              cic.Term cic.prop
                (matita_basics_logic.And (cic.lift cic.prop cic.prop B)
                   (cic.lift cic.prop cic.prop C)) =>
            matita_basics_logic.match_And_Prop (cic.lift cic.prop cic.prop B)
              (cic.lift cic.prop cic.prop C)
              (__ :
                 cic.Term cic.prop
                   (matita_basics_logic.And (cic.lift cic.prop cic.prop B)
                      (cic.lift cic.prop cic.prop C)) =>
               matita_basics_logic.And (cic.lift cic.prop cic.prop A)
                 (cic.lift cic.prop cic.prop C))
              (auto : cic.Term cic.prop B =>
               auto' : cic.Term cic.prop C =>
               matita_basics_logic.conj (cic.lift cic.prop cic.prop A)
                 (cic.lift cic.prop cic.prop C) (H2 auto) auto')
              _clearme0))
        _clearme.

def iff_or_l :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
           (A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
              (B : cic.Univ cic.prop =>
               cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
                 (C : cic.Univ cic.prop =>
                  cic.prod cic.prop cic.prop
                    (matita_basics_logic.iff (cic.lift cic.prop cic.prop A)
                       (cic.lift cic.prop cic.prop B))
                    (__ :
                       cic.Term cic.prop
                         (matita_basics_logic.iff
                            (cic.lift cic.prop cic.prop A)
                            (cic.lift cic.prop cic.prop B)) =>
                     matita_basics_logic.iff
                       (cic.lift cic.prop cic.prop
                          (matita_basics_logic.Or
                             (cic.lift cic.prop cic.prop C)
                             (cic.lift cic.prop cic.prop A)))
                       (cic.lift cic.prop cic.prop
                          (matita_basics_logic.Or
                             (cic.lift cic.prop cic.prop C)
                             (cic.lift cic.prop cic.prop B))))))))
      :=
      A : cic.Univ cic.prop =>
      B : cic.Univ cic.prop =>
      C : cic.Univ cic.prop =>
      _clearme :
        cic.Term cic.prop
          (matita_basics_logic.iff (cic.lift cic.prop cic.prop A)
             (cic.lift cic.prop cic.prop B)) =>
      matita_basics_logic.match_And_Prop
        (cic.lift cic.prop cic.prop
           (cic.prod cic.prop cic.prop A (__ : cic.Term cic.prop A => B)))
        (cic.lift cic.prop cic.prop
           (cic.prod cic.prop cic.prop B (__ : cic.Term cic.prop B => A)))
        (__ :
           cic.Term cic.prop
             (matita_basics_logic.And
                (cic.lift cic.prop cic.prop
                   (cic.prod cic.prop cic.prop A
                      (__ : cic.Term cic.prop A => B)))
                (cic.lift cic.prop cic.prop
                   (cic.prod cic.prop cic.prop B
                      (__ : cic.Term cic.prop B => A)))) =>
         matita_basics_logic.iff
           (cic.lift cic.prop cic.prop
              (matita_basics_logic.Or (cic.lift cic.prop cic.prop C)
                 (cic.lift cic.prop cic.prop A)))
           (cic.lift cic.prop cic.prop
              (matita_basics_logic.Or (cic.lift cic.prop cic.prop C)
                 (cic.lift cic.prop cic.prop B))))
        (H1 :
           cic.Term cic.prop
             (cic.prod cic.prop cic.prop A (__ : cic.Term cic.prop A => B)) =>
         H2 :
           cic.Term cic.prop
             (cic.prod cic.prop cic.prop B (__ : cic.Term cic.prop B => A)) =>
         matita_basics_logic.conj
           (cic.lift cic.prop cic.prop
              (cic.prod cic.prop cic.prop
                 (matita_basics_logic.Or (cic.lift cic.prop cic.prop C)
                    (cic.lift cic.prop cic.prop A))
                 (__ :
                    cic.Term cic.prop
                      (matita_basics_logic.Or (cic.lift cic.prop cic.prop C)
                         (cic.lift cic.prop cic.prop A)) =>
                  matita_basics_logic.Or (cic.lift cic.prop cic.prop C)
                    (cic.lift cic.prop cic.prop B))))
           (cic.lift cic.prop cic.prop
              (cic.prod cic.prop cic.prop
                 (matita_basics_logic.Or (cic.lift cic.prop cic.prop C)
                    (cic.lift cic.prop cic.prop B))
                 (__ :
                    cic.Term cic.prop
                      (matita_basics_logic.Or (cic.lift cic.prop cic.prop C)
                         (cic.lift cic.prop cic.prop B)) =>
                  matita_basics_logic.Or (cic.lift cic.prop cic.prop C)
                    (cic.lift cic.prop cic.prop A))))
           (_clearme0 :
              cic.Term cic.prop
                (matita_basics_logic.Or (cic.lift cic.prop cic.prop C)
                   (cic.lift cic.prop cic.prop A)) =>
            matita_basics_logic.match_Or_Prop (cic.lift cic.prop cic.prop C)
              (cic.lift cic.prop cic.prop A)
              (__ :
                 cic.Term cic.prop
                   (matita_basics_logic.Or (cic.lift cic.prop cic.prop C)
                      (cic.lift cic.prop cic.prop A)) =>
               matita_basics_logic.Or (cic.lift cic.prop cic.prop C)
                 (cic.lift cic.prop cic.prop B))
              (auto : cic.Term cic.prop C =>
               matita_basics_logic.or_introl (cic.lift cic.prop cic.prop C)
                 (cic.lift cic.prop cic.prop B) auto)
              (auto : cic.Term cic.prop A =>
               matita_basics_logic.or_intror (cic.lift cic.prop cic.prop C)
                 (cic.lift cic.prop cic.prop B) (H1 auto))
              _clearme0)
           (_clearme0 :
              cic.Term cic.prop
                (matita_basics_logic.Or (cic.lift cic.prop cic.prop C)
                   (cic.lift cic.prop cic.prop B)) =>
            matita_basics_logic.match_Or_Prop (cic.lift cic.prop cic.prop C)
              (cic.lift cic.prop cic.prop B)
              (__ :
                 cic.Term cic.prop
                   (matita_basics_logic.Or (cic.lift cic.prop cic.prop C)
                      (cic.lift cic.prop cic.prop B)) =>
               matita_basics_logic.Or (cic.lift cic.prop cic.prop C)
                 (cic.lift cic.prop cic.prop A))
              (auto : cic.Term cic.prop C =>
               matita_basics_logic.or_introl (cic.lift cic.prop cic.prop C)
                 (cic.lift cic.prop cic.prop A) auto)
              (auto : cic.Term cic.prop B =>
               matita_basics_logic.or_intror (cic.lift cic.prop cic.prop C)
                 (cic.lift cic.prop cic.prop A) (H2 auto))
              _clearme0))
        _clearme.

def iff_or_r :
      cic.Term cic.prop
        (cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
           (A : cic.Univ cic.prop =>
            cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
              (B : cic.Univ cic.prop =>
               cic.prod (cic.type cic.z) cic.prop (cic.univ cic.prop)
                 (C : cic.Univ cic.prop =>
                  cic.prod cic.prop cic.prop
                    (matita_basics_logic.iff (cic.lift cic.prop cic.prop A)
                       (cic.lift cic.prop cic.prop B))
                    (__ :
                       cic.Term cic.prop
                         (matita_basics_logic.iff
                            (cic.lift cic.prop cic.prop A)
                            (cic.lift cic.prop cic.prop B)) =>
                     matita_basics_logic.iff
                       (cic.lift cic.prop cic.prop
                          (matita_basics_logic.Or
                             (cic.lift cic.prop cic.prop A)
                             (cic.lift cic.prop cic.prop C)))
                       (cic.lift cic.prop cic.prop
                          (matita_basics_logic.Or
                             (cic.lift cic.prop cic.prop B)
                             (cic.lift cic.prop cic.prop C))))))))
      :=
      A : cic.Univ cic.prop =>
      B : cic.Univ cic.prop =>
      C : cic.Univ cic.prop =>
      _clearme :
        cic.Term cic.prop
          (matita_basics_logic.iff (cic.lift cic.prop cic.prop A)
             (cic.lift cic.prop cic.prop B)) =>
      matita_basics_logic.match_And_Prop
        (cic.lift cic.prop cic.prop
           (cic.prod cic.prop cic.prop A (__ : cic.Term cic.prop A => B)))
        (cic.lift cic.prop cic.prop
           (cic.prod cic.prop cic.prop B (__ : cic.Term cic.prop B => A)))
        (__ :
           cic.Term cic.prop
             (matita_basics_logic.And
                (cic.lift cic.prop cic.prop
                   (cic.prod cic.prop cic.prop A
                      (__ : cic.Term cic.prop A => B)))
                (cic.lift cic.prop cic.prop
                   (cic.prod cic.prop cic.prop B
                      (__ : cic.Term cic.prop B => A)))) =>
         matita_basics_logic.iff
           (cic.lift cic.prop cic.prop
              (matita_basics_logic.Or (cic.lift cic.prop cic.prop A)
                 (cic.lift cic.prop cic.prop C)))
           (cic.lift cic.prop cic.prop
              (matita_basics_logic.Or (cic.lift cic.prop cic.prop B)
                 (cic.lift cic.prop cic.prop C))))
        (H1 :
           cic.Term cic.prop
             (cic.prod cic.prop cic.prop A (__ : cic.Term cic.prop A => B)) =>
         H2 :
           cic.Term cic.prop
             (cic.prod cic.prop cic.prop B (__ : cic.Term cic.prop B => A)) =>
         matita_basics_logic.conj
           (cic.lift cic.prop cic.prop
              (cic.prod cic.prop cic.prop
                 (matita_basics_logic.Or (cic.lift cic.prop cic.prop A)
                    (cic.lift cic.prop cic.prop C))
                 (__ :
                    cic.Term cic.prop
                      (matita_basics_logic.Or (cic.lift cic.prop cic.prop A)
                         (cic.lift cic.prop cic.prop C)) =>
                  matita_basics_logic.Or (cic.lift cic.prop cic.prop B)
                    (cic.lift cic.prop cic.prop C))))
           (cic.lift cic.prop cic.prop
              (cic.prod cic.prop cic.prop
                 (matita_basics_logic.Or (cic.lift cic.prop cic.prop B)
                    (cic.lift cic.prop cic.prop C))
                 (__ :
                    cic.Term cic.prop
                      (matita_basics_logic.Or (cic.lift cic.prop cic.prop B)
                         (cic.lift cic.prop cic.prop C)) =>
                  matita_basics_logic.Or (cic.lift cic.prop cic.prop A)
                    (cic.lift cic.prop cic.prop C))))
           (_clearme0 :
              cic.Term cic.prop
                (matita_basics_logic.Or (cic.lift cic.prop cic.prop A)
                   (cic.lift cic.prop cic.prop C)) =>
            matita_basics_logic.match_Or_Prop (cic.lift cic.prop cic.prop A)
              (cic.lift cic.prop cic.prop C)
              (__ :
                 cic.Term cic.prop
                   (matita_basics_logic.Or (cic.lift cic.prop cic.prop A)
                      (cic.lift cic.prop cic.prop C)) =>
               matita_basics_logic.Or (cic.lift cic.prop cic.prop B)
                 (cic.lift cic.prop cic.prop C))
              (auto : cic.Term cic.prop A =>
               matita_basics_logic.or_introl (cic.lift cic.prop cic.prop B)
                 (cic.lift cic.prop cic.prop C) (H1 auto))
              (auto : cic.Term cic.prop C =>
               matita_basics_logic.or_intror (cic.lift cic.prop cic.prop B)
                 (cic.lift cic.prop cic.prop C) auto)
              _clearme0)
           (_clearme0 :
              cic.Term cic.prop
                (matita_basics_logic.Or (cic.lift cic.prop cic.prop B)
                   (cic.lift cic.prop cic.prop C)) =>
            matita_basics_logic.match_Or_Prop (cic.lift cic.prop cic.prop B)
              (cic.lift cic.prop cic.prop C)
              (__ :
                 cic.Term cic.prop
                   (matita_basics_logic.Or (cic.lift cic.prop cic.prop B)
                      (cic.lift cic.prop cic.prop C)) =>
               matita_basics_logic.Or (cic.lift cic.prop cic.prop A)
                 (cic.lift cic.prop cic.prop C))
              (auto : cic.Term cic.prop B =>
               matita_basics_logic.or_introl (cic.lift cic.prop cic.prop A)
                 (cic.lift cic.prop cic.prop C) (H2 auto))
              (auto : cic.Term cic.prop C =>
               matita_basics_logic.or_intror (cic.lift cic.prop cic.prop A)
                 (cic.lift cic.prop cic.prop C) auto)
              _clearme0))
        _clearme.

def R0 :
      cic.Term (cic.type (cic.s cic.z))
        (cic.prod (cic.type (cic.s cic.z)) (cic.type cic.z)
           (cic.univ (cic.type cic.z))
           (T : cic.Univ (cic.type cic.z) =>
            cic.prod (cic.type cic.z) (cic.type cic.z) T
              (_t : cic.Term (cic.type cic.z) T => T)))
      :=
      T : cic.Univ (cic.type cic.z) => t : cic.Term (cic.type cic.z) T => t.

def R1 :
      cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.type (cic.s (cic.s cic.z)))
           (cic.univ (cic.type (cic.s (cic.s cic.z))))
           (A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
            cic.prod (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s (cic.s cic.z))) A
              (_x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
               cic.prod (cic.type (cic.s (cic.s cic.z)))
                 (cic.type (cic.s (cic.s cic.z)))
                 (cic.prod (cic.type (cic.s (cic.s cic.z)))
                    (cic.type (cic.s cic.z)) A
                    (x_19 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                     cic.prod cic.prop (cic.type (cic.s cic.z))
                       (matita_basics_logic.eq
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          _x x_19)
                       (_x_20 :
                          cic.Term cic.prop
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x x_19) =>
                        cic.univ (cic.type cic.z))))
                 (Q_ :
                    cic.Term (cic.type (cic.s (cic.s cic.z)))
                      (cic.prod (cic.type (cic.s (cic.s cic.z)))
                         (cic.type (cic.s cic.z)) A
                         (x_19 :
                            cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                          cic.prod cic.prop (cic.type (cic.s cic.z))
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x x_19)
                            (_x_20 :
                               cic.Term cic.prop
                                 (matita_basics_logic.eq
                                    (cic.lift
                                       (cic.type (cic.s (cic.s cic.z)))
                                       (cic.type (cic.s (cic.s cic.z))) A)
                                    _x x_19) =>
                             cic.univ (cic.type cic.z)))) =>
                  cic.prod (cic.type cic.z) (cic.type (cic.s (cic.s cic.z)))
                    (Q_ _x
                       (matita_basics_logic.refl
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) A)
                          _x))
                    (_H_refl :
                       cic.Term (cic.type cic.z)
                         (Q_ _x
                            (matita_basics_logic.refl
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) A)
                               _x)) =>
                     cic.prod (cic.type (cic.s (cic.s cic.z)))
                       (cic.type cic.z) A
                       (x_19 : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
                        cic.prod cic.prop (cic.type cic.z)
                          (matita_basics_logic.eq
                             (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                (cic.type (cic.s (cic.s cic.z))) A)
                             _x x_19)
                          (x_20 :
                             cic.Term cic.prop
                               (matita_basics_logic.eq
                                  (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                     (cic.type (cic.s (cic.s cic.z))) A)
                                  _x x_19) =>
                           Q_ x_19 x_20)))))))
      := matita_basics_logic.eq_rect_Type0.

def R2 :
      cic.Term (cic.type (cic.s cic.z))
        (cic.prod (cic.type (cic.s cic.z)) (cic.type (cic.s cic.z))
           (cic.univ (cic.type cic.z))
           (T0 : cic.Univ (cic.type cic.z) =>
            cic.prod (cic.type cic.z) (cic.type (cic.s cic.z)) T0
              (a0 : cic.Term (cic.type cic.z) T0 =>
               cic.prod (cic.type (cic.s cic.z)) (cic.type (cic.s cic.z))
                 (cic.prod (cic.type cic.z) (cic.type (cic.s cic.z)) T0
                    (x0 : cic.Term (cic.type cic.z) T0 =>
                     cic.prod cic.prop (cic.type (cic.s cic.z))
                       (matita_basics_logic.eq
                          (cic.lift (cic.type cic.z)
                             (cic.type (cic.s (cic.s cic.z))) T0)
                          a0 x0)
                       (__ :
                          cic.Term cic.prop
                            (matita_basics_logic.eq
                               (cic.lift (cic.type cic.z)
                                  (cic.type (cic.s (cic.s cic.z))) T0)
                               a0 x0) =>
                        cic.univ (cic.type cic.z))))
                 (T1 :
                    cic.Term (cic.type (cic.s cic.z))
                      (cic.prod (cic.type cic.z) (cic.type (cic.s cic.z)) T0
                         (x0 : cic.Term (cic.type cic.z) T0 =>
                          cic.prod cic.prop (cic.type (cic.s cic.z))
                            (matita_basics_logic.eq
                               (cic.lift (cic.type cic.z)
                                  (cic.type (cic.s (cic.s cic.z))) T0)
                               a0 x0)
                            (__ :
                               cic.Term cic.prop
                                 (matita_basics_logic.eq
                                    (cic.lift (cic.type cic.z)
                                       (cic.type (cic.s (cic.s cic.z))) T0)
                                    a0 x0) =>
                             cic.univ (cic.type cic.z)))) =>
                  cic.prod (cic.type cic.z) (cic.type (cic.s cic.z))
                    (T1 a0
                       (matita_basics_logic.refl
                          (cic.lift (cic.type cic.z)
                             (cic.type (cic.s (cic.s cic.z))) T0)
                          a0))
                    (a1 :
                       cic.Term (cic.type cic.z)
                         (T1 a0
                            (matita_basics_logic.refl
                               (cic.lift (cic.type cic.z)
                                  (cic.type (cic.s (cic.s cic.z))) T0)
                               a0)) =>
                     cic.prod (cic.type (cic.s cic.z)) (cic.type cic.z)
                       (cic.prod (cic.type cic.z) (cic.type (cic.s cic.z)) T0
                          (x0 : cic.Term (cic.type cic.z) T0 =>
                           cic.prod cic.prop (cic.type (cic.s cic.z))
                             (matita_basics_logic.eq
                                (cic.lift (cic.type cic.z)
                                   (cic.type (cic.s (cic.s cic.z))) T0)
                                a0 x0)
                             (p0 :
                                cic.Term cic.prop
                                  (matita_basics_logic.eq
                                     (cic.lift (cic.type cic.z)
                                        (cic.type (cic.s (cic.s cic.z))) T0)
                                     a0 x0) =>
                              cic.prod (cic.type cic.z)
                                (cic.type (cic.s cic.z)) (T1 x0 p0)
                                (x1 : cic.Term (cic.type cic.z) (T1 x0 p0) =>
                                 cic.prod cic.prop (cic.type (cic.s cic.z))
                                   (matita_basics_logic.eq
                                      (cic.lift (cic.type cic.z)
                                         (cic.type (cic.s (cic.s cic.z)))
                                         (T1 x0 p0))
                                      (matita_basics_logic.R1
                                         (cic.lift (cic.type cic.z)
                                            (cic.type (cic.s (cic.s cic.z)))
                                            T0)
                                         a0 T1 a1 x0 p0)
                                      x1)
                                   (__ :
                                      cic.Term cic.prop
                                        (matita_basics_logic.eq
                                           (cic.lift (cic.type cic.z)
                                              (cic.type (cic.s (cic.s cic.z)))
                                              (T1 x0 p0))
                                           (matita_basics_logic.R1
                                              (cic.lift (cic.type cic.z)
                                                 (cic.type
                                                    (cic.s (cic.s cic.z)))
                                                 T0)
                                              a0 T1 a1 x0 p0)
                                           x1) =>
                                    cic.univ (cic.type cic.z))))))
                       (T2 :
                          cic.Term (cic.type (cic.s cic.z))
                            (cic.prod (cic.type cic.z)
                               (cic.type (cic.s cic.z)) T0
                               (x0 : cic.Term (cic.type cic.z) T0 =>
                                cic.prod cic.prop (cic.type (cic.s cic.z))
                                  (matita_basics_logic.eq
                                     (cic.lift (cic.type cic.z)
                                        (cic.type (cic.s (cic.s cic.z))) T0)
                                     a0 x0)
                                  (p0 :
                                     cic.Term cic.prop
                                       (matita_basics_logic.eq
                                          (cic.lift (cic.type cic.z)
                                             (cic.type (cic.s (cic.s cic.z)))
                                             T0)
                                          a0 x0) =>
                                   cic.prod (cic.type cic.z)
                                     (cic.type (cic.s cic.z)) (T1 x0 p0)
                                     (x1 :
                                        cic.Term (cic.type cic.z) (T1 x0 p0) =>
                                      cic.prod cic.prop
                                        (cic.type (cic.s cic.z))
                                        (matita_basics_logic.eq
                                           (cic.lift (cic.type cic.z)
                                              (cic.type (cic.s (cic.s cic.z)))
                                              (T1 x0 p0))
                                           (matita_basics_logic.R1
                                              (cic.lift (cic.type cic.z)
                                                 (cic.type
                                                    (cic.s (cic.s cic.z)))
                                                 T0)
                                              a0 T1 a1 x0 p0)
                                           x1)
                                        (__ :
                                           cic.Term cic.prop
                                             (matita_basics_logic.eq
                                                (cic.lift (cic.type cic.z)
                                                   (cic.type
                                                      (cic.s (cic.s cic.z)))
                                                   (T1 x0 p0))
                                                (matita_basics_logic.R1
                                                   (cic.lift (cic.type cic.z)
                                                      (cic.type
                                                         (cic.s (cic.s cic.z)))
                                                      T0)
                                                   a0 T1 a1 x0 p0)
                                                x1) =>
                                         cic.univ (cic.type cic.z)))))) =>
                        cic.prod (cic.type cic.z) (cic.type cic.z)
                          (T2 a0
                             (matita_basics_logic.refl
                                (cic.lift (cic.type cic.z)
                                   (cic.type (cic.s (cic.s cic.z))) T0)
                                a0)
                             a1
                             (matita_basics_logic.refl
                                (cic.lift (cic.type cic.z)
                                   (cic.type (cic.s (cic.s cic.z)))
                                   (T1 a0
                                      (matita_basics_logic.refl
                                         (cic.lift (cic.type cic.z)
                                            (cic.type (cic.s (cic.s cic.z)))
                                            T0)
                                         a0)))
                                a1))
                          (_a2 :
                             cic.Term (cic.type cic.z)
                               (T2 a0
                                  (matita_basics_logic.refl
                                     (cic.lift (cic.type cic.z)
                                        (cic.type (cic.s (cic.s cic.z))) T0)
                                     a0)
                                  a1
                                  (matita_basics_logic.refl
                                     (cic.lift (cic.type cic.z)
                                        (cic.type (cic.s (cic.s cic.z)))
                                        (T1 a0
                                           (matita_basics_logic.refl
                                              (cic.lift (cic.type cic.z)
                                                 (cic.type
                                                    (cic.s (cic.s cic.z)))
                                                 T0)
                                              a0)))
                                     a1)) =>
                           cic.prod (cic.type cic.z) (cic.type cic.z) T0
                             (b0 : cic.Term (cic.type cic.z) T0 =>
                              cic.prod cic.prop (cic.type cic.z)
                                (matita_basics_logic.eq
                                   (cic.lift (cic.type cic.z)
                                      (cic.type (cic.s (cic.s cic.z))) T0)
                                   a0 b0)
                                (e0 :
                                   cic.Term cic.prop
                                     (matita_basics_logic.eq
                                        (cic.lift (cic.type cic.z)
                                           (cic.type (cic.s (cic.s cic.z)))
                                           T0)
                                        a0 b0) =>
                                 cic.prod (cic.type cic.z) (cic.type cic.z)
                                   (T1 b0 e0)
                                   (b1 :
                                      cic.Term (cic.type cic.z) (T1 b0 e0) =>
                                    cic.prod cic.prop (cic.type cic.z)
                                      (matita_basics_logic.eq
                                         (cic.lift (cic.type cic.z)
                                            (cic.type (cic.s (cic.s cic.z)))
                                            (T1 b0 e0))
                                         (matita_basics_logic.R1
                                            (cic.lift (cic.type cic.z)
                                               (cic.type
                                                  (cic.s (cic.s cic.z)))
                                               T0)
                                            a0 T1 a1 b0 e0)
                                         b1)
                                      (e1 :
                                         cic.Term cic.prop
                                           (matita_basics_logic.eq
                                              (cic.lift (cic.type cic.z)
                                                 (cic.type
                                                    (cic.s (cic.s cic.z)))
                                                 (T1 b0 e0))
                                              (matita_basics_logic.R1
                                                 (cic.lift (cic.type cic.z)
                                                    (cic.type
                                                       (cic.s (cic.s cic.z)))
                                                    T0)
                                                 a0 T1 a1 b0 e0)
                                              b1) =>
                                       T2 b0 e0 b1 e1)))))))))))
      :=
      T0 : cic.Univ (cic.type cic.z) =>
      a0 : cic.Term (cic.type cic.z) T0 =>
      T1 :
        cic.Term (cic.type (cic.s cic.z))
          (cic.prod (cic.type cic.z) (cic.type (cic.s cic.z)) T0
             (x0 : cic.Term (cic.type cic.z) T0 =>
              cic.prod cic.prop (cic.type (cic.s cic.z))
                (matita_basics_logic.eq
                   (cic.lift (cic.type cic.z)
                      (cic.type (cic.s (cic.s cic.z))) T0)
                   a0 x0)
                (__ :
                   cic.Term cic.prop
                     (matita_basics_logic.eq
                        (cic.lift (cic.type cic.z)
                           (cic.type (cic.s (cic.s cic.z))) T0)
                        a0 x0) =>
                 cic.univ (cic.type cic.z)))) =>
      a1 :
        cic.Term (cic.type cic.z)
          (T1 a0
             (matita_basics_logic.refl
                (cic.lift (cic.type cic.z) (cic.type (cic.s (cic.s cic.z)))
                   T0)
                a0)) =>
      T2 :
        cic.Term (cic.type (cic.s cic.z))
          (cic.prod (cic.type cic.z) (cic.type (cic.s cic.z)) T0
             (x0 : cic.Term (cic.type cic.z) T0 =>
              cic.prod cic.prop (cic.type (cic.s cic.z))
                (matita_basics_logic.eq
                   (cic.lift (cic.type cic.z)
                      (cic.type (cic.s (cic.s cic.z))) T0)
                   a0 x0)
                (p0 :
                   cic.Term cic.prop
                     (matita_basics_logic.eq
                        (cic.lift (cic.type cic.z)
                           (cic.type (cic.s (cic.s cic.z))) T0)
                        a0 x0) =>
                 cic.prod (cic.type cic.z) (cic.type (cic.s cic.z))
                   (T1 x0 p0)
                   (x1 : cic.Term (cic.type cic.z) (T1 x0 p0) =>
                    cic.prod cic.prop (cic.type (cic.s cic.z))
                      (matita_basics_logic.eq
                         (cic.lift (cic.type cic.z)
                            (cic.type (cic.s (cic.s cic.z))) (T1 x0 p0))
                         (matita_basics_logic.R1
                            (cic.lift (cic.type cic.z)
                               (cic.type (cic.s (cic.s cic.z))) T0)
                            a0 T1 a1 x0 p0)
                         x1)
                      (__ :
                         cic.Term cic.prop
                           (matita_basics_logic.eq
                              (cic.lift (cic.type cic.z)
                                 (cic.type (cic.s (cic.s cic.z))) (T1 x0 p0))
                              (matita_basics_logic.R1
                                 (cic.lift (cic.type cic.z)
                                    (cic.type (cic.s (cic.s cic.z))) T0)
                                 a0 T1 a1 x0 p0)
                              x1) =>
                       cic.univ (cic.type cic.z)))))) =>
      a2 :
        cic.Term (cic.type cic.z)
          (T2 a0
             (matita_basics_logic.refl
                (cic.lift (cic.type cic.z) (cic.type (cic.s (cic.s cic.z)))
                   T0)
                a0)
             a1
             (matita_basics_logic.refl
                (cic.lift (cic.type cic.z) (cic.type (cic.s (cic.s cic.z)))
                   (T1 a0
                      (matita_basics_logic.refl
                         (cic.lift (cic.type cic.z)
                            (cic.type (cic.s (cic.s cic.z))) T0)
                         a0)))
                a1)) =>
      b0 : cic.Term (cic.type cic.z) T0 =>
      e0 :
        cic.Term cic.prop
          (matita_basics_logic.eq
             (cic.lift (cic.type cic.z) (cic.type (cic.s (cic.s cic.z))) T0)
             a0 b0) =>
      b1 : cic.Term (cic.type cic.z) (T1 b0 e0) =>
      e1 :
        cic.Term cic.prop
          (matita_basics_logic.eq
             (cic.lift (cic.type cic.z) (cic.type (cic.s (cic.s cic.z)))
                (T1 b0 e0))
             (matita_basics_logic.R1
                (cic.lift (cic.type cic.z) (cic.type (cic.s (cic.s cic.z)))
                   T0)
                a0 T1 a1 b0 e0)
             b1) =>
      matita_basics_logic.eq_rect_Type0
        (cic.lift (cic.type cic.z) (cic.type (cic.s (cic.s cic.z)))
           (T1 b0 e0))
        (matita_basics_logic.R1
           (cic.lift (cic.type cic.z) (cic.type (cic.s (cic.s cic.z))) T0) a0
           T1 a1 b0 e0)
        (T2 b0 e0)
        (matita_basics_logic.R1
           (cic.lift (cic.type cic.z) (cic.type (cic.s (cic.s cic.z))) T0) a0
           (x_19 : cic.Term (cic.type cic.z) T0 =>
            _x_20 :
              cic.Term cic.prop
                (matita_basics_logic.eq
                   (cic.lift (cic.type cic.z)
                      (cic.type (cic.s (cic.s cic.z))) T0)
                   a0 x_19) =>
            T2 x_19 _x_20
              (matita_basics_logic.R1
                 (cic.lift (cic.type cic.z) (cic.type (cic.s (cic.s cic.z)))
                    T0)
                 a0 T1 a1 x_19 _x_20)
              (matita_basics_logic.refl
                 (cic.lift (cic.type cic.z) (cic.type (cic.s (cic.s cic.z)))
                    (T1 x_19 _x_20))
                 (matita_basics_logic.R1
                    (cic.lift (cic.type cic.z)
                       (cic.type (cic.s (cic.s cic.z))) T0)
                    a0 T1 a1 x_19 _x_20)))
           a2 b0 e0)
        b1 e1.
(;
def R3 :
      cic.Term (cic.type (cic.s cic.z))
        (cic.prod (cic.type (cic.s cic.z)) (cic.type (cic.s cic.z))
           (cic.univ (cic.type cic.z))
           (T0 : cic.Univ (cic.type cic.z) =>
            cic.prod (cic.type cic.z) (cic.type (cic.s cic.z)) T0
              (a0 : cic.Term (cic.type cic.z) T0 =>
               cic.prod (cic.type (cic.s cic.z)) (cic.type (cic.s cic.z))
                 (cic.prod (cic.type cic.z) (cic.type (cic.s cic.z)) T0
                    (x0 : cic.Term (cic.type cic.z) T0 =>
                     cic.prod cic.prop (cic.type (cic.s cic.z))
                       (matita_basics_logic.eq
                          (cic.lift (cic.type cic.z)
                             (cic.type (cic.s (cic.s cic.z))) T0)
                          a0 x0)
                       (__ :
                          cic.Term cic.prop
                            (matita_basics_logic.eq
                               (cic.lift (cic.type cic.z)
                                  (cic.type (cic.s (cic.s cic.z))) T0)
                               a0 x0) =>
                        cic.univ (cic.type cic.z))))
                 (T1 :
                    cic.Term (cic.type (cic.s cic.z))
                      (cic.prod (cic.type cic.z) (cic.type (cic.s cic.z)) T0
                         (x0 : cic.Term (cic.type cic.z) T0 =>
                          cic.prod cic.prop (cic.type (cic.s cic.z))
                            (matita_basics_logic.eq
                               (cic.lift (cic.type cic.z)
                                  (cic.type (cic.s (cic.s cic.z))) T0)
                               a0 x0)
                            (__ :
                               cic.Term cic.prop
                                 (matita_basics_logic.eq
                                    (cic.lift (cic.type cic.z)
                                       (cic.type (cic.s (cic.s cic.z))) T0)
                                    a0 x0) =>
                             cic.univ (cic.type cic.z)))) =>
                  cic.prod (cic.type cic.z) (cic.type (cic.s cic.z))
                    (T1 a0
                       (matita_basics_logic.refl
                          (cic.lift (cic.type cic.z)
                             (cic.type (cic.s (cic.s cic.z))) T0)
                          a0))
                    (a1 :
                       cic.Term (cic.type cic.z)
                         (T1 a0
                            (matita_basics_logic.refl
                               (cic.lift (cic.type cic.z)
                                  (cic.type (cic.s (cic.s cic.z))) T0)
                               a0)) =>
                     cic.prod (cic.type (cic.s cic.z))
                       (cic.type (cic.s cic.z))
                       (cic.prod (cic.type cic.z) (cic.type (cic.s cic.z)) T0
                          (x0 : cic.Term (cic.type cic.z) T0 =>
                           cic.prod cic.prop (cic.type (cic.s cic.z))
                             (matita_basics_logic.eq
                                (cic.lift (cic.type cic.z)
                                   (cic.type (cic.s (cic.s cic.z))) T0)
                                a0 x0)
                             (p0 :
                                cic.Term cic.prop
                                  (matita_basics_logic.eq
                                     (cic.lift (cic.type cic.z)
                                        (cic.type (cic.s (cic.s cic.z))) T0)
                                     a0 x0) =>
                              cic.prod (cic.type cic.z)
                                (cic.type (cic.s cic.z)) (T1 x0 p0)
                                (x1 : cic.Term (cic.type cic.z) (T1 x0 p0) =>
                                 cic.prod cic.prop (cic.type (cic.s cic.z))
                                   (matita_basics_logic.eq
                                      (cic.lift (cic.type cic.z)
                                         (cic.type (cic.s (cic.s cic.z)))
                                         (T1 x0 p0))
                                      (matita_basics_logic.R1
                                         (cic.lift (cic.type cic.z)
                                            (cic.type (cic.s (cic.s cic.z)))
                                            T0)
                                         a0 T1 a1 x0 p0)
                                      x1)
                                   (__ :
                                      cic.Term cic.prop
                                        (matita_basics_logic.eq
                                           (cic.lift (cic.type cic.z)
                                              (cic.type (cic.s (cic.s cic.z)))
                                              (T1 x0 p0))
                                           (matita_basics_logic.R1
                                              (cic.lift (cic.type cic.z)
                                                 (cic.type
                                                    (cic.s (cic.s cic.z)))
                                                 T0)
                                              a0 T1 a1 x0 p0)
                                           x1) =>
                                    cic.univ (cic.type cic.z))))))
                       (T2 :
                          cic.Term (cic.type (cic.s cic.z))
                            (cic.prod (cic.type cic.z)
                               (cic.type (cic.s cic.z)) T0
                               (x0 : cic.Term (cic.type cic.z) T0 =>
                                cic.prod cic.prop (cic.type (cic.s cic.z))
                                  (matita_basics_logic.eq
                                     (cic.lift (cic.type cic.z)
                                        (cic.type (cic.s (cic.s cic.z))) T0)
                                     a0 x0)
                                  (p0 :
                                     cic.Term cic.prop
                                       (matita_basics_logic.eq
                                          (cic.lift (cic.type cic.z)
                                             (cic.type (cic.s (cic.s cic.z)))
                                             T0)
                                          a0 x0) =>
                                   cic.prod (cic.type cic.z)
                                     (cic.type (cic.s cic.z)) (T1 x0 p0)
                                     (x1 :
                                        cic.Term (cic.type cic.z) (T1 x0 p0) =>
                                      cic.prod cic.prop
                                        (cic.type (cic.s cic.z))
                                        (matita_basics_logic.eq
                                           (cic.lift (cic.type cic.z)
                                              (cic.type (cic.s (cic.s cic.z)))
                                              (T1 x0 p0))
                                           (matita_basics_logic.R1
                                              (cic.lift (cic.type cic.z)
                                                 (cic.type
                                                    (cic.s (cic.s cic.z)))
                                                 T0)
                                              a0 T1 a1 x0 p0)
                                           x1)
                                        (__ :
                                           cic.Term cic.prop
                                             (matita_basics_logic.eq
                                                (cic.lift (cic.type cic.z)
                                                   (cic.type
                                                      (cic.s (cic.s cic.z)))
                                                   (T1 x0 p0))
                                                (matita_basics_logic.R1
                                                   (cic.lift (cic.type cic.z)
                                                      (cic.type
                                                         (cic.s (cic.s cic.z)))
                                                      T0)
                                                   a0 T1 a1 x0 p0)
                                                x1) =>
                                         cic.univ (cic.type cic.z)))))) =>
                        cic.prod (cic.type cic.z) (cic.type (cic.s cic.z))
                          (T2 a0
                             (matita_basics_logic.refl
                                (cic.lift (cic.type cic.z)
                                   (cic.type (cic.s (cic.s cic.z))) T0)
                                a0)
                             a1
                             (matita_basics_logic.refl
                                (cic.lift (cic.type cic.z)
                                   (cic.type (cic.s (cic.s cic.z)))
                                   (T1 a0
                                      (matita_basics_logic.refl
                                         (cic.lift (cic.type cic.z)
                                            (cic.type (cic.s (cic.s cic.z)))
                                            T0)
                                         a0)))
                                a1))
                          (a2 :
                             cic.Term (cic.type cic.z)
                               (T2 a0
                                  (matita_basics_logic.refl
                                     (cic.lift (cic.type cic.z)
                                        (cic.type (cic.s (cic.s cic.z))) T0)
                                     a0)
                                  a1
                                  (matita_basics_logic.refl
                                     (cic.lift (cic.type cic.z)
                                        (cic.type (cic.s (cic.s cic.z)))
                                        (T1 a0
                                           (matita_basics_logic.refl
                                              (cic.lift (cic.type cic.z)
                                                 (cic.type
                                                    (cic.s (cic.s cic.z)))
                                                 T0)
                                              a0)))
                                     a1)) =>
                           cic.prod (cic.type (cic.s cic.z)) (cic.type cic.z)
                             (cic.prod (cic.type cic.z)
                                (cic.type (cic.s cic.z)) T0
                                (x0 : cic.Term (cic.type cic.z) T0 =>
                                 cic.prod cic.prop (cic.type (cic.s cic.z))
                                   (matita_basics_logic.eq
                                      (cic.lift (cic.type cic.z)
                                         (cic.type (cic.s (cic.s cic.z))) T0)
                                      a0 x0)
                                   (p0 :
                                      cic.Term cic.prop
                                        (matita_basics_logic.eq
                                           (cic.lift (cic.type cic.z)
                                              (cic.type (cic.s (cic.s cic.z)))
                                              T0)
                                           a0 x0) =>
                                    cic.prod (cic.type cic.z)
                                      (cic.type (cic.s cic.z)) (T1 x0 p0)
                                      (x1 :
                                         cic.Term (cic.type cic.z) (T1 x0 p0) =>
                                       cic.prod cic.prop
                                         (cic.type (cic.s cic.z))
                                         (matita_basics_logic.eq
                                            (cic.lift (cic.type cic.z)
                                               (cic.type
                                                  (cic.s (cic.s cic.z)))
                                               (T1 x0 p0))
                                            (matita_basics_logic.R1
                                               (cic.lift (cic.type cic.z)
                                                  (cic.type
                                                     (cic.s (cic.s cic.z)))
                                                  T0)
                                               a0 T1 a1 x0 p0)
                                            x1)
                                         (p1 :
                                            cic.Term cic.prop
                                              (matita_basics_logic.eq
                                                 (cic.lift (cic.type cic.z)
                                                    (cic.type
                                                       (cic.s (cic.s cic.z)))
                                                    (T1 x0 p0))
                                                 (matita_basics_logic.R1
                                                    (cic.lift
                                                       (cic.type cic.z)
                                                       (cic.type
                                                          (cic.s
                                                             (cic.s cic.z)))
                                                       T0)
                                                    a0 T1 a1 x0 p0)
                                                 x1) =>
                                          cic.prod (cic.type cic.z)
                                            (cic.type (cic.s cic.z))
                                            (T2 x0 p0 x1 p1)
                                            (x2 :
                                               cic.Term (cic.type cic.z)
                                                 (T2 x0 p0 x1 p1) =>
                                             cic.prod cic.prop
                                               (cic.type (cic.s cic.z))
                                               (matita_basics_logic.eq
                                                  (cic.lift (cic.type cic.z)
                                                     (cic.type
                                                        (cic.s (cic.s cic.z)))
                                                     (T2 x0 p0 x1 p1))
                                                  (matita_basics_logic.R2
                                                     (cic.lift
                                                        (cic.type cic.z)
                                                        (cic.type cic.z) T0)
                                                     a0 T1 a1 T2 a2 x0 p0 x1
                                                     p1)
                                                  x2)
                                               (__ :
                                                  cic.Term cic.prop
                                                    (matita_basics_logic.eq
                                                       (cic.lift
                                                          (cic.type cic.z)
                                                          (cic.type
                                                             (cic.s
                                                                (cic.s cic.z)))
                                                          (T2 x0 p0 x1 p1))
                                                       (matita_basics_logic.R2
                                                          (cic.lift
                                                             (cic.type cic.z)
                                                             (cic.type cic.z)
                                                             T0)
                                                          a0 T1 a1 T2 a2 x0
                                                          p0 x1 p1)
                                                       x2) =>
                                                cic.univ (cic.type cic.z))))))))
                             (T3 :
                                cic.Term (cic.type (cic.s cic.z))
                                  (cic.prod (cic.type cic.z)
                                     (cic.type (cic.s cic.z)) T0
                                     (x0 : cic.Term (cic.type cic.z) T0 =>
                                      cic.prod cic.prop
                                        (cic.type (cic.s cic.z))
                                        (matita_basics_logic.eq
                                           (cic.lift (cic.type cic.z)
                                              (cic.type (cic.s (cic.s cic.z)))
                                              T0)
                                           a0 x0)
                                        (p0 :
                                           cic.Term cic.prop
                                             (matita_basics_logic.eq
                                                (cic.lift (cic.type cic.z)
                                                   (cic.type
                                                      (cic.s (cic.s cic.z)))
                                                   T0)
                                                a0 x0) =>
                                         cic.prod (cic.type cic.z)
                                           (cic.type (cic.s cic.z))
                                           (T1 x0 p0)
                                           (x1 :
                                              cic.Term (cic.type cic.z)
                                                (T1 x0 p0) =>
                                            cic.prod cic.prop
                                              (cic.type (cic.s cic.z))
                                              (matita_basics_logic.eq
                                                 (cic.lift (cic.type cic.z)
                                                    (cic.type
                                                       (cic.s (cic.s cic.z)))
                                                    (T1 x0 p0))
                                                 (matita_basics_logic.R1
                                                    (cic.lift
                                                       (cic.type cic.z)
                                                       (cic.type
                                                          (cic.s
                                                             (cic.s cic.z)))
                                                       T0)
                                                    a0 T1 a1 x0 p0)
                                                 x1)
                                              (p1 :
                                                 cic.Term cic.prop
                                                   (matita_basics_logic.eq
                                                      (cic.lift
                                                         (cic.type cic.z)
                                                         (cic.type
                                                            (cic.s
                                                               (cic.s cic.z)))
                                                         (T1 x0 p0))
                                                      (matita_basics_logic.R1
                                                         (cic.lift
                                                            (cic.type cic.z)
                                                            (cic.type
                                                               (cic.s
                                                                  (cic.s
                                                                    cic.z)))
                                                            T0)
                                                         a0 T1 a1 x0 p0)
                                                      x1) =>
                                               cic.prod (cic.type cic.z)
                                                 (cic.type (cic.s cic.z))
                                                 (T2 x0 p0 x1 p1)
                                                 (x2 :
                                                    cic.Term (cic.type cic.z)
                                                      (T2 x0 p0 x1 p1) =>
                                                  cic.prod cic.prop
                                                    (cic.type (cic.s cic.z))
                                                    (matita_basics_logic.eq
                                                       (cic.lift
                                                          (cic.type cic.z)
                                                          (cic.type
                                                             (cic.s
                                                                (cic.s cic.z)))
                                                          (T2 x0 p0 x1 p1))
                                                       (matita_basics_logic.R2
                                                          (cic.lift
                                                             (cic.type cic.z)
                                                             (cic.type cic.z)
                                                             T0)
                                                          a0 T1 a1 T2 a2 x0
                                                          p0 x1 p1)
                                                       x2)
                                                    (__ :
                                                       cic.Term cic.prop
                                                         (matita_basics_logic.eq
                                                            (cic.lift
                                                               (cic.type
                                                                  cic.z)
                                                               (cic.type
                                                                  (cic.s
                                                                    (
                                                                   cic.s
                                                                    cic.z)))
                                                               (T2 x0 p0 x1
                                                                  p1))
                                                            (matita_basics_logic.R2
                                                               (cic.lift
                                                                  (cic.type
                                                                    cic.z)
                                                                  (cic.type
                                                                    cic.z)
                                                                  T0)
                                                               a0 T1 a1 T2 a2
                                                               x0 p0 x1 p1)
                                                            x2) =>
                                                     cic.univ
                                                       (cic.type cic.z)))))))) =>
                              cic.prod (cic.type cic.z) (cic.type cic.z)
                                (T3 a0
                                   (matita_basics_logic.refl
                                      (cic.lift (cic.type cic.z)
                                         (cic.type (cic.s (cic.s cic.z))) T0)
                                      a0)
                                   a1
                                   (matita_basics_logic.refl
                                      (cic.lift (cic.type cic.z)
                                         (cic.type (cic.s (cic.s cic.z)))
                                         (T1 a0
                                            (matita_basics_logic.refl
                                               (cic.lift (cic.type cic.z)
                                                  (cic.type
                                                     (cic.s (cic.s cic.z)))
                                                  T0)
                                               a0)))
                                      a1)
                                   a2
                                   (matita_basics_logic.refl
                                      (cic.lift (cic.type cic.z)
                                         (cic.type (cic.s (cic.s cic.z)))
                                         (T2 a0
                                            (matita_basics_logic.refl
                                               (cic.lift (cic.type cic.z)
                                                  (cic.type
                                                     (cic.s (cic.s cic.z)))
                                                  T0)
                                               a0)
                                            a1
                                            (matita_basics_logic.refl
                                               (cic.lift (cic.type cic.z)
                                                  (cic.type
                                                     (cic.s (cic.s cic.z)))
                                                  (T1 a0
                                                     (matita_basics_logic.refl
                                                        (cic.lift
                                                           (cic.type cic.z)
                                                           (cic.type
                                                              (cic.s
                                                                 (cic.s cic.z)))
                                                           T0)
                                                        a0)))
                                               a1)))
                                      a2))
                                (_a3 :
                                   cic.Term (cic.type cic.z)
                                     (T3 a0
                                        (matita_basics_logic.refl
                                           (cic.lift (cic.type cic.z)
                                              (cic.type (cic.s (cic.s cic.z)))
                                              T0)
                                           a0)
                                        a1
                                        (matita_basics_logic.refl
                                           (cic.lift (cic.type cic.z)
                                              (cic.type (cic.s (cic.s cic.z)))
                                              (T1 a0
                                                 (matita_basics_logic.refl
                                                    (cic.lift
                                                       (cic.type cic.z)
                                                       (cic.type
                                                          (cic.s
                                                             (cic.s cic.z)))
                                                       T0)
                                                    a0)))
                                           a1)
                                        a2
                                        (matita_basics_logic.refl
                                           (cic.lift (cic.type cic.z)
                                              (cic.type (cic.s (cic.s cic.z)))
                                              (T2 a0
                                                 (matita_basics_logic.refl
                                                    (cic.lift
                                                       (cic.type cic.z)
                                                       (cic.type
                                                          (cic.s
                                                             (cic.s cic.z)))
                                                       T0)
                                                    a0)
                                                 a1
                                                 (matita_basics_logic.refl
                                                    (cic.lift
                                                       (cic.type cic.z)
                                                       (cic.type
                                                          (cic.s
                                                             (cic.s cic.z)))
                                                       (T1 a0
                                                          (matita_basics_logic.refl
                                                             (cic.lift
                                                                (cic.type
                                                                   cic.z)
                                                                (cic.type
                                                                   (cic.s
                                                                    (
                                                                    cic.s
                                                                    cic.z)))
                                                                T0)
                                                             a0)))
                                                    a1)))
                                           a2)) =>
                                 cic.prod (cic.type cic.z) (cic.type cic.z)
                                   T0
                                   (b0 : cic.Term (cic.type cic.z) T0 =>
                                    cic.prod cic.prop (cic.type cic.z)
                                      (matita_basics_logic.eq
                                         (cic.lift (cic.type cic.z)
                                            (cic.type (cic.s (cic.s cic.z)))
                                            T0)
                                         a0 b0)
                                      (e0 :
                                         cic.Term cic.prop
                                           (matita_basics_logic.eq
                                              (cic.lift (cic.type cic.z)
                                                 (cic.type
                                                    (cic.s (cic.s cic.z)))
                                                 T0)
                                              a0 b0) =>
                                       cic.prod (cic.type cic.z)
                                         (cic.type cic.z) (T1 b0 e0)
                                         (b1 :
                                            cic.Term (cic.type cic.z)
                                              (T1 b0 e0) =>
                                          cic.prod cic.prop (cic.type cic.z)
                                            (matita_basics_logic.eq
                                               (cic.lift (cic.type cic.z)
                                                  (cic.type
                                                     (cic.s (cic.s cic.z)))
                                                  (T1 b0 e0))
                                               (matita_basics_logic.R1
                                                  (cic.lift (cic.type cic.z)
                                                     (cic.type
                                                        (cic.s (cic.s cic.z)))
                                                     T0)
                                                  a0 T1 a1 b0 e0)
                                               b1)
                                            (e1 :
                                               cic.Term cic.prop
                                                 (matita_basics_logic.eq
                                                    (cic.lift
                                                       (cic.type cic.z)
                                                       (cic.type
                                                          (cic.s
                                                             (cic.s cic.z)))
                                                       (T1 b0 e0))
                                                    (matita_basics_logic.R1
                                                       (cic.lift
                                                          (cic.type cic.z)
                                                          (cic.type
                                                             (cic.s
                                                                (cic.s cic.z)))
                                                          T0)
                                                       a0 T1 a1 b0 e0)
                                                    b1) =>
                                             cic.prod (cic.type cic.z)
                                               (cic.type cic.z)
                                               (T2 b0 e0 b1 e1)
                                               (b2 :
                                                  cic.Term (cic.type cic.z)
                                                    (T2 b0 e0 b1 e1) =>
                                                cic.prod cic.prop
                                                  (cic.type cic.z)
                                                  (matita_basics_logic.eq
                                                     (cic.lift
                                                        (cic.type cic.z)
                                                        (cic.type
                                                           (cic.s
                                                              (cic.s cic.z)))
                                                        (T2 b0 e0 b1 e1))
                                                     (matita_basics_logic.R2
                                                        (cic.lift
                                                           (cic.type cic.z)
                                                           (cic.type cic.z)
                                                           T0)
                                                        a0 T1 a1 T2 a2 b0 e0
                                                        b1 e1)
                                                     b2)
                                                  (e2 :
                                                     cic.Term cic.prop
                                                       (matita_basics_logic.eq
                                                          (cic.lift
                                                             (cic.type cic.z)
                                                             (cic.type
                                                                (cic.s
                                                                   (cic.s
                                                                    cic.z)))
                                                             (T2 b0 e0 b1 e1))
                                                          (matita_basics_logic.R2
                                                             (cic.lift
                                                                (cic.type
                                                                   cic.z)
                                                                (cic.type
                                                                   cic.z)
                                                                T0)
                                                             a0 T1 a1 T2 a2
                                                             b0 e0 b1 e1)
                                                          b2) =>
                                                   T3 b0 e0 b1 e1 b2 e2)))))))))))))))
      :=
      T0 : cic.Univ (cic.type cic.z) =>
      a0 : cic.Term (cic.type cic.z) T0 =>
      T1 :
        cic.Term (cic.type (cic.s cic.z))
          (cic.prod (cic.type cic.z) (cic.type (cic.s cic.z)) T0
             (x0 : cic.Term (cic.type cic.z) T0 =>
              cic.prod cic.prop (cic.type (cic.s cic.z))
                (matita_basics_logic.eq
                   (cic.lift (cic.type cic.z)
                      (cic.type (cic.s (cic.s cic.z))) T0)
                   a0 x0)
                (__ :
                   cic.Term cic.prop
                     (matita_basics_logic.eq
                        (cic.lift (cic.type cic.z)
                           (cic.type (cic.s (cic.s cic.z))) T0)
                        a0 x0) =>
                 cic.univ (cic.type cic.z)))) =>
      a1 :
        cic.Term (cic.type cic.z)
          (T1 a0
             (matita_basics_logic.refl
                (cic.lift (cic.type cic.z) (cic.type (cic.s (cic.s cic.z)))
                   T0)
                a0)) =>
      T2 :
        cic.Term (cic.type (cic.s cic.z))
          (cic.prod (cic.type cic.z) (cic.type (cic.s cic.z)) T0
             (x0 : cic.Term (cic.type cic.z) T0 =>
              cic.prod cic.prop (cic.type (cic.s cic.z))
                (matita_basics_logic.eq
                   (cic.lift (cic.type cic.z)
                      (cic.type (cic.s (cic.s cic.z))) T0)
                   a0 x0)
                (p0 :
                   cic.Term cic.prop
                     (matita_basics_logic.eq
                        (cic.lift (cic.type cic.z)
                           (cic.type (cic.s (cic.s cic.z))) T0)
                        a0 x0) =>
                 cic.prod (cic.type cic.z) (cic.type (cic.s cic.z))
                   (T1 x0 p0)
                   (x1 : cic.Term (cic.type cic.z) (T1 x0 p0) =>
                    cic.prod cic.prop (cic.type (cic.s cic.z))
                      (matita_basics_logic.eq
                         (cic.lift (cic.type cic.z)
                            (cic.type (cic.s (cic.s cic.z))) (T1 x0 p0))
                         (matita_basics_logic.R1
                            (cic.lift (cic.type cic.z)
                               (cic.type (cic.s (cic.s cic.z))) T0)
                            a0 T1 a1 x0 p0)
                         x1)
                      (__ :
                         cic.Term cic.prop
                           (matita_basics_logic.eq
                              (cic.lift (cic.type cic.z)
                                 (cic.type (cic.s (cic.s cic.z))) (T1 x0 p0))
                              (matita_basics_logic.R1
                                 (cic.lift (cic.type cic.z)
                                    (cic.type (cic.s (cic.s cic.z))) T0)
                                 a0 T1 a1 x0 p0)
                              x1) =>
                       cic.univ (cic.type cic.z)))))) =>
      a2 :
        cic.Term (cic.type cic.z)
          (T2 a0
             (matita_basics_logic.refl
                (cic.lift (cic.type cic.z) (cic.type (cic.s (cic.s cic.z)))
                   T0)
                a0)
             a1
             (matita_basics_logic.refl
                (cic.lift (cic.type cic.z) (cic.type (cic.s (cic.s cic.z)))
                   (T1 a0
                      (matita_basics_logic.refl
                         (cic.lift (cic.type cic.z)
                            (cic.type (cic.s (cic.s cic.z))) T0)
                         a0)))
                a1)) =>
      T3 :
        cic.Term (cic.type (cic.s cic.z))
          (cic.prod (cic.type cic.z) (cic.type (cic.s cic.z)) T0
             (x0 : cic.Term (cic.type cic.z) T0 =>
              cic.prod cic.prop (cic.type (cic.s cic.z))
                (matita_basics_logic.eq
                   (cic.lift (cic.type cic.z)
                      (cic.type (cic.s (cic.s cic.z))) T0)
                   a0 x0)
                (p0 :
                   cic.Term cic.prop
                     (matita_basics_logic.eq
                        (cic.lift (cic.type cic.z)
                           (cic.type (cic.s (cic.s cic.z))) T0)
                        a0 x0) =>
                 cic.prod (cic.type cic.z) (cic.type (cic.s cic.z))
                   (T1 x0 p0)
                   (x1 : cic.Term (cic.type cic.z) (T1 x0 p0) =>
                    cic.prod cic.prop (cic.type (cic.s cic.z))
                      (matita_basics_logic.eq
                         (cic.lift (cic.type cic.z)
                            (cic.type (cic.s (cic.s cic.z))) (T1 x0 p0))
                         (matita_basics_logic.R1
                            (cic.lift (cic.type cic.z)
                               (cic.type (cic.s (cic.s cic.z))) T0)
                            a0 T1 a1 x0 p0)
                         x1)
                      (p1 :
                         cic.Term cic.prop
                           (matita_basics_logic.eq
                              (cic.lift (cic.type cic.z)
                                 (cic.type (cic.s (cic.s cic.z))) (T1 x0 p0))
                              (matita_basics_logic.R1
                                 (cic.lift (cic.type cic.z)
                                    (cic.type (cic.s (cic.s cic.z))) T0)
                                 a0 T1 a1 x0 p0)
                              x1) =>
                       cic.prod (cic.type cic.z) (cic.type (cic.s cic.z))
                         (T2 x0 p0 x1 p1)
                         (x2 : cic.Term (cic.type cic.z) (T2 x0 p0 x1 p1) =>
                          cic.prod cic.prop (cic.type (cic.s cic.z))
                            (matita_basics_logic.eq
                               (cic.lift (cic.type cic.z)
                                  (cic.type (cic.s (cic.s cic.z)))
                                  (T2 x0 p0 x1 p1))
                               (matita_basics_logic.R2
                                  (cic.lift (cic.type cic.z) (cic.type cic.z)
                                     T0)
                                  a0 T1 a1 T2 a2 x0 p0 x1 p1)
                               x2)
                            (__ :
                               cic.Term cic.prop
                                 (matita_basics_logic.eq
                                    (cic.lift (cic.type cic.z)
                                       (cic.type (cic.s (cic.s cic.z)))
                                       (T2 x0 p0 x1 p1))
                                    (matita_basics_logic.R2
                                       (cic.lift (cic.type cic.z)
                                          (cic.type cic.z) T0)
                                       a0 T1 a1 T2 a2 x0 p0 x1 p1)
                                    x2) =>
                             cic.univ (cic.type cic.z)))))))) =>
      a3 :
        cic.Term (cic.type cic.z)
          (T3 a0
             (matita_basics_logic.refl
                (cic.lift (cic.type cic.z) (cic.type (cic.s (cic.s cic.z)))
                   T0)
                a0)
             a1
             (matita_basics_logic.refl
                (cic.lift (cic.type cic.z) (cic.type (cic.s (cic.s cic.z)))
                   (T1 a0
                      (matita_basics_logic.refl
                         (cic.lift (cic.type cic.z)
                            (cic.type (cic.s (cic.s cic.z))) T0)
                         a0)))
                a1)
             a2
             (matita_basics_logic.refl
                (cic.lift (cic.type cic.z) (cic.type (cic.s (cic.s cic.z)))
                   (T2 a0
                      (matita_basics_logic.refl
                         (cic.lift (cic.type cic.z)
                            (cic.type (cic.s (cic.s cic.z))) T0)
                         a0)
                      a1
                      (matita_basics_logic.refl
                         (cic.lift (cic.type cic.z)
                            (cic.type (cic.s (cic.s cic.z)))
                            (T1 a0
                               (matita_basics_logic.refl
                                  (cic.lift (cic.type cic.z)
                                     (cic.type (cic.s (cic.s cic.z))) T0)
                                  a0)))
                         a1)))
                a2)) =>
      b0 : cic.Term (cic.type cic.z) T0 =>
      e0 :
        cic.Term cic.prop
          (matita_basics_logic.eq
             (cic.lift (cic.type cic.z) (cic.type (cic.s (cic.s cic.z))) T0)
             a0 b0) =>
      b1 : cic.Term (cic.type cic.z) (T1 b0 e0) =>
      e1 :
        cic.Term cic.prop
          (matita_basics_logic.eq
             (cic.lift (cic.type cic.z) (cic.type (cic.s (cic.s cic.z)))
                (T1 b0 e0))
             (matita_basics_logic.R1
                (cic.lift (cic.type cic.z) (cic.type (cic.s (cic.s cic.z)))
                   T0)
                a0 T1 a1 b0 e0)
             b1) =>
      b2 : cic.Term (cic.type cic.z) (T2 b0 e0 b1 e1) =>
      e2 :
        cic.Term cic.prop
          (matita_basics_logic.eq
             (cic.lift (cic.type cic.z) (cic.type (cic.s (cic.s cic.z)))
                (T2 b0 e0 b1 e1))
             (matita_basics_logic.R2
                (cic.lift (cic.type cic.z) (cic.type cic.z) T0) a0 T1 a1 T2
                a2 b0 e0 b1 e1)
             b2) =>
      matita_basics_logic.eq_rect_Type0
        (cic.lift (cic.type cic.z) (cic.type (cic.s (cic.s cic.z)))
           (T2 b0 e0 b1 e1))
        (matita_basics_logic.R2
           (cic.lift (cic.type cic.z) (cic.type cic.z) T0) a0 T1 a1 T2 a2 b0
           e0 b1 e1)
        (T3 b0 e0 b1 e1)
        (matita_basics_logic.R2
           (cic.lift (cic.type cic.z) (cic.type cic.z) T0) a0 T1 a1
           (x0 : cic.Term (cic.type cic.z) T0 =>
            p0 :
              cic.Term cic.prop
                (matita_basics_logic.eq
                   (cic.lift (cic.type cic.z)
                      (cic.type (cic.s (cic.s cic.z))) T0)
                   a0 x0) =>
            x1 : cic.Term (cic.type cic.z) (T1 x0 p0) =>
            __ :
              cic.Term cic.prop
                (matita_basics_logic.eq
                   (cic.lift (cic.type cic.z)
                      (cic.type (cic.s (cic.s cic.z))) (T1 x0 p0))
                   (matita_basics_logic.R1
                      (cic.lift (cic.type cic.z)
                         (cic.type (cic.s (cic.s cic.z))) T0)
                      a0 T1 a1 x0 p0)
                   x1) =>
            T3 x0 p0 x1 __
              (matita_basics_logic.R2
                 (cic.lift (cic.type cic.z) (cic.type cic.z) T0) a0 T1 a1 T2
                 a2 x0 p0 x1 __)
              (matita_basics_logic.refl
                 (cic.lift (cic.type cic.z) (cic.type (cic.s (cic.s cic.z)))
                    (T2 x0 p0 x1 __))
                 (matita_basics_logic.R2
                    (cic.lift (cic.type cic.z) (cic.type cic.z) T0) a0 T1 a1
                    T2 a2 x0 p0 x1 __)))
           a3 b0 e0 b1 e1)
        b2 e2.
;)
(;
R4 :
      cic.Term (cic.type (cic.s cic.z))
        (cic.prod (cic.type (cic.s cic.z)) (cic.type (cic.s cic.z))
           (cic.univ (cic.type cic.z))
           (T0 : cic.Univ (cic.type cic.z) =>
            cic.prod (cic.type cic.z) (cic.type (cic.s cic.z)) T0
              (a0 : cic.Term (cic.type cic.z) T0 =>
               cic.prod (cic.type (cic.s cic.z)) (cic.type (cic.s cic.z))
                 (cic.prod (cic.type cic.z) (cic.type (cic.s cic.z)) T0
                    (x0 : cic.Term (cic.type cic.z) T0 =>
                     cic.prod cic.prop (cic.type (cic.s cic.z))
                       (matita_basics_logic.eq
                          (cic.lift (cic.type cic.z)
                             (cic.type (cic.s (cic.s cic.z))) T0)
                          a0 x0)
                       (__ :
                          cic.Term cic.prop
                            (matita_basics_logic.eq
                               (cic.lift (cic.type cic.z)
                                  (cic.type (cic.s (cic.s cic.z))) T0)
                               a0 x0) =>
                        cic.univ (cic.type cic.z))))
                 (T1 :
                    cic.Term (cic.type (cic.s cic.z))
                      (cic.prod (cic.type cic.z) (cic.type (cic.s cic.z)) T0
                         (x0 : cic.Term (cic.type cic.z) T0 =>
                          cic.prod cic.prop (cic.type (cic.s cic.z))
                            (matita_basics_logic.eq
                               (cic.lift (cic.type cic.z)
                                  (cic.type (cic.s (cic.s cic.z))) T0)
                               a0 x0)
                            (__ :
                               cic.Term cic.prop
                                 (matita_basics_logic.eq
                                    (cic.lift (cic.type cic.z)
                                       (cic.type (cic.s (cic.s cic.z))) T0)
                                    a0 x0) =>
                             cic.univ (cic.type cic.z)))) =>
                  cic.prod (cic.type cic.z) (cic.type (cic.s cic.z))
                    (T1 a0
                       (matita_basics_logic.refl
                          (cic.lift (cic.type cic.z)
                             (cic.type (cic.s (cic.s cic.z))) T0)
                          a0))
                    (a1 :
                       cic.Term (cic.type cic.z)
                         (T1 a0
                            (matita_basics_logic.refl
                               (cic.lift (cic.type cic.z)
                                  (cic.type (cic.s (cic.s cic.z))) T0)
                               a0)) =>
                     cic.prod (cic.type (cic.s cic.z))
                       (cic.type (cic.s cic.z))
                       (cic.prod (cic.type cic.z) (cic.type (cic.s cic.z)) T0
                          (x0 : cic.Term (cic.type cic.z) T0 =>
                           cic.prod cic.prop (cic.type (cic.s cic.z))
                             (matita_basics_logic.eq
                                (cic.lift (cic.type cic.z)
                                   (cic.type (cic.s (cic.s cic.z))) T0)
                                a0 x0)
                             (p0 :
                                cic.Term cic.prop
                                  (matita_basics_logic.eq
                                     (cic.lift (cic.type cic.z)
                                        (cic.type (cic.s (cic.s cic.z))) T0)
                                     a0 x0) =>
                              cic.prod (cic.type cic.z)
                                (cic.type (cic.s cic.z)) (T1 x0 p0)
                                (x1 : cic.Term (cic.type cic.z) (T1 x0 p0) =>
                                 cic.prod cic.prop (cic.type (cic.s cic.z))
                                   (matita_basics_logic.eq
                                      (cic.lift (cic.type cic.z)
                                         (cic.type (cic.s (cic.s cic.z)))
                                         (T1 x0 p0))
                                      (matita_basics_logic.R1
                                         (cic.lift (cic.type cic.z)
                                            (cic.type (cic.s (cic.s cic.z)))
                                            T0)
                                         a0 T1 a1 x0 p0)
                                      x1)
                                   (__ :
                                      cic.Term cic.prop
                                        (matita_basics_logic.eq
                                           (cic.lift (cic.type cic.z)
                                              (cic.type (cic.s (cic.s cic.z)))
                                              (T1 x0 p0))
                                           (matita_basics_logic.R1
                                              (cic.lift (cic.type cic.z)
                                                 (cic.type
                                                    (cic.s (cic.s cic.z)))
                                                 T0)
                                              a0 T1 a1 x0 p0)
                                           x1) =>
                                    cic.univ (cic.type cic.z))))))
                       (T2 :
                          cic.Term (cic.type (cic.s cic.z))
                            (cic.prod (cic.type cic.z)
                               (cic.type (cic.s cic.z)) T0
                               (x0 : cic.Term (cic.type cic.z) T0 =>
                                cic.prod cic.prop (cic.type (cic.s cic.z))
                                  (matita_basics_logic.eq
                                     (cic.lift (cic.type cic.z)
                                        (cic.type (cic.s (cic.s cic.z))) T0)
                                     a0 x0)
                                  (p0 :
                                     cic.Term cic.prop
                                       (matita_basics_logic.eq
                                          (cic.lift (cic.type cic.z)
                                             (cic.type (cic.s (cic.s cic.z)))
                                             T0)
                                          a0 x0) =>
                                   cic.prod (cic.type cic.z)
                                     (cic.type (cic.s cic.z)) (T1 x0 p0)
                                     (x1 :
                                        cic.Term (cic.type cic.z) (T1 x0 p0) =>
                                      cic.prod cic.prop
                                        (cic.type (cic.s cic.z))
                                        (matita_basics_logic.eq
                                           (cic.lift (cic.type cic.z)
                                              (cic.type (cic.s (cic.s cic.z)))
                                              (T1 x0 p0))
                                           (matita_basics_logic.R1
                                              (cic.lift (cic.type cic.z)
                                                 (cic.type
                                                    (cic.s (cic.s cic.z)))
                                                 T0)
                                              a0 T1 a1 x0 p0)
                                           x1)
                                        (__ :
                                           cic.Term cic.prop
                                             (matita_basics_logic.eq
                                                (cic.lift (cic.type cic.z)
                                                   (cic.type
                                                      (cic.s (cic.s cic.z)))
                                                   (T1 x0 p0))
                                                (matita_basics_logic.R1
                                                   (cic.lift (cic.type cic.z)
                                                      (cic.type
                                                         (cic.s (cic.s cic.z)))
                                                      T0)
                                                   a0 T1 a1 x0 p0)
                                                x1) =>
                                         cic.univ (cic.type cic.z)))))) =>
                        cic.prod (cic.type cic.z) (cic.type (cic.s cic.z))
                          (T2 a0
                             (matita_basics_logic.refl
                                (cic.lift (cic.type cic.z)
                                   (cic.type (cic.s (cic.s cic.z))) T0)
                                a0)
                             a1
                             (matita_basics_logic.refl
                                (cic.lift (cic.type cic.z)
                                   (cic.type (cic.s (cic.s cic.z)))
                                   (T1 a0
                                      (matita_basics_logic.refl
                                         (cic.lift (cic.type cic.z)
                                            (cic.type (cic.s (cic.s cic.z)))
                                            T0)
                                         a0)))
                                a1))
                          (a2 :
                             cic.Term (cic.type cic.z)
                               (T2 a0
                                  (matita_basics_logic.refl
                                     (cic.lift (cic.type cic.z)
                                        (cic.type (cic.s (cic.s cic.z))) T0)
                                     a0)
                                  a1
                                  (matita_basics_logic.refl
                                     (cic.lift (cic.type cic.z)
                                        (cic.type (cic.s (cic.s cic.z)))
                                        (T1 a0
                                           (matita_basics_logic.refl
                                              (cic.lift (cic.type cic.z)
                                                 (cic.type
                                                    (cic.s (cic.s cic.z)))
                                                 T0)
                                              a0)))
                                     a1)) =>
                           cic.prod (cic.type (cic.s cic.z))
                             (cic.type (cic.s cic.z))
                             (cic.prod (cic.type cic.z)
                                (cic.type (cic.s cic.z)) T0
                                (x0 : cic.Term (cic.type cic.z) T0 =>
                                 cic.prod cic.prop (cic.type (cic.s cic.z))
                                   (matita_basics_logic.eq
                                      (cic.lift (cic.type cic.z)
                                         (cic.type (cic.s (cic.s cic.z))) T0)
                                      a0 x0)
                                   (p0 :
                                      cic.Term cic.prop
                                        (matita_basics_logic.eq
                                           (cic.lift (cic.type cic.z)
                                              (cic.type (cic.s (cic.s cic.z)))
                                              T0)
                                           a0 x0) =>
                                    cic.prod (cic.type cic.z)
                                      (cic.type (cic.s cic.z)) (T1 x0 p0)
                                      (x1 :
                                         cic.Term (cic.type cic.z) (T1 x0 p0) =>
                                       cic.prod cic.prop
                                         (cic.type (cic.s cic.z))
                                         (matita_basics_logic.eq
                                            (cic.lift (cic.type cic.z)
                                               (cic.type
                                                  (cic.s (cic.s cic.z)))
                                               (T1 x0 p0))
                                            (matita_basics_logic.R1
                                               (cic.lift (cic.type cic.z)
                                                  (cic.type
                                                     (cic.s (cic.s cic.z)))
                                                  T0)
                                               a0 T1 a1 x0 p0)
                                            x1)
                                         (p1 :
                                            cic.Term cic.prop
                                              (matita_basics_logic.eq
                                                 (cic.lift (cic.type cic.z)
                                                    (cic.type
                                                       (cic.s (cic.s cic.z)))
                                                    (T1 x0 p0))
                                                 (matita_basics_logic.R1
                                                    (cic.lift
                                                       (cic.type cic.z)
                                                       (cic.type
                                                          (cic.s
                                                             (cic.s cic.z)))
                                                       T0)
                                                    a0 T1 a1 x0 p0)
                                                 x1) =>
                                          cic.prod (cic.type cic.z)
                                            (cic.type (cic.s cic.z))
                                            (T2 x0 p0 x1 p1)
                                            (x2 :
                                               cic.Term (cic.type cic.z)
                                                 (T2 x0 p0 x1 p1) =>
                                             cic.prod cic.prop
                                               (cic.type (cic.s cic.z))
                                               (matita_basics_logic.eq
                                                  (cic.lift (cic.type cic.z)
                                                     (cic.type
                                                        (cic.s (cic.s cic.z)))
                                                     (T2 x0 p0 x1 p1))
                                                  (matita_basics_logic.R2
                                                     (cic.lift
                                                        (cic.type cic.z)
                                                        (cic.type cic.z) T0)
                                                     a0 T1 a1 T2 a2 x0 p0 x1
                                                     p1)
                                                  x2)
                                               (__ :
                                                  cic.Term cic.prop
                                                    (matita_basics_logic.eq
                                                       (cic.lift
                                                          (cic.type cic.z)
                                                          (cic.type
                                                             (cic.s
                                                                (cic.s cic.z)))
                                                          (T2 x0 p0 x1 p1))
                                                       (matita_basics_logic.R2
                                                          (cic.lift
                                                             (cic.type cic.z)
                                                             (cic.type cic.z)
                                                             T0)
                                                          a0 T1 a1 T2 a2 x0
                                                          p0 x1 p1)
                                                       x2) =>
                                                cic.univ (cic.type cic.z))))))))
                             (T3 :
                                cic.Term (cic.type (cic.s cic.z))
                                  (cic.prod (cic.type cic.z)
                                     (cic.type (cic.s cic.z)) T0
                                     (x0 : cic.Term (cic.type cic.z) T0 =>
                                      cic.prod cic.prop
                                        (cic.type (cic.s cic.z))
                                        (matita_basics_logic.eq
                                           (cic.lift (cic.type cic.z)
                                              (cic.type (cic.s (cic.s cic.z)))
                                              T0)
                                           a0 x0)
                                        (p0 :
                                           cic.Term cic.prop
                                             (matita_basics_logic.eq
                                                (cic.lift (cic.type cic.z)
                                                   (cic.type
                                                      (cic.s (cic.s cic.z)))
                                                   T0)
                                                a0 x0) =>
                                         cic.prod (cic.type cic.z)
                                           (cic.type (cic.s cic.z))
                                           (T1 x0 p0)
                                           (x1 :
                                              cic.Term (cic.type cic.z)
                                                (T1 x0 p0) =>
                                            cic.prod cic.prop
                                              (cic.type (cic.s cic.z))
                                              (matita_basics_logic.eq
                                                 (cic.lift (cic.type cic.z)
                                                    (cic.type
                                                       (cic.s (cic.s cic.z)))
                                                    (T1 x0 p0))
                                                 (matita_basics_logic.R1
                                                    (cic.lift
                                                       (cic.type cic.z)
                                                       (cic.type
                                                          (cic.s
                                                             (cic.s cic.z)))
                                                       T0)
                                                    a0 T1 a1 x0 p0)
                                                 x1)
                                              (p1 :
                                                 cic.Term cic.prop
                                                   (matita_basics_logic.eq
                                                      (cic.lift
                                                         (cic.type cic.z)
                                                         (cic.type
                                                            (cic.s
                                                               (cic.s cic.z)))
                                                         (T1 x0 p0))
                                                      (matita_basics_logic.R1
                                                         (cic.lift
                                                            (cic.type cic.z)
                                                            (cic.type
                                                               (cic.s
                                                                  (cic.s
                                                                    cic.z)))
                                                            T0)
                                                         a0 T1 a1 x0 p0)
                                                      x1) =>
                                               cic.prod (cic.type cic.z)
                                                 (cic.type (cic.s cic.z))
                                                 (T2 x0 p0 x1 p1)
                                                 (x2 :
                                                    cic.Term (cic.type cic.z)
                                                      (T2 x0 p0 x1 p1) =>
                                                  cic.prod cic.prop
                                                    (cic.type (cic.s cic.z))
                                                    (matita_basics_logic.eq
                                                       (cic.lift
                                                          (cic.type cic.z)
                                                          (cic.type
                                                             (cic.s
                                                                (cic.s cic.z)))
                                                          (T2 x0 p0 x1 p1))
                                                       (matita_basics_logic.R2
                                                          (cic.lift
                                                             (cic.type cic.z)
                                                             (cic.type cic.z)
                                                             T0)
                                                          a0 T1 a1 T2 a2 x0
                                                          p0 x1 p1)
                                                       x2)
                                                    (__ :
                                                       cic.Term cic.prop
                                                         (matita_basics_logic.eq
                                                            (cic.lift
                                                               (cic.type
                                                                  cic.z)
                                                               (cic.type
                                                                  (cic.s
                                                                    (
                                                                   cic.s
                                                                    cic.z)))
                                                               (T2 x0 p0 x1
                                                                  p1))
                                                            (matita_basics_logic.R2
                                                               (cic.lift
                                                                  (cic.type
                                                                    cic.z)
                                                                  (cic.type
                                                                    cic.z)
                                                                  T0)
                                                               a0 T1 a1 T2 a2
                                                               x0 p0 x1 p1)
                                                            x2) =>
                                                     cic.univ
                                                       (cic.type cic.z)))))))) =>
                              cic.prod (cic.type cic.z)
                                (cic.type (cic.s cic.z))
                                (T3 a0
                                   (matita_basics_logic.refl
                                      (cic.lift (cic.type cic.z)
                                         (cic.type (cic.s (cic.s cic.z))) T0)
                                      a0)
                                   a1
                                   (matita_basics_logic.refl
                                      (cic.lift (cic.type cic.z)
                                         (cic.type (cic.s (cic.s cic.z)))
                                         (T1 a0
                                            (matita_basics_logic.refl
                                               (cic.lift (cic.type cic.z)
                                                  (cic.type
                                                     (cic.s (cic.s cic.z)))
                                                  T0)
                                               a0)))
                                      a1)
                                   a2
                                   (matita_basics_logic.refl
                                      (cic.lift (cic.type cic.z)
                                         (cic.type (cic.s (cic.s cic.z)))
                                         (T2 a0
                                            (matita_basics_logic.refl
                                               (cic.lift (cic.type cic.z)
                                                  (cic.type
                                                     (cic.s (cic.s cic.z)))
                                                  T0)
                                               a0)
                                            a1
                                            (matita_basics_logic.refl
                                               (cic.lift (cic.type cic.z)
                                                  (cic.type
                                                     (cic.s (cic.s cic.z)))
                                                  (T1 a0
                                                     (matita_basics_logic.refl
                                                        (cic.lift
                                                           (cic.type cic.z)
                                                           (cic.type
                                                              (cic.s
                                                                 (cic.s cic.z)))
                                                           T0)
                                                        a0)))
                                               a1)))
                                      a2))
                                (a3 :
                                   cic.Term (cic.type cic.z)
                                     (T3 a0
                                        (matita_basics_logic.refl
                                           (cic.lift (cic.type cic.z)
                                              (cic.type (cic.s (cic.s cic.z)))
                                              T0)
                                           a0)
                                        a1
                                        (matita_basics_logic.refl
                                           (cic.lift (cic.type cic.z)
                                              (cic.type (cic.s (cic.s cic.z)))
                                              (T1 a0
                                                 (matita_basics_logic.refl
                                                    (cic.lift
                                                       (cic.type cic.z)
                                                       (cic.type
                                                          (cic.s
                                                             (cic.s cic.z)))
                                                       T0)
                                                    a0)))
                                           a1)
                                        a2
                                        (matita_basics_logic.refl
                                           (cic.lift (cic.type cic.z)
                                              (cic.type (cic.s (cic.s cic.z)))
                                              (T2 a0
                                                 (matita_basics_logic.refl
                                                    (cic.lift
                                                       (cic.type cic.z)
                                                       (cic.type
                                                          (cic.s
                                                             (cic.s cic.z)))
                                                       T0)
                                                    a0)
                                                 a1
                                                 (matita_basics_logic.refl
                                                    (cic.lift
                                                       (cic.type cic.z)
                                                       (cic.type
                                                          (cic.s
                                                             (cic.s cic.z)))
                                                       (T1 a0
                                                          (matita_basics_logic.refl
                                                             (cic.lift
                                                                (cic.type
                                                                   cic.z)
                                                                (cic.type
                                                                   (cic.s
                                                                    (
                                                                    cic.s
                                                                    cic.z)))
                                                                T0)
                                                             a0)))
                                                    a1)))
                                           a2)) =>
                                 cic.prod (cic.type (cic.s cic.z))
                                   (cic.type cic.z)
                                   (cic.prod (cic.type cic.z)
                                      (cic.type (cic.s cic.z)) T0
                                      (x0 : cic.Term (cic.type cic.z) T0 =>
                                       cic.prod cic.prop
                                         (cic.type (cic.s cic.z))
                                         (matita_basics_logic.eq
                                            (cic.lift (cic.type cic.z)
                                               (cic.type
                                                  (cic.s (cic.s cic.z)))
                                               T0)
                                            a0 x0)
                                         (p0 :
                                            cic.Term cic.prop
                                              (matita_basics_logic.eq
                                                 (cic.lift (cic.type cic.z)
                                                    (cic.type
                                                       (cic.s (cic.s cic.z)))
                                                    T0)
                                                 a0 x0) =>
                                          cic.prod (cic.type cic.z)
                                            (cic.type (cic.s cic.z))
                                            (T1 x0 p0)
                                            (x1 :
                                               cic.Term (cic.type cic.z)
                                                 (T1 x0 p0) =>
                                             cic.prod cic.prop
                                               (cic.type (cic.s cic.z))
                                               (matita_basics_logic.eq
                                                  (cic.lift (cic.type cic.z)
                                                     (cic.type
                                                        (cic.s (cic.s cic.z)))
                                                     (T1 x0 p0))
                                                  (matita_basics_logic.R1
                                                     (cic.lift
                                                        (cic.type cic.z)
                                                        (cic.type
                                                           (cic.s
                                                              (cic.s cic.z)))
                                                        T0)
                                                     a0 T1 a1 x0 p0)
                                                  x1)
                                               (p1 :
                                                  cic.Term cic.prop
                                                    (matita_basics_logic.eq
                                                       (cic.lift
                                                          (cic.type cic.z)
                                                          (cic.type
                                                             (cic.s
                                                                (cic.s cic.z)))
                                                          (T1 x0 p0))
                                                       (matita_basics_logic.R1
                                                          (cic.lift
                                                             (cic.type cic.z)
                                                             (cic.type
                                                                (cic.s
                                                                   (cic.s
                                                                    cic.z)))
                                                             T0)
                                                          a0 T1 a1 x0 p0)
                                                       x1) =>
                                                cic.prod (cic.type cic.z)
                                                  (cic.type (cic.s cic.z))
                                                  (T2 x0 p0 x1 p1)
                                                  (x2 :
                                                     cic.Term
                                                       (cic.type cic.z)
                                                       (T2 x0 p0 x1 p1) =>
                                                   cic.prod cic.prop
                                                     (cic.type (cic.s cic.z))
                                                     (matita_basics_logic.eq
                                                        (cic.lift
                                                           (cic.type cic.z)
                                                           (cic.type
                                                              (cic.s
                                                                 (cic.s cic.z)))
                                                           (T2 x0 p0 x1 p1))
                                                        (matita_basics_logic.R2
                                                           (cic.lift
                                                              (cic.type cic.z)
                                                              (cic.type cic.z)
                                                              T0)
                                                           a0 T1 a1 T2 a2 x0
                                                           p0 x1 p1)
                                                        x2)
                                                     (p2 :
                                                        cic.Term cic.prop
                                                          (matita_basics_logic.eq
                                                             (cic.lift
                                                                (cic.type
                                                                   cic.z)
                                                                (cic.type
                                                                   (cic.s
                                                                    (
                                                                    cic.s
                                                                    cic.z)))
                                                                (T2 x0 p0 x1
                                                                   p1))
                                                             (matita_basics_logic.R2
                                                                (cic.lift
                                                                   (cic.type
                                                                    cic.z)
                                                                   (cic.type
                                                                    cic.z)
                                                                   T0)
                                                                a0 T1 a1 T2
                                                                a2 x0 p0 x1
                                                                p1)
                                                             x2) =>
                                                      cic.prod
                                                        (cic.type cic.z)
                                                        (cic.type
                                                           (cic.s cic.z))
                                                        (T3 x0 p0 x1 p1 x2 p2)
                                                        (x3 :
                                                           cic.Term
                                                             (cic.type cic.z)
                                                             (T3 x0 p0 x1 p1
                                                                x2 p2) =>
                                                         cic.prod cic.prop
                                                           (cic.type
                                                              (cic.s cic.z))
                                                           (matita_basics_logic.eq
                                                              (cic.lift
                                                                 (cic.type
                                                                    cic.z)
                                                                 (cic.type
                                                                    (
                                                                  cic.s
                                                                    (
                                                                  cic.s cic.z)))
                                                                 (T3 x0 p0 x1
                                                                    p1 x2 p2))
                                                              (matita_basics_logic.R3
                                                                 (cic.lift
                                                                    (
                                                                  cic.type
                                                                    cic.z)
                                                                    (
                                                                  cic.type
                                                                    cic.z) T0)
                                                                 a0 T1 a1 T2
                                                                 a2 T3 a3 x0
                                                                 p0 x1 p1 x2
                                                                 p2)
                                                              x3)
                                                           (_p3 :
                                                              cic.Term
                                                                cic.prop
                                                                (matita_basics_logic.eq
                                                                   (cic.lift
                                                                    (
                                                                    cic.type
                                                                    cic.z)
                                                                    (
                                                                    cic.type
                                                                    (
                                                                    cic.s
                                                                    (
                                                                    cic.s
                                                                    cic.z)))
                                                                    (
                                                                    T3 x0 p0
                                                                    x1 p1 x2
                                                                    p2))
                                                                   (matita_basics_logic.R3
                                                                    (
                                                                    cic.lift
                                                                    (
                                                                    cic.type
                                                                    cic.z)
                                                                    (
                                                                    cic.type
                                                                    cic.z) T0)
                                                                    a0 T1 a1
                                                                    T2 a2 T3
                                                                    a3 x0 p0
                                                                    x1 p1 x2
                                                                    p2)
                                                                   x3) =>
                                                            cic.univ
                                                              (cic.type cic.z))))))))))
                                   (T4 :
                                      cic.Term (cic.type (cic.s cic.z))
                                        (cic.prod (cic.type cic.z)
                                           (cic.type (cic.s cic.z)) T0
                                           (x0 :
                                              cic.Term (cic.type cic.z) T0 =>
                                            cic.prod cic.prop
                                              (cic.type (cic.s cic.z))
                                              (matita_basics_logic.eq
                                                 (cic.lift (cic.type cic.z)
                                                    (cic.type
                                                       (cic.s (cic.s cic.z)))
                                                    T0)
                                                 a0 x0)
                                              (p0 :
                                                 cic.Term cic.prop
                                                   (matita_basics_logic.eq
                                                      (cic.lift
                                                         (cic.type cic.z)
                                                         (cic.type
                                                            (cic.s
                                                               (cic.s cic.z)))
                                                         T0)
                                                      a0 x0) =>
                                               cic.prod (cic.type cic.z)
                                                 (cic.type (cic.s cic.z))
                                                 (T1 x0 p0)
                                                 (x1 :
                                                    cic.Term (cic.type cic.z)
                                                      (T1 x0 p0) =>
                                                  cic.prod cic.prop
                                                    (cic.type (cic.s cic.z))
                                                    (matita_basics_logic.eq
                                                       (cic.lift
                                                          (cic.type cic.z)
                                                          (cic.type
                                                             (cic.s
                                                                (cic.s cic.z)))
                                                          (T1 x0 p0))
                                                       (matita_basics_logic.R1
                                                          (cic.lift
                                                             (cic.type cic.z)
                                                             (cic.type
                                                                (cic.s
                                                                   (cic.s
                                                                    cic.z)))
                                                             T0)
                                                          a0 T1 a1 x0 p0)
                                                       x1)
                                                    (p1 :
                                                       cic.Term cic.prop
                                                         (matita_basics_logic.eq
                                                            (cic.lift
                                                               (cic.type
                                                                  cic.z)
                                                               (cic.type
                                                                  (cic.s
                                                                    (
                                                                   cic.s
                                                                    cic.z)))
                                                               (T1 x0 p0))
                                                            (matita_basics_logic.R1
                                                               (cic.lift
                                                                  (cic.type
                                                                    cic.z)
                                                                  (cic.type
                                                                    (
                                                                   cic.s
                                                                    (
                                                                   cic.s
                                                                    cic.z)))
                                                                  T0)
                                                               a0 T1 a1 x0 p0)
                                                            x1) =>
                                                     cic.prod
                                                       (cic.type cic.z)
                                                       (cic.type
                                                          (cic.s cic.z))
                                                       (T2 x0 p0 x1 p1)
                                                       (x2 :
                                                          cic.Term
                                                            (cic.type cic.z)
                                                            (T2 x0 p0 x1 p1) =>
                                                        cic.prod cic.prop
                                                          (cic.type
                                                             (cic.s cic.z))
                                                          (matita_basics_logic.eq
                                                             (cic.lift
                                                                (cic.type
                                                                   cic.z)
                                                                (cic.type
                                                                   (cic.s
                                                                    (
                                                                    cic.s
                                                                    cic.z)))
                                                                (T2 x0 p0 x1
                                                                   p1))
                                                             (matita_basics_logic.R2
                                                                (cic.lift
                                                                   (cic.type
                                                                    cic.z)
                                                                   (cic.type
                                                                    cic.z)
                                                                   T0)
                                                                a0 T1 a1 T2
                                                                a2 x0 p0 x1
                                                                p1)
                                                             x2)
                                                          (p2 :
                                                             cic.Term
                                                               cic.prop
                                                               (matita_basics_logic.eq
                                                                  (cic.lift
                                                                    (
                                                                   cic.type
                                                                    cic.z)
                                                                    (
                                                                   cic.type
                                                                    (
                                                                   cic.s
                                                                    (
                                                                   cic.s
                                                                    cic.z)))
                                                                    (
                                                                   T2 x0 p0
                                                                    x1 p1))
                                                                  (matita_basics_logic.R2
                                                                    (
                                                                   cic.lift
                                                                    (
                                                                   cic.type
                                                                    cic.z)
                                                                    (
                                                                   cic.type
                                                                    cic.z) T0)
                                                                    a0 T1 a1
                                                                    T2 a2 x0
                                                                    p0 x1 p1)
                                                                  x2) =>
                                                           cic.prod
                                                             (cic.type cic.z)
                                                             (cic.type
                                                                (cic.s cic.z))
                                                             (T3 x0 p0 x1 p1
                                                                x2 p2)
                                                             (x3 :
                                                                cic.Term
                                                                  (cic.type
                                                                    cic.z)
                                                                  (T3 x0 p0
                                                                    x1 p1 x2
                                                                    p2) =>
                                                              cic.prod
                                                                cic.prop
                                                                (cic.type
                                                                   (cic.s
                                                                    cic.z))
                                                                (matita_basics_logic.eq
                                                                   (cic.lift
                                                                    (
                                                                    cic.type
                                                                    cic.z)
                                                                    (
                                                                    cic.type
                                                                    (
                                                                    cic.s
                                                                    (
                                                                    cic.s
                                                                    cic.z)))
                                                                    (
                                                                    T3 x0 p0
                                                                    x1 p1 x2
                                                                    p2))
                                                                   (matita_basics_logic.R3
                                                                    (
                                                                    cic.lift
                                                                    (
                                                                    cic.type
                                                                    cic.z)
                                                                    (
                                                                    cic.type
                                                                    cic.z) T0)
                                                                    a0 T1 a1
                                                                    T2 a2 T3
                                                                    a3 x0 p0
                                                                    x1 p1 x2
                                                                    p2)
                                                                   x3)
                                                                (_p3 :
                                                                   cic.Term
                                                                    cic.prop
                                                                    (
                                                                   matita_basics_logic.eq
                                                                    (
                                                                   cic.lift
                                                                    (
                                                                   cic.type
                                                                    cic.z)
                                                                    (
                                                                   cic.type
                                                                    (
                                                                   cic.s
                                                                    (
                                                                   cic.s
                                                                    cic.z)))
                                                                    (
                                                                   T3 x0 p0
                                                                    x1 p1 x2
                                                                    p2))
                                                                    (
                                                                   matita_basics_logic.R3
                                                                    (
                                                                   cic.lift
                                                                    (
                                                                   cic.type
                                                                    cic.z)
                                                                    (
                                                                   cic.type
                                                                    cic.z) T0)
                                                                    a0 T1 a1
                                                                    T2 a2 T3
                                                                    a3 x0 p0
                                                                    x1 p1 x2
                                                                    p2) x3) =>
                                                                 cic.univ
                                                                   (cic.type
                                                                    cic.z)))))))))) =>
                                    cic.prod (cic.type cic.z)
                                      (cic.type cic.z)
                                      (T4 a0
                                         (matita_basics_logic.refl
                                            (cic.lift (cic.type cic.z)
                                               (cic.type
                                                  (cic.s (cic.s cic.z)))
                                               T0)
                                            a0)
                                         a1
                                         (matita_basics_logic.refl
                                            (cic.lift (cic.type cic.z)
                                               (cic.type
                                                  (cic.s (cic.s cic.z)))
                                               (T1 a0
                                                  (matita_basics_logic.refl
                                                     (cic.lift
                                                        (cic.type cic.z)
                                                        (cic.type
                                                           (cic.s
                                                              (cic.s cic.z)))
                                                        T0)
                                                     a0)))
                                            a1)
                                         a2
                                         (matita_basics_logic.refl
                                            (cic.lift (cic.type cic.z)
                                               (cic.type
                                                  (cic.s (cic.s cic.z)))
                                               (T2 a0
                                                  (matita_basics_logic.refl
                                                     (cic.lift
                                                        (cic.type cic.z)
                                                        (cic.type
                                                           (cic.s
                                                              (cic.s cic.z)))
                                                        T0)
                                                     a0)
                                                  a1
                                                  (matita_basics_logic.refl
                                                     (cic.lift
                                                        (cic.type cic.z)
                                                        (cic.type
                                                           (cic.s
                                                              (cic.s cic.z)))
                                                        (T1 a0
                                                           (matita_basics_logic.refl
                                                              (cic.lift
                                                                 (cic.type
                                                                    cic.z)
                                                                 (cic.type
                                                                    (
                                                                  cic.s
                                                                    (
                                                                  cic.s cic.z)))
                                                                 T0)
                                                              a0)))
                                                     a1)))
                                            a2)
                                         a3
                                         (matita_basics_logic.refl
                                            (cic.lift (cic.type cic.z)
                                               (cic.type
                                                  (cic.s (cic.s cic.z)))
                                               (T3 a0
                                                  (matita_basics_logic.refl
                                                     (cic.lift
                                                        (cic.type cic.z)
                                                        (cic.type
                                                           (cic.s
                                                              (cic.s cic.z)))
                                                        T0)
                                                     a0)
                                                  a1
                                                  (matita_basics_logic.refl
                                                     (cic.lift
                                                        (cic.type cic.z)
                                                        (cic.type
                                                           (cic.s
                                                              (cic.s cic.z)))
                                                        (T1 a0
                                                           (matita_basics_logic.refl
                                                              (cic.lift
                                                                 (cic.type
                                                                    cic.z)
                                                                 (cic.type
                                                                    (
                                                                  cic.s
                                                                    (
                                                                  cic.s cic.z)))
                                                                 T0)
                                                              a0)))
                                                     a1)
                                                  a2
                                                  (matita_basics_logic.refl
                                                     (cic.lift
                                                        (cic.type cic.z)
                                                        (cic.type
                                                           (cic.s
                                                              (cic.s cic.z)))
                                                        (T2 a0
                                                           (matita_basics_logic.refl
                                                              (cic.lift
                                                                 (cic.type
                                                                    cic.z)
                                                                 (cic.type
                                                                    (
                                                                  cic.s
                                                                    (
                                                                  cic.s cic.z)))
                                                                 T0)
                                                              a0)
                                                           a1
                                                           (matita_basics_logic.refl
                                                              (cic.lift
                                                                 (cic.type
                                                                    cic.z)
                                                                 (cic.type
                                                                    (
                                                                  cic.s
                                                                    (
                                                                  cic.s cic.z)))
                                                                 (T1 a0
                                                                    (
                                                                  matita_basics_logic.refl
                                                                    (
                                                                  cic.lift
                                                                    (
                                                                  cic.type
                                                                    cic.z)
                                                                    (
                                                                  cic.type
                                                                    (
                                                                  cic.s
                                                                    (
                                                                  cic.s cic.z)))
                                                                    T0) a0)))
                                                              a1)))
                                                     a2)))
                                            a3))
                                      (_a4 :
                                         cic.Term (cic.type cic.z)
                                           (T4 a0
                                              (matita_basics_logic.refl
                                                 (cic.lift (cic.type cic.z)
                                                    (cic.type
                                                       (cic.s (cic.s cic.z)))
                                                    T0)
                                                 a0)
                                              a1
                                              (matita_basics_logic.refl
                                                 (cic.lift (cic.type cic.z)
                                                    (cic.type
                                                       (cic.s (cic.s cic.z)))
                                                    (T1 a0
                                                       (matita_basics_logic.refl
                                                          (cic.lift
                                                             (cic.type cic.z)
                                                             (cic.type
                                                                (cic.s
                                                                   (cic.s
                                                                    cic.z)))
                                                             T0)
                                                          a0)))
                                                 a1)
                                              a2
                                              (matita_basics_logic.refl
                                                 (cic.lift (cic.type cic.z)
                                                    (cic.type
                                                       (cic.s (cic.s cic.z)))
                                                    (T2 a0
                                                       (matita_basics_logic.refl
                                                          (cic.lift
                                                             (cic.type cic.z)
                                                             (cic.type
                                                                (cic.s
                                                                   (cic.s
                                                                    cic.z)))
                                                             T0)
                                                          a0)
                                                       a1
                                                       (matita_basics_logic.refl
                                                          (cic.lift
                                                             (cic.type cic.z)
                                                             (cic.type
                                                                (cic.s
                                                                   (cic.s
                                                                    cic.z)))
                                                             (T1 a0
                                                                (matita_basics_logic.refl
                                                                   (cic.lift
                                                                    (
                                                                    cic.type
                                                                    cic.z)
                                                                    (
                                                                    cic.type
                                                                    (
                                                                    cic.s
                                                                    (
                                                                    cic.s
                                                                    cic.z)))
                                                                    T0)
                                                                   a0)))
                                                          a1)))
                                                 a2)
                                              a3
                                              (matita_basics_logic.refl
                                                 (cic.lift (cic.type cic.z)
                                                    (cic.type
                                                       (cic.s (cic.s cic.z)))
                                                    (T3 a0
                                                       (matita_basics_logic.refl
                                                          (cic.lift
                                                             (cic.type cic.z)
                                                             (cic.type
                                                                (cic.s
                                                                   (cic.s
                                                                    cic.z)))
                                                             T0)
                                                          a0)
                                                       a1
                                                       (matita_basics_logic.refl
                                                          (cic.lift
                                                             (cic.type cic.z)
                                                             (cic.type
                                                                (cic.s
                                                                   (cic.s
                                                                    cic.z)))
                                                             (T1 a0
                                                                (matita_basics_logic.refl
                                                                   (cic.lift
                                                                    (
                                                                    cic.type
                                                                    cic.z)
                                                                    (
                                                                    cic.type
                                                                    (
                                                                    cic.s
                                                                    (
                                                                    cic.s
                                                                    cic.z)))
                                                                    T0)
                                                                   a0)))
                                                          a1)
                                                       a2
                                                       (matita_basics_logic.refl
                                                          (cic.lift
                                                             (cic.type cic.z)
                                                             (cic.type
                                                                (cic.s
                                                                   (cic.s
                                                                    cic.z)))
                                                             (T2 a0
                                                                (matita_basics_logic.refl
                                                                   (cic.lift
                                                                    (
                                                                    cic.type
                                                                    cic.z)
                                                                    (
                                                                    cic.type
                                                                    (
                                                                    cic.s
                                                                    (
                                                                    cic.s
                                                                    cic.z)))
                                                                    T0)
                                                                   a0)
                                                                a1
                                                                (matita_basics_logic.refl
                                                                   (cic.lift
                                                                    (
                                                                    cic.type
                                                                    cic.z)
                                                                    (
                                                                    cic.type
                                                                    (
                                                                    cic.s
                                                                    (
                                                                    cic.s
                                                                    cic.z)))
                                                                    (
                                                                    T1 a0
                                                                    (
                                                                    matita_basics_logic.refl
                                                                    (
                                                                    cic.lift
                                                                    (
                                                                    cic.type
                                                                    cic.z)
                                                                    (
                                                                    cic.type
                                                                    (
                                                                    cic.s
                                                                    (
                                                                    cic.s
                                                                    cic.z)))
                                                                    T0) a0)))
                                                                   a1)))
                                                          a2)))
                                                 a3)) =>
                                       cic.prod (cic.type cic.z)
                                         (cic.type cic.z) T0
                                         (b0 :
                                            cic.Term (cic.type cic.z) T0 =>
                                          cic.prod cic.prop (cic.type cic.z)
                                            (matita_basics_logic.eq
                                               (cic.lift (cic.type cic.z)
                                                  (cic.type
                                                     (cic.s (cic.s cic.z)))
                                                  T0)
                                               a0 b0)
                                            (e0 :
                                               cic.Term cic.prop
                                                 (matita_basics_logic.eq
                                                    (cic.lift
                                                       (cic.type cic.z)
                                                       (cic.type
                                                          (cic.s
                                                             (cic.s cic.z)))
                                                       T0)
                                                    a0 b0) =>
                                             cic.prod (cic.type cic.z)
                                               (cic.type cic.z) (T1 b0 e0)
                                               (b1 :
                                                  cic.Term (cic.type cic.z)
                                                    (T1 b0 e0) =>
                                                cic.prod cic.prop
                                                  (cic.type cic.z)
                                                  (matita_basics_logic.eq
                                                     (cic.lift
                                                        (cic.type cic.z)
                                                        (cic.type
                                                           (cic.s
                                                              (cic.s cic.z)))
                                                        (T1 b0 e0))
                                                     (matita_basics_logic.R1
                                                        (cic.lift
                                                           (cic.type cic.z)
                                                           (cic.type
                                                              (cic.s
                                                                 (cic.s cic.z)))
                                                           T0)
                                                        a0 T1 a1 b0 e0)
                                                     b1)
                                                  (e1 :
                                                     cic.Term cic.prop
                                                       (matita_basics_logic.eq
                                                          (cic.lift
                                                             (cic.type cic.z)
                                                             (cic.type
                                                                (cic.s
                                                                   (cic.s
                                                                    cic.z)))
                                                             (T1 b0 e0))
                                                          (matita_basics_logic.R1
                                                             (cic.lift
                                                                (cic.type
                                                                   cic.z)
                                                                (cic.type
                                                                   (cic.s
                                                                    (
                                                                    cic.s
                                                                    cic.z)))
                                                                T0)
                                                             a0 T1 a1 b0 e0)
                                                          b1) =>
                                                   cic.prod (cic.type cic.z)
                                                     (cic.type cic.z)
                                                     (T2 b0 e0 b1 e1)
                                                     (b2 :
                                                        cic.Term
                                                          (cic.type cic.z)
                                                          (T2 b0 e0 b1 e1) =>
                                                      cic.prod cic.prop
                                                        (cic.type cic.z)
                                                        (matita_basics_logic.eq
                                                           (cic.lift
                                                              (cic.type cic.z)
                                                              (cic.type
                                                                 (cic.s
                                                                    (
                                                                  cic.s cic.z)))
                                                              (T2 b0 e0 b1 e1))
                                                           (matita_basics_logic.R2
                                                              (cic.lift
                                                                 (cic.type
                                                                    cic.z)
                                                                 (cic.type
                                                                    cic.z)
                                                                 T0)
                                                              a0 T1 a1 T2 a2
                                                              b0 e0 b1 e1)
                                                           b2)
                                                        (e2 :
                                                           cic.Term cic.prop
                                                             (matita_basics_logic.eq
                                                                (cic.lift
                                                                   (cic.type
                                                                    cic.z)
                                                                   (cic.type
                                                                    (
                                                                    cic.s
                                                                    (
                                                                    cic.s
                                                                    cic.z)))
                                                                   (T2 b0 e0
                                                                    b1 e1))
                                                                (matita_basics_logic.R2
                                                                   (cic.lift
                                                                    (
                                                                    cic.type
                                                                    cic.z)
                                                                    (
                                                                    cic.type
                                                                    cic.z) T0)
                                                                   a0 T1 a1
                                                                   T2 a2 b0
                                                                   e0 b1 e1)
                                                                b2) =>
                                                         cic.prod
                                                           (cic.type cic.z)
                                                           (cic.type cic.z)
                                                           (T3 b0 e0 b1 e1 b2
                                                              e2)
                                                           (b3 :
                                                              cic.Term
                                                                (cic.type
                                                                   cic.z)
                                                                (T3 b0 e0 b1
                                                                   e1 b2 e2) =>
                                                            cic.prod cic.prop
                                                              (cic.type cic.z)
                                                              (matita_basics_logic.eq
                                                                 (cic.lift
                                                                    (
                                                                  cic.type
                                                                    cic.z)
                                                                    (
                                                                  cic.type
                                                                    (
                                                                  cic.s
                                                                    (
                                                                  cic.s cic.z)))
                                                                    (
                                                                  T3 b0 e0 b1
                                                                    e1 b2 e2))
                                                                 (matita_basics_logic.R3
                                                                    (
                                                                  cic.lift
                                                                    (
                                                                  cic.type
                                                                    cic.z)
                                                                    (
                                                                  cic.type
                                                                    cic.z) T0)
                                                                    a0 T1 a1
                                                                    T2 a2 T3
                                                                    a3 b0 e0
                                                                    b1 e1 b2
                                                                    e2)
                                                                 b3)
                                                              (e3 :
                                                                 cic.Term
                                                                   cic.prop
                                                                   (matita_basics_logic.eq
                                                                    (
                                                                    cic.lift
                                                                    (
                                                                    cic.type
                                                                    cic.z)
                                                                    (
                                                                    cic.type
                                                                    (
                                                                    cic.s
                                                                    (
                                                                    cic.s
                                                                    cic.z)))
                                                                    (
                                                                    T3 b0 e0
                                                                    b1 e1 b2
                                                                    e2))
                                                                    (
                                                                    matita_basics_logic.R3
                                                                    (
                                                                    cic.lift
                                                                    (
                                                                    cic.type
                                                                    cic.z)
                                                                    (
                                                                    cic.type
                                                                    cic.z) T0)
                                                                    a0 T1 a1
                                                                    T2 a2 T3
                                                                    a3 b0 e0
                                                                    b1 e1 b2
                                                                    e2) b3) =>
                                                               T4 b0 e0 b1 e1
                                                                 b2 e2 b3 e3)))))))))))))))))))
.
;)

def eqProp :
      cic.Term (cic.type cic.z)
        (cic.prod (cic.type cic.z) (cic.type cic.z) (cic.univ cic.prop)
           (A : cic.Univ cic.prop =>
            cic.prod cic.prop (cic.type cic.z) A
              (_x : cic.Term cic.prop A =>
               cic.prod cic.prop (cic.type cic.z) A
                 (__ : cic.Term cic.prop A => cic.univ cic.prop))))
      :=
      A : cic.Univ cic.prop =>
      matita_basics_logic.eq
        (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z))) A).

lemmaK :
  cic.Term cic.prop
    (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z)))) cic.prop
       (cic.univ (cic.type (cic.s (cic.s cic.z))))
       (A : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
        cic.prod (cic.type (cic.s (cic.s cic.z))) cic.prop A
          (x : cic.Term (cic.type (cic.s (cic.s cic.z))) A =>
           cic.prod cic.prop cic.prop
             (matita_basics_logic.eq
                (cic.lift (cic.type (cic.s (cic.s cic.z)))
                   (cic.type (cic.s (cic.s cic.z))) A)
                x x)
             (h :
                cic.Term cic.prop
                  (matita_basics_logic.eq
                     (cic.lift (cic.type (cic.s (cic.s cic.z)))
                        (cic.type (cic.s (cic.s cic.z))) A)
                     x x) =>
              matita_basics_logic.eqProp
                (cic.lift cic.prop cic.prop
                   (matita_basics_logic.eq
                      (cic.lift (cic.type (cic.s (cic.s cic.z)))
                         (cic.type (cic.s (cic.s cic.z))) A)
                      x x))
                h
                (matita_basics_logic.refl
                   (cic.lift (cic.type (cic.s (cic.s cic.z)))
                      (cic.type (cic.s (cic.s cic.z))) A)
                   x))))).

def streicherK :
      cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
        (cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
           (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
           (cic.univ (cic.type (cic.s (cic.s cic.z))))
           (T : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
            cic.prod (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s (cic.s (cic.s (cic.s cic.z))))) T
              (t : cic.Term (cic.type (cic.s (cic.s cic.z))) T =>
               cic.prod (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                 (cic.type (cic.s (cic.s (cic.s cic.z))))
                 (cic.prod cic.prop
                    (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                    (matita_basics_logic.eq
                       (cic.lift (cic.type (cic.s (cic.s cic.z)))
                          (cic.type (cic.s (cic.s cic.z))) T)
                       t t)
                    (__ :
                       cic.Term cic.prop
                         (matita_basics_logic.eq
                            (cic.lift (cic.type (cic.s (cic.s cic.z)))
                               (cic.type (cic.s (cic.s cic.z))) T)
                            t t) =>
                     cic.univ (cic.type (cic.s (cic.s (cic.s cic.z))))))
                 (P :
                    cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                      (cic.prod cic.prop
                         (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
                         (matita_basics_logic.eq
                            (cic.lift (cic.type (cic.s (cic.s cic.z)))
                               (cic.type (cic.s (cic.s cic.z))) T)
                            t t)
                         (__ :
                            cic.Term cic.prop
                              (matita_basics_logic.eq
                                 (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                    (cic.type (cic.s (cic.s cic.z))) T)
                                 t t) =>
                          cic.univ (cic.type (cic.s (cic.s (cic.s cic.z)))))) =>
                  cic.prod (cic.type (cic.s (cic.s (cic.s cic.z))))
                    (cic.type (cic.s (cic.s (cic.s cic.z))))
                    (P
                       (matita_basics_logic.refl
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) T)
                          t))
                    (__ :
                       cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
                         (P
                            (matita_basics_logic.refl
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) T)
                               t)) =>
                     cic.prod cic.prop
                       (cic.type (cic.s (cic.s (cic.s cic.z))))
                       (matita_basics_logic.eq
                          (cic.lift (cic.type (cic.s (cic.s cic.z)))
                             (cic.type (cic.s (cic.s cic.z))) T)
                          t t)
                       (p :
                          cic.Term cic.prop
                            (matita_basics_logic.eq
                               (cic.lift (cic.type (cic.s (cic.s cic.z)))
                                  (cic.type (cic.s (cic.s cic.z))) T)
                               t t) =>
                        P p))))))
      :=
      T : cic.Univ (cic.type (cic.s (cic.s cic.z))) =>
      t : cic.Term (cic.type (cic.s (cic.s cic.z))) T =>
      P :
        cic.Term (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
          (cic.prod cic.prop (cic.type (cic.s (cic.s (cic.s (cic.s cic.z)))))
             (matita_basics_logic.eq
                (cic.lift (cic.type (cic.s (cic.s cic.z)))
                   (cic.type (cic.s (cic.s cic.z))) T)
                t t)
             (__ :
                cic.Term cic.prop
                  (matita_basics_logic.eq
                     (cic.lift (cic.type (cic.s (cic.s cic.z)))
                        (cic.type (cic.s (cic.s cic.z))) T)
                     t t) =>
              cic.univ (cic.type (cic.s (cic.s (cic.s cic.z)))))) =>
      H :
        cic.Term (cic.type (cic.s (cic.s (cic.s cic.z))))
          (P
             (matita_basics_logic.refl
                (cic.lift (cic.type (cic.s (cic.s cic.z)))
                   (cic.type (cic.s (cic.s cic.z))) T)
                t)) =>
      p :
        cic.Term cic.prop
          (matita_basics_logic.eq
             (cic.lift (cic.type (cic.s (cic.s cic.z)))
                (cic.type (cic.s (cic.s cic.z))) T)
             t t) =>
      matita_basics_logic.eq_rect_Type3_r
        (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
           (matita_basics_logic.eq
              (cic.lift (cic.type (cic.s (cic.s cic.z)))
                 (cic.type (cic.s (cic.s cic.z))) T)
              t t))
        (matita_basics_logic.refl
           (cic.lift (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s (cic.s cic.z))) T)
           t)
        (x :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift (cic.type (cic.s (cic.s cic.z)))
                   (cic.type (cic.s (cic.s cic.z))) T)
                t t) =>
         __ :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop (cic.type (cic.s (cic.s cic.z)))
                   (matita_basics_logic.eq
                      (cic.lift (cic.type (cic.s (cic.s cic.z)))
                         (cic.type (cic.s (cic.s cic.z))) T)
                      t t))
                x
                (matita_basics_logic.refl
                   (cic.lift (cic.type (cic.s (cic.s cic.z)))
                      (cic.type (cic.s (cic.s cic.z))) T)
                   t)) =>
         P x)
        H p
        (matita_basics_logic.lemmaK
           (cic.lift (cic.type (cic.s (cic.s cic.z)))
              (cic.type (cic.s (cic.s cic.z))) T)
           t p).


