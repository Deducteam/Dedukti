(; This is not a CiC implementation : nocic ;)

def Nat : Type := cc.Sort.
def z : Nat := cc.0.
def s : Nat -> Nat := x => cc.plus cc.1 x.

def m : Nat -> Nat -> Nat := cc.max.

(; Sorts ;)

def Sort : Type := cc.Sort.

def prop : Sort := cc.0.
def type : Nat -> Sort := s.
def succ : Sort -> Sort := s.
def next : Sort -> Sort := s.
def rule : Sort -> Sort -> Sort := cc.rule.
def max : Sort -> Sort -> Sort := cc.max.

(; Types and terms ;)

def Univ : s : Sort -> Type := cc.U.
def Term : s : Sort -> a : Univ s -> Type := cc.T.

def univ : s : Sort -> Univ (succ s) := cc.u.

def prod : s1 : Sort ->
		   s2 : Sort ->
		   a : Univ s1 ->
		   b : (Term s1 a -> Univ s2) ->
		   Univ (rule s1 s2) := cc.prod.

def lift : s1 : Sort -> s2 : Sort -> a : Univ s1 -> Univ (cc.max s1 s2).
[i,j,a] lift (cc.plus i j) i a --> a.
[i,j,a] lift i (cc.plus i j) a --> cc.liftnk i j a.
[j,a] lift j cc.0 a --> a.
[i,a] lift i i a --> a.
[j,a] lift cc.0 j a --> cc.liftn j a.
