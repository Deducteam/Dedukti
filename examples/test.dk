#NAME test.

nat : Type.
0 : nat.
S : nat -> nat.

def 1  := S 0.
def 2  := S 1.
def 3  := S 2.
def 4  := S 3.
def 5  := S 4.
def 6  := S 5.
def 7  := S 6.
def 8  := S 7.
def 9  := S 8.
def 10 := S 9.

defac mset [nat].

#CONV mset 1 0, mset 0 1.
#CONV mset 0 1, mset 1 0.
#CONV mset 1 0, mset 0 0.

#WHNF mset (mset 2 0) (mset 1 ( (x : nat => mset x (mset (S x) x)) 4)).
#SNF mset (mset 2 0) (mset 1 ( (x : nat => mset x (mset (S x) x)) 4)).

#CONV mset (mset 3 4) (mset 0 1), mset (mset (mset 1 4) 0) 3.


defac min [nat].
[] min 0 --> (x : nat => x)
[x]   min 0     x     --> 0
[x,y] min (S x) (S y) --> S (min x y).
#GDT min.

#PRINT "----------- Gaspard ------------".
#SNF min (S (S 0)) (min 0 (S 0)).


#PRINT "".
#PRINT "----------- plus ------------".

defacu plus [nat,0].
[x,y] plus (S x) y --> S (plus x y).
#GDT plus.

#SNF plus (plus 2 0) (plus 1 ( (x : nat => plus x (plus (S x) x)) 4)).


#PRINT "".
#PRINT "----------- time ------------".

defacu time [nat,S 0].
[]    time 0     _ --> 0.
[x,y] time (S x) y --> plus y (time x y).
#GDT time.

#WHNF time 1 2.
#SNF time 1 2.
#CONV time 5 5, plus (plus 10 10) 5.


#PRINT "----------- square ------------".

def square := (x : nat => time x x).
#CONV plus (square 3) (square 4), square 5.


#PRINT "----------- bug ------------".

(; This rewrite system is too restrictive ;)
defacu bug [nat,0].
[x] bug (S x) (S x) --> x.
[x] bug     x (S x) --> x.

#SNF bug (bug 1 3) 3.

(; Use an extra variable to fix it ;)
defacu dbug [nat,0].
[x]           dbug (S x) (S x)  --> x.
[x,y] dbug y (dbug (S x) (S x)) --> dbug y x.
[x]           dbug     x (S x)  --> x.
[x,y] dbug y (dbug     x (S x)) --> dbug y x.

#WHNF dbug (dbug 1 3) 3.


(; Loops because of the following loop when x <- 0 :
   + a b  -->  + (+ a b) (+ 0 0)  -->  + (+ a b) 0  -->  + a b
 ;)
defacu bug2 [nat,0].
[x,y] bug2 y (bug2 x x) --> bug2 y x.
(;
#WHNF bug2 1 1.
(;;)



#PRINT "----------- max ------------".

defac max [nat].
[x]   max 0     x     --> x
[x]   max x     0     --> x
[x,y] max (S x) (S y) --> S (max x y).

def b : nat -> Type.
[]  b 0     --> nat
[x] b (S x) --> nat -> (b x).

def c : n : nat -> b (S n).
[x]     c     0 x   --> x
[x,y,n] c (S n) x y --> c n (max x y).

(; this fails when the list is too long...
#WHNF (c 10 8 7 3 4 5 6 7 4 6 1 2 2 3 5 4 1 2 2 2 9).
;)


#PRINT "----------- bin ------------".

defac bin [nat].
[x]   bin x         x --> S x
[x,y] bin (bin x x) y --> bin (S x) y.

def e : nat -> nat.
[]    e 0         --> 1
[x]   e (S x)     --> plus (e x) (e x)
[x,y] e (bin x y) --> plus (e x) (e y).


#SNF bin 1 (bin 2 (bin 3 2)).
#SNF e (bin 1 (bin 2 (bin 3 1))).
