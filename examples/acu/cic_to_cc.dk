def Nat : Type := cc.Sort.

def z : Nat := cc.0.

def s : Nat -> Nat := x => cc.plus cc.1 x.

def m : Nat -> Nat -> Nat := cc.max.

#CHECK ( i : Nat =>            m i z         ) == i : Nat => i.
#CHECK ( j : Nat =>            m z j         ) == j : Nat => j.
#CHECK ( i : Nat => j : Nat => m (s i) (s j) ) == i : Nat => j : Nat => s (m i j).

(; Sorts ;)

def Sort : Type := cc.Sort.

def prop : Sort := cc.0.
def type : Nat -> Sort := s.

(; Universe successors ;)
def succ : Sort -> Sort := s.
#CHECK succ prop == type z.
#CHECK (i : Nat => succ (type i))
    == i : Nat => type (s i).

(; Universe cumulativity ;)
def next : Sort -> Sort := s.
#CHECK next prop == type z.
#CHECK (i : Nat => next (type i))
    == i : Nat => type (s i).

(; Universe product rules ;)
def rule : Sort -> Sort -> Sort := cc.rule.
#CHECK (s1 : Sort => rule s1 prop)
    == s1 : Sort => prop.
#CHECK (s2 : Sort => rule prop s2)
    == s2 : Sort => s2.
#CHECK (i : Nat => j : Nat => rule (type i) (type j))
    == i : Nat => j : Nat => type (m i j).

def max : Sort -> Sort -> Sort := cc.max.
#CHECK (s1 : Sort => max s1 prop)
    == s1 : Sort => s1.
#CHECK (s2 : Sort => max prop s2)
    == s2 : Sort => s2.
#CHECK (i : Nat => j : Nat => max (type i) (type j))
    == i : Nat => j : Nat => type (m i j).

(; Types and terms ;)

def Univ : s : Sort -> Type := cc.U.
def Term : s : Sort -> a : Univ s -> Type := cc.T.

def univ : s : Sort -> Univ (succ s) := cc.u.

def lift : s1 : Sort -> s2 : Sort -> a : Univ s1 -> Univ (max s1 s2).
[i  ,a] lift i i a --> a
[i,j,a] lift i (cc.plus i j) a --> cc.lnlift i j a
[i,j,a] lift (cc.plus i j) i a --> a.

def prod : s1 : Sort ->
		   s2 : Sort ->
		   a : Univ s1 ->
		   b : (Term s1 a -> Univ s2) ->
		   Univ (rule s1 s2) := cc.prod.

#CHECK (s : Sort => Term (succ s) (univ s))
    == s : Sort => Univ s.

#PRINT "Issue here".
#CHECK (s1 : Sort => s2 : Sort => a : Univ s1 => Term (max s1 s2) (lift s1 s2 a))
    == s1 : Sort => s2 : Sort => a : Univ s1 => Term s1 a.

#CHECK (s1 : Sort => s2 : Sort => a : Univ s1 => b : (Term s1 a -> Univ s2) =>
         Term (rule s1 s2) (prod s1 s2 a b))
    == s1 : Sort => s2 : Sort => a : Univ s1 => b : (Term s1 a -> Univ s2) =>
         x : Term s1 a -> Term s2 (b x).

(; Canonicity rules ;)

#CHECK (s : Sort => max s s)
    == s : Sort => s.
#CHECK (s1 : Sort => s2 : Sort => s3 : Sort => max (max s1 s2) s3)
    == s1 : Sort => s2 : Sort => s3 : Sort => max s1 (max s2 s3).

#CHECK (s1 : Sort => s2 : Sort => s3 : Sort => rule (max s1 s3) s2)
    == s1 : Sort => s2 : Sort => s3 : Sort => max (rule s1 s2) (rule s3 s2).
#CHECK (s1 : Sort => s2 : Sort => s3 : Sort => rule s1 (max s2 s3))
    == s1 : Sort => s2 : Sort => s3 : Sort => max (rule s1 s2) (rule s1 s3).

#CHECK (s : Sort => a : Univ s => lift s s a)
    == s : Sort => a : Univ s => a.

#PRINT "Issue here".
#CHECK (s1 : Sort => s2 : Sort => s3 : Sort => a : Univ s1 => lift (max s1 s2) s3 (lift s1 s2 a))
    == s1 : Sort => s2 : Sort => s3 : Sort => a : Univ s1 => lift s1 (max s2 s3) a.

(; This doesn't type check because the following terms are not covnertible:
    T (max i j) (lift i j) a
    T i a
;)
(;
#CHECK (s1 : Sort=> s2 : Sort => s3 : Sort => a : Univ s1 => b : (Term s1 a -> Univ s2) =>
         prod (max s1 s3) s2 (lift s1 s3 a) b)
    == s1 : Sort=> s2 : Sort => s3 : Sort => a : Univ s1 => b : (Term s1 a -> Univ s2) =>
         lift (rule s1 s2) (rule s3 s2) (prod s1 s2 a b).
;)

#PRINT "Issue here".
#CHECK (s1 : Sort  => s2 : Sort => s3 : Sort => a : Univ s1 => b : (Term s1 a -> Univ s2) =>
         prod s1 (max s3 s2) a (x => lift s2 s3 (b x)))
    == s1 : Sort => s2 : Sort => s3 : Sort => a : Univ s1 => b : (Term s1 a -> Univ s2) =>
         lift (rule s1 s2) (rule s1 s3) (prod s1 s2 a (x => b x)).
