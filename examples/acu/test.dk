#NAME test.

N : Type.
0 : N.
S : N -> N.

def 1  := S 0.
def 2  := S 1.
def 3  := S 2.
def 4  := S 3.
def 5  := S 4.
def 6  := S 5.
def 7  := S 6.
def 8  := S 7.
def 9  := S 8.
def 10 := S 9.
def 11 := S 10.
def 12 := S 11.
def 13 := S 12.
def 14 := S 13.
def 15 := S 14.
def 16 := S 15.
def 17 := S 16.
def 18 := S 17.
def 19 := S 18.
def 20 := S 19.

def double : N -> N.
[] double 0 --> 0
[n] double (S n) --> S (S (double n)).

(;       AC     ;)

defac mset [N].

#PRINT "--------".
#PRINT "YES".
#CONV mset 1 0, mset 0 1.
#PRINT "--------".
#PRINT "YES".
#CONV mset 0 1, mset 1 0.
#PRINT "--------".
#PRINT "NO".
#CONV mset 1 0, mset 0 0.

#WHNF mset (mset 2 0) (mset 1 ( (x : N => mset x (mset (S x) x)) 4)).
#SNF mset (mset 2 0) (mset 1 ( (x : N => mset x (mset (S x) x)) 4)).

#CONV mset (mset 3 4) (mset 0 1), mset (mset (mset 1 4) 0) 3.


defac min [N].
[] min 0 --> (x : N => x)
[x]   min 0     x     --> 0
[x,y] min (S x) (S y) --> S (min x y).
#GDT min.

#PRINT "----------- Gaspard ------------".
#SNF min 3 (min 1 2).


#PRINT "".
#PRINT "----------- plus ------------".

defacu plus [N,0].
[x,y] plus (S x) y --> S (plus x y).
#GDT plus.

#SNF plus 10 6.
#SNF plus (plus 2 0) (plus 1 ( (x : N => plus x (plus (S x) x)) 4)).


#PRINT "".
#PRINT "----------- time ------------".

defacu time [N,S 0].
[]    time 0     _ --> 0.
[x,y] time (S x) y --> plus y (time x y).
#GDT time.

#WHNF time 1 2.
#SNF time 1 2.
#CONV time 5 5, plus (plus 10 10) 5.


#PRINT "----------- square ------------".

def square := (x : N => time x x).
#CONV plus (square 3) (square 4), square 5.


#PRINT "----------- bug ------------".

(; This rewrite system is too restrictive ;)
defacu bug [N,0].
[x] bug (S x) (S x) --> x.
[x] bug     x (S x) --> x.

#SNF bug (bug 1 3) 3.

(; Use an extra variable to fix it ;)
defacu dbug [N,0].
[x]           dbug (S x) (S x)  --> x.
[x,y] dbug y (dbug (S x) (S x)) --> dbug y x.
[x]           dbug     x (S x)  --> x.
[x,y] dbug y (dbug     x (S x)) --> dbug y x.

#WHNF dbug (dbug 1 3) 3.


(; Loops because of the following loop when x <- 0 :
   + a b  -->  + (+ a b) (+ 0 0)  -->  + (+ a b) 0  -->  + a b
 ;)
defacu bug2 [N,0].
[x,y] bug2 y (bug2 x x) --> bug2 y x.
(;
#WHNF bug2 1 1.
(;;)



#PRINT "----------- max ------------".

defac max [N].
[x]   max 0     x     --> x
[x]   max x     0     --> x
[x,y] max (S x) (S y) --> S (max x y).

def b : N -> Type.
[]  b 0     --> N
[x] b (S x) --> N -> (b x).

def c : n : N -> b (S n).
[x]     c     0 x   --> x
[x,y,n] c (S n) x y --> c n (max x y).

#SNF (c (double 10) 8 7 3 4 5 6 7 4 6 1 2 2 3 5 4 1 2 2 2 9).


#PRINT "----------- bin ------------".

defac bin [N].
[x]          bin x x  -->        S x
[x,y] bin y (bin x x) --> bin y (S x).

def e : N -> N.
[]    e 0         --> 1
[x]   e (S x)     --> plus (e x) (e x)
[x,y] e (bin x y) --> plus (e x) (e y).

#CONV bin 1 1, 2.
#CONV bin 1 (bin 2 (bin 3 2)), bin 1 4.
#CONV bin 1 (bin 2 (bin 3 1)), 4.
#CONV e (bin 1 (bin 2 (bin 3 1))), double 8.

