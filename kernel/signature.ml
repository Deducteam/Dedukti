(** Global Environment *)

open Basics
open Term
open Rule

let ignore_redecl = ref false
let autodep = ref false

type dtree_or_def =
  | DoD_None
  | DoD_Def of term
  | DoD_Dtree of int*dtree

module H = Hashtbl.Make(
struct
  type t        = ident
  let equal     = ident_eq
  let hash      = Hashtbl.hash
end )

type rw_infos =
  | Decl    of term
  | Def     of term*term
  | Decl_rw of term*rule_infos list*int*dtree

type t = { name:ident; tables:(rw_infos H.t) H.t }

let dummy = { name=qmark; tables=H.create 1; }

let make name =
  let ht = H.create 19 in
    H.add ht name (H.create 251); { name=name; tables=ht; }

let get_name sg = sg.name

(******************************************************************************)

let marshal name deps env =
  try
    begin
      let out = open_out (string_of_ident name ^ ".dko" ) in
        Marshal.to_channel out Version.version [] ;
        Marshal.to_channel out deps [] ;
        Marshal.to_channel out env [Marshal.Closures] ;
        close_out out
    end
  with
    | _ -> Print.fail dloc "Fail to export module '%a'." pp_ident name

exception BadVersionNumber

let file_exists = Sys.file_exists

let rec find_dko_in_path name = function
  | [] -> failwith "find_dko"  (* Captured by the unmarshal function *)
  | dir :: path ->
      let filename = dir ^ "/" ^ name ^ ".dko" in
        if file_exists filename then
          open_in filename
        else
          find_dko_in_path name path

let find_dko name =
  (* First check in the current directory *)
  let filename = name ^ ".dko" in
    if file_exists filename then
      open_in filename
    else
      (* If not found in the current directory, search in load-path *)
      find_dko_in_path name (get_path())

let unmarshal (lc:loc) (m:string) : string list * rw_infos H.t =
  try
    begin
      let chan = find_dko m in
      let ver:string = Marshal.from_channel chan in
        if String.compare ver Version.version = 0 then
          begin
            let deps:string list = Marshal.from_channel chan in
            let ctx:rw_infos H.t = Marshal.from_channel chan in
              close_in chan ; (deps,ctx)
          end
        else raise BadVersionNumber
    end
  with
    | BadVersionNumber -> Print.fail lc "Fail to open\
module '%s' (file generated by a different version?)." m
    | Sys_error s -> Print.fail lc "Fail to open module '%s' (%s)." m s
    | _ -> Print.fail lc "Fail to open module '%s'." m

(******************************************************************************)

(* Recursively load a module and its dependencies*)
let rec import sg lc m =
  assert ( not (H.mem sg.tables m) ) ;

  (* If the [.dko] file is not found, try to compile it first.
   This hack is terrible. It uses system calls and can loop with circular dependencies. *)
  ( if !autodep && not ( Sys.file_exists ( string_of_ident m ^ ".dko" ) ) then
    if Sys.command ( "dkcheck -autodep -e " ^ string_of_ident m ^ ".dk" ) <> 0 then
      Print.fail lc "Fail to compile dependency '%a'." pp_ident m
    ) ;

    let (deps,ctx) = unmarshal lc (string_of_ident m) in
  H.add sg.tables m ctx;
  List.iter (
    fun dep -> if not (H.mem sg.tables m) then
      ignore (import sg lc (hstring dep))
      ) deps ;
                                       ctx

let get_deps sg : string list = (*only direct dependencies*)
  H.fold (
    fun md _ lst ->
      if ident_eq md sg.name then lst
      else (string_of_ident md)::lst
    ) sg.tables []

let export sg = marshal sg.name (get_deps sg) (H.find sg.tables sg.name)

(******************************************************************************)

let get_infos sg lc m v =
  let env =
    try H.find sg.tables m
          with Not_found -> import sg lc m
                              in
  try ( H.find env v )
with Not_found ->
  Print.fail lc "Cannot find symbol '%a.%a'." pp_ident m pp_ident v

let get_type sg lc m v =
  match get_infos sg lc m v with
    | Decl ty
    | Def (_,ty)
        | Decl_rw (ty,_,_,_) -> ty

let get_dtree sg l m v =
  match get_infos sg l m v with
    | Decl _ -> DoD_None
    | Def (te,_) -> DoD_Def te
        | Decl_rw (_,_,i,tr) -> DoD_Dtree (i,tr)

(******************************************************************************)

let add sg lc v gst =
  let env = H.find sg.tables sg.name in
  if H.mem env v then
    if !ignore_redecl then
      Print.debug "Redeclaration ignored."
    else
      Print.fail lc "Already defined symbol '%a'." pp_ident v
    else
      H.add env v gst

let declare sg lc v ty    = add sg lc v (Decl ty)
let define sg lc v te ty  = add sg lc v (Def (te,ty))
(*
 let rule_to_frule (ctx,pat,rhs) =
 match pat with
 | Pattern(l,md,id,args) -> { l ; ctx ; md; id ; args ; rhs }
 | Var (l,_,_,_) -> Print.fail l "A variable is not a valid pattern."
 | Brackets _ -> assert false
 | Lambda _ -> assert false
 *)
let add_rules sg lst =
  let rs = List.map Dtree.to_rule_infos lst in
    match rs with
      | [] -> ()
      | r::_ as rs ->
          let env = H.find sg.tables sg.name in
          let (ty,rules) =
            match H.find env r.id with
              | Decl ty                   -> ( ty , rs )
              | Decl_rw (ty,mx,_,_)       -> ( ty , mx@rs )
              | Def (_,_)                 ->
                  Print.fail r.l "Cannot add rewrite\
                    rules for the defined symbol '%a'." pp_ident r.id
          in
          let (n,tree) = Dtree.of_rules rules in
            H.add env r.id (Decl_rw (ty,rules,n,tree))

