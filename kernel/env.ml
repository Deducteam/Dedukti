open Term
open Rule
open Printf

let name = ref (hstring "noname")
let ignore_redecl = ref false
let autodep = ref false

module H = Hashtbl.Make(
struct
  type t        = ident
  let equal     = ident_eq
  let hash      = Hashtbl.hash
end )

(******************************************************************************)

type rw_infos =
  | Decl    of term
  | Def     of term*term
  | Decl_rw of term*rule list*int*dtree

let envs : (rw_infos H.t) H.t = H.create 19
let init nm =
  name := nm;
  H.add envs nm (H.create 251)

let marshal name deps env =
  try
    begin
      let out = open_out (string_of_ident name ^ ".dko" ) in
        Marshal.to_channel out Version.version [] ;
        Marshal.to_channel out deps [] ;
        Marshal.to_channel out env [Marshal.Closures] ;
        close_out out
    end
  with
    | _ -> Print.fail dloc "Fail to export module '%a'." pp_ident name

exception BadVersionNumber

let unmarshal (lc:loc) (m:string) =
  try
    begin
      let chan = open_in ( m ^ ".dko" ) in
      let ver:string = Marshal.from_channel chan in
        if String.compare ver Version.version = 0 then
          begin
            let deps:string list = Marshal.from_channel chan in
            let ctx:rw_infos H.t = Marshal.from_channel chan in
              close_in chan ; (deps,ctx)
          end
        else raise BadVersionNumber
    end
  with
    | BadVersionNumber -> Print.fail lc "Fail to open\
module '%s' (file generated by a different version?)." m
    | Sys_error s -> Print.fail lc "Fail to open module '%s' (%s)." m s
    | _ -> Print.fail lc "Fail to open module '%s'." m

(******************************************************************************)

let import lc m =
  assert ( not (H.mem envs m) );
  (* If the [.dko] file is not found, try to compile it first.
   This hack is terrible. It uses system calls and can loop with circular dependencies. *)
  ( if !autodep && not ( Sys.file_exists ( string_of_ident m ^ ".dko" ) ) then
      if Sys.command ( "dkcheck -autodep -e " ^ string_of_ident m ^ ".dk" ) <> 0 then
        Print.fail lc "Fail to compile dependency '%a'." pp_ident m
  ) ;
    let (_,ctx) = unmarshal lc (string_of_ident m) in
      ( H.add envs m ctx ; ctx )

let get_deps () : string list =
  H.fold (
    fun md _ lst ->
      if ident_eq md !name then lst
      else (string_of_ident md)::lst
  ) envs []

let clear () = H.clear envs
let export () = marshal !name (get_deps ()) (H.find envs !name)

(******************************************************************************)

let get_infos lc m v =
  let env =
    try H.find envs m
    with Not_found -> import lc m
  in
    try ( H.find env v )
    with Not_found ->
      Print.fail lc "Cannot find symbol '%a.%a'." pp_ident m pp_ident v

let get_type lc m v =
  match get_infos lc m v with
    | Decl ty
    | Def (_,ty)
    | Decl_rw (ty,_,_,_) -> ty

(******************************************************************************)

let add lc v gst =
  let env = H.find envs !name in
    if H.mem env v then
      if !ignore_redecl then
        Print.debug "Redeclaration ignored."
      else
        Print.fail lc "Already defined symbol '%a'." pp_ident v
    else
      H.add env v gst

let add_decl lc v ty    = add lc v (Decl ty)
let add_def lc v te ty  = add lc v (Def (te,ty))

let add_rw : rule list -> unit = function
  | [] -> ()
  | r::_ as rs ->
      let env = H.find envs !name in
      let (ty,rules) =
        match H.find env r.id with
          | Decl ty                   -> ( ty , rs )
          | Decl_rw (ty,mx,_,_)       -> ( ty , mx@rs )
          | Def (_,_)                 ->
              Print.fail r.l "Cannot add rewrite\
                rules for the defined symbol '%a'." pp_ident r.id
      in
      let (n,tree) = Dtree.of_rules rules in
        H.add env r.id (Decl_rw (ty,rules,n,tree))

(******************************************************************************)


module S = Set.Make (
struct
  type t = string
  let compare = String.compare
end )

let get_rules ctx : rule list =
  let lst_lst =
    H.fold (fun _ infos lst ->
              match infos with
                | Decl_rw (_,rs,_,_) -> rs::lst
                | _ -> lst
    ) ctx []
  in List.flatten lst_lst

let get_all_rules (md:string) : (string*rule list) list =
  let set = S.empty in
  let rec load = function
    | [] -> []
    | m::lst ->
        if S.mem m set then load lst
        else
          begin
            let (deps,ctx) = unmarshal dloc m in
              (m,ctx)::(load (List.rev_append lst deps))
          end
  in
    List.rev_map (fun (m,ctx) -> (m,get_rules ctx)) (load [md])
