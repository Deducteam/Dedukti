open Basics
open Term
open Rule

let ignore_redecl = ref false
let autodep = ref false

type dtree_or_def =
    | DoD_None
    | DoD_Def of term
    | DoD_Dtree of int*dtree

module Signature : sig
  type t

  val dummy               : t
  val make                : ident -> t
  val get_name            : t -> ident

  val export    : t -> unit
  val get_type            : t -> loc -> ident -> ident -> term
  val get_dtree           : t -> loc -> ident -> ident -> dtree_or_def
  val declare             : t -> loc -> ident -> term -> unit
  val define              : t -> loc -> ident -> term -> term -> unit
  val add_rules           : t -> Rule.rule list -> unit
  val get_all_rules       : string -> (string*frule list) list
end =

struct
  module H = Hashtbl.Make(
  struct
    type t        = ident
    let equal     = ident_eq
    let hash      = Hashtbl.hash
  end )

  type rw_infos =
    | Decl    of term
    | Def     of term*term
    | Decl_rw of term*frule list*int*dtree

  type t = { name:ident; tables:(rw_infos H.t) H.t }

  let dummy = { name=qmark; tables=H.create 1; }

  let make name =
    let ht = H.create 19 in
      H.add ht name (H.create 251); { name=name; tables=ht; }

  let get_name sg = sg.name

  (******************************************************************************)

  let marshal name deps env =
    try
      begin
        let out = open_out (string_of_ident name ^ ".dko" ) in
          Marshal.to_channel out Version.version [] ;
          Marshal.to_channel out deps [] ;
          Marshal.to_channel out env [Marshal.Closures] ;
          close_out out
      end
    with
      | _ -> Print.fail dloc "Fail to export module '%a'." pp_ident name

  exception BadVersionNumber

  let unmarshal (lc:loc) (m:string) : string list * rw_infos H.t =
    try
      begin
        let chan = open_in ( m ^ ".dko" ) in
        let ver:string = Marshal.from_channel chan in
          if String.compare ver Version.version = 0 then
            begin
              let deps:string list = Marshal.from_channel chan in
              let ctx:rw_infos H.t = Marshal.from_channel chan in
                close_in chan ; (deps,ctx)
            end
          else raise BadVersionNumber
      end
    with
      | BadVersionNumber -> Print.fail lc "Fail to open\
  module '%s' (file generated by a different version?)." m
      | Sys_error s -> Print.fail lc "Fail to open module '%s' (%s)." m s
      | _ -> Print.fail lc "Fail to open module '%s'." m

  (******************************************************************************)

  let import sg lc m =
    assert ( not (H.mem sg.tables m) );
    (* If the [.dko] file is not found, try to compile it first.
     This hack is terrible. It uses system calls and can loop with circular dependencies. *)
    ( if !autodep && not ( Sys.file_exists ( string_of_ident m ^ ".dko" ) ) then
        if Sys.command ( "dkcheck -autodep -e " ^ string_of_ident m ^ ".dk" ) <> 0 then
          Print.fail lc "Fail to compile dependency '%a'." pp_ident m
    ) ;
    let (_,ctx) = unmarshal lc (string_of_ident m) in
      ( H.add sg.tables m ctx ; ctx )

  let get_deps sg : string list = (*only direct dependencies*)
    H.fold (
      fun md _ lst ->
        if ident_eq md sg.name then lst
        else (string_of_ident md)::lst
    ) sg.tables []

  let export sg = marshal sg.name (get_deps sg) (H.find sg.tables sg.name)

  (******************************************************************************)

  let get_infos sg lc m v =
    let env =
      try H.find sg.tables m
      with Not_found -> import sg lc m
    in
      try ( H.find env v )
      with Not_found ->
        Print.fail lc "Cannot find symbol '%a.%a'." pp_ident m pp_ident v

  let get_type sg lc m v =
    match get_infos sg lc m v with
      | Decl ty
      | Def (_,ty)
      | Decl_rw (ty,_,_,_) -> ty

  let get_dtree sg l m v =
    match get_infos sg l m v with
      | Decl _ -> DoD_None
      | Def (te,_) -> DoD_Def te
      | Decl_rw (_,_,i,tr) -> DoD_Dtree (i,tr)


  (******************************************************************************)

  let add sg lc v gst =
    let env = H.find sg.tables sg.name in
      if H.mem env v then
        if !ignore_redecl then
          Print.debug "Redeclaration ignored."
        else
          Print.fail lc "Already defined symbol '%a'." pp_ident v
      else
        H.add env v gst

  let declare sg lc v ty    = add sg lc v (Decl ty)
  let define sg lc v te ty  = add sg lc v (Def (te,ty))

  let rule_to_frule (ctx,pat,rhs) =
    match pat with
      | Pattern(l,md,id,args) -> { l ; ctx ; md; id ; args ; rhs }
      | Var (l,_,_,_) -> Print.fail l "A variable is not a valid pattern."
      | Brackets _ -> assert false
      | Lambda _ -> assert false
      | Joker _ -> assert false

  let add_rules sg lst =
    match List.map rule_to_frule lst with
      | [] -> ()
      | r::_ as rs ->
          let env = H.find sg.tables sg.name in
          let (ty,rules) =
            match H.find env r.id with
              | Decl ty                   -> ( ty , rs )
              | Decl_rw (ty,mx,_,_)       -> ( ty , mx@rs )
              | Def (_,_)                 ->
                  Print.fail r.l "Cannot add rewrite\
                    rules for the defined symbol '%a'." pp_ident r.id
          in
          let (n,tree) = Dtree.of_rules rules in
            H.add env r.id (Decl_rw (ty,rules,n,tree))

  (******************************************************************************)

  module S = Set.Make (
  struct
    type t = string
    let compare = String.compare
  end )

  let get_rules ctx : frule list =
    let lst_lst =
      H.fold (fun _ infos lst ->
                match infos with
                  | Decl_rw (_,rs,_,_) -> rs::lst
                  | _ -> lst
      ) ctx []
    in List.flatten lst_lst

  let get_all_rules (md:string) : (string*frule list) list =
    let set = S.empty in
    let rec load = function
      | [] -> []
      | m::lst ->
          if S.mem m set then load lst
          else
            begin
              let (deps,ctx) = unmarshal dloc m in
                (m,ctx)::(load (List.rev_append lst deps))
            end
    in
      List.rev_map (fun (m,ctx) -> (m,get_rules ctx)) (load [md])
end
  (******************************************************************************)

(* Wrapper around Signature *)
let sg = ref Signature.dummy

let init name = sg := Signature.make name
let export () = Signature.export !sg

let get_name () = Signature.get_name !sg
let get_type l md id = Signature.get_type !sg l md id
let get_dtree l md id = Signature.get_dtree !sg l md id

let declare l id ty = Signature.declare !sg l id ty
let define l id te ty = Signature.define !sg l id te ty
let add_rules rs = Signature.add_rules !sg rs
