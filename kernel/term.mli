open Basic

(** Lambda terms *)

(** {2 Terms} *)

(* TODO: abstract de Bruijn indices in DB constructor *)
type term = private
  | Kind  (** Kind *)
  | Type of loc  (** Type *)
  | DB of loc * ident * int  (** deBruijn indices *)
  | Const of loc * name  (** Global variable *)
  | App of term * term * term list  (** f a1 [ a2 ; ... ; an ] , f not an App *)
  | Lam of loc * ident * term option * term  (** Lambda abstraction *)
  | Pi of loc * ident * term * term  (** Pi abstraction *)

val pp_term : term printer

val get_loc : term -> loc

val mk_Kind : term

val mk_Type : loc -> term

val mk_DB : loc -> ident -> int -> term

val mk_Const : loc -> name -> term

val mk_Lam : loc -> ident -> term option -> term -> term

val mk_App : term -> term -> term list -> term

val mk_App2 : term -> term list -> term

val mk_Pi : loc -> ident -> term -> term -> term

val mk_Arrow : loc -> term -> term -> term

(** [add_n_lambdas n t] returns the term [t] with [n] (extra) anonymous
    lambda abstraction. Doesn't shift free variables of [t]. *)
val add_n_lambdas : int -> term -> term

(** [term_eq t t'] is [true] if [t] = [t'] (up to alpha equivalence) *)
val term_eq : term -> term -> bool

(** Position in a term *)
type position = int list

exception InvalidSubterm of term * int

(** [subterm t p] returns the subterm of [t] at position [p].
    Raises InvalidSubterm in case of invalid position in given term. *)
val subterm : term -> position -> term

(** Type for comparison functions *)
type 'a comparator = 'a -> 'a -> int

(** compare_term [id_comp] [t] [t'] compares both terms (up to alpha equivalence).
 * The order relation goes :
 * Kind < Type < Const < DB < App < Lam < Pi
 * Besides
 * Const m v < Const m' v' iif (m,v) < (m',v')
 * DB n < DB n' iif n < n'
 * App f a args < App f' a' args' iif (f,a,args) < (f',a',args')
 * Lam x ty t < Lam x' ty' t'  iif t < t'
 * Pi  x a  b < Pi  x' a'  b'  iif (a,b) < (a',b')
 *)
val compare_term : name comparator -> term comparator

type algebra = Free | AC | ACU of term  (** Symbols' algebra *)

(** Return true iff given algebra is AC or ACU. *)
val is_AC : algebra -> bool

(** Constraints [(n,t,u)] are [t]=[u] under [n] lambdas *)
type cstr = int * term * term

val pp_cstr : cstr printer

(** {2 Contexts} *)

(** General context: variables have abstract annotations *)
type 'a context = (loc * ident * 'a) list

(** Partially annotated context: as generated at rule parsing *)
type partially_typed_context = term option context

(** Fully type annotated context: as generated by type checking *)
type typed_context = term context

(** Arity annotated context: used for rewriting in untyped setting *)
type arity_context = int context

val pp_untyped_context : 'a context printer

val pp_typed_context : typed_context printer

val pp_part_typed_context : partially_typed_context printer

val rename_vars_with_typed_context : typed_context -> term -> term

(** ([n], [t]) represents the term represented by [t]
  * (whichever its representation) under [n] lambda abstractions. *)
type 'a depthed = int * 'a
