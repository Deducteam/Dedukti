open Basic
open Term


(** Rewrite rules *)

(** {2 Patterns} *)

type pattern =
  | Var         of loc * ident * int * pattern list
      (** l x i [x1 ; x2 ; ... ; xn ] where [i] is the position of x inside the context
          of the rule *)
  | Pattern     of loc * ident * ident * pattern list
      (** l md id [p1 ; p2 ; ... ; pn ] where [md.id] is a constant *)
  | Lambda      of loc * ident * pattern
      (** lambda abstraction *)
  | Brackets    of term
      (** te where [te] is convertible to the pattern matched *)

val pp_pattern : Format.formatter -> pattern -> unit

val get_loc_pat : pattern -> loc

val pattern_to_term : pattern -> term

(** a linear_pattern is a pattern whithout brackets constraints and each free variable appear exactly once. The function Dtree.linearize handle the linearization of a pattern *)
type linear_pattern =
  | LJoker
  | LVar         of ident * int * int list
  | LLambda      of ident * linear_pattern
  | LPattern     of ident * ident * linear_pattern array
  | LBoundVar    of ident * int * linear_pattern array

val pp_linear_pattern : Format.formatter -> linear_pattern -> unit

(** constr is the type of constraints. They are generated by the function Dtree.linearize *)
type constr =
  | Linearity of int * int (** indices i and j should be convertible *)
  | Bracket of int * term (** indicies i should be convertible to term te *)

(** {2 Contexts} *)

(** context of rules after they have been parsed *)
type untyped_context = (loc * ident) list

val pp_untyped_context : Format.formatter -> untyped_context -> unit

(** type checking rules implies to give a type to the variables of the context *)
type typed_context = ( loc * ident * term ) list

val pp_typed_context : Format.formatter -> typed_context -> unit

(** {2 Rewrite Rules} *)

type 'a rule = 'a * pattern * term

type untyped_rule = untyped_context rule

val pp_untyped_rule : Format.formatter -> untyped_rule -> unit

type typed_rule = typed_context rule

val pp_typed_rule : Format.formatter -> typed_rule -> unit

type rule_infos = {
  l : loc; (** location of the rule *)
  ctx : typed_context; (** typed context of the rule *)
  md : ident; (** module where the pattern constant is defined *)
  id : ident; (** name of the pattern constant *)
  args : pattern list; (** arguments list of the pattern constant *)
  rhs : term; (** right hand side of the rule *)
  esize : int; (** size of the context *)
  l_args : linear_pattern array; (** free pattern without constraint *)
  constraints : constr list; (** constraints generated from the pattern to the free pattern *)
}

val pp_rule_infos : Format.formatter -> rule_infos -> unit

(** {2 Linarization} *)

type rule_error =
  | BoundVariableExpected of pattern
  | DistinctBoundVariablesExpected of loc * ident
  | VariableBoundOutsideTheGuard of term

val allow_non_linear : bool ref

val linearize : int -> pattern list -> (int * linear_pattern list * constr list)
