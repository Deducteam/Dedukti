
open Types

type gst =
  | Decl  of term
  | Def   of term*term

type env = (string,gst) Hashtbl.t

let env : env = Hashtbl.create 251
let ext : (string,env) Hashtbl.t = Hashtbl.create 19 

(* Get *)

let get_env m = 
  if m = !Global.name then env
  else
    ( try Hashtbl.find ext m 
      with Not_found -> failwith "Could not find the module" )

let get_symbol (m,v) =
  let ht = get_env m in
  try ( Hashtbl.find ht v )
  with Not_found -> raise (TypingError (UndefinedSymbol (m,v)))

let get_type id = 
  match get_symbol id with
    | Decl ty           -> ty
    | Def (_,ty)        -> ty 

let get_def id = 
  match get_symbol id with
    | Decl _          -> None
    | Def (te,_)      -> Some te 

(* Add *)

let add_decl (v,ty) = 
  if Hashtbl.mem env v then failwith "Already defined id" 
  else Hashtbl.add env v (Decl ty)

let add_def (v,te,ty) =
  if Hashtbl.mem env v then failwith "Already defined id"
  else Hashtbl.add env v (Def (te,ty))

(* Modules *)

let import m =
  if Hashtbl.mem ext m then failwith "import (1)"
  else
    try 
      let chan = open_in (m^".dko") in
      let ctx:env = Marshal.from_channel chan in
        Hashtbl.add ext m ctx
    with Not_found -> failwith "import (2)"

let export_and_clear () = 
  ( if !Global.export then
    let out = open_out (!Global.name^".dko") in (*FIXME*)
      Marshal.to_channel out env [Marshal.Closures] ) ;
  Hashtbl.clear env ;
  Hashtbl.clear ext

(* Debug *)

let dump_context h =
  Hashtbl.iter (
  fun s d ->
    match d with
      | Def (_,_)       -> Global.msg (s^" is a def.\n")
      | Decl _          -> Global.msg (s^" is declared.\n")
  ) h

let dump_symbols () = 
  Global.msg ("### MODULE "^ !Global.name ^"\n");
  dump_context env; 
  Hashtbl.iter (
    fun m h ->
      Global.msg ("### MODULE "^m^"\n");
      dump_context h
  ) ext
