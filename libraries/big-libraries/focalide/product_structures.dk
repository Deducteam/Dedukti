#NAME product_structures.

Product_additive_monoid__me_as_species :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) -> Type.

Product_additive_monoid__mk_record :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  Product_additive_monoid__rf_T:cc.uT ->
  Product_additive_monoid__rf_first:((cc.eT Product_additive_monoid__rf_T) ->
                                     cc.eT M1_T) ->
  Product_additive_monoid__rf_pair:((cc.eT M1_T) ->
                                    (cc.eT M2_T) ->
                                    cc.eT Product_additive_monoid__rf_T) ->
  Product_additive_monoid__rf_parse:((cc.eT basics.string__t) ->
                                     cc.eT Product_additive_monoid__rf_T) ->
  Product_additive_monoid__rf_print:((cc.eT Product_additive_monoid__rf_T) ->
                                     cc.eT basics.string__t) ->
  Product_additive_monoid__rf_second:((cc.eT Product_additive_monoid__rf_T) ->
                                      cc.eT M2_T) ->
  Product_additive_monoid__rf_zero:(cc.eT Product_additive_monoid__rf_T) ->
  Product_additive_monoid__rf_element:(cc.eT Product_additive_monoid__rf_T) ->
  Product_additive_monoid__rf_pair_preserves_first:(dk_logic.eP 
                                                      (dk_logic.forall M1_T 
                                                         (x:(cc.eT M1_T) =>
                                                          dk_logic.forall 
                                                            M2_T 
                                                            (y:
                                                             (cc.eT M2_T) =>
                                                             dk_logic.ebP 
                                                               (_p_M1_equal 
                                                                  (Product_additive_monoid__rf_first 
                                                                    (Product_additive_monoid__rf_pair 
                                                                    x y)) x))))) ->
  Product_additive_monoid__rf_equal:((cc.eT Product_additive_monoid__rf_T) ->
                                     (cc.eT Product_additive_monoid__rf_T) ->
                                     cc.eT basics.bool__t) ->
  Product_additive_monoid__rf_pair_preserves_second:(dk_logic.eP 
                                                       (dk_logic.forall M1_T 
                                                          (x:(cc.eT M1_T) =>
                                                           dk_logic.forall 
                                                             M2_T 
                                                             (y:
                                                              (cc.eT M2_T) =>
                                                              dk_logic.ebP 
                                                                (_p_M2_equal 
                                                                   (Product_additive_monoid__rf_second 
                                                                    (Product_additive_monoid__rf_pair 
                                                                    x y)) y))))) ->
  Product_additive_monoid__rf_plus:((cc.eT Product_additive_monoid__rf_T) ->
                                    (cc.eT Product_additive_monoid__rf_T) ->
                                    cc.eT Product_additive_monoid__rf_T) ->
  Product_additive_monoid__rf_first_accessibility:(dk_logic.eP 
                                                     (dk_logic.forall M1_T 
                                                        (x:(cc.eT M1_T) =>
                                                         dk_logic.exists 
                                                           Product_additive_monoid__rf_T 
                                                           (s:
                                                            (cc.eT 
                                                               Product_additive_monoid__rf_T) =>
                                                            dk_logic.ebP 
                                                              (_p_M1_equal 
                                                                 (Product_additive_monoid__rf_first 
                                                                    s) x))))) ->
  Product_additive_monoid__rf_different:((cc.eT Product_additive_monoid__rf_T) ->
                                         (cc.eT Product_additive_monoid__rf_T) ->
                                         cc.eT basics.bool__t) ->
  Product_additive_monoid__rf_equal_reflexive:(dk_logic.eP 
                                                 (dk_logic.forall 
                                                    Product_additive_monoid__rf_T 
                                                    (x:
                                                     (cc.eT 
                                                        Product_additive_monoid__rf_T) =>
                                                     dk_logic.ebP 
                                                       (Product_additive_monoid__rf_equal 
                                                          x x)))) ->
  Product_additive_monoid__rf_equal_spec:(dk_logic.eP 
                                            (dk_logic.forall 
                                               Product_additive_monoid__rf_T 
                                               (x:
                                                (cc.eT 
                                                   Product_additive_monoid__rf_T) =>
                                                dk_logic.forall 
                                                  Product_additive_monoid__rf_T 
                                                  (y:
                                                   (cc.eT 
                                                      Product_additive_monoid__rf_T) =>
                                                   dk_logic.eqv 
                                                     (dk_logic.ebP 
                                                        (Product_additive_monoid__rf_equal 
                                                           x y)) 
                                                     (dk_logic.and 
                                                        (dk_logic.ebP 
                                                           (_p_M1_equal 
                                                              (Product_additive_monoid__rf_first 
                                                                 x) 
                                                              (Product_additive_monoid__rf_first 
                                                                 y))) 
                                                        (dk_logic.ebP 
                                                           (_p_M2_equal 
                                                              (Product_additive_monoid__rf_second 
                                                                 x) 
                                                              (Product_additive_monoid__rf_second 
                                                                 y)))))))) ->
  Product_additive_monoid__rf_equal_symmetric:(dk_logic.eP 
                                                 (dk_logic.forall 
                                                    Product_additive_monoid__rf_T 
                                                    (x:
                                                     (cc.eT 
                                                        Product_additive_monoid__rf_T) =>
                                                     dk_logic.forall 
                                                       Product_additive_monoid__rf_T 
                                                       (y:
                                                        (cc.eT 
                                                           Product_additive_monoid__rf_T) =>
                                                        dk_logic.imp 
                                                          (dk_logic.ebP 
                                                             (Product_additive_monoid__rf_equal 
                                                                x y)) 
                                                          (dk_logic.ebP 
                                                             (Product_additive_monoid__rf_equal 
                                                                y x)))))) ->
  Product_additive_monoid__rf_equal_transitive:(dk_logic.eP 
                                                  (dk_logic.forall 
                                                     Product_additive_monoid__rf_T 
                                                     (x:
                                                      (cc.eT 
                                                         Product_additive_monoid__rf_T) =>
                                                      dk_logic.forall 
                                                        Product_additive_monoid__rf_T 
                                                        (y:
                                                         (cc.eT 
                                                            Product_additive_monoid__rf_T) =>
                                                         dk_logic.forall 
                                                           Product_additive_monoid__rf_T 
                                                           (z:
                                                            (cc.eT 
                                                               Product_additive_monoid__rf_T) =>
                                                            dk_logic.imp 
                                                              (dk_logic.ebP 
                                                                 (Product_additive_monoid__rf_equal 
                                                                    x y)) 
                                                              (dk_logic.imp 
                                                                 (dk_logic.ebP 
                                                                    (
                                                                    Product_additive_monoid__rf_equal 
                                                                    y z)) 
                                                                 (dk_logic.ebP 
                                                                    (
                                                                    Product_additive_monoid__rf_equal 
                                                                    x z)))))))) ->
  Product_additive_monoid__rf_first_substitution_rule:(dk_logic.eP 
                                                         (dk_logic.forall 
                                                            Product_additive_monoid__rf_T 
                                                            (x:
                                                             (cc.eT 
                                                                Product_additive_monoid__rf_T) =>
                                                             dk_logic.forall 
                                                               Product_additive_monoid__rf_T 
                                                               (y:
                                                                (cc.eT 
                                                                   Product_additive_monoid__rf_T) =>
                                                                dk_logic.imp 
                                                                  (dk_logic.ebP 
                                                                    (Product_additive_monoid__rf_equal 
                                                                    x y)) 
                                                                  (dk_logic.ebP 
                                                                    (_p_M1_equal 
                                                                    (Product_additive_monoid__rf_first 
                                                                    x) 
                                                                    (Product_additive_monoid__rf_first 
                                                                    y))))))) ->
  Product_additive_monoid__rf_is_zero:((cc.eT Product_additive_monoid__rf_T) ->
                                       cc.eT basics.bool__t) ->
  Product_additive_monoid__rf_second_substitution_rule:(dk_logic.eP 
                                                          (dk_logic.forall 
                                                             Product_additive_monoid__rf_T 
                                                             (x:
                                                              (cc.eT 
                                                                 Product_additive_monoid__rf_T) =>
                                                              dk_logic.forall 
                                                                Product_additive_monoid__rf_T 
                                                                (y:
                                                                 (cc.eT 
                                                                    Product_additive_monoid__rf_T) =>
                                                                 dk_logic.imp 
                                                                   (dk_logic.ebP 
                                                                    (Product_additive_monoid__rf_equal 
                                                                    x y)) 
                                                                   (dk_logic.ebP 
                                                                    (_p_M2_equal 
                                                                    (Product_additive_monoid__rf_second 
                                                                    x) 
                                                                    (Product_additive_monoid__rf_second 
                                                                    y))))))) ->
  Product_additive_monoid__rf_pair_left_substitution_rule:(dk_logic.eP 
                                                             (dk_logic.forall 
                                                                M1_T 
                                                                (x_1:
                                                                 (cc.eT M1_T) =>
                                                                 dk_logic.forall 
                                                                   M1_T 
                                                                   (x_2:
                                                                    (
                                                                    cc.eT 
                                                                    M1_T) =>
                                                                    dk_logic.forall 
                                                                    M2_T 
                                                                    (y:
                                                                    (cc.eT 
                                                                    M2_T) =>
                                                                    dk_logic.imp 
                                                                    (dk_logic.ebP 
                                                                    (_p_M1_equal 
                                                                    x_1 x_2)) 
                                                                    (dk_logic.ebP 
                                                                    (Product_additive_monoid__rf_equal 
                                                                    (Product_additive_monoid__rf_pair 
                                                                    x_1 y) 
                                                                    (Product_additive_monoid__rf_pair 
                                                                    x_2 y)))))))) ->
  Product_additive_monoid__rf_pair_right_substitution_rule:(dk_logic.eP 
                                                              (dk_logic.forall 
                                                                 M1_T 
                                                                 (x:
                                                                  (cc.eT M1_T) =>
                                                                  dk_logic.forall 
                                                                    M2_T 
                                                                    (
                                                                    y_1:
                                                                    (
                                                                    cc.eT 
                                                                    M2_T) =>
                                                                    dk_logic.forall 
                                                                    M2_T 
                                                                    (y_2:
                                                                    (cc.eT 
                                                                    M2_T) =>
                                                                    dk_logic.imp 
                                                                    (dk_logic.ebP 
                                                                    (_p_M2_equal 
                                                                    y_1 y_2)) 
                                                                    (dk_logic.ebP 
                                                                    (Product_additive_monoid__rf_equal 
                                                                    (Product_additive_monoid__rf_pair 
                                                                    x y_1) 
                                                                    (Product_additive_monoid__rf_pair 
                                                                    x y_2)))))))) ->
  Product_additive_monoid__rf_second_accessibility:(dk_logic.eP 
                                                      (dk_logic.forall M2_T 
                                                         (x:(cc.eT M2_T) =>
                                                          dk_logic.exists 
                                                            Product_additive_monoid__rf_T 
                                                            (s:
                                                             (cc.eT 
                                                                Product_additive_monoid__rf_T) =>
                                                             dk_logic.ebP 
                                                               (_p_M2_equal 
                                                                  (Product_additive_monoid__rf_second 
                                                                    s) x))))) ->
  Product_additive_monoid__rf_plus_is_associative:(dk_logic.eP 
                                                     (dk_logic.forall 
                                                        Product_additive_monoid__rf_T 
                                                        (x:
                                                         (cc.eT 
                                                            Product_additive_monoid__rf_T) =>
                                                         dk_logic.forall 
                                                           Product_additive_monoid__rf_T 
                                                           (y:
                                                            (cc.eT 
                                                               Product_additive_monoid__rf_T) =>
                                                            dk_logic.forall 
                                                              Product_additive_monoid__rf_T 
                                                              (z:
                                                               (cc.eT 
                                                                  Product_additive_monoid__rf_T) =>
                                                               dk_logic.ebP 
                                                                 (Product_additive_monoid__rf_equal 
                                                                    (
                                                                    Product_additive_monoid__rf_plus 
                                                                    x 
                                                                    (Product_additive_monoid__rf_plus 
                                                                    y z)) 
                                                                    (
                                                                    Product_additive_monoid__rf_plus 
                                                                    (Product_additive_monoid__rf_plus 
                                                                    x y) z))))))) ->
  Product_additive_monoid__rf_zero_is_neutral:(dk_logic.eP 
                                                 (dk_logic.forall 
                                                    Product_additive_monoid__rf_T 
                                                    (x:
                                                     (cc.eT 
                                                        Product_additive_monoid__rf_T) =>
                                                     dk_logic.and 
                                                       (dk_logic.ebP 
                                                          (Product_additive_monoid__rf_equal 
                                                             (Product_additive_monoid__rf_plus 
                                                                x 
                                                                Product_additive_monoid__rf_zero) 
                                                             x)) 
                                                       (dk_logic.ebP 
                                                          (Product_additive_monoid__rf_equal 
                                                             (Product_additive_monoid__rf_plus 
                                                                Product_additive_monoid__rf_zero 
                                                                x) x))))) ->
  Product_additive_monoid__rf_same_is_not_different:(dk_logic.eP 
                                                       (dk_logic.forall 
                                                          Product_additive_monoid__rf_T 
                                                          (x:
                                                           (cc.eT 
                                                              Product_additive_monoid__rf_T) =>
                                                           dk_logic.forall 
                                                             Product_additive_monoid__rf_T 
                                                             (y:
                                                              (cc.eT 
                                                                 Product_additive_monoid__rf_T) =>
                                                              dk_logic.eqv 
                                                                (dk_logic.ebP 
                                                                   (Product_additive_monoid__rf_different 
                                                                    x y)) 
                                                                (dk_logic.not 
                                                                   (dk_logic.ebP 
                                                                    (Product_additive_monoid__rf_equal 
                                                                    x y))))))) ->
  Product_additive_monoid__rf_is_zero_spec:(dk_logic.eP 
                                              (dk_logic.forall 
                                                 Product_additive_monoid__rf_T 
                                                 (x:
                                                  (cc.eT 
                                                     Product_additive_monoid__rf_T) =>
                                                  dk_logic.eqv 
                                                    (dk_logic.ebP 
                                                       (Product_additive_monoid__rf_is_zero 
                                                          x)) 
                                                    (dk_logic.or 
                                                       (dk_logic.ebP 
                                                          (Product_additive_monoid__rf_equal 
                                                             x 
                                                             Product_additive_monoid__rf_zero)) 
                                                       (dk_logic.ebP 
                                                          (Product_additive_monoid__rf_equal 
                                                             Product_additive_monoid__rf_zero 
                                                             x)))))) ->
  Product_additive_monoid__rf_pair_substitution_rule:(dk_logic.eP 
                                                        (dk_logic.forall 
                                                           M1_T 
                                                           (x_1:
                                                            (cc.eT M1_T) =>
                                                            dk_logic.forall 
                                                              M1_T 
                                                              (x_2:
                                                               (cc.eT M1_T) =>
                                                               dk_logic.forall 
                                                                 M2_T 
                                                                 (y_1:
                                                                  (cc.eT M2_T) =>
                                                                  dk_logic.forall 
                                                                    M2_T 
                                                                    (
                                                                    y_2:
                                                                    (
                                                                    cc.eT 
                                                                    M2_T) =>
                                                                    dk_logic.imp 
                                                                    (dk_logic.ebP 
                                                                    (_p_M1_equal 
                                                                    x_1 x_2)) 
                                                                    (dk_logic.imp 
                                                                    (dk_logic.ebP 
                                                                    (_p_M2_equal 
                                                                    y_1 y_2)) 
                                                                    (dk_logic.ebP 
                                                                    (Product_additive_monoid__rf_equal 
                                                                    (Product_additive_monoid__rf_pair 
                                                                    x_1 y_1) 
                                                                    (Product_additive_monoid__rf_pair 
                                                                    x_2 y_2)))))))))) ->
  Product_additive_monoid__rf_zero_is_unique:(dk_logic.eP 
                                                (dk_logic.forall 
                                                   Product_additive_monoid__rf_T 
                                                   (o:
                                                    (cc.eT 
                                                       Product_additive_monoid__rf_T) =>
                                                    dk_logic.imp 
                                                      (dk_logic.forall 
                                                         Product_additive_monoid__rf_T 
                                                         (x:
                                                          (cc.eT 
                                                             Product_additive_monoid__rf_T) =>
                                                          dk_logic.ebP 
                                                            (Product_additive_monoid__rf_equal 
                                                               x 
                                                               (Product_additive_monoid__rf_plus 
                                                                  x o)))) 
                                                      (dk_logic.ebP 
                                                         (Product_additive_monoid__rf_equal 
                                                            o 
                                                            Product_additive_monoid__rf_zero))))) ->
  Product_additive_monoid__rf_different_is_complete:(dk_logic.eP 
                                                       (dk_logic.forall 
                                                          Product_additive_monoid__rf_T 
                                                          (x:
                                                           (cc.eT 
                                                              Product_additive_monoid__rf_T) =>
                                                           dk_logic.forall 
                                                             Product_additive_monoid__rf_T 
                                                             (y:
                                                              (cc.eT 
                                                                 Product_additive_monoid__rf_T) =>
                                                              dk_logic.forall 
                                                                Product_additive_monoid__rf_T 
                                                                (z:
                                                                 (cc.eT 
                                                                    Product_additive_monoid__rf_T) =>
                                                                 dk_logic.imp 
                                                                   (dk_logic.ebP 
                                                                    (Product_additive_monoid__rf_different 
                                                                    x y)) 
                                                                   (dk_logic.or 
                                                                    (dk_logic.ebP 
                                                                    (Product_additive_monoid__rf_different 
                                                                    x z)) 
                                                                    (dk_logic.ebP 
                                                                    (Product_additive_monoid__rf_different 
                                                                    y z)))))))) ->
  Product_additive_monoid__rf_different_is_irreflexive:(dk_logic.eP 
                                                          (dk_logic.forall 
                                                             Product_additive_monoid__rf_T 
                                                             (x:
                                                              (cc.eT 
                                                                 Product_additive_monoid__rf_T) =>
                                                              dk_logic.not 
                                                                (dk_logic.ebP 
                                                                   (Product_additive_monoid__rf_different 
                                                                    x x))))) ->
  Product_additive_monoid__rf_different_is_symmetric:(dk_logic.eP 
                                                        (dk_logic.forall 
                                                           Product_additive_monoid__rf_T 
                                                           (x:
                                                            (cc.eT 
                                                               Product_additive_monoid__rf_T) =>
                                                            dk_logic.forall 
                                                              Product_additive_monoid__rf_T 
                                                              (y:
                                                               (cc.eT 
                                                                  Product_additive_monoid__rf_T) =>
                                                               dk_logic.imp 
                                                                 (dk_logic.ebP 
                                                                    (
                                                                    Product_additive_monoid__rf_different 
                                                                    x y)) 
                                                                 (dk_logic.ebP 
                                                                    (
                                                                    Product_additive_monoid__rf_different 
                                                                    y x)))))) ->
  Product_additive_monoid__rf_zero_checks_to_zero:(dk_logic.eP 
                                                     (dk_logic.ebP 
                                                        (Product_additive_monoid__rf_is_zero 
                                                           Product_additive_monoid__rf_zero))) ->
  Product_additive_monoid__rf_plus_commutes:(dk_logic.eP 
                                               (dk_logic.forall 
                                                  Product_additive_monoid__rf_T 
                                                  (x:
                                                   (cc.eT 
                                                      Product_additive_monoid__rf_T) =>
                                                   dk_logic.forall 
                                                     Product_additive_monoid__rf_T 
                                                     (y:
                                                      (cc.eT 
                                                         Product_additive_monoid__rf_T) =>
                                                      dk_logic.ebP 
                                                        (Product_additive_monoid__rf_equal 
                                                           (Product_additive_monoid__rf_plus 
                                                              x y) 
                                                           (Product_additive_monoid__rf_plus 
                                                              y x)))))) ->
  Product_additive_monoid__rf_plus_right_substitution_rule:(dk_logic.eP 
                                                              (dk_logic.forall 
                                                                 Product_additive_monoid__rf_T 
                                                                 (x:
                                                                  (cc.eT 
                                                                    Product_additive_monoid__rf_T) =>
                                                                  dk_logic.forall 
                                                                    Product_additive_monoid__rf_T 
                                                                    (
                                                                    y:
                                                                    (
                                                                    cc.eT 
                                                                    Product_additive_monoid__rf_T) =>
                                                                    dk_logic.forall 
                                                                    Product_additive_monoid__rf_T 
                                                                    (z:
                                                                    (cc.eT 
                                                                    Product_additive_monoid__rf_T) =>
                                                                    dk_logic.imp 
                                                                    (dk_logic.ebP 
                                                                    (Product_additive_monoid__rf_equal 
                                                                    x y)) 
                                                                    (dk_logic.ebP 
                                                                    (Product_additive_monoid__rf_equal 
                                                                    (Product_additive_monoid__rf_plus 
                                                                    z x) 
                                                                    (Product_additive_monoid__rf_plus 
                                                                    z y)))))))) ->
  Product_additive_monoid__rf_plus_left_substitution_rule:(dk_logic.eP 
                                                             (dk_logic.forall 
                                                                Product_additive_monoid__rf_T 
                                                                (x:
                                                                 (cc.eT 
                                                                    Product_additive_monoid__rf_T) =>
                                                                 dk_logic.forall 
                                                                   Product_additive_monoid__rf_T 
                                                                   (y:
                                                                    (
                                                                    cc.eT 
                                                                    Product_additive_monoid__rf_T) =>
                                                                    dk_logic.forall 
                                                                    Product_additive_monoid__rf_T 
                                                                    (z:
                                                                    (cc.eT 
                                                                    Product_additive_monoid__rf_T) =>
                                                                    dk_logic.imp 
                                                                    (dk_logic.ebP 
                                                                    (Product_additive_monoid__rf_equal 
                                                                    x y)) 
                                                                    (dk_logic.ebP 
                                                                    (Product_additive_monoid__rf_equal 
                                                                    (Product_additive_monoid__rf_plus 
                                                                    x z) 
                                                                    (Product_additive_monoid__rf_plus 
                                                                    y z)))))))) ->
  Product_additive_monoid__rf_plus_substitution_rule:(dk_logic.eP 
                                                        (dk_logic.forall 
                                                           Product_additive_monoid__rf_T 
                                                           (x1:
                                                            (cc.eT 
                                                               Product_additive_monoid__rf_T) =>
                                                            dk_logic.forall 
                                                              Product_additive_monoid__rf_T 
                                                              (x2:
                                                               (cc.eT 
                                                                  Product_additive_monoid__rf_T) =>
                                                               dk_logic.forall 
                                                                 Product_additive_monoid__rf_T 
                                                                 (y1:
                                                                  (cc.eT 
                                                                    Product_additive_monoid__rf_T) =>
                                                                  dk_logic.forall 
                                                                    Product_additive_monoid__rf_T 
                                                                    (
                                                                    y2:
                                                                    (
                                                                    cc.eT 
                                                                    Product_additive_monoid__rf_T) =>
                                                                    dk_logic.imp 
                                                                    (dk_logic.ebP 
                                                                    (Product_additive_monoid__rf_equal 
                                                                    x1 x2)) 
                                                                    (dk_logic.imp 
                                                                    (dk_logic.ebP 
                                                                    (Product_additive_monoid__rf_equal 
                                                                    y1 y2)) 
                                                                    (dk_logic.ebP 
                                                                    (Product_additive_monoid__rf_equal 
                                                                    (Product_additive_monoid__rf_plus 
                                                                    x1 y1) 
                                                                    (Product_additive_monoid__rf_plus 
                                                                    x2 y2)))))))))) ->
  Product_additive_monoid__me_as_species M1_T M2_T _p_M1_equal _p_M2_equal.

def proj_Product_additive_monoid__rf_T :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_additive_monoid__me_as_species M1_T M2_T _p_M1_equal 
            _p_M2_equal) ->
  cc.uT.

[Product_additive_monoid__rf_T]
  proj_Product_additive_monoid__rf_T _ _ _ _ 
    (Product_additive_monoid__mk_record _ _ _ _ 
    Product_additive_monoid__rf_T _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
  -->
  Product_additive_monoid__rf_T.

def proj_Product_additive_monoid__rf_first :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_additive_monoid__me_as_species M1_T M2_T _p_M1_equal 
            _p_M2_equal) ->
  (cc.eT 
     (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal _p_M2_equal 
        record)) ->
  cc.eT M1_T.

[Product_additive_monoid__rf_first]
  proj_Product_additive_monoid__rf_first _ _ _ _ 
    (Product_additive_monoid__mk_record _ _ _ _ _ 
    Product_additive_monoid__rf_first _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
  -->
  Product_additive_monoid__rf_first.

def proj_Product_additive_monoid__rf_pair :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_additive_monoid__me_as_species M1_T M2_T _p_M1_equal 
            _p_M2_equal) ->
  (cc.eT M1_T) ->
  (cc.eT M2_T) ->
  cc.eT 
    (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal _p_M2_equal 
       record).

[Product_additive_monoid__rf_pair]
  proj_Product_additive_monoid__rf_pair _ _ _ _ 
    (Product_additive_monoid__mk_record _ _ _ _ _ _ 
    Product_additive_monoid__rf_pair _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
  -->
  Product_additive_monoid__rf_pair.

def proj_Product_additive_monoid__rf_parse :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_additive_monoid__me_as_species M1_T M2_T _p_M1_equal 
            _p_M2_equal) ->
  (cc.eT basics.string__t) ->
  cc.eT 
    (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal _p_M2_equal 
       record).

[Product_additive_monoid__rf_parse]
  proj_Product_additive_monoid__rf_parse _ _ _ _ 
    (Product_additive_monoid__mk_record _ _ _ _ _ _ _ 
    Product_additive_monoid__rf_parse _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
  -->
  Product_additive_monoid__rf_parse.

def proj_Product_additive_monoid__rf_print :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_additive_monoid__me_as_species M1_T M2_T _p_M1_equal 
            _p_M2_equal) ->
  (cc.eT 
     (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal _p_M2_equal 
        record)) ->
  cc.eT basics.string__t.

[Product_additive_monoid__rf_print]
  proj_Product_additive_monoid__rf_print _ _ _ _ 
    (Product_additive_monoid__mk_record _ _ _ _ _ _ _ _ 
    Product_additive_monoid__rf_print _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _)
  -->
  Product_additive_monoid__rf_print.

def proj_Product_additive_monoid__rf_second :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_additive_monoid__me_as_species M1_T M2_T _p_M1_equal 
            _p_M2_equal) ->
  (cc.eT 
     (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal _p_M2_equal 
        record)) ->
  cc.eT M2_T.

[Product_additive_monoid__rf_second]
  proj_Product_additive_monoid__rf_second _ _ _ _ 
    (Product_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ 
    Product_additive_monoid__rf_second _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _)
  -->
  Product_additive_monoid__rf_second.

def proj_Product_additive_monoid__rf_zero :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_additive_monoid__me_as_species M1_T M2_T _p_M1_equal 
            _p_M2_equal) ->
  cc.eT 
    (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal _p_M2_equal 
       record).

[Product_additive_monoid__rf_zero]
  proj_Product_additive_monoid__rf_zero _ _ _ _ 
    (Product_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ 
    Product_additive_monoid__rf_zero _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _)
  -->
  Product_additive_monoid__rf_zero.

def proj_Product_additive_monoid__rf_element :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_additive_monoid__me_as_species M1_T M2_T _p_M1_equal 
            _p_M2_equal) ->
  cc.eT 
    (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal _p_M2_equal 
       record).

[Product_additive_monoid__rf_element]
  proj_Product_additive_monoid__rf_element _ _ _ _ 
    (Product_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ 
    Product_additive_monoid__rf_element _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _)
  -->
  Product_additive_monoid__rf_element.

def proj_Product_additive_monoid__rf_pair_preserves_first :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_additive_monoid__me_as_species M1_T M2_T _p_M1_equal 
            _p_M2_equal) ->
  dk_logic.eP 
    (dk_logic.forall M1_T 
       (x:(cc.eT M1_T) =>
        dk_logic.forall M2_T 
          (y:(cc.eT M2_T) =>
           dk_logic.ebP 
             (_p_M1_equal 
                (proj_Product_additive_monoid__rf_first M1_T M2_T 
                   _p_M1_equal _p_M2_equal record 
                   (proj_Product_additive_monoid__rf_pair M1_T M2_T 
                      _p_M1_equal _p_M2_equal record x y)) x)))).

[Product_additive_monoid__rf_pair_preserves_first]
  proj_Product_additive_monoid__rf_pair_preserves_first _ _ _ _ 
    (Product_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ 
    Product_additive_monoid__rf_pair_preserves_first _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
  -->
  Product_additive_monoid__rf_pair_preserves_first.

def proj_Product_additive_monoid__rf_equal :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_additive_monoid__me_as_species M1_T M2_T _p_M1_equal 
            _p_M2_equal) ->
  (cc.eT 
     (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal _p_M2_equal 
        record)) ->
  (cc.eT 
     (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal _p_M2_equal 
        record)) ->
  cc.eT basics.bool__t.

[Product_additive_monoid__rf_equal]
  proj_Product_additive_monoid__rf_equal _ _ _ _ 
    (Product_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ 
    Product_additive_monoid__rf_equal _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _)
  -->
  Product_additive_monoid__rf_equal.

def proj_Product_additive_monoid__rf_pair_preserves_second :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_additive_monoid__me_as_species M1_T M2_T _p_M1_equal 
            _p_M2_equal) ->
  dk_logic.eP 
    (dk_logic.forall M1_T 
       (x:(cc.eT M1_T) =>
        dk_logic.forall M2_T 
          (y:(cc.eT M2_T) =>
           dk_logic.ebP 
             (_p_M2_equal 
                (proj_Product_additive_monoid__rf_second M1_T M2_T 
                   _p_M1_equal _p_M2_equal record 
                   (proj_Product_additive_monoid__rf_pair M1_T M2_T 
                      _p_M1_equal _p_M2_equal record x y)) y)))).

[Product_additive_monoid__rf_pair_preserves_second]
  proj_Product_additive_monoid__rf_pair_preserves_second _ _ _ _ 
    (Product_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    Product_additive_monoid__rf_pair_preserves_second _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
  -->
  Product_additive_monoid__rf_pair_preserves_second.

def proj_Product_additive_monoid__rf_plus :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_additive_monoid__me_as_species M1_T M2_T _p_M1_equal 
            _p_M2_equal) ->
  (cc.eT 
     (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal _p_M2_equal 
        record)) ->
  (cc.eT 
     (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal _p_M2_equal 
        record)) ->
  cc.eT 
    (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal _p_M2_equal 
       record).

[Product_additive_monoid__rf_plus]
  proj_Product_additive_monoid__rf_plus _ _ _ _ 
    (Product_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    Product_additive_monoid__rf_plus _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _)
  -->
  Product_additive_monoid__rf_plus.

def proj_Product_additive_monoid__rf_first_accessibility :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_additive_monoid__me_as_species M1_T M2_T _p_M1_equal 
            _p_M2_equal) ->
  dk_logic.eP 
    (dk_logic.forall M1_T 
       (x:(cc.eT M1_T) =>
        dk_logic.exists 
          (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
             _p_M2_equal record) 
          (s:
           (cc.eT 
              (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
                 _p_M2_equal record)) =>
           dk_logic.ebP 
             (_p_M1_equal 
                (proj_Product_additive_monoid__rf_first M1_T M2_T 
                   _p_M1_equal _p_M2_equal record s) x)))).

[Product_additive_monoid__rf_first_accessibility]
  proj_Product_additive_monoid__rf_first_accessibility _ _ _ _ 
    (Product_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    Product_additive_monoid__rf_first_accessibility _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _)
  -->
  Product_additive_monoid__rf_first_accessibility.

def proj_Product_additive_monoid__rf_different :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_additive_monoid__me_as_species M1_T M2_T _p_M1_equal 
            _p_M2_equal) ->
  (cc.eT 
     (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal _p_M2_equal 
        record)) ->
  (cc.eT 
     (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal _p_M2_equal 
        record)) ->
  cc.eT basics.bool__t.

[Product_additive_monoid__rf_different]
  proj_Product_additive_monoid__rf_different _ _ _ _ 
    (Product_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    Product_additive_monoid__rf_different _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _)
  -->
  Product_additive_monoid__rf_different.

def proj_Product_additive_monoid__rf_equal_reflexive :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_additive_monoid__me_as_species M1_T M2_T _p_M1_equal 
            _p_M2_equal) ->
  dk_logic.eP 
    (dk_logic.forall 
       (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal _p_M2_equal 
          record) 
       (x:
        (cc.eT 
           (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
              _p_M2_equal record)) =>
        dk_logic.ebP 
          (proj_Product_additive_monoid__rf_equal M1_T M2_T _p_M1_equal 
             _p_M2_equal record x x))).

[Product_additive_monoid__rf_equal_reflexive]
  proj_Product_additive_monoid__rf_equal_reflexive _ _ _ _ 
    (Product_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    Product_additive_monoid__rf_equal_reflexive _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _)
  -->
  Product_additive_monoid__rf_equal_reflexive.

def proj_Product_additive_monoid__rf_equal_spec :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_additive_monoid__me_as_species M1_T M2_T _p_M1_equal 
            _p_M2_equal) ->
  dk_logic.eP 
    (dk_logic.forall 
       (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal _p_M2_equal 
          record) 
       (x:
        (cc.eT 
           (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
              _p_M2_equal record)) =>
        dk_logic.forall 
          (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
             _p_M2_equal record) 
          (y:
           (cc.eT 
              (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
                 _p_M2_equal record)) =>
           dk_logic.eqv 
             (dk_logic.ebP 
                (proj_Product_additive_monoid__rf_equal M1_T M2_T 
                   _p_M1_equal _p_M2_equal record x y)) 
             (dk_logic.and 
                (dk_logic.ebP 
                   (_p_M1_equal 
                      (proj_Product_additive_monoid__rf_first M1_T M2_T 
                         _p_M1_equal _p_M2_equal record x) 
                      (proj_Product_additive_monoid__rf_first M1_T M2_T 
                         _p_M1_equal _p_M2_equal record y))) 
                (dk_logic.ebP 
                   (_p_M2_equal 
                      (proj_Product_additive_monoid__rf_second M1_T M2_T 
                         _p_M1_equal _p_M2_equal record x) 
                      (proj_Product_additive_monoid__rf_second M1_T M2_T 
                         _p_M1_equal _p_M2_equal record y))))))).

[Product_additive_monoid__rf_equal_spec]
  proj_Product_additive_monoid__rf_equal_spec _ _ _ _ 
    (Product_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ Product_additive_monoid__rf_equal_spec _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _)
  -->
  Product_additive_monoid__rf_equal_spec.

def proj_Product_additive_monoid__rf_equal_symmetric :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_additive_monoid__me_as_species M1_T M2_T _p_M1_equal 
            _p_M2_equal) ->
  dk_logic.eP 
    (dk_logic.forall 
       (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal _p_M2_equal 
          record) 
       (x:
        (cc.eT 
           (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
              _p_M2_equal record)) =>
        dk_logic.forall 
          (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
             _p_M2_equal record) 
          (y:
           (cc.eT 
              (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
                 _p_M2_equal record)) =>
           dk_logic.imp 
             (dk_logic.ebP 
                (proj_Product_additive_monoid__rf_equal M1_T M2_T 
                   _p_M1_equal _p_M2_equal record x y)) 
             (dk_logic.ebP 
                (proj_Product_additive_monoid__rf_equal M1_T M2_T 
                   _p_M1_equal _p_M2_equal record y x))))).

[Product_additive_monoid__rf_equal_symmetric]
  proj_Product_additive_monoid__rf_equal_symmetric _ _ _ _ 
    (Product_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ Product_additive_monoid__rf_equal_symmetric _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _)
  -->
  Product_additive_monoid__rf_equal_symmetric.

def proj_Product_additive_monoid__rf_equal_transitive :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_additive_monoid__me_as_species M1_T M2_T _p_M1_equal 
            _p_M2_equal) ->
  dk_logic.eP 
    (dk_logic.forall 
       (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal _p_M2_equal 
          record) 
       (x:
        (cc.eT 
           (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
              _p_M2_equal record)) =>
        dk_logic.forall 
          (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
             _p_M2_equal record) 
          (y:
           (cc.eT 
              (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
                 _p_M2_equal record)) =>
           dk_logic.forall 
             (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
                _p_M2_equal record) 
             (z:
              (cc.eT 
                 (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
                    _p_M2_equal record)) =>
              dk_logic.imp 
                (dk_logic.ebP 
                   (proj_Product_additive_monoid__rf_equal M1_T M2_T 
                      _p_M1_equal _p_M2_equal record x y)) 
                (dk_logic.imp 
                   (dk_logic.ebP 
                      (proj_Product_additive_monoid__rf_equal M1_T M2_T 
                         _p_M1_equal _p_M2_equal record y z)) 
                   (dk_logic.ebP 
                      (proj_Product_additive_monoid__rf_equal M1_T M2_T 
                         _p_M1_equal _p_M2_equal record x z))))))).

[Product_additive_monoid__rf_equal_transitive]
  proj_Product_additive_monoid__rf_equal_transitive _ _ _ _ 
    (Product_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ Product_additive_monoid__rf_equal_transitive _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _)
  -->
  Product_additive_monoid__rf_equal_transitive.

def proj_Product_additive_monoid__rf_first_substitution_rule :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_additive_monoid__me_as_species M1_T M2_T _p_M1_equal 
            _p_M2_equal) ->
  dk_logic.eP 
    (dk_logic.forall 
       (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal _p_M2_equal 
          record) 
       (x:
        (cc.eT 
           (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
              _p_M2_equal record)) =>
        dk_logic.forall 
          (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
             _p_M2_equal record) 
          (y:
           (cc.eT 
              (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
                 _p_M2_equal record)) =>
           dk_logic.imp 
             (dk_logic.ebP 
                (proj_Product_additive_monoid__rf_equal M1_T M2_T 
                   _p_M1_equal _p_M2_equal record x y)) 
             (dk_logic.ebP 
                (_p_M1_equal 
                   (proj_Product_additive_monoid__rf_first M1_T M2_T 
                      _p_M1_equal _p_M2_equal record x) 
                   (proj_Product_additive_monoid__rf_first M1_T M2_T 
                      _p_M1_equal _p_M2_equal record y)))))).

[Product_additive_monoid__rf_first_substitution_rule]
  proj_Product_additive_monoid__rf_first_substitution_rule _ _ _ _ 
    (Product_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ Product_additive_monoid__rf_first_substitution_rule _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _)
  -->
  Product_additive_monoid__rf_first_substitution_rule.

def proj_Product_additive_monoid__rf_is_zero :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_additive_monoid__me_as_species M1_T M2_T _p_M1_equal 
            _p_M2_equal) ->
  (cc.eT 
     (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal _p_M2_equal 
        record)) ->
  cc.eT basics.bool__t.

[Product_additive_monoid__rf_is_zero]
  proj_Product_additive_monoid__rf_is_zero _ _ _ _ 
    (Product_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ Product_additive_monoid__rf_is_zero _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _)
  -->
  Product_additive_monoid__rf_is_zero.

def proj_Product_additive_monoid__rf_second_substitution_rule :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_additive_monoid__me_as_species M1_T M2_T _p_M1_equal 
            _p_M2_equal) ->
  dk_logic.eP 
    (dk_logic.forall 
       (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal _p_M2_equal 
          record) 
       (x:
        (cc.eT 
           (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
              _p_M2_equal record)) =>
        dk_logic.forall 
          (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
             _p_M2_equal record) 
          (y:
           (cc.eT 
              (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
                 _p_M2_equal record)) =>
           dk_logic.imp 
             (dk_logic.ebP 
                (proj_Product_additive_monoid__rf_equal M1_T M2_T 
                   _p_M1_equal _p_M2_equal record x y)) 
             (dk_logic.ebP 
                (_p_M2_equal 
                   (proj_Product_additive_monoid__rf_second M1_T M2_T 
                      _p_M1_equal _p_M2_equal record x) 
                   (proj_Product_additive_monoid__rf_second M1_T M2_T 
                      _p_M1_equal _p_M2_equal record y)))))).

[Product_additive_monoid__rf_second_substitution_rule]
  proj_Product_additive_monoid__rf_second_substitution_rule _ _ _ _ 
    (Product_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ Product_additive_monoid__rf_second_substitution_rule _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _)
  -->
  Product_additive_monoid__rf_second_substitution_rule.

def proj_Product_additive_monoid__rf_pair_left_substitution_rule :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_additive_monoid__me_as_species M1_T M2_T _p_M1_equal 
            _p_M2_equal) ->
  dk_logic.eP 
    (dk_logic.forall M1_T 
       (x_1:(cc.eT M1_T) =>
        dk_logic.forall M1_T 
          (x_2:(cc.eT M1_T) =>
           dk_logic.forall M2_T 
             (y:(cc.eT M2_T) =>
              dk_logic.imp (dk_logic.ebP (_p_M1_equal x_1 x_2)) 
                (dk_logic.ebP 
                   (proj_Product_additive_monoid__rf_equal M1_T M2_T 
                      _p_M1_equal _p_M2_equal record 
                      (proj_Product_additive_monoid__rf_pair M1_T M2_T 
                         _p_M1_equal _p_M2_equal record x_1 y) 
                      (proj_Product_additive_monoid__rf_pair M1_T M2_T 
                         _p_M1_equal _p_M2_equal record x_2 y))))))).

[Product_additive_monoid__rf_pair_left_substitution_rule]
  proj_Product_additive_monoid__rf_pair_left_substitution_rule _ _ _ _ 
    (Product_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ Product_additive_monoid__rf_pair_left_substitution_rule _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
  -->
  Product_additive_monoid__rf_pair_left_substitution_rule.

def proj_Product_additive_monoid__rf_pair_right_substitution_rule :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_additive_monoid__me_as_species M1_T M2_T _p_M1_equal 
            _p_M2_equal) ->
  dk_logic.eP 
    (dk_logic.forall M1_T 
       (x:(cc.eT M1_T) =>
        dk_logic.forall M2_T 
          (y_1:(cc.eT M2_T) =>
           dk_logic.forall M2_T 
             (y_2:(cc.eT M2_T) =>
              dk_logic.imp (dk_logic.ebP (_p_M2_equal y_1 y_2)) 
                (dk_logic.ebP 
                   (proj_Product_additive_monoid__rf_equal M1_T M2_T 
                      _p_M1_equal _p_M2_equal record 
                      (proj_Product_additive_monoid__rf_pair M1_T M2_T 
                         _p_M1_equal _p_M2_equal record x y_1) 
                      (proj_Product_additive_monoid__rf_pair M1_T M2_T 
                         _p_M1_equal _p_M2_equal record x y_2))))))).

[Product_additive_monoid__rf_pair_right_substitution_rule]
  proj_Product_additive_monoid__rf_pair_right_substitution_rule _ _ _ _ 
    (Product_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ Product_additive_monoid__rf_pair_right_substitution_rule 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
  -->
  Product_additive_monoid__rf_pair_right_substitution_rule.

def proj_Product_additive_monoid__rf_second_accessibility :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_additive_monoid__me_as_species M1_T M2_T _p_M1_equal 
            _p_M2_equal) ->
  dk_logic.eP 
    (dk_logic.forall M2_T 
       (x:(cc.eT M2_T) =>
        dk_logic.exists 
          (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
             _p_M2_equal record) 
          (s:
           (cc.eT 
              (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
                 _p_M2_equal record)) =>
           dk_logic.ebP 
             (_p_M2_equal 
                (proj_Product_additive_monoid__rf_second M1_T M2_T 
                   _p_M1_equal _p_M2_equal record s) x)))).

[Product_additive_monoid__rf_second_accessibility]
  proj_Product_additive_monoid__rf_second_accessibility _ _ _ _ 
    (Product_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ Product_additive_monoid__rf_second_accessibility _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _)
  -->
  Product_additive_monoid__rf_second_accessibility.

def proj_Product_additive_monoid__rf_plus_is_associative :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_additive_monoid__me_as_species M1_T M2_T _p_M1_equal 
            _p_M2_equal) ->
  dk_logic.eP 
    (dk_logic.forall 
       (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal _p_M2_equal 
          record) 
       (x:
        (cc.eT 
           (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
              _p_M2_equal record)) =>
        dk_logic.forall 
          (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
             _p_M2_equal record) 
          (y:
           (cc.eT 
              (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
                 _p_M2_equal record)) =>
           dk_logic.forall 
             (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
                _p_M2_equal record) 
             (z:
              (cc.eT 
                 (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
                    _p_M2_equal record)) =>
              dk_logic.ebP 
                (proj_Product_additive_monoid__rf_equal M1_T M2_T 
                   _p_M1_equal _p_M2_equal record 
                   (proj_Product_additive_monoid__rf_plus M1_T M2_T 
                      _p_M1_equal _p_M2_equal record x 
                      (proj_Product_additive_monoid__rf_plus M1_T M2_T 
                         _p_M1_equal _p_M2_equal record y z)) 
                   (proj_Product_additive_monoid__rf_plus M1_T M2_T 
                      _p_M1_equal _p_M2_equal record 
                      (proj_Product_additive_monoid__rf_plus M1_T M2_T 
                         _p_M1_equal _p_M2_equal record x y) z)))))).

[Product_additive_monoid__rf_plus_is_associative]
  proj_Product_additive_monoid__rf_plus_is_associative _ _ _ _ 
    (Product_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ Product_additive_monoid__rf_plus_is_associative _ _ 
    _ _ _ _ _ _ _ _ _ _ _)
  -->
  Product_additive_monoid__rf_plus_is_associative.

def proj_Product_additive_monoid__rf_zero_is_neutral :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_additive_monoid__me_as_species M1_T M2_T _p_M1_equal 
            _p_M2_equal) ->
  dk_logic.eP 
    (dk_logic.forall 
       (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal _p_M2_equal 
          record) 
       (x:
        (cc.eT 
           (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
              _p_M2_equal record)) =>
        dk_logic.and 
          (dk_logic.ebP 
             (proj_Product_additive_monoid__rf_equal M1_T M2_T _p_M1_equal 
                _p_M2_equal record 
                (proj_Product_additive_monoid__rf_plus M1_T M2_T _p_M1_equal 
                   _p_M2_equal record x 
                   (proj_Product_additive_monoid__rf_zero M1_T M2_T 
                      _p_M1_equal _p_M2_equal record)) x)) 
          (dk_logic.ebP 
             (proj_Product_additive_monoid__rf_equal M1_T M2_T _p_M1_equal 
                _p_M2_equal record 
                (proj_Product_additive_monoid__rf_plus M1_T M2_T _p_M1_equal 
                   _p_M2_equal record 
                   (proj_Product_additive_monoid__rf_zero M1_T M2_T 
                      _p_M1_equal _p_M2_equal record) x) x)))).

[Product_additive_monoid__rf_zero_is_neutral]
  proj_Product_additive_monoid__rf_zero_is_neutral _ _ _ _ 
    (Product_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ Product_additive_monoid__rf_zero_is_neutral _ _ _ 
    _ _ _ _ _ _ _ _ _)
  -->
  Product_additive_monoid__rf_zero_is_neutral.

def proj_Product_additive_monoid__rf_same_is_not_different :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_additive_monoid__me_as_species M1_T M2_T _p_M1_equal 
            _p_M2_equal) ->
  dk_logic.eP 
    (dk_logic.forall 
       (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal _p_M2_equal 
          record) 
       (x:
        (cc.eT 
           (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
              _p_M2_equal record)) =>
        dk_logic.forall 
          (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
             _p_M2_equal record) 
          (y:
           (cc.eT 
              (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
                 _p_M2_equal record)) =>
           dk_logic.eqv 
             (dk_logic.ebP 
                (proj_Product_additive_monoid__rf_different M1_T M2_T 
                   _p_M1_equal _p_M2_equal record x y)) 
             (dk_logic.not 
                (dk_logic.ebP 
                   (proj_Product_additive_monoid__rf_equal M1_T M2_T 
                      _p_M1_equal _p_M2_equal record x y)))))).

[Product_additive_monoid__rf_same_is_not_different]
  proj_Product_additive_monoid__rf_same_is_not_different _ _ _ _ 
    (Product_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ 
    Product_additive_monoid__rf_same_is_not_different _ _ _ _ _ _ _ _ _ _ _)
  -->
  Product_additive_monoid__rf_same_is_not_different.

def proj_Product_additive_monoid__rf_is_zero_spec :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_additive_monoid__me_as_species M1_T M2_T _p_M1_equal 
            _p_M2_equal) ->
  dk_logic.eP 
    (dk_logic.forall 
       (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal _p_M2_equal 
          record) 
       (x:
        (cc.eT 
           (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
              _p_M2_equal record)) =>
        dk_logic.eqv 
          (dk_logic.ebP 
             (proj_Product_additive_monoid__rf_is_zero M1_T M2_T _p_M1_equal 
                _p_M2_equal record x)) 
          (dk_logic.or 
             (dk_logic.ebP 
                (proj_Product_additive_monoid__rf_equal M1_T M2_T 
                   _p_M1_equal _p_M2_equal record x 
                   (proj_Product_additive_monoid__rf_zero M1_T M2_T 
                      _p_M1_equal _p_M2_equal record))) 
             (dk_logic.ebP 
                (proj_Product_additive_monoid__rf_equal M1_T M2_T 
                   _p_M1_equal _p_M2_equal record 
                   (proj_Product_additive_monoid__rf_zero M1_T M2_T 
                      _p_M1_equal _p_M2_equal record) x))))).

[Product_additive_monoid__rf_is_zero_spec]
  proj_Product_additive_monoid__rf_is_zero_spec _ _ _ _ 
    (Product_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ Product_additive_monoid__rf_is_zero_spec _ _ _ 
    _ _ _ _ _ _ _)
  -->
  Product_additive_monoid__rf_is_zero_spec.

def proj_Product_additive_monoid__rf_pair_substitution_rule :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_additive_monoid__me_as_species M1_T M2_T _p_M1_equal 
            _p_M2_equal) ->
  dk_logic.eP 
    (dk_logic.forall M1_T 
       (x_1:(cc.eT M1_T) =>
        dk_logic.forall M1_T 
          (x_2:(cc.eT M1_T) =>
           dk_logic.forall M2_T 
             (y_1:(cc.eT M2_T) =>
              dk_logic.forall M2_T 
                (y_2:(cc.eT M2_T) =>
                 dk_logic.imp (dk_logic.ebP (_p_M1_equal x_1 x_2)) 
                   (dk_logic.imp (dk_logic.ebP (_p_M2_equal y_1 y_2)) 
                      (dk_logic.ebP 
                         (proj_Product_additive_monoid__rf_equal M1_T M2_T 
                            _p_M1_equal _p_M2_equal record 
                            (proj_Product_additive_monoid__rf_pair M1_T M2_T 
                               _p_M1_equal _p_M2_equal record x_1 y_1) 
                            (proj_Product_additive_monoid__rf_pair M1_T M2_T 
                               _p_M1_equal _p_M2_equal record x_2 y_2))))))))).

[Product_additive_monoid__rf_pair_substitution_rule]
  proj_Product_additive_monoid__rf_pair_substitution_rule _ _ _ _ 
    (Product_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    Product_additive_monoid__rf_pair_substitution_rule _ _ _ _ _ _ _ _ _)
  -->
  Product_additive_monoid__rf_pair_substitution_rule.

def proj_Product_additive_monoid__rf_zero_is_unique :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_additive_monoid__me_as_species M1_T M2_T _p_M1_equal 
            _p_M2_equal) ->
  dk_logic.eP 
    (dk_logic.forall 
       (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal _p_M2_equal 
          record) 
       (o:
        (cc.eT 
           (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
              _p_M2_equal record)) =>
        dk_logic.imp 
          (dk_logic.forall 
             (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
                _p_M2_equal record) 
             (x:
              (cc.eT 
                 (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
                    _p_M2_equal record)) =>
              dk_logic.ebP 
                (proj_Product_additive_monoid__rf_equal M1_T M2_T 
                   _p_M1_equal _p_M2_equal record x 
                   (proj_Product_additive_monoid__rf_plus M1_T M2_T 
                      _p_M1_equal _p_M2_equal record x o)))) 
          (dk_logic.ebP 
             (proj_Product_additive_monoid__rf_equal M1_T M2_T _p_M1_equal 
                _p_M2_equal record o 
                (proj_Product_additive_monoid__rf_zero M1_T M2_T _p_M1_equal 
                   _p_M2_equal record))))).

[Product_additive_monoid__rf_zero_is_unique]
  proj_Product_additive_monoid__rf_zero_is_unique _ _ _ _ 
    (Product_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ Product_additive_monoid__rf_zero_is_unique 
    _ _ _ _ _ _ _ _)
  -->
  Product_additive_monoid__rf_zero_is_unique.

def proj_Product_additive_monoid__rf_different_is_complete :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_additive_monoid__me_as_species M1_T M2_T _p_M1_equal 
            _p_M2_equal) ->
  dk_logic.eP 
    (dk_logic.forall 
       (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal _p_M2_equal 
          record) 
       (x:
        (cc.eT 
           (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
              _p_M2_equal record)) =>
        dk_logic.forall 
          (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
             _p_M2_equal record) 
          (y:
           (cc.eT 
              (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
                 _p_M2_equal record)) =>
           dk_logic.forall 
             (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
                _p_M2_equal record) 
             (z:
              (cc.eT 
                 (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
                    _p_M2_equal record)) =>
              dk_logic.imp 
                (dk_logic.ebP 
                   (proj_Product_additive_monoid__rf_different M1_T M2_T 
                      _p_M1_equal _p_M2_equal record x y)) 
                (dk_logic.or 
                   (dk_logic.ebP 
                      (proj_Product_additive_monoid__rf_different M1_T M2_T 
                         _p_M1_equal _p_M2_equal record x z)) 
                   (dk_logic.ebP 
                      (proj_Product_additive_monoid__rf_different M1_T M2_T 
                         _p_M1_equal _p_M2_equal record y z))))))).

[Product_additive_monoid__rf_different_is_complete]
  proj_Product_additive_monoid__rf_different_is_complete _ _ _ _ 
    (Product_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    Product_additive_monoid__rf_different_is_complete _ _ _ _ _ _ _)
  -->
  Product_additive_monoid__rf_different_is_complete.

def proj_Product_additive_monoid__rf_different_is_irreflexive :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_additive_monoid__me_as_species M1_T M2_T _p_M1_equal 
            _p_M2_equal) ->
  dk_logic.eP 
    (dk_logic.forall 
       (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal _p_M2_equal 
          record) 
       (x:
        (cc.eT 
           (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
              _p_M2_equal record)) =>
        dk_logic.not 
          (dk_logic.ebP 
             (proj_Product_additive_monoid__rf_different M1_T M2_T 
                _p_M1_equal _p_M2_equal record x x)))).

[Product_additive_monoid__rf_different_is_irreflexive]
  proj_Product_additive_monoid__rf_different_is_irreflexive _ _ _ _ 
    (Product_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    Product_additive_monoid__rf_different_is_irreflexive _ _ _ _ _ _)
  -->
  Product_additive_monoid__rf_different_is_irreflexive.

def proj_Product_additive_monoid__rf_different_is_symmetric :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_additive_monoid__me_as_species M1_T M2_T _p_M1_equal 
            _p_M2_equal) ->
  dk_logic.eP 
    (dk_logic.forall 
       (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal _p_M2_equal 
          record) 
       (x:
        (cc.eT 
           (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
              _p_M2_equal record)) =>
        dk_logic.forall 
          (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
             _p_M2_equal record) 
          (y:
           (cc.eT 
              (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
                 _p_M2_equal record)) =>
           dk_logic.imp 
             (dk_logic.ebP 
                (proj_Product_additive_monoid__rf_different M1_T M2_T 
                   _p_M1_equal _p_M2_equal record x y)) 
             (dk_logic.ebP 
                (proj_Product_additive_monoid__rf_different M1_T M2_T 
                   _p_M1_equal _p_M2_equal record y x))))).

[Product_additive_monoid__rf_different_is_symmetric]
  proj_Product_additive_monoid__rf_different_is_symmetric _ _ _ _ 
    (Product_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    Product_additive_monoid__rf_different_is_symmetric _ _ _ _ _)
  -->
  Product_additive_monoid__rf_different_is_symmetric.

def proj_Product_additive_monoid__rf_zero_checks_to_zero :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_additive_monoid__me_as_species M1_T M2_T _p_M1_equal 
            _p_M2_equal) ->
  dk_logic.eP 
    (dk_logic.ebP 
       (proj_Product_additive_monoid__rf_is_zero M1_T M2_T _p_M1_equal 
          _p_M2_equal record 
          (proj_Product_additive_monoid__rf_zero M1_T M2_T _p_M1_equal 
             _p_M2_equal record))).

[Product_additive_monoid__rf_zero_checks_to_zero]
  proj_Product_additive_monoid__rf_zero_checks_to_zero _ _ _ _ 
    (Product_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    Product_additive_monoid__rf_zero_checks_to_zero _ _ _ _)
  -->
  Product_additive_monoid__rf_zero_checks_to_zero.

def proj_Product_additive_monoid__rf_plus_commutes :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_additive_monoid__me_as_species M1_T M2_T _p_M1_equal 
            _p_M2_equal) ->
  dk_logic.eP 
    (dk_logic.forall 
       (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal _p_M2_equal 
          record) 
       (x:
        (cc.eT 
           (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
              _p_M2_equal record)) =>
        dk_logic.forall 
          (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
             _p_M2_equal record) 
          (y:
           (cc.eT 
              (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
                 _p_M2_equal record)) =>
           dk_logic.ebP 
             (proj_Product_additive_monoid__rf_equal M1_T M2_T _p_M1_equal 
                _p_M2_equal record 
                (proj_Product_additive_monoid__rf_plus M1_T M2_T _p_M1_equal 
                   _p_M2_equal record x y) 
                (proj_Product_additive_monoid__rf_plus M1_T M2_T _p_M1_equal 
                   _p_M2_equal record y x))))).

[Product_additive_monoid__rf_plus_commutes]
  proj_Product_additive_monoid__rf_plus_commutes _ _ _ _ 
    (Product_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    Product_additive_monoid__rf_plus_commutes _ _ _)
  -->
  Product_additive_monoid__rf_plus_commutes.

def proj_Product_additive_monoid__rf_plus_right_substitution_rule :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_additive_monoid__me_as_species M1_T M2_T _p_M1_equal 
            _p_M2_equal) ->
  dk_logic.eP 
    (dk_logic.forall 
       (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal _p_M2_equal 
          record) 
       (x:
        (cc.eT 
           (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
              _p_M2_equal record)) =>
        dk_logic.forall 
          (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
             _p_M2_equal record) 
          (y:
           (cc.eT 
              (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
                 _p_M2_equal record)) =>
           dk_logic.forall 
             (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
                _p_M2_equal record) 
             (z:
              (cc.eT 
                 (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
                    _p_M2_equal record)) =>
              dk_logic.imp 
                (dk_logic.ebP 
                   (proj_Product_additive_monoid__rf_equal M1_T M2_T 
                      _p_M1_equal _p_M2_equal record x y)) 
                (dk_logic.ebP 
                   (proj_Product_additive_monoid__rf_equal M1_T M2_T 
                      _p_M1_equal _p_M2_equal record 
                      (proj_Product_additive_monoid__rf_plus M1_T M2_T 
                         _p_M1_equal _p_M2_equal record z x) 
                      (proj_Product_additive_monoid__rf_plus M1_T M2_T 
                         _p_M1_equal _p_M2_equal record z y))))))).

[Product_additive_monoid__rf_plus_right_substitution_rule]
  proj_Product_additive_monoid__rf_plus_right_substitution_rule _ _ _ _ 
    (Product_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    Product_additive_monoid__rf_plus_right_substitution_rule _ _)
  -->
  Product_additive_monoid__rf_plus_right_substitution_rule.

def proj_Product_additive_monoid__rf_plus_left_substitution_rule :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_additive_monoid__me_as_species M1_T M2_T _p_M1_equal 
            _p_M2_equal) ->
  dk_logic.eP 
    (dk_logic.forall 
       (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal _p_M2_equal 
          record) 
       (x:
        (cc.eT 
           (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
              _p_M2_equal record)) =>
        dk_logic.forall 
          (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
             _p_M2_equal record) 
          (y:
           (cc.eT 
              (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
                 _p_M2_equal record)) =>
           dk_logic.forall 
             (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
                _p_M2_equal record) 
             (z:
              (cc.eT 
                 (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
                    _p_M2_equal record)) =>
              dk_logic.imp 
                (dk_logic.ebP 
                   (proj_Product_additive_monoid__rf_equal M1_T M2_T 
                      _p_M1_equal _p_M2_equal record x y)) 
                (dk_logic.ebP 
                   (proj_Product_additive_monoid__rf_equal M1_T M2_T 
                      _p_M1_equal _p_M2_equal record 
                      (proj_Product_additive_monoid__rf_plus M1_T M2_T 
                         _p_M1_equal _p_M2_equal record x z) 
                      (proj_Product_additive_monoid__rf_plus M1_T M2_T 
                         _p_M1_equal _p_M2_equal record y z))))))).

[Product_additive_monoid__rf_plus_left_substitution_rule]
  proj_Product_additive_monoid__rf_plus_left_substitution_rule _ _ _ _ 
    (Product_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    Product_additive_monoid__rf_plus_left_substitution_rule _)
  -->
  Product_additive_monoid__rf_plus_left_substitution_rule.

def proj_Product_additive_monoid__rf_plus_substitution_rule :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_additive_monoid__me_as_species M1_T M2_T _p_M1_equal 
            _p_M2_equal) ->
  dk_logic.eP 
    (dk_logic.forall 
       (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal _p_M2_equal 
          record) 
       (x1:
        (cc.eT 
           (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
              _p_M2_equal record)) =>
        dk_logic.forall 
          (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
             _p_M2_equal record) 
          (x2:
           (cc.eT 
              (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
                 _p_M2_equal record)) =>
           dk_logic.forall 
             (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
                _p_M2_equal record) 
             (y1:
              (cc.eT 
                 (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
                    _p_M2_equal record)) =>
              dk_logic.forall 
                (proj_Product_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
                   _p_M2_equal record) 
                (y2:
                 (cc.eT 
                    (proj_Product_additive_monoid__rf_T M1_T M2_T 
                       _p_M1_equal _p_M2_equal record)) =>
                 dk_logic.imp 
                   (dk_logic.ebP 
                      (proj_Product_additive_monoid__rf_equal M1_T M2_T 
                         _p_M1_equal _p_M2_equal record x1 x2)) 
                   (dk_logic.imp 
                      (dk_logic.ebP 
                         (proj_Product_additive_monoid__rf_equal M1_T M2_T 
                            _p_M1_equal _p_M2_equal record y1 y2)) 
                      (dk_logic.ebP 
                         (proj_Product_additive_monoid__rf_equal M1_T M2_T 
                            _p_M1_equal _p_M2_equal record 
                            (proj_Product_additive_monoid__rf_plus M1_T M2_T 
                               _p_M1_equal _p_M2_equal record x1 y1) 
                            (proj_Product_additive_monoid__rf_plus M1_T M2_T 
                               _p_M1_equal _p_M2_equal record x2 y2))))))))).

[Product_additive_monoid__rf_plus_substitution_rule]
  proj_Product_additive_monoid__rf_plus_substitution_rule _ _ _ _ 
    (Product_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    Product_additive_monoid__rf_plus_substitution_rule)
  -->
  Product_additive_monoid__rf_plus_substitution_rule.

def Product_additive_monoid__zero :
  _p_M1_T:cc.uT ->
  _p_M2_T:cc.uT ->
  _p_M1_zero:(cc.eT _p_M1_T) ->
  _p_M2_zero:(cc.eT _p_M2_T) -> cc.eT (dk_tuple.prod _p_M1_T _p_M2_T)
  :=
  _p_M1_T:cc.uT =>
  _p_M2_T:cc.uT =>
  _p_M1_zero:(cc.eT _p_M1_T) =>
  _p_M2_zero:(cc.eT _p_M2_T) =>
  dk_tuple.pair _p_M1_T _p_M2_T _p_M1_zero _p_M2_zero.

def Product_additive_monoid__plus :
  _p_M1_T:cc.uT ->
  _p_M2_T:cc.uT ->
  _p_M1_plus:((cc.eT _p_M1_T) -> (cc.eT _p_M1_T) -> cc.eT _p_M1_T) ->
  _p_M2_plus:((cc.eT _p_M2_T) -> (cc.eT _p_M2_T) -> cc.eT _p_M2_T) ->
  abst_T:cc.uT ->
  abst_first:((cc.eT abst_T) -> cc.eT _p_M1_T) ->
  abst_pair:((cc.eT _p_M1_T) -> (cc.eT _p_M2_T) -> cc.eT abst_T) ->
  abst_second:((cc.eT abst_T) -> cc.eT _p_M2_T) ->
  a:(cc.eT abst_T) -> b:(cc.eT abst_T) -> cc.eT abst_T
  :=
  _p_M1_T:cc.uT =>
  _p_M2_T:cc.uT =>
  _p_M1_plus:((cc.eT _p_M1_T) -> (cc.eT _p_M1_T) -> cc.eT _p_M1_T) =>
  _p_M2_plus:((cc.eT _p_M2_T) -> (cc.eT _p_M2_T) -> cc.eT _p_M2_T) =>
  abst_T:cc.uT =>
  abst_first:((cc.eT abst_T) -> cc.eT _p_M1_T) =>
  abst_pair:((cc.eT _p_M1_T) -> (cc.eT _p_M2_T) -> cc.eT abst_T) =>
  abst_second:((cc.eT abst_T) -> cc.eT _p_M2_T) =>
  a:(cc.eT abst_T) =>
  b:(cc.eT abst_T) =>
  (a1:(cc.eT _p_M1_T) =>
   (a2:(cc.eT _p_M2_T) =>
    (b1:(cc.eT _p_M1_T) =>
     (b2:(cc.eT _p_M2_T) => abst_pair (_p_M1_plus a1 b1) (_p_M2_plus a2 b2)) 
       (abst_second b)) (abst_first b)) (abst_second a)) (abst_first a).

def Product_additive_monoid__plus_is_associative :
  _p_M1_T:cc.uT ->
  _p_M2_T:cc.uT ->
  abst_T:cc.uT ->
  abst_equal:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) ->
  abst_plus:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT abst_T) ->
  dk_logic.eP 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.forall abst_T 
             (z:(cc.eT abst_T) =>
              dk_logic.ebP 
                (abst_equal (abst_plus x (abst_plus y z)) 
                   (abst_plus (abst_plus x y) z))))))
  :=
  _p_M1_T:cc.uT =>
  _p_M2_T:cc.uT =>
  abst_T:cc.uT =>
  abst_equal:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) =>
  abst_plus:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT abst_T) =>
  dk_builtins.magic_prove 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.forall abst_T 
             (z:(cc.eT abst_T) =>
              dk_logic.ebP 
                (abst_equal (abst_plus x (abst_plus y z)) 
                   (abst_plus (abst_plus x y) z)))))).

def Product_additive_monoid__zero_is_neutral :
  _p_M1_T:cc.uT ->
  _p_M2_T:cc.uT ->
  abst_T:cc.uT ->
  abst_zero:(cc.eT abst_T) ->
  abst_equal:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) ->
  abst_plus:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT abst_T) ->
  dk_logic.eP 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.and (dk_logic.ebP (abst_equal (abst_plus x abst_zero) x)) 
          (dk_logic.ebP (abst_equal (abst_plus abst_zero x) x))))
  :=
  _p_M1_T:cc.uT =>
  _p_M2_T:cc.uT =>
  abst_T:cc.uT =>
  abst_zero:(cc.eT abst_T) =>
  abst_equal:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) =>
  abst_plus:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT abst_T) =>
  dk_builtins.magic_prove 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.and (dk_logic.ebP (abst_equal (abst_plus x abst_zero) x)) 
          (dk_logic.ebP (abst_equal (abst_plus abst_zero x) x)))).

def Product_additive_monoid__plus_commutes :
  _p_M1_T:cc.uT ->
  _p_M2_T:cc.uT ->
  _p_M1_equal:((cc.eT _p_M1_T) -> (cc.eT _p_M1_T) -> cc.eT basics.bool__t) ->
  _p_M1_plus:((cc.eT _p_M1_T) -> (cc.eT _p_M1_T) -> cc.eT _p_M1_T) ->
  _p_M1_plus_commutes:(dk_logic.eP 
                         (dk_logic.forall _p_M1_T 
                            (x:(cc.eT _p_M1_T) =>
                             dk_logic.forall _p_M1_T 
                               (y:(cc.eT _p_M1_T) =>
                                dk_logic.ebP 
                                  (_p_M1_equal (_p_M1_plus x y) 
                                     (_p_M1_plus y x)))))) ->
  _p_M2_equal:((cc.eT _p_M2_T) -> (cc.eT _p_M2_T) -> cc.eT basics.bool__t) ->
  _p_M2_plus:((cc.eT _p_M2_T) -> (cc.eT _p_M2_T) -> cc.eT _p_M2_T) ->
  _p_M2_plus_commutes:(dk_logic.eP 
                         (dk_logic.forall _p_M2_T 
                            (x:(cc.eT _p_M2_T) =>
                             dk_logic.forall _p_M2_T 
                               (y:(cc.eT _p_M2_T) =>
                                dk_logic.ebP 
                                  (_p_M2_equal (_p_M2_plus x y) 
                                     (_p_M2_plus y x)))))) ->
  abst_T:cc.uT ->
  abst_first:((cc.eT abst_T) -> cc.eT _p_M1_T) ->
  abst_pair:((cc.eT _p_M1_T) -> (cc.eT _p_M2_T) -> cc.eT abst_T) ->
  abst_second:((cc.eT abst_T) -> cc.eT _p_M2_T) ->
  abst_equal:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) ->
  abst_pair_substitution_rule:(dk_logic.eP 
                                 (dk_logic.forall _p_M1_T 
                                    (x_1:(cc.eT _p_M1_T) =>
                                     dk_logic.forall _p_M1_T 
                                       (x_2:(cc.eT _p_M1_T) =>
                                        dk_logic.forall _p_M2_T 
                                          (y_1:(cc.eT _p_M2_T) =>
                                           dk_logic.forall _p_M2_T 
                                             (y_2:(cc.eT _p_M2_T) =>
                                              dk_logic.imp 
                                                (dk_logic.ebP 
                                                   (_p_M1_equal x_1 x_2)) 
                                                (dk_logic.imp 
                                                   (dk_logic.ebP 
                                                      (_p_M2_equal y_1 y_2)) 
                                                   (dk_logic.ebP 
                                                      (abst_equal 
                                                         (abst_pair x_1 y_1) 
                                                         (abst_pair x_2 y_2)))))))))) ->
  dk_logic.eP 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.ebP 
             (abst_equal 
                (Product_additive_monoid__plus _p_M1_T _p_M2_T _p_M1_plus 
                   _p_M2_plus abst_T abst_first abst_pair abst_second x y) 
                (Product_additive_monoid__plus _p_M1_T _p_M2_T _p_M1_plus 
                   _p_M2_plus abst_T abst_first abst_pair abst_second y x)))))
  :=
  _p_M1_T:cc.uT =>
  _p_M2_T:cc.uT =>
  _p_M1_equal:((cc.eT _p_M1_T) -> (cc.eT _p_M1_T) -> cc.eT basics.bool__t) =>
  _p_M1_plus:((cc.eT _p_M1_T) -> (cc.eT _p_M1_T) -> cc.eT _p_M1_T) =>
  _p_M1_plus_commutes:
  (dk_logic.eP 
     (dk_logic.forall _p_M1_T 
        (x:(cc.eT _p_M1_T) =>
         dk_logic.forall _p_M1_T 
           (y:(cc.eT _p_M1_T) =>
            dk_logic.ebP (_p_M1_equal (_p_M1_plus x y) (_p_M1_plus y x)))))) =>
  _p_M2_equal:((cc.eT _p_M2_T) -> (cc.eT _p_M2_T) -> cc.eT basics.bool__t) =>
  _p_M2_plus:((cc.eT _p_M2_T) -> (cc.eT _p_M2_T) -> cc.eT _p_M2_T) =>
  _p_M2_plus_commutes:
  (dk_logic.eP 
     (dk_logic.forall _p_M2_T 
        (x:(cc.eT _p_M2_T) =>
         dk_logic.forall _p_M2_T 
           (y:(cc.eT _p_M2_T) =>
            dk_logic.ebP (_p_M2_equal (_p_M2_plus x y) (_p_M2_plus y x)))))) =>
  abst_T:cc.uT =>
  abst_first:((cc.eT abst_T) -> cc.eT _p_M1_T) =>
  abst_pair:((cc.eT _p_M1_T) -> (cc.eT _p_M2_T) -> cc.eT abst_T) =>
  abst_second:((cc.eT abst_T) -> cc.eT _p_M2_T) =>
  abst_equal:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) =>
  abst_pair_substitution_rule:
  (dk_logic.eP 
     (dk_logic.forall _p_M1_T 
        (x_1:(cc.eT _p_M1_T) =>
         dk_logic.forall _p_M1_T 
           (x_2:(cc.eT _p_M1_T) =>
            dk_logic.forall _p_M2_T 
              (y_1:(cc.eT _p_M2_T) =>
               dk_logic.forall _p_M2_T 
                 (y_2:(cc.eT _p_M2_T) =>
                  dk_logic.imp (dk_logic.ebP (_p_M1_equal x_1 x_2)) 
                    (dk_logic.imp (dk_logic.ebP (_p_M2_equal y_1 y_2)) 
                       (dk_logic.ebP 
                          (abst_equal (abst_pair x_1 y_1) (abst_pair x_2 y_2)))))))))) =>
  (__A_1_LEMMA:
   (a:(cc.eT abst_T) ->
    b:(cc.eT abst_T) ->
    dk_logic.eP 
      (dk_logic.ebP 
         (abst_equal 
            (Product_additive_monoid__plus _p_M1_T _p_M2_T _p_M1_plus 
               _p_M2_plus abst_T abst_first abst_pair abst_second a b) 
            (Product_additive_monoid__plus _p_M1_T _p_M2_T _p_M1_plus 
               _p_M2_plus abst_T abst_first abst_pair abst_second b a)))) =>
   zen.nnpp 
     (zen.forall abst_T 
        (v_Vzb:(zen.term abst_T) =>
         zen.forall abst_T 
           (v_Vac:(zen.term abst_T) =>
            zen.triangle 
              (focal.is_true 
                 (abst_equal 
                    (Product_additive_monoid__plus _p_M1_T _p_M2_T 
                       _p_M1_plus _p_M2_plus abst_T abst_first abst_pair 
                       abst_second v_Vzb v_Vac) 
                    (Product_additive_monoid__plus _p_M1_T _p_M2_T 
                       _p_M1_plus _p_M2_plus abst_T abst_first abst_pair 
                       abst_second v_Vac v_Vzb)))))) 
     (v_Vbc:
      (zen.proof 
         (zen.not 
            (zen.forall abst_T 
               (v_Vzb:(zen.term abst_T) =>
                zen.forall abst_T 
                  (v_Vac:(zen.term abst_T) =>
                   zen.triangle 
                     (focal.is_true 
                        (abst_equal 
                           (Product_additive_monoid__plus _p_M1_T _p_M2_T 
                              _p_M1_plus _p_M2_plus abst_T abst_first 
                              abst_pair abst_second v_Vzb v_Vac) 
                           (Product_additive_monoid__plus _p_M1_T _p_M2_T 
                              _p_M1_plus _p_M2_plus abst_T abst_first 
                              abst_pair abst_second v_Vac v_Vzb)))))))) =>
      zen.Raxiom 
        (zen.forall abst_T 
           (v_Vzb:(zen.term abst_T) =>
            zen.forall abst_T 
              (v_Vac:(zen.term abst_T) =>
               zen.triangle 
                 (focal.is_true 
                    (abst_equal 
                       (Product_additive_monoid__plus _p_M1_T _p_M2_T 
                          _p_M1_plus _p_M2_plus abst_T abst_first abst_pair 
                          abst_second v_Vzb v_Vac) 
                       (Product_additive_monoid__plus _p_M1_T _p_M2_T 
                          _p_M1_plus _p_M2_plus abst_T abst_first abst_pair 
                          abst_second v_Vac v_Vzb)))))) __A_1_LEMMA v_Vbc)) 
    (a:(cc.eT abst_T) =>
     b:(cc.eT abst_T) =>
     (__A_1_1_LEMMA:
      (a1:(cc.eT _p_M1_T) ->
       a2:(cc.eT _p_M2_T) ->
       b1:(cc.eT _p_M1_T) ->
       b2:(cc.eT _p_M2_T) ->
       dk_logic.eP 
         (dk_logic.ebP 
            (abst_equal (abst_pair (_p_M1_plus a1 b1) (_p_M2_plus a2 b2)) 
               (abst_pair (_p_M1_plus b1 a1) (_p_M2_plus b2 a2))))) =>
      zen.nnpp 
        (zen.triangle 
           (focal.is_true 
              (abst_equal 
                 (Product_additive_monoid__plus _p_M1_T _p_M2_T _p_M1_plus 
                    _p_M2_plus abst_T abst_first abst_pair abst_second a b) 
                 (Product_additive_monoid__plus _p_M1_T _p_M2_T _p_M1_plus 
                    _p_M2_plus abst_T abst_first abst_pair abst_second b a)))) 
        (v_Vzb:
         (zen.proof 
            (zen.not 
               (zen.triangle 
                  (focal.is_true 
                     (abst_equal 
                        (abst_pair 
                           (_p_M1_plus (abst_first a) (abst_first b)) 
                           (_p_M2_plus (abst_second a) (abst_second b))) 
                        (abst_pair 
                           (_p_M1_plus (abst_first b) (abst_first a)) 
                           (_p_M2_plus (abst_second b) (abst_second a)))))))) =>
         zen.Rall _p_M1_T 
           (v_Vac:(zen.term _p_M1_T) =>
            zen.forall _p_M2_T 
              (v_Vbc:(zen.term _p_M2_T) =>
               zen.forall _p_M1_T 
                 (v_Vcc:(zen.term _p_M1_T) =>
                  zen.forall _p_M2_T 
                    (v_Vdc:(zen.term _p_M2_T) =>
                     zen.triangle 
                       (focal.is_true 
                          (abst_equal 
                             (abst_pair (_p_M1_plus v_Vac v_Vcc) 
                                (_p_M2_plus v_Vbc v_Vdc)) 
                             (abst_pair (_p_M1_plus v_Vcc v_Vac) 
                                (_p_M2_plus v_Vdc v_Vbc)))))))) 
           (abst_first a) 
           (v_Vec:
            (zen.proof 
               (zen.forall _p_M2_T 
                  (v_Vbc:(zen.term _p_M2_T) =>
                   zen.forall _p_M1_T 
                     (v_Vcc:(zen.term _p_M1_T) =>
                      zen.forall _p_M2_T 
                        (v_Vdc:(zen.term _p_M2_T) =>
                         zen.triangle 
                           (focal.is_true 
                              (abst_equal 
                                 (abst_pair 
                                    (_p_M1_plus (abst_first a) v_Vcc) 
                                    (_p_M2_plus v_Vbc v_Vdc)) 
                                 (abst_pair 
                                    (_p_M1_plus v_Vcc (abst_first a)) 
                                    (_p_M2_plus v_Vdc v_Vbc))))))))) =>
            zen.Rall _p_M2_T 
              (v_Vbc:(zen.term _p_M2_T) =>
               zen.forall _p_M1_T 
                 (v_Vcc:(zen.term _p_M1_T) =>
                  zen.forall _p_M2_T 
                    (v_Vdc:(zen.term _p_M2_T) =>
                     zen.triangle 
                       (focal.is_true 
                          (abst_equal 
                             (abst_pair (_p_M1_plus (abst_first a) v_Vcc) 
                                (_p_M2_plus v_Vbc v_Vdc)) 
                             (abst_pair (_p_M1_plus v_Vcc (abst_first a)) 
                                (_p_M2_plus v_Vdc v_Vbc))))))) 
              (abst_second a) 
              (v_Vfc:
               (zen.proof 
                  (zen.forall _p_M1_T 
                     (v_Vcc:(zen.term _p_M1_T) =>
                      zen.forall _p_M2_T 
                        (v_Vdc:(zen.term _p_M2_T) =>
                         zen.triangle 
                           (focal.is_true 
                              (abst_equal 
                                 (abst_pair 
                                    (_p_M1_plus (abst_first a) v_Vcc) 
                                    (_p_M2_plus (abst_second a) v_Vdc)) 
                                 (abst_pair 
                                    (_p_M1_plus v_Vcc (abst_first a)) 
                                    (_p_M2_plus v_Vdc (abst_second a))))))))) =>
               zen.Rall _p_M1_T 
                 (v_Vcc:(zen.term _p_M1_T) =>
                  zen.forall _p_M2_T 
                    (v_Vdc:(zen.term _p_M2_T) =>
                     zen.triangle 
                       (focal.is_true 
                          (abst_equal 
                             (abst_pair (_p_M1_plus (abst_first a) v_Vcc) 
                                (_p_M2_plus (abst_second a) v_Vdc)) 
                             (abst_pair (_p_M1_plus v_Vcc (abst_first a)) 
                                (_p_M2_plus v_Vdc (abst_second a))))))) 
                 (abst_first b) 
                 (v_Vgc:
                  (zen.proof 
                     (zen.forall _p_M2_T 
                        (v_Vdc:(zen.term _p_M2_T) =>
                         zen.triangle 
                           (focal.is_true 
                              (abst_equal 
                                 (abst_pair 
                                    (_p_M1_plus (abst_first a) (abst_first b)) 
                                    (_p_M2_plus (abst_second a) v_Vdc)) 
                                 (abst_pair 
                                    (_p_M1_plus (abst_first b) (abst_first a)) 
                                    (_p_M2_plus v_Vdc (abst_second a)))))))) =>
                  zen.Rall _p_M2_T 
                    (v_Vdc:(zen.term _p_M2_T) =>
                     zen.triangle 
                       (focal.is_true 
                          (abst_equal 
                             (abst_pair 
                                (_p_M1_plus (abst_first a) (abst_first b)) 
                                (_p_M2_plus (abst_second a) v_Vdc)) 
                             (abst_pair 
                                (_p_M1_plus (abst_first b) (abst_first a)) 
                                (_p_M2_plus v_Vdc (abst_second a)))))) 
                    (abst_second b) 
                    (v_Vhc:
                     (zen.proof 
                        (zen.triangle 
                           (focal.is_true 
                              (abst_equal 
                                 (abst_pair 
                                    (_p_M1_plus (abst_first a) (abst_first b)) 
                                    (_p_M2_plus (abst_second a) 
                                       (abst_second b))) 
                                 (abst_pair 
                                    (_p_M1_plus (abst_first b) (abst_first a)) 
                                    (_p_M2_plus (abst_second b) 
                                       (abst_second a))))))) =>
                     zen.Raxiom 
                       (zen.triangle 
                          (focal.is_true 
                             (abst_equal 
                                (abst_pair 
                                   (_p_M1_plus (abst_first a) (abst_first b)) 
                                   (_p_M2_plus (abst_second a) 
                                      (abst_second b))) 
                                (abst_pair 
                                   (_p_M1_plus (abst_first b) (abst_first a)) 
                                   (_p_M2_plus (abst_second b) 
                                      (abst_second a)))))) v_Vhc v_Vzb) v_Vgc) 
                 v_Vfc) v_Vec) __A_1_1_LEMMA)) 
       (a1:(cc.eT _p_M1_T) =>
        a2:(cc.eT _p_M2_T) =>
        b1:(cc.eT _p_M1_T) =>
        b2:(cc.eT _p_M2_T) =>
        zen.nnpp 
          (zen.triangle 
             (focal.is_true 
                (abst_equal 
                   (abst_pair (_p_M1_plus a1 b1) (_p_M2_plus a2 b2)) 
                   (abst_pair (_p_M1_plus b1 a1) (_p_M2_plus b2 a2))))) 
          (v_Vzb:
           (zen.proof 
              (zen.not 
                 (zen.triangle 
                    (focal.is_true 
                       (abst_equal 
                          (abst_pair (_p_M1_plus a1 b1) (_p_M2_plus a2 b2)) 
                          (abst_pair (_p_M1_plus b1 a1) (_p_M2_plus b2 a2))))))) =>
           zen.Rall _p_M1_T 
             (v_Vac:(zen.term _p_M1_T) =>
              zen.forall _p_M1_T 
                (v_Vbc:(zen.term _p_M1_T) =>
                 zen.forall _p_M2_T 
                   (v_Vcc:(zen.term _p_M2_T) =>
                    zen.forall _p_M2_T 
                      (v_Vdc:(zen.term _p_M2_T) =>
                       zen.imp 
                         (zen.triangle 
                            (focal.is_true (_p_M1_equal v_Vac v_Vbc))) 
                         (zen.imp 
                            (zen.triangle 
                               (focal.is_true (_p_M2_equal v_Vcc v_Vdc))) 
                            (zen.triangle 
                               (focal.is_true 
                                  (abst_equal (abst_pair v_Vac v_Vcc) 
                                     (abst_pair v_Vbc v_Vdc))))))))) 
             (_p_M1_plus a1 b1) 
             (v_Vec:
              (zen.proof 
                 (zen.forall _p_M1_T 
                    (v_Vbc:(zen.term _p_M1_T) =>
                     zen.forall _p_M2_T 
                       (v_Vcc:(zen.term _p_M2_T) =>
                        zen.forall _p_M2_T 
                          (v_Vdc:(zen.term _p_M2_T) =>
                           zen.imp 
                             (zen.triangle 
                                (focal.is_true 
                                   (_p_M1_equal (_p_M1_plus a1 b1) v_Vbc))) 
                             (zen.imp 
                                (zen.triangle 
                                   (focal.is_true (_p_M2_equal v_Vcc v_Vdc))) 
                                (zen.triangle 
                                   (focal.is_true 
                                      (abst_equal 
                                         (abst_pair (_p_M1_plus a1 b1) v_Vcc) 
                                         (abst_pair v_Vbc v_Vdc)))))))))) =>
              zen.Rall _p_M1_T 
                (v_Vbc:(zen.term _p_M1_T) =>
                 zen.forall _p_M2_T 
                   (v_Vcc:(zen.term _p_M2_T) =>
                    zen.forall _p_M2_T 
                      (v_Vdc:(zen.term _p_M2_T) =>
                       zen.imp 
                         (zen.triangle 
                            (focal.is_true 
                               (_p_M1_equal (_p_M1_plus a1 b1) v_Vbc))) 
                         (zen.imp 
                            (zen.triangle 
                               (focal.is_true (_p_M2_equal v_Vcc v_Vdc))) 
                            (zen.triangle 
                               (focal.is_true 
                                  (abst_equal 
                                     (abst_pair (_p_M1_plus a1 b1) v_Vcc) 
                                     (abst_pair v_Vbc v_Vdc)))))))) 
                (_p_M1_plus b1 a1) 
                (v_Vfc:
                 (zen.proof 
                    (zen.forall _p_M2_T 
                       (v_Vcc:(zen.term _p_M2_T) =>
                        zen.forall _p_M2_T 
                          (v_Vdc:(zen.term _p_M2_T) =>
                           zen.imp 
                             (zen.triangle 
                                (focal.is_true 
                                   (_p_M1_equal (_p_M1_plus a1 b1) 
                                      (_p_M1_plus b1 a1)))) 
                             (zen.imp 
                                (zen.triangle 
                                   (focal.is_true (_p_M2_equal v_Vcc v_Vdc))) 
                                (zen.triangle 
                                   (focal.is_true 
                                      (abst_equal 
                                         (abst_pair (_p_M1_plus a1 b1) v_Vcc) 
                                         (abst_pair (_p_M1_plus b1 a1) v_Vdc))))))))) =>
                 zen.Rall _p_M2_T 
                   (v_Vcc:(zen.term _p_M2_T) =>
                    zen.forall _p_M2_T 
                      (v_Vdc:(zen.term _p_M2_T) =>
                       zen.imp 
                         (zen.triangle 
                            (focal.is_true 
                               (_p_M1_equal (_p_M1_plus a1 b1) 
                                  (_p_M1_plus b1 a1)))) 
                         (zen.imp 
                            (zen.triangle 
                               (focal.is_true (_p_M2_equal v_Vcc v_Vdc))) 
                            (zen.triangle 
                               (focal.is_true 
                                  (abst_equal 
                                     (abst_pair (_p_M1_plus a1 b1) v_Vcc) 
                                     (abst_pair (_p_M1_plus b1 a1) v_Vdc))))))) 
                   (_p_M2_plus a2 b2) 
                   (v_Vgc:
                    (zen.proof 
                       (zen.forall _p_M2_T 
                          (v_Vdc:(zen.term _p_M2_T) =>
                           zen.imp 
                             (zen.triangle 
                                (focal.is_true 
                                   (_p_M1_equal (_p_M1_plus a1 b1) 
                                      (_p_M1_plus b1 a1)))) 
                             (zen.imp 
                                (zen.triangle 
                                   (focal.is_true 
                                      (_p_M2_equal (_p_M2_plus a2 b2) v_Vdc))) 
                                (zen.triangle 
                                   (focal.is_true 
                                      (abst_equal 
                                         (abst_pair (_p_M1_plus a1 b1) 
                                            (_p_M2_plus a2 b2)) 
                                         (abst_pair (_p_M1_plus b1 a1) v_Vdc)))))))) =>
                    zen.Rall _p_M2_T 
                      (v_Vdc:(zen.term _p_M2_T) =>
                       zen.imp 
                         (zen.triangle 
                            (focal.is_true 
                               (_p_M1_equal (_p_M1_plus a1 b1) 
                                  (_p_M1_plus b1 a1)))) 
                         (zen.imp 
                            (zen.triangle 
                               (focal.is_true 
                                  (_p_M2_equal (_p_M2_plus a2 b2) v_Vdc))) 
                            (zen.triangle 
                               (focal.is_true 
                                  (abst_equal 
                                     (abst_pair (_p_M1_plus a1 b1) 
                                        (_p_M2_plus a2 b2)) 
                                     (abst_pair (_p_M1_plus b1 a1) v_Vdc)))))) 
                      (_p_M2_plus b2 a2) 
                      (v_Vhc:
                       (zen.proof 
                          (zen.imp 
                             (zen.triangle 
                                (focal.is_true 
                                   (_p_M1_equal (_p_M1_plus a1 b1) 
                                      (_p_M1_plus b1 a1)))) 
                             (zen.imp 
                                (zen.triangle 
                                   (focal.is_true 
                                      (_p_M2_equal (_p_M2_plus a2 b2) 
                                         (_p_M2_plus b2 a2)))) 
                                (zen.triangle 
                                   (focal.is_true 
                                      (abst_equal 
                                         (abst_pair (_p_M1_plus a1 b1) 
                                            (_p_M2_plus a2 b2)) 
                                         (abst_pair (_p_M1_plus b1 a1) 
                                            (_p_M2_plus b2 a2)))))))) =>
                       zen.Rimply 
                         (zen.triangle 
                            (focal.is_true 
                               (_p_M1_equal (_p_M1_plus a1 b1) 
                                  (_p_M1_plus b1 a1)))) 
                         (zen.imp 
                            (zen.triangle 
                               (focal.is_true 
                                  (_p_M2_equal (_p_M2_plus a2 b2) 
                                     (_p_M2_plus b2 a2)))) 
                            (zen.triangle 
                               (focal.is_true 
                                  (abst_equal 
                                     (abst_pair (_p_M1_plus a1 b1) 
                                        (_p_M2_plus a2 b2)) 
                                     (abst_pair (_p_M1_plus b1 a1) 
                                        (_p_M2_plus b2 a2)))))) 
                         (v_Vic:
                          (zen.proof 
                             (zen.not 
                                (zen.triangle 
                                   (focal.is_true 
                                      (_p_M1_equal (_p_M1_plus a1 b1) 
                                         (_p_M1_plus b1 a1)))))) =>
                          zen.Rall _p_M1_T 
                            (v_Vjc:(zen.term _p_M1_T) =>
                             zen.forall _p_M1_T 
                               (v_Vkc:(zen.term _p_M1_T) =>
                                zen.triangle 
                                  (focal.is_true 
                                     (_p_M1_equal (_p_M1_plus v_Vjc v_Vkc) 
                                        (_p_M1_plus v_Vkc v_Vjc))))) a1 
                            (v_Vlc:
                             (zen.proof 
                                (zen.forall _p_M1_T 
                                   (v_Vkc:(zen.term _p_M1_T) =>
                                    zen.triangle 
                                      (focal.is_true 
                                         (_p_M1_equal (_p_M1_plus a1 v_Vkc) 
                                            (_p_M1_plus v_Vkc a1)))))) =>
                             zen.Rall _p_M1_T 
                               (v_Vkc:(zen.term _p_M1_T) =>
                                zen.triangle 
                                  (focal.is_true 
                                     (_p_M1_equal (_p_M1_plus a1 v_Vkc) 
                                        (_p_M1_plus v_Vkc a1)))) b1 
                               (v_Vmc:
                                (zen.proof 
                                   (zen.triangle 
                                      (focal.is_true 
                                         (_p_M1_equal (_p_M1_plus a1 b1) 
                                            (_p_M1_plus b1 a1))))) =>
                                zen.Raxiom 
                                  (zen.triangle 
                                     (focal.is_true 
                                        (_p_M1_equal (_p_M1_plus a1 b1) 
                                           (_p_M1_plus b1 a1)))) v_Vmc v_Vic) 
                               v_Vlc) _p_M1_plus_commutes) 
                         (v_Vnc:
                          (zen.proof 
                             (zen.imp 
                                (zen.triangle 
                                   (focal.is_true 
                                      (_p_M2_equal (_p_M2_plus a2 b2) 
                                         (_p_M2_plus b2 a2)))) 
                                (zen.triangle 
                                   (focal.is_true 
                                      (abst_equal 
                                         (abst_pair (_p_M1_plus a1 b1) 
                                            (_p_M2_plus a2 b2)) 
                                         (abst_pair (_p_M1_plus b1 a1) 
                                            (_p_M2_plus b2 a2))))))) =>
                          zen.Rimply 
                            (zen.triangle 
                               (focal.is_true 
                                  (_p_M2_equal (_p_M2_plus a2 b2) 
                                     (_p_M2_plus b2 a2)))) 
                            (zen.triangle 
                               (focal.is_true 
                                  (abst_equal 
                                     (abst_pair (_p_M1_plus a1 b1) 
                                        (_p_M2_plus a2 b2)) 
                                     (abst_pair (_p_M1_plus b1 a1) 
                                        (_p_M2_plus b2 a2))))) 
                            (v_Voc:
                             (zen.proof 
                                (zen.not 
                                   (zen.triangle 
                                      (focal.is_true 
                                         (_p_M2_equal (_p_M2_plus a2 b2) 
                                            (_p_M2_plus b2 a2)))))) =>
                             zen.Rall _p_M2_T 
                               (v_Vpc:(zen.term _p_M2_T) =>
                                zen.forall _p_M2_T 
                                  (v_Vqc:(zen.term _p_M2_T) =>
                                   zen.triangle 
                                     (focal.is_true 
                                        (_p_M2_equal 
                                           (_p_M2_plus v_Vpc v_Vqc) 
                                           (_p_M2_plus v_Vqc v_Vpc))))) a2 
                               (v_Vrc:
                                (zen.proof 
                                   (zen.forall _p_M2_T 
                                      (v_Vqc:(zen.term _p_M2_T) =>
                                       zen.triangle 
                                         (focal.is_true 
                                            (_p_M2_equal 
                                               (_p_M2_plus a2 v_Vqc) 
                                               (_p_M2_plus v_Vqc a2)))))) =>
                                zen.Rall _p_M2_T 
                                  (v_Vqc:(zen.term _p_M2_T) =>
                                   zen.triangle 
                                     (focal.is_true 
                                        (_p_M2_equal (_p_M2_plus a2 v_Vqc) 
                                           (_p_M2_plus v_Vqc a2)))) b2 
                                  (v_Vsc:
                                   (zen.proof 
                                      (zen.triangle 
                                         (focal.is_true 
                                            (_p_M2_equal (_p_M2_plus a2 b2) 
                                               (_p_M2_plus b2 a2))))) =>
                                   zen.Raxiom 
                                     (zen.triangle 
                                        (focal.is_true 
                                           (_p_M2_equal (_p_M2_plus a2 b2) 
                                              (_p_M2_plus b2 a2)))) v_Vsc 
                                     v_Voc) v_Vrc) _p_M2_plus_commutes) 
                            (v_Vtc:
                             (zen.proof 
                                (zen.triangle 
                                   (focal.is_true 
                                      (abst_equal 
                                         (abst_pair (_p_M1_plus a1 b1) 
                                            (_p_M2_plus a2 b2)) 
                                         (abst_pair (_p_M1_plus b1 a1) 
                                            (_p_M2_plus b2 a2)))))) =>
                             zen.Raxiom 
                               (zen.triangle 
                                  (focal.is_true 
                                     (abst_equal 
                                        (abst_pair (_p_M1_plus a1 b1) 
                                           (_p_M2_plus a2 b2)) 
                                        (abst_pair (_p_M1_plus b1 a1) 
                                           (_p_M2_plus b2 a2))))) v_Vtc v_Vzb) 
                            v_Vnc) v_Vhc) v_Vgc) v_Vfc) v_Vec) 
             abst_pair_substitution_rule))).

def Product_additive_monoid__plus_right_substitution_rule :
  _p_M1_T:cc.uT ->
  _p_M2_T:cc.uT ->
  _p_M1_equal:((cc.eT _p_M1_T) -> (cc.eT _p_M1_T) -> cc.eT basics.bool__t) ->
  _p_M1_plus:((cc.eT _p_M1_T) -> (cc.eT _p_M1_T) -> cc.eT _p_M1_T) ->
  _p_M1_plus_right_substitution_rule:(dk_logic.eP 
                                        (dk_logic.forall _p_M1_T 
                                           (x:(cc.eT _p_M1_T) =>
                                            dk_logic.forall _p_M1_T 
                                              (y:(cc.eT _p_M1_T) =>
                                               dk_logic.forall _p_M1_T 
                                                 (z:(cc.eT _p_M1_T) =>
                                                  dk_logic.imp 
                                                    (dk_logic.ebP 
                                                       (_p_M1_equal x y)) 
                                                    (dk_logic.ebP 
                                                       (_p_M1_equal 
                                                          (_p_M1_plus z x) 
                                                          (_p_M1_plus z y)))))))) ->
  _p_M2_equal:((cc.eT _p_M2_T) -> (cc.eT _p_M2_T) -> cc.eT basics.bool__t) ->
  _p_M2_plus:((cc.eT _p_M2_T) -> (cc.eT _p_M2_T) -> cc.eT _p_M2_T) ->
  _p_M2_plus_right_substitution_rule:(dk_logic.eP 
                                        (dk_logic.forall _p_M2_T 
                                           (x:(cc.eT _p_M2_T) =>
                                            dk_logic.forall _p_M2_T 
                                              (y:(cc.eT _p_M2_T) =>
                                               dk_logic.forall _p_M2_T 
                                                 (z:(cc.eT _p_M2_T) =>
                                                  dk_logic.imp 
                                                    (dk_logic.ebP 
                                                       (_p_M2_equal x y)) 
                                                    (dk_logic.ebP 
                                                       (_p_M2_equal 
                                                          (_p_M2_plus z x) 
                                                          (_p_M2_plus z y)))))))) ->
  abst_T:cc.uT ->
  abst_first:((cc.eT abst_T) -> cc.eT _p_M1_T) ->
  abst_pair:((cc.eT _p_M1_T) -> (cc.eT _p_M2_T) -> cc.eT abst_T) ->
  abst_second:((cc.eT abst_T) -> cc.eT _p_M2_T) ->
  abst_equal:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) ->
  abst_equal_spec:(dk_logic.eP 
                     (dk_logic.forall abst_T 
                        (x:(cc.eT abst_T) =>
                         dk_logic.forall abst_T 
                           (y:(cc.eT abst_T) =>
                            dk_logic.eqv (dk_logic.ebP (abst_equal x y)) 
                              (dk_logic.and 
                                 (dk_logic.ebP 
                                    (_p_M1_equal (abst_first x) 
                                       (abst_first y))) 
                                 (dk_logic.ebP 
                                    (_p_M2_equal (abst_second x) 
                                       (abst_second y)))))))) ->
  abst_pair_substitution_rule:(dk_logic.eP 
                                 (dk_logic.forall _p_M1_T 
                                    (x_1:(cc.eT _p_M1_T) =>
                                     dk_logic.forall _p_M1_T 
                                       (x_2:(cc.eT _p_M1_T) =>
                                        dk_logic.forall _p_M2_T 
                                          (y_1:(cc.eT _p_M2_T) =>
                                           dk_logic.forall _p_M2_T 
                                             (y_2:(cc.eT _p_M2_T) =>
                                              dk_logic.imp 
                                                (dk_logic.ebP 
                                                   (_p_M1_equal x_1 x_2)) 
                                                (dk_logic.imp 
                                                   (dk_logic.ebP 
                                                      (_p_M2_equal y_1 y_2)) 
                                                   (dk_logic.ebP 
                                                      (abst_equal 
                                                         (abst_pair x_1 y_1) 
                                                         (abst_pair x_2 y_2)))))))))) ->
  dk_logic.eP 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.forall abst_T 
             (z:(cc.eT abst_T) =>
              dk_logic.imp (dk_logic.ebP (abst_equal x y)) 
                (dk_logic.ebP 
                   (abst_equal 
                      (Product_additive_monoid__plus _p_M1_T _p_M2_T 
                         _p_M1_plus _p_M2_plus abst_T abst_first abst_pair 
                         abst_second z x) 
                      (Product_additive_monoid__plus _p_M1_T _p_M2_T 
                         _p_M1_plus _p_M2_plus abst_T abst_first abst_pair 
                         abst_second z y)))))))
  :=
  _p_M1_T:cc.uT =>
  _p_M2_T:cc.uT =>
  _p_M1_equal:((cc.eT _p_M1_T) -> (cc.eT _p_M1_T) -> cc.eT basics.bool__t) =>
  _p_M1_plus:((cc.eT _p_M1_T) -> (cc.eT _p_M1_T) -> cc.eT _p_M1_T) =>
  _p_M1_plus_right_substitution_rule:
  (dk_logic.eP 
     (dk_logic.forall _p_M1_T 
        (x:(cc.eT _p_M1_T) =>
         dk_logic.forall _p_M1_T 
           (y:(cc.eT _p_M1_T) =>
            dk_logic.forall _p_M1_T 
              (z:(cc.eT _p_M1_T) =>
               dk_logic.imp (dk_logic.ebP (_p_M1_equal x y)) 
                 (dk_logic.ebP 
                    (_p_M1_equal (_p_M1_plus z x) (_p_M1_plus z y)))))))) =>
  _p_M2_equal:((cc.eT _p_M2_T) -> (cc.eT _p_M2_T) -> cc.eT basics.bool__t) =>
  _p_M2_plus:((cc.eT _p_M2_T) -> (cc.eT _p_M2_T) -> cc.eT _p_M2_T) =>
  _p_M2_plus_right_substitution_rule:
  (dk_logic.eP 
     (dk_logic.forall _p_M2_T 
        (x:(cc.eT _p_M2_T) =>
         dk_logic.forall _p_M2_T 
           (y:(cc.eT _p_M2_T) =>
            dk_logic.forall _p_M2_T 
              (z:(cc.eT _p_M2_T) =>
               dk_logic.imp (dk_logic.ebP (_p_M2_equal x y)) 
                 (dk_logic.ebP 
                    (_p_M2_equal (_p_M2_plus z x) (_p_M2_plus z y)))))))) =>
  abst_T:cc.uT =>
  abst_first:((cc.eT abst_T) -> cc.eT _p_M1_T) =>
  abst_pair:((cc.eT _p_M1_T) -> (cc.eT _p_M2_T) -> cc.eT abst_T) =>
  abst_second:((cc.eT abst_T) -> cc.eT _p_M2_T) =>
  abst_equal:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) =>
  abst_equal_spec:
  (dk_logic.eP 
     (dk_logic.forall abst_T 
        (x:(cc.eT abst_T) =>
         dk_logic.forall abst_T 
           (y:(cc.eT abst_T) =>
            dk_logic.eqv (dk_logic.ebP (abst_equal x y)) 
              (dk_logic.and 
                 (dk_logic.ebP (_p_M1_equal (abst_first x) (abst_first y))) 
                 (dk_logic.ebP (_p_M2_equal (abst_second x) (abst_second y)))))))) =>
  abst_pair_substitution_rule:
  (dk_logic.eP 
     (dk_logic.forall _p_M1_T 
        (x_1:(cc.eT _p_M1_T) =>
         dk_logic.forall _p_M1_T 
           (x_2:(cc.eT _p_M1_T) =>
            dk_logic.forall _p_M2_T 
              (y_1:(cc.eT _p_M2_T) =>
               dk_logic.forall _p_M2_T 
                 (y_2:(cc.eT _p_M2_T) =>
                  dk_logic.imp (dk_logic.ebP (_p_M1_equal x_1 x_2)) 
                    (dk_logic.imp (dk_logic.ebP (_p_M2_equal y_1 y_2)) 
                       (dk_logic.ebP 
                          (abst_equal (abst_pair x_1 y_1) (abst_pair x_2 y_2)))))))))) =>
  (__B_0_LEMMA:
   (a1:(cc.eT _p_M1_T) ->
    b1:(cc.eT _p_M1_T) ->
    c1:(cc.eT _p_M1_T) ->
    a2:(cc.eT _p_M2_T) ->
    b2:(cc.eT _p_M2_T) ->
    c2:(cc.eT _p_M2_T) ->
    H1:(dk_logic.eP (dk_logic.ebP (_p_M1_equal b1 c1))) ->
    H2:(dk_logic.eP (dk_logic.ebP (_p_M2_equal b2 c2))) ->
    dk_logic.eP 
      (dk_logic.ebP 
         (abst_equal (abst_pair (_p_M1_plus a1 b1) (_p_M2_plus a2 b2)) 
            (abst_pair (_p_M1_plus a1 c1) (_p_M2_plus a2 c2))))) =>
   (__B_1_LEMMA:
    (a:(cc.eT abst_T) ->
     b:(cc.eT abst_T) ->
     c:(cc.eT abst_T) ->
     H:(dk_logic.eP (dk_logic.ebP (abst_equal b c))) ->
     dk_logic.eP 
       (dk_logic.ebP 
          (abst_equal 
             (Product_additive_monoid__plus _p_M1_T _p_M2_T _p_M1_plus 
                _p_M2_plus abst_T abst_first abst_pair abst_second a b) 
             (Product_additive_monoid__plus _p_M1_T _p_M2_T _p_M1_plus 
                _p_M2_plus abst_T abst_first abst_pair abst_second a c)))) =>
    zen.nnpp 
      (zen.forall abst_T 
         (v_Vzb:(zen.term abst_T) =>
          zen.forall abst_T 
            (v_Vac:(zen.term abst_T) =>
             zen.forall abst_T 
               (v_Vbc:(zen.term abst_T) =>
                zen.imp 
                  (zen.triangle (focal.is_true (abst_equal v_Vzb v_Vac))) 
                  (zen.triangle 
                     (focal.is_true 
                        (abst_equal 
                           (Product_additive_monoid__plus _p_M1_T _p_M2_T 
                              _p_M1_plus _p_M2_plus abst_T abst_first 
                              abst_pair abst_second v_Vbc v_Vzb) 
                           (Product_additive_monoid__plus _p_M1_T _p_M2_T 
                              _p_M1_plus _p_M2_plus abst_T abst_first 
                              abst_pair abst_second v_Vbc v_Vac)))))))) 
      (v_Vcc:
       (zen.proof 
          (zen.not 
             (zen.forall abst_T 
                (v_Vzb:(zen.term abst_T) =>
                 zen.forall abst_T 
                   (v_Vac:(zen.term abst_T) =>
                    zen.forall abst_T 
                      (v_Vbc:(zen.term abst_T) =>
                       zen.imp 
                         (zen.triangle 
                            (focal.is_true (abst_equal v_Vzb v_Vac))) 
                         (zen.triangle 
                            (focal.is_true 
                               (abst_equal 
                                  (Product_additive_monoid__plus _p_M1_T 
                                     _p_M2_T _p_M1_plus _p_M2_plus abst_T 
                                     abst_first abst_pair abst_second v_Vbc 
                                     v_Vzb) 
                                  (Product_additive_monoid__plus _p_M1_T 
                                     _p_M2_T _p_M1_plus _p_M2_plus abst_T 
                                     abst_first abst_pair abst_second v_Vbc 
                                     v_Vac)))))))))) =>
       zen.Rnotall abst_T 
         (v_Vzb:(zen.term abst_T) =>
          zen.forall abst_T 
            (v_Vac:(zen.term abst_T) =>
             zen.forall abst_T 
               (v_Vbc:(zen.term abst_T) =>
                zen.imp 
                  (zen.triangle (focal.is_true (abst_equal v_Vzb v_Vac))) 
                  (zen.triangle 
                     (focal.is_true 
                        (abst_equal 
                           (Product_additive_monoid__plus _p_M1_T _p_M2_T 
                              _p_M1_plus _p_M2_plus abst_T abst_first 
                              abst_pair abst_second v_Vbc v_Vzb) 
                           (Product_additive_monoid__plus _p_M1_T _p_M2_T 
                              _p_M1_plus _p_M2_plus abst_T abst_first 
                              abst_pair abst_second v_Vbc v_Vac))))))) 
         (v_Vdc:(zen.term abst_T) =>
          v_Vec:
          (zen.proof 
             (zen.not 
                (zen.forall abst_T 
                   (v_Vac:(zen.term abst_T) =>
                    zen.forall abst_T 
                      (v_Vbc:(zen.term abst_T) =>
                       zen.imp 
                         (zen.triangle 
                            (focal.is_true (abst_equal v_Vdc v_Vac))) 
                         (zen.triangle 
                            (focal.is_true 
                               (abst_equal 
                                  (Product_additive_monoid__plus _p_M1_T 
                                     _p_M2_T _p_M1_plus _p_M2_plus abst_T 
                                     abst_first abst_pair abst_second v_Vbc 
                                     v_Vdc) 
                                  (Product_additive_monoid__plus _p_M1_T 
                                     _p_M2_T _p_M1_plus _p_M2_plus abst_T 
                                     abst_first abst_pair abst_second v_Vbc 
                                     v_Vac))))))))) =>
          zen.Rnotall abst_T 
            (v_Vac:(zen.term abst_T) =>
             zen.forall abst_T 
               (v_Vbc:(zen.term abst_T) =>
                zen.imp 
                  (zen.triangle (focal.is_true (abst_equal v_Vdc v_Vac))) 
                  (zen.triangle 
                     (focal.is_true 
                        (abst_equal 
                           (Product_additive_monoid__plus _p_M1_T _p_M2_T 
                              _p_M1_plus _p_M2_plus abst_T abst_first 
                              abst_pair abst_second v_Vbc v_Vdc) 
                           (Product_additive_monoid__plus _p_M1_T _p_M2_T 
                              _p_M1_plus _p_M2_plus abst_T abst_first 
                              abst_pair abst_second v_Vbc v_Vac)))))) 
            (v_Vfc:(zen.term abst_T) =>
             v_Vgc:
             (zen.proof 
                (zen.not 
                   (zen.forall abst_T 
                      (v_Vbc:(zen.term abst_T) =>
                       zen.imp 
                         (zen.triangle 
                            (focal.is_true (abst_equal v_Vdc v_Vfc))) 
                         (zen.triangle 
                            (focal.is_true 
                               (abst_equal 
                                  (Product_additive_monoid__plus _p_M1_T 
                                     _p_M2_T _p_M1_plus _p_M2_plus abst_T 
                                     abst_first abst_pair abst_second v_Vbc 
                                     v_Vdc) 
                                  (Product_additive_monoid__plus _p_M1_T 
                                     _p_M2_T _p_M1_plus _p_M2_plus abst_T 
                                     abst_first abst_pair abst_second v_Vbc 
                                     v_Vfc)))))))) =>
             zen.Rnotall abst_T 
               (v_Vbc:(zen.term abst_T) =>
                zen.imp 
                  (zen.triangle (focal.is_true (abst_equal v_Vdc v_Vfc))) 
                  (zen.triangle 
                     (focal.is_true 
                        (abst_equal 
                           (Product_additive_monoid__plus _p_M1_T _p_M2_T 
                              _p_M1_plus _p_M2_plus abst_T abst_first 
                              abst_pair abst_second v_Vbc v_Vdc) 
                           (Product_additive_monoid__plus _p_M1_T _p_M2_T 
                              _p_M1_plus _p_M2_plus abst_T abst_first 
                              abst_pair abst_second v_Vbc v_Vfc))))) 
               (v_Vhc:(zen.term abst_T) =>
                v_Vic:
                (zen.proof 
                   (zen.not 
                      (zen.imp 
                         (zen.triangle 
                            (focal.is_true (abst_equal v_Vdc v_Vfc))) 
                         (zen.triangle 
                            (focal.is_true 
                               (abst_equal 
                                  (Product_additive_monoid__plus _p_M1_T 
                                     _p_M2_T _p_M1_plus _p_M2_plus abst_T 
                                     abst_first abst_pair abst_second v_Vhc 
                                     v_Vdc) 
                                  (Product_additive_monoid__plus _p_M1_T 
                                     _p_M2_T _p_M1_plus _p_M2_plus abst_T 
                                     abst_first abst_pair abst_second v_Vhc 
                                     v_Vfc))))))) =>
                zen.Rall abst_T 
                  (v_Vjc:(zen.term abst_T) =>
                   zen.forall abst_T 
                     (v_Vkc:(zen.term abst_T) =>
                      zen.forall abst_T 
                        (v_Vlc:(zen.term abst_T) =>
                         zen.imp 
                           (zen.triangle 
                              (focal.is_true (abst_equal v_Vkc v_Vlc))) 
                           (zen.triangle 
                              (focal.is_true 
                                 (abst_equal 
                                    (Product_additive_monoid__plus _p_M1_T 
                                       _p_M2_T _p_M1_plus _p_M2_plus abst_T 
                                       abst_first abst_pair abst_second 
                                       v_Vjc v_Vkc) 
                                    (Product_additive_monoid__plus _p_M1_T 
                                       _p_M2_T _p_M1_plus _p_M2_plus abst_T 
                                       abst_first abst_pair abst_second 
                                       v_Vjc v_Vlc))))))) v_Vhc 
                  (v_Vmc:
                   (zen.proof 
                      (zen.forall abst_T 
                         (v_Vkc:(zen.term abst_T) =>
                          zen.forall abst_T 
                            (v_Vlc:(zen.term abst_T) =>
                             zen.imp 
                               (zen.triangle 
                                  (focal.is_true (abst_equal v_Vkc v_Vlc))) 
                               (zen.triangle 
                                  (focal.is_true 
                                     (abst_equal 
                                        (Product_additive_monoid__plus 
                                           _p_M1_T _p_M2_T _p_M1_plus 
                                           _p_M2_plus abst_T abst_first 
                                           abst_pair abst_second v_Vhc v_Vkc) 
                                        (Product_additive_monoid__plus 
                                           _p_M1_T _p_M2_T _p_M1_plus 
                                           _p_M2_plus abst_T abst_first 
                                           abst_pair abst_second v_Vhc v_Vlc)))))))) =>
                   zen.Rall abst_T 
                     (v_Vkc:(zen.term abst_T) =>
                      zen.forall abst_T 
                        (v_Vlc:(zen.term abst_T) =>
                         zen.imp 
                           (zen.triangle 
                              (focal.is_true (abst_equal v_Vkc v_Vlc))) 
                           (zen.triangle 
                              (focal.is_true 
                                 (abst_equal 
                                    (Product_additive_monoid__plus _p_M1_T 
                                       _p_M2_T _p_M1_plus _p_M2_plus abst_T 
                                       abst_first abst_pair abst_second 
                                       v_Vhc v_Vkc) 
                                    (Product_additive_monoid__plus _p_M1_T 
                                       _p_M2_T _p_M1_plus _p_M2_plus abst_T 
                                       abst_first abst_pair abst_second 
                                       v_Vhc v_Vlc)))))) v_Vdc 
                     (v_Vnc:
                      (zen.proof 
                         (zen.forall abst_T 
                            (v_Vlc:(zen.term abst_T) =>
                             zen.imp 
                               (zen.triangle 
                                  (focal.is_true (abst_equal v_Vdc v_Vlc))) 
                               (zen.triangle 
                                  (focal.is_true 
                                     (abst_equal 
                                        (Product_additive_monoid__plus 
                                           _p_M1_T _p_M2_T _p_M1_plus 
                                           _p_M2_plus abst_T abst_first 
                                           abst_pair abst_second v_Vhc v_Vdc) 
                                        (Product_additive_monoid__plus 
                                           _p_M1_T _p_M2_T _p_M1_plus 
                                           _p_M2_plus abst_T abst_first 
                                           abst_pair abst_second v_Vhc v_Vlc))))))) =>
                      zen.Rall abst_T 
                        (v_Vlc:(zen.term abst_T) =>
                         zen.imp 
                           (zen.triangle 
                              (focal.is_true (abst_equal v_Vdc v_Vlc))) 
                           (zen.triangle 
                              (focal.is_true 
                                 (abst_equal 
                                    (Product_additive_monoid__plus _p_M1_T 
                                       _p_M2_T _p_M1_plus _p_M2_plus abst_T 
                                       abst_first abst_pair abst_second 
                                       v_Vhc v_Vdc) 
                                    (Product_additive_monoid__plus _p_M1_T 
                                       _p_M2_T _p_M1_plus _p_M2_plus abst_T 
                                       abst_first abst_pair abst_second 
                                       v_Vhc v_Vlc))))) v_Vfc 
                        (v_Voc:
                         (zen.proof 
                            (zen.imp 
                               (zen.triangle 
                                  (focal.is_true (abst_equal v_Vdc v_Vfc))) 
                               (zen.triangle 
                                  (focal.is_true 
                                     (abst_equal 
                                        (Product_additive_monoid__plus 
                                           _p_M1_T _p_M2_T _p_M1_plus 
                                           _p_M2_plus abst_T abst_first 
                                           abst_pair abst_second v_Vhc v_Vdc) 
                                        (Product_additive_monoid__plus 
                                           _p_M1_T _p_M2_T _p_M1_plus 
                                           _p_M2_plus abst_T abst_first 
                                           abst_pair abst_second v_Vhc v_Vfc)))))) =>
                         zen.Raxiom 
                           (zen.imp 
                              (zen.triangle 
                                 (focal.is_true (abst_equal v_Vdc v_Vfc))) 
                              (zen.triangle 
                                 (focal.is_true 
                                    (abst_equal 
                                       (Product_additive_monoid__plus 
                                          _p_M1_T _p_M2_T _p_M1_plus 
                                          _p_M2_plus abst_T abst_first 
                                          abst_pair abst_second v_Vhc v_Vdc) 
                                       (Product_additive_monoid__plus 
                                          _p_M1_T _p_M2_T _p_M1_plus 
                                          _p_M2_plus abst_T abst_first 
                                          abst_pair abst_second v_Vhc v_Vfc))))) 
                           v_Voc v_Vic) v_Vnc) v_Vmc) __B_1_LEMMA) v_Vgc) 
            v_Vec) v_Vcc)) 
     (a:(cc.eT abst_T) =>
      b:(cc.eT abst_T) =>
      c:(cc.eT abst_T) =>
      H:(dk_logic.eP (dk_logic.ebP (abst_equal b c))) =>
      (__B_1_1_LEMMA:
       (dk_logic.eP 
          (dk_logic.ebP (_p_M1_equal (abst_first b) (abst_first c)))) =>
       (__B_1_2_LEMMA:
        (dk_logic.eP 
           (dk_logic.ebP (_p_M2_equal (abst_second b) (abst_second c)))) =>
        zen.nnpp 
          (zen.triangle 
             (focal.is_true 
                (abst_equal 
                   (Product_additive_monoid__plus _p_M1_T _p_M2_T _p_M1_plus 
                      _p_M2_plus abst_T abst_first abst_pair abst_second a b) 
                   (Product_additive_monoid__plus _p_M1_T _p_M2_T _p_M1_plus 
                      _p_M2_plus abst_T abst_first abst_pair abst_second a c)))) 
          (v_Vzb:
           (zen.proof 
              (zen.not 
                 (zen.triangle 
                    (focal.is_true 
                       (abst_equal 
                          (abst_pair 
                             (_p_M1_plus (abst_first a) (abst_first b)) 
                             (_p_M2_plus (abst_second a) (abst_second b))) 
                          (abst_pair 
                             (_p_M1_plus (abst_first a) (abst_first c)) 
                             (_p_M2_plus (abst_second a) (abst_second c)))))))) =>
           zen.Rall _p_M1_T 
             (v_Vac:(zen.term _p_M1_T) =>
              zen.forall _p_M1_T 
                (v_Vbc:(zen.term _p_M1_T) =>
                 zen.forall _p_M1_T 
                   (v_Vcc:(zen.term _p_M1_T) =>
                    zen.forall _p_M2_T 
                      (v_Vdc:(zen.term _p_M2_T) =>
                       zen.forall _p_M2_T 
                         (v_Vec:(zen.term _p_M2_T) =>
                          zen.forall _p_M2_T 
                            (v_Vfc:(zen.term _p_M2_T) =>
                             zen.imp 
                               (zen.triangle 
                                  (focal.is_true (_p_M1_equal v_Vbc v_Vcc))) 
                               (zen.imp 
                                  (zen.triangle 
                                     (focal.is_true (_p_M2_equal v_Vec v_Vfc))) 
                                  (zen.triangle 
                                     (focal.is_true 
                                        (abst_equal 
                                           (abst_pair 
                                              (_p_M1_plus v_Vac v_Vbc) 
                                              (_p_M2_plus v_Vdc v_Vec)) 
                                           (abst_pair 
                                              (_p_M1_plus v_Vac v_Vcc) 
                                              (_p_M2_plus v_Vdc v_Vfc)))))))))))) 
             (abst_first a) 
             (v_Vgc:
              (zen.proof 
                 (zen.forall _p_M1_T 
                    (v_Vbc:(zen.term _p_M1_T) =>
                     zen.forall _p_M1_T 
                       (v_Vcc:(zen.term _p_M1_T) =>
                        zen.forall _p_M2_T 
                          (v_Vdc:(zen.term _p_M2_T) =>
                           zen.forall _p_M2_T 
                             (v_Vec:(zen.term _p_M2_T) =>
                              zen.forall _p_M2_T 
                                (v_Vfc:(zen.term _p_M2_T) =>
                                 zen.imp 
                                   (zen.triangle 
                                      (focal.is_true 
                                         (_p_M1_equal v_Vbc v_Vcc))) 
                                   (zen.imp 
                                      (zen.triangle 
                                         (focal.is_true 
                                            (_p_M2_equal v_Vec v_Vfc))) 
                                      (zen.triangle 
                                         (focal.is_true 
                                            (abst_equal 
                                               (abst_pair 
                                                  (_p_M1_plus (abst_first a) 
                                                     v_Vbc) 
                                                  (_p_M2_plus v_Vdc v_Vec)) 
                                               (abst_pair 
                                                  (_p_M1_plus (abst_first a) 
                                                     v_Vcc) 
                                                  (_p_M2_plus v_Vdc v_Vfc))))))))))))) =>
              zen.Rall _p_M1_T 
                (v_Vbc:(zen.term _p_M1_T) =>
                 zen.forall _p_M1_T 
                   (v_Vcc:(zen.term _p_M1_T) =>
                    zen.forall _p_M2_T 
                      (v_Vdc:(zen.term _p_M2_T) =>
                       zen.forall _p_M2_T 
                         (v_Vec:(zen.term _p_M2_T) =>
                          zen.forall _p_M2_T 
                            (v_Vfc:(zen.term _p_M2_T) =>
                             zen.imp 
                               (zen.triangle 
                                  (focal.is_true (_p_M1_equal v_Vbc v_Vcc))) 
                               (zen.imp 
                                  (zen.triangle 
                                     (focal.is_true (_p_M2_equal v_Vec v_Vfc))) 
                                  (zen.triangle 
                                     (focal.is_true 
                                        (abst_equal 
                                           (abst_pair 
                                              (_p_M1_plus (abst_first a) 
                                                 v_Vbc) 
                                              (_p_M2_plus v_Vdc v_Vec)) 
                                           (abst_pair 
                                              (_p_M1_plus (abst_first a) 
                                                 v_Vcc) 
                                              (_p_M2_plus v_Vdc v_Vfc))))))))))) 
                (abst_first b) 
                (v_Vhc:
                 (zen.proof 
                    (zen.forall _p_M1_T 
                       (v_Vcc:(zen.term _p_M1_T) =>
                        zen.forall _p_M2_T 
                          (v_Vdc:(zen.term _p_M2_T) =>
                           zen.forall _p_M2_T 
                             (v_Vec:(zen.term _p_M2_T) =>
                              zen.forall _p_M2_T 
                                (v_Vfc:(zen.term _p_M2_T) =>
                                 zen.imp 
                                   (zen.triangle 
                                      (focal.is_true 
                                         (_p_M1_equal (abst_first b) v_Vcc))) 
                                   (zen.imp 
                                      (zen.triangle 
                                         (focal.is_true 
                                            (_p_M2_equal v_Vec v_Vfc))) 
                                      (zen.triangle 
                                         (focal.is_true 
                                            (abst_equal 
                                               (abst_pair 
                                                  (_p_M1_plus (abst_first a) 
                                                     (abst_first b)) 
                                                  (_p_M2_plus v_Vdc v_Vec)) 
                                               (abst_pair 
                                                  (_p_M1_plus (abst_first a) 
                                                     v_Vcc) 
                                                  (_p_M2_plus v_Vdc v_Vfc)))))))))))) =>
                 zen.Rall _p_M1_T 
                   (v_Vcc:(zen.term _p_M1_T) =>
                    zen.forall _p_M2_T 
                      (v_Vdc:(zen.term _p_M2_T) =>
                       zen.forall _p_M2_T 
                         (v_Vec:(zen.term _p_M2_T) =>
                          zen.forall _p_M2_T 
                            (v_Vfc:(zen.term _p_M2_T) =>
                             zen.imp 
                               (zen.triangle 
                                  (focal.is_true 
                                     (_p_M1_equal (abst_first b) v_Vcc))) 
                               (zen.imp 
                                  (zen.triangle 
                                     (focal.is_true (_p_M2_equal v_Vec v_Vfc))) 
                                  (zen.triangle 
                                     (focal.is_true 
                                        (abst_equal 
                                           (abst_pair 
                                              (_p_M1_plus (abst_first a) 
                                                 (abst_first b)) 
                                              (_p_M2_plus v_Vdc v_Vec)) 
                                           (abst_pair 
                                              (_p_M1_plus (abst_first a) 
                                                 v_Vcc) 
                                              (_p_M2_plus v_Vdc v_Vfc)))))))))) 
                   (abst_first c) 
                   (v_Vic:
                    (zen.proof 
                       (zen.forall _p_M2_T 
                          (v_Vdc:(zen.term _p_M2_T) =>
                           zen.forall _p_M2_T 
                             (v_Vec:(zen.term _p_M2_T) =>
                              zen.forall _p_M2_T 
                                (v_Vfc:(zen.term _p_M2_T) =>
                                 zen.imp 
                                   (zen.triangle 
                                      (focal.is_true 
                                         (_p_M1_equal (abst_first b) 
                                            (abst_first c)))) 
                                   (zen.imp 
                                      (zen.triangle 
                                         (focal.is_true 
                                            (_p_M2_equal v_Vec v_Vfc))) 
                                      (zen.triangle 
                                         (focal.is_true 
                                            (abst_equal 
                                               (abst_pair 
                                                  (_p_M1_plus (abst_first a) 
                                                     (abst_first b)) 
                                                  (_p_M2_plus v_Vdc v_Vec)) 
                                               (abst_pair 
                                                  (_p_M1_plus (abst_first a) 
                                                     (abst_first c)) 
                                                  (_p_M2_plus v_Vdc v_Vfc))))))))))) =>
                    zen.Rall _p_M2_T 
                      (v_Vdc:(zen.term _p_M2_T) =>
                       zen.forall _p_M2_T 
                         (v_Vec:(zen.term _p_M2_T) =>
                          zen.forall _p_M2_T 
                            (v_Vfc:(zen.term _p_M2_T) =>
                             zen.imp 
                               (zen.triangle 
                                  (focal.is_true 
                                     (_p_M1_equal (abst_first b) 
                                        (abst_first c)))) 
                               (zen.imp 
                                  (zen.triangle 
                                     (focal.is_true (_p_M2_equal v_Vec v_Vfc))) 
                                  (zen.triangle 
                                     (focal.is_true 
                                        (abst_equal 
                                           (abst_pair 
                                              (_p_M1_plus (abst_first a) 
                                                 (abst_first b)) 
                                              (_p_M2_plus v_Vdc v_Vec)) 
                                           (abst_pair 
                                              (_p_M1_plus (abst_first a) 
                                                 (abst_first c)) 
                                              (_p_M2_plus v_Vdc v_Vfc))))))))) 
                      (abst_second a) 
                      (v_Vjc:
                       (zen.proof 
                          (zen.forall _p_M2_T 
                             (v_Vec:(zen.term _p_M2_T) =>
                              zen.forall _p_M2_T 
                                (v_Vfc:(zen.term _p_M2_T) =>
                                 zen.imp 
                                   (zen.triangle 
                                      (focal.is_true 
                                         (_p_M1_equal (abst_first b) 
                                            (abst_first c)))) 
                                   (zen.imp 
                                      (zen.triangle 
                                         (focal.is_true 
                                            (_p_M2_equal v_Vec v_Vfc))) 
                                      (zen.triangle 
                                         (focal.is_true 
                                            (abst_equal 
                                               (abst_pair 
                                                  (_p_M1_plus (abst_first a) 
                                                     (abst_first b)) 
                                                  (_p_M2_plus 
                                                     (abst_second a) v_Vec)) 
                                               (abst_pair 
                                                  (_p_M1_plus (abst_first a) 
                                                     (abst_first c)) 
                                                  (_p_M2_plus 
                                                     (abst_second a) v_Vfc)))))))))) =>
                       zen.Rall _p_M2_T 
                         (v_Vec:(zen.term _p_M2_T) =>
                          zen.forall _p_M2_T 
                            (v_Vfc:(zen.term _p_M2_T) =>
                             zen.imp 
                               (zen.triangle 
                                  (focal.is_true 
                                     (_p_M1_equal (abst_first b) 
                                        (abst_first c)))) 
                               (zen.imp 
                                  (zen.triangle 
                                     (focal.is_true (_p_M2_equal v_Vec v_Vfc))) 
                                  (zen.triangle 
                                     (focal.is_true 
                                        (abst_equal 
                                           (abst_pair 
                                              (_p_M1_plus (abst_first a) 
                                                 (abst_first b)) 
                                              (_p_M2_plus (abst_second a) 
                                                 v_Vec)) 
                                           (abst_pair 
                                              (_p_M1_plus (abst_first a) 
                                                 (abst_first c)) 
                                              (_p_M2_plus (abst_second a) 
                                                 v_Vfc)))))))) 
                         (abst_second b) 
                         (v_Vkc:
                          (zen.proof 
                             (zen.forall _p_M2_T 
                                (v_Vfc:(zen.term _p_M2_T) =>
                                 zen.imp 
                                   (zen.triangle 
                                      (focal.is_true 
                                         (_p_M1_equal (abst_first b) 
                                            (abst_first c)))) 
                                   (zen.imp 
                                      (zen.triangle 
                                         (focal.is_true 
                                            (_p_M2_equal (abst_second b) 
                                               v_Vfc))) 
                                      (zen.triangle 
                                         (focal.is_true 
                                            (abst_equal 
                                               (abst_pair 
                                                  (_p_M1_plus (abst_first a) 
                                                     (abst_first b)) 
                                                  (_p_M2_plus 
                                                     (abst_second a) 
                                                     (abst_second b))) 
                                               (abst_pair 
                                                  (_p_M1_plus (abst_first a) 
                                                     (abst_first c)) 
                                                  (_p_M2_plus 
                                                     (abst_second a) v_Vfc))))))))) =>
                          zen.Rall _p_M2_T 
                            (v_Vfc:(zen.term _p_M2_T) =>
                             zen.imp 
                               (zen.triangle 
                                  (focal.is_true 
                                     (_p_M1_equal (abst_first b) 
                                        (abst_first c)))) 
                               (zen.imp 
                                  (zen.triangle 
                                     (focal.is_true 
                                        (_p_M2_equal (abst_second b) v_Vfc))) 
                                  (zen.triangle 
                                     (focal.is_true 
                                        (abst_equal 
                                           (abst_pair 
                                              (_p_M1_plus (abst_first a) 
                                                 (abst_first b)) 
                                              (_p_M2_plus (abst_second a) 
                                                 (abst_second b))) 
                                           (abst_pair 
                                              (_p_M1_plus (abst_first a) 
                                                 (abst_first c)) 
                                              (_p_M2_plus (abst_second a) 
                                                 v_Vfc))))))) 
                            (abst_second c) 
                            (v_Vlc:
                             (zen.proof 
                                (zen.imp 
                                   (zen.triangle 
                                      (focal.is_true 
                                         (_p_M1_equal (abst_first b) 
                                            (abst_first c)))) 
                                   (zen.imp 
                                      (zen.triangle 
                                         (focal.is_true 
                                            (_p_M2_equal (abst_second b) 
                                               (abst_second c)))) 
                                      (zen.triangle 
                                         (focal.is_true 
                                            (abst_equal 
                                               (abst_pair 
                                                  (_p_M1_plus (abst_first a) 
                                                     (abst_first b)) 
                                                  (_p_M2_plus 
                                                     (abst_second a) 
                                                     (abst_second b))) 
                                               (abst_pair 
                                                  (_p_M1_plus (abst_first a) 
                                                     (abst_first c)) 
                                                  (_p_M2_plus 
                                                     (abst_second a) 
                                                     (abst_second c))))))))) =>
                             zen.Rimply 
                               (zen.triangle 
                                  (focal.is_true 
                                     (_p_M1_equal (abst_first b) 
                                        (abst_first c)))) 
                               (zen.imp 
                                  (zen.triangle 
                                     (focal.is_true 
                                        (_p_M2_equal (abst_second b) 
                                           (abst_second c)))) 
                                  (zen.triangle 
                                     (focal.is_true 
                                        (abst_equal 
                                           (abst_pair 
                                              (_p_M1_plus (abst_first a) 
                                                 (abst_first b)) 
                                              (_p_M2_plus (abst_second a) 
                                                 (abst_second b))) 
                                           (abst_pair 
                                              (_p_M1_plus (abst_first a) 
                                                 (abst_first c)) 
                                              (_p_M2_plus (abst_second a) 
                                                 (abst_second c))))))) 
                               (v_Vmc:
                                (zen.proof 
                                   (zen.not 
                                      (zen.triangle 
                                         (focal.is_true 
                                            (_p_M1_equal (abst_first b) 
                                               (abst_first c)))))) =>
                                zen.Raxiom 
                                  (zen.triangle 
                                     (focal.is_true 
                                        (_p_M1_equal (abst_first b) 
                                           (abst_first c)))) __B_1_1_LEMMA 
                                  v_Vmc) 
                               (v_Vnc:
                                (zen.proof 
                                   (zen.imp 
                                      (zen.triangle 
                                         (focal.is_true 
                                            (_p_M2_equal (abst_second b) 
                                               (abst_second c)))) 
                                      (zen.triangle 
                                         (focal.is_true 
                                            (abst_equal 
                                               (abst_pair 
                                                  (_p_M1_plus (abst_first a) 
                                                     (abst_first b)) 
                                                  (_p_M2_plus 
                                                     (abst_second a) 
                                                     (abst_second b))) 
                                               (abst_pair 
                                                  (_p_M1_plus (abst_first a) 
                                                     (abst_first c)) 
                                                  (_p_M2_plus 
                                                     (abst_second a) 
                                                     (abst_second c)))))))) =>
                                zen.Rimply 
                                  (zen.triangle 
                                     (focal.is_true 
                                        (_p_M2_equal (abst_second b) 
                                           (abst_second c)))) 
                                  (zen.triangle 
                                     (focal.is_true 
                                        (abst_equal 
                                           (abst_pair 
                                              (_p_M1_plus (abst_first a) 
                                                 (abst_first b)) 
                                              (_p_M2_plus (abst_second a) 
                                                 (abst_second b))) 
                                           (abst_pair 
                                              (_p_M1_plus (abst_first a) 
                                                 (abst_first c)) 
                                              (_p_M2_plus (abst_second a) 
                                                 (abst_second c)))))) 
                                  (v_Voc:
                                   (zen.proof 
                                      (zen.not 
                                         (zen.triangle 
                                            (focal.is_true 
                                               (_p_M2_equal (abst_second b) 
                                                  (abst_second c)))))) =>
                                   zen.Raxiom 
                                     (zen.triangle 
                                        (focal.is_true 
                                           (_p_M2_equal (abst_second b) 
                                              (abst_second c)))) 
                                     __B_1_2_LEMMA v_Voc) 
                                  (v_Vpc:
                                   (zen.proof 
                                      (zen.triangle 
                                         (focal.is_true 
                                            (abst_equal 
                                               (abst_pair 
                                                  (_p_M1_plus (abst_first a) 
                                                     (abst_first b)) 
                                                  (_p_M2_plus 
                                                     (abst_second a) 
                                                     (abst_second b))) 
                                               (abst_pair 
                                                  (_p_M1_plus (abst_first a) 
                                                     (abst_first c)) 
                                                  (_p_M2_plus 
                                                     (abst_second a) 
                                                     (abst_second c))))))) =>
                                   zen.Raxiom 
                                     (zen.triangle 
                                        (focal.is_true 
                                           (abst_equal 
                                              (abst_pair 
                                                 (_p_M1_plus (abst_first a) 
                                                    (abst_first b)) 
                                                 (_p_M2_plus (abst_second a) 
                                                    (abst_second b))) 
                                              (abst_pair 
                                                 (_p_M1_plus (abst_first a) 
                                                    (abst_first c)) 
                                                 (_p_M2_plus (abst_second a) 
                                                    (abst_second c)))))) 
                                     v_Vpc v_Vzb) v_Vnc) v_Vlc) v_Vkc) v_Vjc) 
                      v_Vic) v_Vhc) v_Vgc) __B_0_LEMMA)) 
         (zen.nnpp 
            (zen.triangle 
               (focal.is_true (_p_M2_equal (abst_second b) (abst_second c)))) 
            (v_Vac:
             (zen.proof 
                (zen.not 
                   (zen.triangle 
                      (focal.is_true 
                         (_p_M2_equal (abst_second b) (abst_second c)))))) =>
             zen.Rall abst_T 
               (v_Vbc:(zen.term abst_T) =>
                zen.forall abst_T 
                  (v_Vcc:(zen.term abst_T) =>
                   zen.eqv 
                     (zen.triangle (focal.is_true (abst_equal v_Vbc v_Vcc))) 
                     (zen.and 
                        (zen.triangle 
                           (focal.is_true 
                              (_p_M1_equal (abst_first v_Vbc) 
                                 (abst_first v_Vcc)))) 
                        (zen.triangle 
                           (focal.is_true 
                              (_p_M2_equal (abst_second v_Vbc) 
                                 (abst_second v_Vcc))))))) b 
               (v_Vdc:
                (zen.proof 
                   (zen.forall abst_T 
                      (v_Vcc:(zen.term abst_T) =>
                       zen.eqv 
                         (zen.triangle (focal.is_true (abst_equal b v_Vcc))) 
                         (zen.and 
                            (zen.triangle 
                               (focal.is_true 
                                  (_p_M1_equal (abst_first b) 
                                     (abst_first v_Vcc)))) 
                            (zen.triangle 
                               (focal.is_true 
                                  (_p_M2_equal (abst_second b) 
                                     (abst_second v_Vcc)))))))) =>
                zen.Rall abst_T 
                  (v_Vcc:(zen.term abst_T) =>
                   zen.eqv 
                     (zen.triangle (focal.is_true (abst_equal b v_Vcc))) 
                     (zen.and 
                        (zen.triangle 
                           (focal.is_true 
                              (_p_M1_equal (abst_first b) (abst_first v_Vcc)))) 
                        (zen.triangle 
                           (focal.is_true 
                              (_p_M2_equal (abst_second b) 
                                 (abst_second v_Vcc)))))) c 
                  (v_Vec:
                   (zen.proof 
                      (zen.eqv 
                         (zen.triangle (focal.is_true (abst_equal b c))) 
                         (zen.and 
                            (zen.triangle 
                               (focal.is_true 
                                  (_p_M1_equal (abst_first b) (abst_first c)))) 
                            (zen.triangle 
                               (focal.is_true 
                                  (_p_M2_equal (abst_second b) 
                                     (abst_second c))))))) =>
                   zen.Requiv 
                     (zen.triangle (focal.is_true (abst_equal b c))) 
                     (zen.and 
                        (zen.triangle 
                           (focal.is_true 
                              (_p_M1_equal (abst_first b) (abst_first c)))) 
                        (zen.triangle 
                           (focal.is_true 
                              (_p_M2_equal (abst_second b) (abst_second c))))) 
                     (v_Vfc:
                      (zen.proof 
                         (zen.not 
                            (zen.triangle (focal.is_true (abst_equal b c))))) =>
                      v_Vgc:
                      (zen.proof 
                         (zen.not 
                            (zen.and 
                               (zen.triangle 
                                  (focal.is_true 
                                     (_p_M1_equal (abst_first b) 
                                        (abst_first c)))) 
                               (zen.triangle 
                                  (focal.is_true 
                                     (_p_M2_equal (abst_second b) 
                                        (abst_second c))))))) =>
                      zen.Raxiom 
                        (zen.triangle (focal.is_true (abst_equal b c))) H 
                        v_Vfc) 
                     (H0:
                      (zen.proof 
                         (zen.triangle (focal.is_true (abst_equal b c)))) =>
                      v_Vhc:
                      (zen.proof 
                         (zen.and 
                            (zen.triangle 
                               (focal.is_true 
                                  (_p_M1_equal (abst_first b) (abst_first c)))) 
                            (zen.triangle 
                               (focal.is_true 
                                  (_p_M2_equal (abst_second b) 
                                     (abst_second c)))))) =>
                      zen.Rand 
                        (zen.triangle 
                           (focal.is_true 
                              (_p_M1_equal (abst_first b) (abst_first c)))) 
                        (zen.triangle 
                           (focal.is_true 
                              (_p_M2_equal (abst_second b) (abst_second c)))) 
                        (v_Vic:
                         (zen.proof 
                            (zen.triangle 
                               (focal.is_true 
                                  (_p_M1_equal (abst_first b) (abst_first c))))) =>
                         v_Vjc:
                         (zen.proof 
                            (zen.triangle 
                               (focal.is_true 
                                  (_p_M2_equal (abst_second b) 
                                     (abst_second c))))) =>
                         zen.Raxiom 
                           (zen.triangle 
                              (focal.is_true 
                                 (_p_M2_equal (abst_second b) (abst_second c)))) 
                           v_Vjc v_Vac) v_Vhc) v_Vec) v_Vdc) abst_equal_spec))) 
        (zen.nnpp 
           (zen.triangle 
              (focal.is_true (_p_M1_equal (abst_first b) (abst_first c)))) 
           (v_Vac:
            (zen.proof 
               (zen.not 
                  (zen.triangle 
                     (focal.is_true 
                        (_p_M1_equal (abst_first b) (abst_first c)))))) =>
            zen.Rall abst_T 
              (v_Vbc:(zen.term abst_T) =>
               zen.forall abst_T 
                 (v_Vcc:(zen.term abst_T) =>
                  zen.eqv 
                    (zen.triangle (focal.is_true (abst_equal v_Vbc v_Vcc))) 
                    (zen.and 
                       (zen.triangle 
                          (focal.is_true 
                             (_p_M1_equal (abst_first v_Vbc) 
                                (abst_first v_Vcc)))) 
                       (zen.triangle 
                          (focal.is_true 
                             (_p_M2_equal (abst_second v_Vbc) 
                                (abst_second v_Vcc))))))) b 
              (v_Vdc:
               (zen.proof 
                  (zen.forall abst_T 
                     (v_Vcc:(zen.term abst_T) =>
                      zen.eqv 
                        (zen.triangle (focal.is_true (abst_equal b v_Vcc))) 
                        (zen.and 
                           (zen.triangle 
                              (focal.is_true 
                                 (_p_M1_equal (abst_first b) 
                                    (abst_first v_Vcc)))) 
                           (zen.triangle 
                              (focal.is_true 
                                 (_p_M2_equal (abst_second b) 
                                    (abst_second v_Vcc)))))))) =>
               zen.Rall abst_T 
                 (v_Vcc:(zen.term abst_T) =>
                  zen.eqv 
                    (zen.triangle (focal.is_true (abst_equal b v_Vcc))) 
                    (zen.and 
                       (zen.triangle 
                          (focal.is_true 
                             (_p_M1_equal (abst_first b) (abst_first v_Vcc)))) 
                       (zen.triangle 
                          (focal.is_true 
                             (_p_M2_equal (abst_second b) (abst_second v_Vcc)))))) 
                 c 
                 (v_Vec:
                  (zen.proof 
                     (zen.eqv 
                        (zen.triangle (focal.is_true (abst_equal b c))) 
                        (zen.and 
                           (zen.triangle 
                              (focal.is_true 
                                 (_p_M1_equal (abst_first b) (abst_first c)))) 
                           (zen.triangle 
                              (focal.is_true 
                                 (_p_M2_equal (abst_second b) (abst_second c))))))) =>
                  zen.Requiv (zen.triangle (focal.is_true (abst_equal b c))) 
                    (zen.and 
                       (zen.triangle 
                          (focal.is_true 
                             (_p_M1_equal (abst_first b) (abst_first c)))) 
                       (zen.triangle 
                          (focal.is_true 
                             (_p_M2_equal (abst_second b) (abst_second c))))) 
                    (v_Vfc:
                     (zen.proof 
                        (zen.not 
                           (zen.triangle (focal.is_true (abst_equal b c))))) =>
                     v_Vgc:
                     (zen.proof 
                        (zen.not 
                           (zen.and 
                              (zen.triangle 
                                 (focal.is_true 
                                    (_p_M1_equal (abst_first b) 
                                       (abst_first c)))) 
                              (zen.triangle 
                                 (focal.is_true 
                                    (_p_M2_equal (abst_second b) 
                                       (abst_second c))))))) =>
                     zen.Raxiom 
                       (zen.triangle (focal.is_true (abst_equal b c))) H 
                       v_Vfc) 
                    (H0:
                     (zen.proof 
                        (zen.triangle (focal.is_true (abst_equal b c)))) =>
                     v_Vhc:
                     (zen.proof 
                        (zen.and 
                           (zen.triangle 
                              (focal.is_true 
                                 (_p_M1_equal (abst_first b) (abst_first c)))) 
                           (zen.triangle 
                              (focal.is_true 
                                 (_p_M2_equal (abst_second b) (abst_second c)))))) =>
                     zen.Rand 
                       (zen.triangle 
                          (focal.is_true 
                             (_p_M1_equal (abst_first b) (abst_first c)))) 
                       (zen.triangle 
                          (focal.is_true 
                             (_p_M2_equal (abst_second b) (abst_second c)))) 
                       (v_Vic:
                        (zen.proof 
                           (zen.triangle 
                              (focal.is_true 
                                 (_p_M1_equal (abst_first b) (abst_first c))))) =>
                        v_Vjc:
                        (zen.proof 
                           (zen.triangle 
                              (focal.is_true 
                                 (_p_M2_equal (abst_second b) (abst_second c))))) =>
                        zen.Raxiom 
                          (zen.triangle 
                             (focal.is_true 
                                (_p_M1_equal (abst_first b) (abst_first c)))) 
                          v_Vic v_Vac) v_Vhc) v_Vec) v_Vdc) abst_equal_spec)))) 
    (a1:(cc.eT _p_M1_T) =>
     b1:(cc.eT _p_M1_T) =>
     c1:(cc.eT _p_M1_T) =>
     a2:(cc.eT _p_M2_T) =>
     b2:(cc.eT _p_M2_T) =>
     c2:(cc.eT _p_M2_T) =>
     H1:(dk_logic.eP (dk_logic.ebP (_p_M1_equal b1 c1))) =>
     H2:(dk_logic.eP (dk_logic.ebP (_p_M2_equal b2 c2))) =>
     zen.nnpp 
       (zen.triangle 
          (focal.is_true 
             (abst_equal (abst_pair (_p_M1_plus a1 b1) (_p_M2_plus a2 b2)) 
                (abst_pair (_p_M1_plus a1 c1) (_p_M2_plus a2 c2))))) 
       (v_Vzb:
        (zen.proof 
           (zen.not 
              (zen.triangle 
                 (focal.is_true 
                    (abst_equal 
                       (abst_pair (_p_M1_plus a1 b1) (_p_M2_plus a2 b2)) 
                       (abst_pair (_p_M1_plus a1 c1) (_p_M2_plus a2 c2))))))) =>
        zen.Rall _p_M1_T 
          (v_Vac:(zen.term _p_M1_T) =>
           zen.forall _p_M1_T 
             (v_Vbc:(zen.term _p_M1_T) =>
              zen.forall _p_M2_T 
                (v_Vcc:(zen.term _p_M2_T) =>
                 zen.forall _p_M2_T 
                   (v_Vdc:(zen.term _p_M2_T) =>
                    zen.imp 
                      (zen.triangle (focal.is_true (_p_M1_equal v_Vac v_Vbc))) 
                      (zen.imp 
                         (zen.triangle 
                            (focal.is_true (_p_M2_equal v_Vcc v_Vdc))) 
                         (zen.triangle 
                            (focal.is_true 
                               (abst_equal (abst_pair v_Vac v_Vcc) 
                                  (abst_pair v_Vbc v_Vdc))))))))) 
          (_p_M1_plus a1 b1) 
          (v_Vec:
           (zen.proof 
              (zen.forall _p_M1_T 
                 (v_Vbc:(zen.term _p_M1_T) =>
                  zen.forall _p_M2_T 
                    (v_Vcc:(zen.term _p_M2_T) =>
                     zen.forall _p_M2_T 
                       (v_Vdc:(zen.term _p_M2_T) =>
                        zen.imp 
                          (zen.triangle 
                             (focal.is_true 
                                (_p_M1_equal (_p_M1_plus a1 b1) v_Vbc))) 
                          (zen.imp 
                             (zen.triangle 
                                (focal.is_true (_p_M2_equal v_Vcc v_Vdc))) 
                             (zen.triangle 
                                (focal.is_true 
                                   (abst_equal 
                                      (abst_pair (_p_M1_plus a1 b1) v_Vcc) 
                                      (abst_pair v_Vbc v_Vdc)))))))))) =>
           zen.Rall _p_M1_T 
             (v_Vbc:(zen.term _p_M1_T) =>
              zen.forall _p_M2_T 
                (v_Vcc:(zen.term _p_M2_T) =>
                 zen.forall _p_M2_T 
                   (v_Vdc:(zen.term _p_M2_T) =>
                    zen.imp 
                      (zen.triangle 
                         (focal.is_true 
                            (_p_M1_equal (_p_M1_plus a1 b1) v_Vbc))) 
                      (zen.imp 
                         (zen.triangle 
                            (focal.is_true (_p_M2_equal v_Vcc v_Vdc))) 
                         (zen.triangle 
                            (focal.is_true 
                               (abst_equal 
                                  (abst_pair (_p_M1_plus a1 b1) v_Vcc) 
                                  (abst_pair v_Vbc v_Vdc)))))))) 
             (_p_M1_plus a1 c1) 
             (v_Vfc:
              (zen.proof 
                 (zen.forall _p_M2_T 
                    (v_Vcc:(zen.term _p_M2_T) =>
                     zen.forall _p_M2_T 
                       (v_Vdc:(zen.term _p_M2_T) =>
                        zen.imp 
                          (zen.triangle 
                             (focal.is_true 
                                (_p_M1_equal (_p_M1_plus a1 b1) 
                                   (_p_M1_plus a1 c1)))) 
                          (zen.imp 
                             (zen.triangle 
                                (focal.is_true (_p_M2_equal v_Vcc v_Vdc))) 
                             (zen.triangle 
                                (focal.is_true 
                                   (abst_equal 
                                      (abst_pair (_p_M1_plus a1 b1) v_Vcc) 
                                      (abst_pair (_p_M1_plus a1 c1) v_Vdc))))))))) =>
              zen.Rall _p_M2_T 
                (v_Vcc:(zen.term _p_M2_T) =>
                 zen.forall _p_M2_T 
                   (v_Vdc:(zen.term _p_M2_T) =>
                    zen.imp 
                      (zen.triangle 
                         (focal.is_true 
                            (_p_M1_equal (_p_M1_plus a1 b1) 
                               (_p_M1_plus a1 c1)))) 
                      (zen.imp 
                         (zen.triangle 
                            (focal.is_true (_p_M2_equal v_Vcc v_Vdc))) 
                         (zen.triangle 
                            (focal.is_true 
                               (abst_equal 
                                  (abst_pair (_p_M1_plus a1 b1) v_Vcc) 
                                  (abst_pair (_p_M1_plus a1 c1) v_Vdc))))))) 
                (_p_M2_plus a2 b2) 
                (v_Vgc:
                 (zen.proof 
                    (zen.forall _p_M2_T 
                       (v_Vdc:(zen.term _p_M2_T) =>
                        zen.imp 
                          (zen.triangle 
                             (focal.is_true 
                                (_p_M1_equal (_p_M1_plus a1 b1) 
                                   (_p_M1_plus a1 c1)))) 
                          (zen.imp 
                             (zen.triangle 
                                (focal.is_true 
                                   (_p_M2_equal (_p_M2_plus a2 b2) v_Vdc))) 
                             (zen.triangle 
                                (focal.is_true 
                                   (abst_equal 
                                      (abst_pair (_p_M1_plus a1 b1) 
                                         (_p_M2_plus a2 b2)) 
                                      (abst_pair (_p_M1_plus a1 c1) v_Vdc)))))))) =>
                 zen.Rall _p_M2_T 
                   (v_Vdc:(zen.term _p_M2_T) =>
                    zen.imp 
                      (zen.triangle 
                         (focal.is_true 
                            (_p_M1_equal (_p_M1_plus a1 b1) 
                               (_p_M1_plus a1 c1)))) 
                      (zen.imp 
                         (zen.triangle 
                            (focal.is_true 
                               (_p_M2_equal (_p_M2_plus a2 b2) v_Vdc))) 
                         (zen.triangle 
                            (focal.is_true 
                               (abst_equal 
                                  (abst_pair (_p_M1_plus a1 b1) 
                                     (_p_M2_plus a2 b2)) 
                                  (abst_pair (_p_M1_plus a1 c1) v_Vdc)))))) 
                   (_p_M2_plus a2 c2) 
                   (v_Vhc:
                    (zen.proof 
                       (zen.imp 
                          (zen.triangle 
                             (focal.is_true 
                                (_p_M1_equal (_p_M1_plus a1 b1) 
                                   (_p_M1_plus a1 c1)))) 
                          (zen.imp 
                             (zen.triangle 
                                (focal.is_true 
                                   (_p_M2_equal (_p_M2_plus a2 b2) 
                                      (_p_M2_plus a2 c2)))) 
                             (zen.triangle 
                                (focal.is_true 
                                   (abst_equal 
                                      (abst_pair (_p_M1_plus a1 b1) 
                                         (_p_M2_plus a2 b2)) 
                                      (abst_pair (_p_M1_plus a1 c1) 
                                         (_p_M2_plus a2 c2)))))))) =>
                    zen.Rimply 
                      (zen.triangle 
                         (focal.is_true 
                            (_p_M1_equal (_p_M1_plus a1 b1) 
                               (_p_M1_plus a1 c1)))) 
                      (zen.imp 
                         (zen.triangle 
                            (focal.is_true 
                               (_p_M2_equal (_p_M2_plus a2 b2) 
                                  (_p_M2_plus a2 c2)))) 
                         (zen.triangle 
                            (focal.is_true 
                               (abst_equal 
                                  (abst_pair (_p_M1_plus a1 b1) 
                                     (_p_M2_plus a2 b2)) 
                                  (abst_pair (_p_M1_plus a1 c1) 
                                     (_p_M2_plus a2 c2)))))) 
                      (v_Vic:
                       (zen.proof 
                          (zen.not 
                             (zen.triangle 
                                (focal.is_true 
                                   (_p_M1_equal (_p_M1_plus a1 b1) 
                                      (_p_M1_plus a1 c1)))))) =>
                       zen.Rall _p_M1_T 
                         (v_Vjc:(zen.term _p_M1_T) =>
                          zen.forall _p_M1_T 
                            (v_Vkc:(zen.term _p_M1_T) =>
                             zen.forall _p_M1_T 
                               (v_Vlc:(zen.term _p_M1_T) =>
                                zen.imp 
                                  (zen.triangle 
                                     (focal.is_true (_p_M1_equal v_Vjc v_Vkc))) 
                                  (zen.triangle 
                                     (focal.is_true 
                                        (_p_M1_equal 
                                           (_p_M1_plus v_Vlc v_Vjc) 
                                           (_p_M1_plus v_Vlc v_Vkc))))))) b1 
                         (v_Vmc:
                          (zen.proof 
                             (zen.forall _p_M1_T 
                                (v_Vkc:(zen.term _p_M1_T) =>
                                 zen.forall _p_M1_T 
                                   (v_Vlc:(zen.term _p_M1_T) =>
                                    zen.imp 
                                      (zen.triangle 
                                         (focal.is_true 
                                            (_p_M1_equal b1 v_Vkc))) 
                                      (zen.triangle 
                                         (focal.is_true 
                                            (_p_M1_equal 
                                               (_p_M1_plus v_Vlc b1) 
                                               (_p_M1_plus v_Vlc v_Vkc)))))))) =>
                          zen.Rall _p_M1_T 
                            (v_Vkc:(zen.term _p_M1_T) =>
                             zen.forall _p_M1_T 
                               (v_Vlc:(zen.term _p_M1_T) =>
                                zen.imp 
                                  (zen.triangle 
                                     (focal.is_true (_p_M1_equal b1 v_Vkc))) 
                                  (zen.triangle 
                                     (focal.is_true 
                                        (_p_M1_equal (_p_M1_plus v_Vlc b1) 
                                           (_p_M1_plus v_Vlc v_Vkc)))))) c1 
                            (v_Vnc:
                             (zen.proof 
                                (zen.forall _p_M1_T 
                                   (v_Vlc:(zen.term _p_M1_T) =>
                                    zen.imp 
                                      (zen.triangle 
                                         (focal.is_true (_p_M1_equal b1 c1))) 
                                      (zen.triangle 
                                         (focal.is_true 
                                            (_p_M1_equal 
                                               (_p_M1_plus v_Vlc b1) 
                                               (_p_M1_plus v_Vlc c1))))))) =>
                             zen.Rall _p_M1_T 
                               (v_Vlc:(zen.term _p_M1_T) =>
                                zen.imp 
                                  (zen.triangle 
                                     (focal.is_true (_p_M1_equal b1 c1))) 
                                  (zen.triangle 
                                     (focal.is_true 
                                        (_p_M1_equal (_p_M1_plus v_Vlc b1) 
                                           (_p_M1_plus v_Vlc c1))))) a1 
                               (v_Voc:
                                (zen.proof 
                                   (zen.imp 
                                      (zen.triangle 
                                         (focal.is_true (_p_M1_equal b1 c1))) 
                                      (zen.triangle 
                                         (focal.is_true 
                                            (_p_M1_equal (_p_M1_plus a1 b1) 
                                               (_p_M1_plus a1 c1)))))) =>
                                zen.Rimply 
                                  (zen.triangle 
                                     (focal.is_true (_p_M1_equal b1 c1))) 
                                  (zen.triangle 
                                     (focal.is_true 
                                        (_p_M1_equal (_p_M1_plus a1 b1) 
                                           (_p_M1_plus a1 c1)))) 
                                  (v_Vpc:
                                   (zen.proof 
                                      (zen.not 
                                         (zen.triangle 
                                            (focal.is_true 
                                               (_p_M1_equal b1 c1))))) =>
                                   zen.Raxiom 
                                     (zen.triangle 
                                        (focal.is_true (_p_M1_equal b1 c1))) 
                                     H1 v_Vpc) 
                                  (v_Vqc:
                                   (zen.proof 
                                      (zen.triangle 
                                         (focal.is_true 
                                            (_p_M1_equal (_p_M1_plus a1 b1) 
                                               (_p_M1_plus a1 c1))))) =>
                                   zen.Raxiom 
                                     (zen.triangle 
                                        (focal.is_true 
                                           (_p_M1_equal (_p_M1_plus a1 b1) 
                                              (_p_M1_plus a1 c1)))) v_Vqc 
                                     v_Vic) v_Voc) v_Vnc) v_Vmc) 
                         _p_M1_plus_right_substitution_rule) 
                      (v_Vrc:
                       (zen.proof 
                          (zen.imp 
                             (zen.triangle 
                                (focal.is_true 
                                   (_p_M2_equal (_p_M2_plus a2 b2) 
                                      (_p_M2_plus a2 c2)))) 
                             (zen.triangle 
                                (focal.is_true 
                                   (abst_equal 
                                      (abst_pair (_p_M1_plus a1 b1) 
                                         (_p_M2_plus a2 b2)) 
                                      (abst_pair (_p_M1_plus a1 c1) 
                                         (_p_M2_plus a2 c2))))))) =>
                       zen.Rimply 
                         (zen.triangle 
                            (focal.is_true 
                               (_p_M2_equal (_p_M2_plus a2 b2) 
                                  (_p_M2_plus a2 c2)))) 
                         (zen.triangle 
                            (focal.is_true 
                               (abst_equal 
                                  (abst_pair (_p_M1_plus a1 b1) 
                                     (_p_M2_plus a2 b2)) 
                                  (abst_pair (_p_M1_plus a1 c1) 
                                     (_p_M2_plus a2 c2))))) 
                         (v_Vsc:
                          (zen.proof 
                             (zen.not 
                                (zen.triangle 
                                   (focal.is_true 
                                      (_p_M2_equal (_p_M2_plus a2 b2) 
                                         (_p_M2_plus a2 c2)))))) =>
                          zen.Rall _p_M2_T 
                            (v_Vtc:(zen.term _p_M2_T) =>
                             zen.forall _p_M2_T 
                               (v_Vuc:(zen.term _p_M2_T) =>
                                zen.forall _p_M2_T 
                                  (v_Vvc:(zen.term _p_M2_T) =>
                                   zen.imp 
                                     (zen.triangle 
                                        (focal.is_true 
                                           (_p_M2_equal v_Vtc v_Vuc))) 
                                     (zen.triangle 
                                        (focal.is_true 
                                           (_p_M2_equal 
                                              (_p_M2_plus v_Vvc v_Vtc) 
                                              (_p_M2_plus v_Vvc v_Vuc))))))) 
                            b2 
                            (v_Vwc:
                             (zen.proof 
                                (zen.forall _p_M2_T 
                                   (v_Vuc:(zen.term _p_M2_T) =>
                                    zen.forall _p_M2_T 
                                      (v_Vvc:(zen.term _p_M2_T) =>
                                       zen.imp 
                                         (zen.triangle 
                                            (focal.is_true 
                                               (_p_M2_equal b2 v_Vuc))) 
                                         (zen.triangle 
                                            (focal.is_true 
                                               (_p_M2_equal 
                                                  (_p_M2_plus v_Vvc b2) 
                                                  (_p_M2_plus v_Vvc v_Vuc)))))))) =>
                             zen.Rall _p_M2_T 
                               (v_Vuc:(zen.term _p_M2_T) =>
                                zen.forall _p_M2_T 
                                  (v_Vvc:(zen.term _p_M2_T) =>
                                   zen.imp 
                                     (zen.triangle 
                                        (focal.is_true (_p_M2_equal b2 v_Vuc))) 
                                     (zen.triangle 
                                        (focal.is_true 
                                           (_p_M2_equal 
                                              (_p_M2_plus v_Vvc b2) 
                                              (_p_M2_plus v_Vvc v_Vuc)))))) 
                               c2 
                               (v_Vxc:
                                (zen.proof 
                                   (zen.forall _p_M2_T 
                                      (v_Vvc:(zen.term _p_M2_T) =>
                                       zen.imp 
                                         (zen.triangle 
                                            (focal.is_true 
                                               (_p_M2_equal b2 c2))) 
                                         (zen.triangle 
                                            (focal.is_true 
                                               (_p_M2_equal 
                                                  (_p_M2_plus v_Vvc b2) 
                                                  (_p_M2_plus v_Vvc c2))))))) =>
                                zen.Rall _p_M2_T 
                                  (v_Vvc:(zen.term _p_M2_T) =>
                                   zen.imp 
                                     (zen.triangle 
                                        (focal.is_true (_p_M2_equal b2 c2))) 
                                     (zen.triangle 
                                        (focal.is_true 
                                           (_p_M2_equal 
                                              (_p_M2_plus v_Vvc b2) 
                                              (_p_M2_plus v_Vvc c2))))) a2 
                                  (v_Vyc:
                                   (zen.proof 
                                      (zen.imp 
                                         (zen.triangle 
                                            (focal.is_true 
                                               (_p_M2_equal b2 c2))) 
                                         (zen.triangle 
                                            (focal.is_true 
                                               (_p_M2_equal 
                                                  (_p_M2_plus a2 b2) 
                                                  (_p_M2_plus a2 c2)))))) =>
                                   zen.Rimply 
                                     (zen.triangle 
                                        (focal.is_true (_p_M2_equal b2 c2))) 
                                     (zen.triangle 
                                        (focal.is_true 
                                           (_p_M2_equal (_p_M2_plus a2 b2) 
                                              (_p_M2_plus a2 c2)))) 
                                     (v_Vzc:
                                      (zen.proof 
                                         (zen.not 
                                            (zen.triangle 
                                               (focal.is_true 
                                                  (_p_M2_equal b2 c2))))) =>
                                      zen.Raxiom 
                                        (zen.triangle 
                                           (focal.is_true (_p_M2_equal b2 c2))) 
                                        H2 v_Vzc) 
                                     (v_Vad:
                                      (zen.proof 
                                         (zen.triangle 
                                            (focal.is_true 
                                               (_p_M2_equal 
                                                  (_p_M2_plus a2 b2) 
                                                  (_p_M2_plus a2 c2))))) =>
                                      zen.Raxiom 
                                        (zen.triangle 
                                           (focal.is_true 
                                              (_p_M2_equal 
                                                 (_p_M2_plus a2 b2) 
                                                 (_p_M2_plus a2 c2)))) v_Vad 
                                        v_Vsc) v_Vyc) v_Vxc) v_Vwc) 
                            _p_M2_plus_right_substitution_rule) 
                         (v_Vbd:
                          (zen.proof 
                             (zen.triangle 
                                (focal.is_true 
                                   (abst_equal 
                                      (abst_pair (_p_M1_plus a1 b1) 
                                         (_p_M2_plus a2 b2)) 
                                      (abst_pair (_p_M1_plus a1 c1) 
                                         (_p_M2_plus a2 c2)))))) =>
                          zen.Raxiom 
                            (zen.triangle 
                               (focal.is_true 
                                  (abst_equal 
                                     (abst_pair (_p_M1_plus a1 b1) 
                                        (_p_M2_plus a2 b2)) 
                                     (abst_pair (_p_M1_plus a1 c1) 
                                        (_p_M2_plus a2 c2))))) v_Vbd v_Vzb) 
                         v_Vrc) v_Vhc) v_Vgc) v_Vfc) v_Vec) 
          abst_pair_substitution_rule)).

def Product_additive_monoid__collection_create
  :=
  _p_M1_T:cc.uT =>
  _p_M2_T:cc.uT =>
  _p_M1_equal:((cc.eT _p_M1_T) -> (cc.eT _p_M1_T) -> cc.eT basics.bool__t) =>
  _p_M1_plus:((cc.eT _p_M1_T) -> (cc.eT _p_M1_T) -> cc.eT _p_M1_T) =>
  _p_M1_zero:(cc.eT _p_M1_T) =>
  _p_M1_equal_reflexive:
  (dk_logic.eP 
     (dk_logic.forall _p_M1_T 
        (x:(cc.eT _p_M1_T) => dk_logic.ebP (_p_M1_equal x x)))) =>
  _p_M1_equal_symmetric:
  (dk_logic.eP 
     (dk_logic.forall _p_M1_T 
        (x:(cc.eT _p_M1_T) =>
         dk_logic.forall _p_M1_T 
           (y:(cc.eT _p_M1_T) =>
            dk_logic.imp (dk_logic.ebP (_p_M1_equal x y)) 
              (dk_logic.ebP (_p_M1_equal y x)))))) =>
  _p_M1_equal_transitive:
  (dk_logic.eP 
     (dk_logic.forall _p_M1_T 
        (x:(cc.eT _p_M1_T) =>
         dk_logic.forall _p_M1_T 
           (y:(cc.eT _p_M1_T) =>
            dk_logic.forall _p_M1_T 
              (z:(cc.eT _p_M1_T) =>
               dk_logic.imp (dk_logic.ebP (_p_M1_equal x y)) 
                 (dk_logic.imp (dk_logic.ebP (_p_M1_equal y z)) 
                    (dk_logic.ebP (_p_M1_equal x z)))))))) =>
  _p_M1_plus_commutes:
  (dk_logic.eP 
     (dk_logic.forall _p_M1_T 
        (x:(cc.eT _p_M1_T) =>
         dk_logic.forall _p_M1_T 
           (y:(cc.eT _p_M1_T) =>
            dk_logic.ebP (_p_M1_equal (_p_M1_plus x y) (_p_M1_plus y x)))))) =>
  _p_M1_plus_right_substitution_rule:
  (dk_logic.eP 
     (dk_logic.forall _p_M1_T 
        (x:(cc.eT _p_M1_T) =>
         dk_logic.forall _p_M1_T 
           (y:(cc.eT _p_M1_T) =>
            dk_logic.forall _p_M1_T 
              (z:(cc.eT _p_M1_T) =>
               dk_logic.imp (dk_logic.ebP (_p_M1_equal x y)) 
                 (dk_logic.ebP 
                    (_p_M1_equal (_p_M1_plus z x) (_p_M1_plus z y)))))))) =>
  _p_M1_element:(cc.eT _p_M1_T) =>
  _p_M2_equal:((cc.eT _p_M2_T) -> (cc.eT _p_M2_T) -> cc.eT basics.bool__t) =>
  _p_M2_plus:((cc.eT _p_M2_T) -> (cc.eT _p_M2_T) -> cc.eT _p_M2_T) =>
  _p_M2_zero:(cc.eT _p_M2_T) =>
  _p_M2_equal_reflexive:
  (dk_logic.eP 
     (dk_logic.forall _p_M2_T 
        (x:(cc.eT _p_M2_T) => dk_logic.ebP (_p_M2_equal x x)))) =>
  _p_M2_equal_symmetric:
  (dk_logic.eP 
     (dk_logic.forall _p_M2_T 
        (x:(cc.eT _p_M2_T) =>
         dk_logic.forall _p_M2_T 
           (y:(cc.eT _p_M2_T) =>
            dk_logic.imp (dk_logic.ebP (_p_M2_equal x y)) 
              (dk_logic.ebP (_p_M2_equal y x)))))) =>
  _p_M2_equal_transitive:
  (dk_logic.eP 
     (dk_logic.forall _p_M2_T 
        (x:(cc.eT _p_M2_T) =>
         dk_logic.forall _p_M2_T 
           (y:(cc.eT _p_M2_T) =>
            dk_logic.forall _p_M2_T 
              (z:(cc.eT _p_M2_T) =>
               dk_logic.imp (dk_logic.ebP (_p_M2_equal x y)) 
                 (dk_logic.imp (dk_logic.ebP (_p_M2_equal y z)) 
                    (dk_logic.ebP (_p_M2_equal x z)))))))) =>
  _p_M2_plus_commutes:
  (dk_logic.eP 
     (dk_logic.forall _p_M2_T 
        (x:(cc.eT _p_M2_T) =>
         dk_logic.forall _p_M2_T 
           (y:(cc.eT _p_M2_T) =>
            dk_logic.ebP (_p_M2_equal (_p_M2_plus x y) (_p_M2_plus y x)))))) =>
  _p_M2_plus_right_substitution_rule:
  (dk_logic.eP 
     (dk_logic.forall _p_M2_T 
        (x:(cc.eT _p_M2_T) =>
         dk_logic.forall _p_M2_T 
           (y:(cc.eT _p_M2_T) =>
            dk_logic.forall _p_M2_T 
              (z:(cc.eT _p_M2_T) =>
               dk_logic.imp (dk_logic.ebP (_p_M2_equal x y)) 
                 (dk_logic.ebP 
                    (_p_M2_equal (_p_M2_plus z x) (_p_M2_plus z y)))))))) =>
  _p_M2_element:(cc.eT _p_M2_T) =>
  Product_additive_monoid__mk_record _p_M1_T _p_M2_T _p_M1_equal _p_M2_equal 
    (dk_tuple.prod _p_M1_T _p_M2_T) 
    (products.Cartesian_product__first _p_M1_T _p_M2_T) 
    (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
    (basics.Basic_object__parse (dk_tuple.prod _p_M1_T _p_M2_T)) 
    (basics.Basic_object__print (dk_tuple.prod _p_M1_T _p_M2_T)) 
    (products.Cartesian_product__second _p_M1_T _p_M2_T) 
    (Product_additive_monoid__zero _p_M1_T _p_M2_T _p_M1_zero _p_M2_zero) 
    (products.Product_set__element _p_M1_T _p_M2_T _p_M1_element 
       _p_M2_element (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Cartesian_product__pair _p_M1_T _p_M2_T)) 
    (products.Cartesian_product__pair_preserves_first _p_M1_T _p_M2_T 
       _p_M1_equal _p_M1_equal_reflexive) 
    (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal _p_M2_equal 
       (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Cartesian_product__first _p_M1_T _p_M2_T) 
       (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
    (products.Cartesian_product__pair_preserves_second _p_M1_T _p_M2_T 
       _p_M2_equal _p_M2_equal_reflexive) 
    (Product_additive_monoid__plus _p_M1_T _p_M2_T _p_M1_plus _p_M2_plus 
       (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Cartesian_product__first _p_M1_T _p_M2_T) 
       (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
       (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
    (products.Product_set__first_accessibility _p_M1_T _p_M2_T _p_M1_equal 
       _p_M2_element (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Cartesian_product__first _p_M1_T _p_M2_T) 
       (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
       (products.Cartesian_product__pair_preserves_first _p_M1_T _p_M2_T 
          _p_M1_equal _p_M1_equal_reflexive)) 
    (sets.Setoid__different (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal _p_M2_equal 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T))) 
    (products.Product_set__equal_reflexive _p_M1_T _p_M2_T _p_M1_equal 
       _p_M1_equal_reflexive _p_M2_equal _p_M2_equal_reflexive 
       (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Cartesian_product__first _p_M1_T _p_M2_T) 
       (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
    (products.Product_set__equal_spec _p_M1_T _p_M2_T _p_M1_equal 
       _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Cartesian_product__first _p_M1_T _p_M2_T) 
       (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
    (products.Product_set__equal_symmetric _p_M1_T _p_M2_T _p_M1_equal 
       _p_M1_equal_symmetric _p_M2_equal _p_M2_equal_symmetric 
       (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Cartesian_product__first _p_M1_T _p_M2_T) 
       (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
    (products.Product_set__equal_transitive _p_M1_T _p_M2_T _p_M1_equal 
       _p_M1_equal_transitive _p_M2_equal _p_M2_equal_transitive 
       (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Cartesian_product__first _p_M1_T _p_M2_T) 
       (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
    (products.Product_set__first_substitution_rule _p_M1_T _p_M2_T 
       _p_M1_equal _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Cartesian_product__first _p_M1_T _p_M2_T) 
       (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
    (constants.Setoid_with_zero__is_zero (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal _p_M2_equal 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (Product_additive_monoid__zero _p_M1_T _p_M2_T _p_M1_zero _p_M2_zero)) 
    (products.Product_set__second_substitution_rule _p_M1_T _p_M2_T 
       _p_M1_equal _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Cartesian_product__first _p_M1_T _p_M2_T) 
       (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
    (products.Product_set__pair_left_substitution_rule _p_M1_T _p_M2_T 
       _p_M1_equal _p_M1_equal_symmetric _p_M1_equal_transitive _p_M2_equal 
       _p_M2_equal_reflexive _p_M2_equal_symmetric _p_M2_equal_transitive 
       (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Cartesian_product__first _p_M1_T _p_M2_T) 
       (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
       (products.Cartesian_product__second _p_M1_T _p_M2_T) 
       (products.Cartesian_product__pair_preserves_first _p_M1_T _p_M2_T 
          _p_M1_equal _p_M1_equal_reflexive) 
       (products.Cartesian_product__pair_preserves_second _p_M1_T _p_M2_T 
          _p_M2_equal _p_M2_equal_reflexive)) 
    (products.Product_set__pair_right_substitution_rule _p_M1_T _p_M2_T 
       _p_M1_equal _p_M1_equal_reflexive _p_M1_equal_symmetric 
       _p_M1_equal_transitive _p_M2_equal _p_M2_equal_symmetric 
       _p_M2_equal_transitive (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Cartesian_product__first _p_M1_T _p_M2_T) 
       (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
       (products.Cartesian_product__second _p_M1_T _p_M2_T) 
       (products.Cartesian_product__pair_preserves_first _p_M1_T _p_M2_T 
          _p_M1_equal _p_M1_equal_reflexive) 
       (products.Cartesian_product__pair_preserves_second _p_M1_T _p_M2_T 
          _p_M2_equal _p_M2_equal_reflexive)) 
    (products.Product_set__second_accessibility _p_M1_T _p_M2_T 
       _p_M1_element _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
       (products.Cartesian_product__second _p_M1_T _p_M2_T) 
       (products.Cartesian_product__pair_preserves_second _p_M1_T _p_M2_T 
          _p_M2_equal _p_M2_equal_reflexive)) 
    (Product_additive_monoid__plus_is_associative _p_M1_T _p_M2_T 
       (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal _p_M2_equal 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (Product_additive_monoid__plus _p_M1_T _p_M2_T _p_M1_plus _p_M2_plus 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T))) 
    (Product_additive_monoid__zero_is_neutral _p_M1_T _p_M2_T 
       (dk_tuple.prod _p_M1_T _p_M2_T) 
       (Product_additive_monoid__zero _p_M1_T _p_M2_T _p_M1_zero _p_M2_zero) 
       (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal _p_M2_equal 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (Product_additive_monoid__plus _p_M1_T _p_M2_T _p_M1_plus _p_M2_plus 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T))) 
    (sets.Setoid__same_is_not_different (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal _p_M2_equal 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T))) 
    (constants.Setoid_with_zero__is_zero_spec 
       (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal _p_M2_equal 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (Product_additive_monoid__zero _p_M1_T _p_M2_T _p_M1_zero _p_M2_zero) 
       (products.Product_set__equal_reflexive _p_M1_T _p_M2_T _p_M1_equal 
          _p_M1_equal_reflexive _p_M2_equal _p_M2_equal_reflexive 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (products.Product_set__equal_symmetric _p_M1_T _p_M2_T _p_M1_equal 
          _p_M1_equal_symmetric _p_M2_equal _p_M2_equal_symmetric 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T))) 
    (products.Product_set__pair_substitution_rule _p_M1_T _p_M2_T 
       _p_M1_equal _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
       (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal _p_M2_equal 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (products.Product_set__equal_transitive _p_M1_T _p_M2_T _p_M1_equal 
          _p_M1_equal_transitive _p_M2_equal _p_M2_equal_transitive 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (products.Product_set__pair_left_substitution_rule _p_M1_T _p_M2_T 
          _p_M1_equal _p_M1_equal_symmetric _p_M1_equal_transitive 
          _p_M2_equal _p_M2_equal_reflexive _p_M2_equal_symmetric 
          _p_M2_equal_transitive (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T) 
          (products.Cartesian_product__pair_preserves_first _p_M1_T _p_M2_T 
             _p_M1_equal _p_M1_equal_reflexive) 
          (products.Cartesian_product__pair_preserves_second _p_M1_T _p_M2_T 
             _p_M2_equal _p_M2_equal_reflexive)) 
       (products.Product_set__pair_right_substitution_rule _p_M1_T _p_M2_T 
          _p_M1_equal _p_M1_equal_reflexive _p_M1_equal_symmetric 
          _p_M1_equal_transitive _p_M2_equal _p_M2_equal_symmetric 
          _p_M2_equal_transitive (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T) 
          (products.Cartesian_product__pair_preserves_first _p_M1_T _p_M2_T 
             _p_M1_equal _p_M1_equal_reflexive) 
          (products.Cartesian_product__pair_preserves_second _p_M1_T _p_M2_T 
             _p_M2_equal _p_M2_equal_reflexive))) 
    (additive_law.Additive_monoid__zero_is_unique 
       (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal _p_M2_equal 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (Product_additive_monoid__plus _p_M1_T _p_M2_T _p_M1_plus _p_M2_plus 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (Product_additive_monoid__zero _p_M1_T _p_M2_T _p_M1_zero _p_M2_zero) 
       (products.Product_set__equal_symmetric _p_M1_T _p_M2_T _p_M1_equal 
          _p_M1_equal_symmetric _p_M2_equal _p_M2_equal_symmetric 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (products.Product_set__equal_transitive _p_M1_T _p_M2_T _p_M1_equal 
          _p_M1_equal_transitive _p_M2_equal _p_M2_equal_transitive 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (Product_additive_monoid__zero_is_neutral _p_M1_T _p_M2_T 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (Product_additive_monoid__zero _p_M1_T _p_M2_T _p_M1_zero 
             _p_M2_zero) 
          (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal 
             _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
          (Product_additive_monoid__plus _p_M1_T _p_M2_T _p_M1_plus 
             _p_M2_plus (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T)))) 
    (sets.Setoid__different_is_complete (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal _p_M2_equal 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (sets.Setoid__different (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal 
             _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T))) 
       (products.Product_set__equal_reflexive _p_M1_T _p_M2_T _p_M1_equal 
          _p_M1_equal_reflexive _p_M2_equal _p_M2_equal_reflexive 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (products.Product_set__equal_symmetric _p_M1_T _p_M2_T _p_M1_equal 
          _p_M1_equal_symmetric _p_M2_equal _p_M2_equal_symmetric 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (products.Product_set__equal_transitive _p_M1_T _p_M2_T _p_M1_equal 
          _p_M1_equal_transitive _p_M2_equal _p_M2_equal_transitive 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (sets.Setoid__same_is_not_different (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal 
             _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T)))) 
    (sets.Setoid__different_is_irreflexive (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal _p_M2_equal 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (sets.Setoid__different (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal 
             _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T))) 
       (products.Product_set__equal_reflexive _p_M1_T _p_M2_T _p_M1_equal 
          _p_M1_equal_reflexive _p_M2_equal _p_M2_equal_reflexive 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (sets.Setoid__same_is_not_different (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal 
             _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T)))) 
    (sets.Setoid__different_is_symmetric (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal _p_M2_equal 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (sets.Setoid__different (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal 
             _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T))) 
       (products.Product_set__equal_symmetric _p_M1_T _p_M2_T _p_M1_equal 
          _p_M1_equal_symmetric _p_M2_equal _p_M2_equal_symmetric 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (sets.Setoid__same_is_not_different (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal 
             _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T)))) 
    (constants.Setoid_with_zero__zero_checks_to_zero 
       (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal _p_M2_equal 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (Product_additive_monoid__zero _p_M1_T _p_M2_T _p_M1_zero _p_M2_zero) 
       (products.Product_set__equal_reflexive _p_M1_T _p_M2_T _p_M1_equal 
          _p_M1_equal_reflexive _p_M2_equal _p_M2_equal_reflexive 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (constants.Setoid_with_zero__is_zero (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal 
             _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
          (Product_additive_monoid__zero _p_M1_T _p_M2_T _p_M1_zero 
             _p_M2_zero)) 
       (constants.Setoid_with_zero__is_zero_spec 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal 
             _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
          (Product_additive_monoid__zero _p_M1_T _p_M2_T _p_M1_zero 
             _p_M2_zero) 
          (products.Product_set__equal_reflexive _p_M1_T _p_M2_T _p_M1_equal 
             _p_M1_equal_reflexive _p_M2_equal _p_M2_equal_reflexive 
             (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
          (products.Product_set__equal_symmetric _p_M1_T _p_M2_T _p_M1_equal 
             _p_M1_equal_symmetric _p_M2_equal _p_M2_equal_symmetric 
             (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T)))) 
    (Product_additive_monoid__plus_commutes _p_M1_T _p_M2_T _p_M1_equal 
       _p_M1_plus _p_M1_plus_commutes _p_M2_equal _p_M2_plus 
       _p_M2_plus_commutes (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Cartesian_product__first _p_M1_T _p_M2_T) 
       (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
       (products.Cartesian_product__second _p_M1_T _p_M2_T) 
       (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal _p_M2_equal 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (products.Product_set__pair_substitution_rule _p_M1_T _p_M2_T 
          _p_M1_equal _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
          (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal 
             _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
          (products.Product_set__equal_transitive _p_M1_T _p_M2_T 
             _p_M1_equal _p_M1_equal_transitive _p_M2_equal 
             _p_M2_equal_transitive (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
          (products.Product_set__pair_left_substitution_rule _p_M1_T _p_M2_T 
             _p_M1_equal _p_M1_equal_symmetric _p_M1_equal_transitive 
             _p_M2_equal _p_M2_equal_reflexive _p_M2_equal_symmetric 
             _p_M2_equal_transitive (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T) 
             (products.Cartesian_product__pair_preserves_first _p_M1_T 
                _p_M2_T _p_M1_equal _p_M1_equal_reflexive) 
             (products.Cartesian_product__pair_preserves_second _p_M1_T 
                _p_M2_T _p_M2_equal _p_M2_equal_reflexive)) 
          (products.Product_set__pair_right_substitution_rule _p_M1_T 
             _p_M2_T _p_M1_equal _p_M1_equal_reflexive _p_M1_equal_symmetric 
             _p_M1_equal_transitive _p_M2_equal _p_M2_equal_symmetric 
             _p_M2_equal_transitive (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T) 
             (products.Cartesian_product__pair_preserves_first _p_M1_T 
                _p_M2_T _p_M1_equal _p_M1_equal_reflexive) 
             (products.Cartesian_product__pair_preserves_second _p_M1_T 
                _p_M2_T _p_M2_equal _p_M2_equal_reflexive)))) 
    (Product_additive_monoid__plus_right_substitution_rule _p_M1_T _p_M2_T 
       _p_M1_equal _p_M1_plus _p_M1_plus_right_substitution_rule _p_M2_equal 
       _p_M2_plus _p_M2_plus_right_substitution_rule 
       (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Cartesian_product__first _p_M1_T _p_M2_T) 
       (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
       (products.Cartesian_product__second _p_M1_T _p_M2_T) 
       (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal _p_M2_equal 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (products.Product_set__equal_spec _p_M1_T _p_M2_T _p_M1_equal 
          _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (products.Product_set__pair_substitution_rule _p_M1_T _p_M2_T 
          _p_M1_equal _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
          (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal 
             _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
          (products.Product_set__equal_transitive _p_M1_T _p_M2_T 
             _p_M1_equal _p_M1_equal_transitive _p_M2_equal 
             _p_M2_equal_transitive (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
          (products.Product_set__pair_left_substitution_rule _p_M1_T _p_M2_T 
             _p_M1_equal _p_M1_equal_symmetric _p_M1_equal_transitive 
             _p_M2_equal _p_M2_equal_reflexive _p_M2_equal_symmetric 
             _p_M2_equal_transitive (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T) 
             (products.Cartesian_product__pair_preserves_first _p_M1_T 
                _p_M2_T _p_M1_equal _p_M1_equal_reflexive) 
             (products.Cartesian_product__pair_preserves_second _p_M1_T 
                _p_M2_T _p_M2_equal _p_M2_equal_reflexive)) 
          (products.Product_set__pair_right_substitution_rule _p_M1_T 
             _p_M2_T _p_M1_equal _p_M1_equal_reflexive _p_M1_equal_symmetric 
             _p_M1_equal_transitive _p_M2_equal _p_M2_equal_symmetric 
             _p_M2_equal_transitive (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T) 
             (products.Cartesian_product__pair_preserves_first _p_M1_T 
                _p_M2_T _p_M1_equal _p_M1_equal_reflexive) 
             (products.Cartesian_product__pair_preserves_second _p_M1_T 
                _p_M2_T _p_M2_equal _p_M2_equal_reflexive)))) 
    (additive_law.Additive_semi_group__plus_left_substitution_rule 
       (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal _p_M2_equal 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (Product_additive_monoid__plus _p_M1_T _p_M2_T _p_M1_plus _p_M2_plus 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (products.Product_set__equal_transitive _p_M1_T _p_M2_T _p_M1_equal 
          _p_M1_equal_transitive _p_M2_equal _p_M2_equal_transitive 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (Product_additive_monoid__plus_commutes _p_M1_T _p_M2_T _p_M1_equal 
          _p_M1_plus _p_M1_plus_commutes _p_M2_equal _p_M2_plus 
          _p_M2_plus_commutes (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T) 
          (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal 
             _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
          (products.Product_set__pair_substitution_rule _p_M1_T _p_M2_T 
             _p_M1_equal _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
             (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal 
                _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
                (products.Cartesian_product__first _p_M1_T _p_M2_T) 
                (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
             (products.Product_set__equal_transitive _p_M1_T _p_M2_T 
                _p_M1_equal _p_M1_equal_transitive _p_M2_equal 
                _p_M2_equal_transitive (dk_tuple.prod _p_M1_T _p_M2_T) 
                (products.Cartesian_product__first _p_M1_T _p_M2_T) 
                (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
             (products.Product_set__pair_left_substitution_rule _p_M1_T 
                _p_M2_T _p_M1_equal _p_M1_equal_symmetric 
                _p_M1_equal_transitive _p_M2_equal _p_M2_equal_reflexive 
                _p_M2_equal_symmetric _p_M2_equal_transitive 
                (dk_tuple.prod _p_M1_T _p_M2_T) 
                (products.Cartesian_product__first _p_M1_T _p_M2_T) 
                (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
                (products.Cartesian_product__second _p_M1_T _p_M2_T) 
                (products.Cartesian_product__pair_preserves_first _p_M1_T 
                   _p_M2_T _p_M1_equal _p_M1_equal_reflexive) 
                (products.Cartesian_product__pair_preserves_second _p_M1_T 
                   _p_M2_T _p_M2_equal _p_M2_equal_reflexive)) 
             (products.Product_set__pair_right_substitution_rule _p_M1_T 
                _p_M2_T _p_M1_equal _p_M1_equal_reflexive 
                _p_M1_equal_symmetric _p_M1_equal_transitive _p_M2_equal 
                _p_M2_equal_symmetric _p_M2_equal_transitive 
                (dk_tuple.prod _p_M1_T _p_M2_T) 
                (products.Cartesian_product__first _p_M1_T _p_M2_T) 
                (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
                (products.Cartesian_product__second _p_M1_T _p_M2_T) 
                (products.Cartesian_product__pair_preserves_first _p_M1_T 
                   _p_M2_T _p_M1_equal _p_M1_equal_reflexive) 
                (products.Cartesian_product__pair_preserves_second _p_M1_T 
                   _p_M2_T _p_M2_equal _p_M2_equal_reflexive)))) 
       (Product_additive_monoid__plus_right_substitution_rule _p_M1_T 
          _p_M2_T _p_M1_equal _p_M1_plus _p_M1_plus_right_substitution_rule 
          _p_M2_equal _p_M2_plus _p_M2_plus_right_substitution_rule 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T) 
          (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal 
             _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
          (products.Product_set__equal_spec _p_M1_T _p_M2_T _p_M1_equal 
             _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
          (products.Product_set__pair_substitution_rule _p_M1_T _p_M2_T 
             _p_M1_equal _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
             (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal 
                _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
                (products.Cartesian_product__first _p_M1_T _p_M2_T) 
                (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
             (products.Product_set__equal_transitive _p_M1_T _p_M2_T 
                _p_M1_equal _p_M1_equal_transitive _p_M2_equal 
                _p_M2_equal_transitive (dk_tuple.prod _p_M1_T _p_M2_T) 
                (products.Cartesian_product__first _p_M1_T _p_M2_T) 
                (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
             (products.Product_set__pair_left_substitution_rule _p_M1_T 
                _p_M2_T _p_M1_equal _p_M1_equal_symmetric 
                _p_M1_equal_transitive _p_M2_equal _p_M2_equal_reflexive 
                _p_M2_equal_symmetric _p_M2_equal_transitive 
                (dk_tuple.prod _p_M1_T _p_M2_T) 
                (products.Cartesian_product__first _p_M1_T _p_M2_T) 
                (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
                (products.Cartesian_product__second _p_M1_T _p_M2_T) 
                (products.Cartesian_product__pair_preserves_first _p_M1_T 
                   _p_M2_T _p_M1_equal _p_M1_equal_reflexive) 
                (products.Cartesian_product__pair_preserves_second _p_M1_T 
                   _p_M2_T _p_M2_equal _p_M2_equal_reflexive)) 
             (products.Product_set__pair_right_substitution_rule _p_M1_T 
                _p_M2_T _p_M1_equal _p_M1_equal_reflexive 
                _p_M1_equal_symmetric _p_M1_equal_transitive _p_M2_equal 
                _p_M2_equal_symmetric _p_M2_equal_transitive 
                (dk_tuple.prod _p_M1_T _p_M2_T) 
                (products.Cartesian_product__first _p_M1_T _p_M2_T) 
                (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
                (products.Cartesian_product__second _p_M1_T _p_M2_T) 
                (products.Cartesian_product__pair_preserves_first _p_M1_T 
                   _p_M2_T _p_M1_equal _p_M1_equal_reflexive) 
                (products.Cartesian_product__pair_preserves_second _p_M1_T 
                   _p_M2_T _p_M2_equal _p_M2_equal_reflexive))))) 
    (additive_law.Additive_semi_group__plus_substitution_rule 
       (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal _p_M2_equal 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (Product_additive_monoid__plus _p_M1_T _p_M2_T _p_M1_plus _p_M2_plus 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (products.Product_set__equal_transitive _p_M1_T _p_M2_T _p_M1_equal 
          _p_M1_equal_transitive _p_M2_equal _p_M2_equal_transitive 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (Product_additive_monoid__plus_right_substitution_rule _p_M1_T 
          _p_M2_T _p_M1_equal _p_M1_plus _p_M1_plus_right_substitution_rule 
          _p_M2_equal _p_M2_plus _p_M2_plus_right_substitution_rule 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T) 
          (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal 
             _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
          (products.Product_set__equal_spec _p_M1_T _p_M2_T _p_M1_equal 
             _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
          (products.Product_set__pair_substitution_rule _p_M1_T _p_M2_T 
             _p_M1_equal _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
             (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal 
                _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
                (products.Cartesian_product__first _p_M1_T _p_M2_T) 
                (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
             (products.Product_set__equal_transitive _p_M1_T _p_M2_T 
                _p_M1_equal _p_M1_equal_transitive _p_M2_equal 
                _p_M2_equal_transitive (dk_tuple.prod _p_M1_T _p_M2_T) 
                (products.Cartesian_product__first _p_M1_T _p_M2_T) 
                (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
             (products.Product_set__pair_left_substitution_rule _p_M1_T 
                _p_M2_T _p_M1_equal _p_M1_equal_symmetric 
                _p_M1_equal_transitive _p_M2_equal _p_M2_equal_reflexive 
                _p_M2_equal_symmetric _p_M2_equal_transitive 
                (dk_tuple.prod _p_M1_T _p_M2_T) 
                (products.Cartesian_product__first _p_M1_T _p_M2_T) 
                (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
                (products.Cartesian_product__second _p_M1_T _p_M2_T) 
                (products.Cartesian_product__pair_preserves_first _p_M1_T 
                   _p_M2_T _p_M1_equal _p_M1_equal_reflexive) 
                (products.Cartesian_product__pair_preserves_second _p_M1_T 
                   _p_M2_T _p_M2_equal _p_M2_equal_reflexive)) 
             (products.Product_set__pair_right_substitution_rule _p_M1_T 
                _p_M2_T _p_M1_equal _p_M1_equal_reflexive 
                _p_M1_equal_symmetric _p_M1_equal_transitive _p_M2_equal 
                _p_M2_equal_symmetric _p_M2_equal_transitive 
                (dk_tuple.prod _p_M1_T _p_M2_T) 
                (products.Cartesian_product__first _p_M1_T _p_M2_T) 
                (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
                (products.Cartesian_product__second _p_M1_T _p_M2_T) 
                (products.Cartesian_product__pair_preserves_first _p_M1_T 
                   _p_M2_T _p_M1_equal _p_M1_equal_reflexive) 
                (products.Cartesian_product__pair_preserves_second _p_M1_T 
                   _p_M2_T _p_M2_equal _p_M2_equal_reflexive)))) 
       (additive_law.Additive_semi_group__plus_left_substitution_rule 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal 
             _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
          (Product_additive_monoid__plus _p_M1_T _p_M2_T _p_M1_plus 
             _p_M2_plus (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
          (products.Product_set__equal_transitive _p_M1_T _p_M2_T 
             _p_M1_equal _p_M1_equal_transitive _p_M2_equal 
             _p_M2_equal_transitive (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
          (Product_additive_monoid__plus_commutes _p_M1_T _p_M2_T 
             _p_M1_equal _p_M1_plus _p_M1_plus_commutes _p_M2_equal 
             _p_M2_plus _p_M2_plus_commutes (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T) 
             (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal 
                _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
                (products.Cartesian_product__first _p_M1_T _p_M2_T) 
                (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
             (products.Product_set__pair_substitution_rule _p_M1_T _p_M2_T 
                _p_M1_equal _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
                (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
                (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal 
                   _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
                   (products.Cartesian_product__first _p_M1_T _p_M2_T) 
                   (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
                (products.Product_set__equal_transitive _p_M1_T _p_M2_T 
                   _p_M1_equal _p_M1_equal_transitive _p_M2_equal 
                   _p_M2_equal_transitive (dk_tuple.prod _p_M1_T _p_M2_T) 
                   (products.Cartesian_product__first _p_M1_T _p_M2_T) 
                   (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
                (products.Product_set__pair_left_substitution_rule _p_M1_T 
                   _p_M2_T _p_M1_equal _p_M1_equal_symmetric 
                   _p_M1_equal_transitive _p_M2_equal _p_M2_equal_reflexive 
                   _p_M2_equal_symmetric _p_M2_equal_transitive 
                   (dk_tuple.prod _p_M1_T _p_M2_T) 
                   (products.Cartesian_product__first _p_M1_T _p_M2_T) 
                   (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
                   (products.Cartesian_product__second _p_M1_T _p_M2_T) 
                   (products.Cartesian_product__pair_preserves_first _p_M1_T 
                      _p_M2_T _p_M1_equal _p_M1_equal_reflexive) 
                   (products.Cartesian_product__pair_preserves_second 
                      _p_M1_T _p_M2_T _p_M2_equal _p_M2_equal_reflexive)) 
                (products.Product_set__pair_right_substitution_rule _p_M1_T 
                   _p_M2_T _p_M1_equal _p_M1_equal_reflexive 
                   _p_M1_equal_symmetric _p_M1_equal_transitive _p_M2_equal 
                   _p_M2_equal_symmetric _p_M2_equal_transitive 
                   (dk_tuple.prod _p_M1_T _p_M2_T) 
                   (products.Cartesian_product__first _p_M1_T _p_M2_T) 
                   (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
                   (products.Cartesian_product__second _p_M1_T _p_M2_T) 
                   (products.Cartesian_product__pair_preserves_first _p_M1_T 
                      _p_M2_T _p_M1_equal _p_M1_equal_reflexive) 
                   (products.Cartesian_product__pair_preserves_second 
                      _p_M1_T _p_M2_T _p_M2_equal _p_M2_equal_reflexive)))) 
          (Product_additive_monoid__plus_right_substitution_rule _p_M1_T 
             _p_M2_T _p_M1_equal _p_M1_plus 
             _p_M1_plus_right_substitution_rule _p_M2_equal _p_M2_plus 
             _p_M2_plus_right_substitution_rule 
             (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T) 
             (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal 
                _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
                (products.Cartesian_product__first _p_M1_T _p_M2_T) 
                (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
             (products.Product_set__equal_spec _p_M1_T _p_M2_T _p_M1_equal 
                _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
                (products.Cartesian_product__first _p_M1_T _p_M2_T) 
                (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
             (products.Product_set__pair_substitution_rule _p_M1_T _p_M2_T 
                _p_M1_equal _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
                (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
                (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal 
                   _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
                   (products.Cartesian_product__first _p_M1_T _p_M2_T) 
                   (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
                (products.Product_set__equal_transitive _p_M1_T _p_M2_T 
                   _p_M1_equal _p_M1_equal_transitive _p_M2_equal 
                   _p_M2_equal_transitive (dk_tuple.prod _p_M1_T _p_M2_T) 
                   (products.Cartesian_product__first _p_M1_T _p_M2_T) 
                   (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
                (products.Product_set__pair_left_substitution_rule _p_M1_T 
                   _p_M2_T _p_M1_equal _p_M1_equal_symmetric 
                   _p_M1_equal_transitive _p_M2_equal _p_M2_equal_reflexive 
                   _p_M2_equal_symmetric _p_M2_equal_transitive 
                   (dk_tuple.prod _p_M1_T _p_M2_T) 
                   (products.Cartesian_product__first _p_M1_T _p_M2_T) 
                   (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
                   (products.Cartesian_product__second _p_M1_T _p_M2_T) 
                   (products.Cartesian_product__pair_preserves_first _p_M1_T 
                      _p_M2_T _p_M1_equal _p_M1_equal_reflexive) 
                   (products.Cartesian_product__pair_preserves_second 
                      _p_M1_T _p_M2_T _p_M2_equal _p_M2_equal_reflexive)) 
                (products.Product_set__pair_right_substitution_rule _p_M1_T 
                   _p_M2_T _p_M1_equal _p_M1_equal_reflexive 
                   _p_M1_equal_symmetric _p_M1_equal_transitive _p_M2_equal 
                   _p_M2_equal_symmetric _p_M2_equal_transitive 
                   (dk_tuple.prod _p_M1_T _p_M2_T) 
                   (products.Cartesian_product__first _p_M1_T _p_M2_T) 
                   (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
                   (products.Cartesian_product__second _p_M1_T _p_M2_T) 
                   (products.Cartesian_product__pair_preserves_first _p_M1_T 
                      _p_M2_T _p_M1_equal _p_M1_equal_reflexive) 
                   (products.Cartesian_product__pair_preserves_second 
                      _p_M1_T _p_M2_T _p_M2_equal _p_M2_equal_reflexive)))))).

Product_regular_additive_monoid__me_as_species :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) -> Type.

Product_regular_additive_monoid__mk_record :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  Product_regular_additive_monoid__rf_T:cc.uT ->
  Product_regular_additive_monoid__rf_first:((cc.eT 
                                                Product_regular_additive_monoid__rf_T) ->
                                             cc.eT M1_T) ->
  Product_regular_additive_monoid__rf_pair:((cc.eT M1_T) ->
                                            (cc.eT M2_T) ->
                                            cc.eT 
                                              Product_regular_additive_monoid__rf_T) ->
  Product_regular_additive_monoid__rf_parse:((cc.eT basics.string__t) ->
                                             cc.eT 
                                               Product_regular_additive_monoid__rf_T) ->
  Product_regular_additive_monoid__rf_print:((cc.eT 
                                                Product_regular_additive_monoid__rf_T) ->
                                             cc.eT basics.string__t) ->
  Product_regular_additive_monoid__rf_second:((cc.eT 
                                                 Product_regular_additive_monoid__rf_T) ->
                                              cc.eT M2_T) ->
  Product_regular_additive_monoid__rf_zero:(cc.eT 
                                              Product_regular_additive_monoid__rf_T) ->
  Product_regular_additive_monoid__rf_element:(cc.eT 
                                                 Product_regular_additive_monoid__rf_T) ->
  Product_regular_additive_monoid__rf_pair_preserves_first:(dk_logic.eP 
                                                              (dk_logic.forall 
                                                                 M1_T 
                                                                 (x:
                                                                  (cc.eT M1_T) =>
                                                                  dk_logic.forall 
                                                                    M2_T 
                                                                    (
                                                                    y:
                                                                    (
                                                                    cc.eT 
                                                                    M2_T) =>
                                                                    dk_logic.ebP 
                                                                    (_p_M1_equal 
                                                                    (Product_regular_additive_monoid__rf_first 
                                                                    (Product_regular_additive_monoid__rf_pair 
                                                                    x y)) x))))) ->
  Product_regular_additive_monoid__rf_equal:((cc.eT 
                                                Product_regular_additive_monoid__rf_T) ->
                                             (cc.eT 
                                                Product_regular_additive_monoid__rf_T) ->
                                             cc.eT basics.bool__t) ->
  Product_regular_additive_monoid__rf_minus:((cc.eT 
                                                Product_regular_additive_monoid__rf_T) ->
                                             (cc.eT 
                                                Product_regular_additive_monoid__rf_T) ->
                                             cc.eT 
                                               Product_regular_additive_monoid__rf_T) ->
  Product_regular_additive_monoid__rf_pair_preserves_second:(dk_logic.eP 
                                                               (dk_logic.forall 
                                                                  M1_T 
                                                                  (x:
                                                                   (cc.eT 
                                                                    M1_T) =>
                                                                   dk_logic.forall 
                                                                    M2_T 
                                                                    (y:
                                                                    (cc.eT 
                                                                    M2_T) =>
                                                                    dk_logic.ebP 
                                                                    (_p_M2_equal 
                                                                    (Product_regular_additive_monoid__rf_second 
                                                                    (Product_regular_additive_monoid__rf_pair 
                                                                    x y)) y))))) ->
  Product_regular_additive_monoid__rf_plus:((cc.eT 
                                               Product_regular_additive_monoid__rf_T) ->
                                            (cc.eT 
                                               Product_regular_additive_monoid__rf_T) ->
                                            cc.eT 
                                              Product_regular_additive_monoid__rf_T) ->
  Product_regular_additive_monoid__rf_failed:((cc.eT basics.string__t) ->
                                              cc.eT 
                                                Product_regular_additive_monoid__rf_T) ->
  Product_regular_additive_monoid__rf_first_accessibility:(dk_logic.eP 
                                                             (dk_logic.forall 
                                                                M1_T 
                                                                (x:
                                                                 (cc.eT M1_T) =>
                                                                 dk_logic.exists 
                                                                   Product_regular_additive_monoid__rf_T 
                                                                   (s:
                                                                    (
                                                                    cc.eT 
                                                                    Product_regular_additive_monoid__rf_T) =>
                                                                    dk_logic.ebP 
                                                                    (_p_M1_equal 
                                                                    (Product_regular_additive_monoid__rf_first 
                                                                    s) x))))) ->
  Product_regular_additive_monoid__rf_different:((cc.eT 
                                                    Product_regular_additive_monoid__rf_T) ->
                                                 (cc.eT 
                                                    Product_regular_additive_monoid__rf_T) ->
                                                 cc.eT basics.bool__t) ->
  Product_regular_additive_monoid__rf_equal_reflexive:(dk_logic.eP 
                                                         (dk_logic.forall 
                                                            Product_regular_additive_monoid__rf_T 
                                                            (x:
                                                             (cc.eT 
                                                                Product_regular_additive_monoid__rf_T) =>
                                                             dk_logic.ebP 
                                                               (Product_regular_additive_monoid__rf_equal 
                                                                  x x)))) ->
  Product_regular_additive_monoid__rf_equal_spec:(dk_logic.eP 
                                                    (dk_logic.forall 
                                                       Product_regular_additive_monoid__rf_T 
                                                       (x:
                                                        (cc.eT 
                                                           Product_regular_additive_monoid__rf_T) =>
                                                        dk_logic.forall 
                                                          Product_regular_additive_monoid__rf_T 
                                                          (y:
                                                           (cc.eT 
                                                              Product_regular_additive_monoid__rf_T) =>
                                                           dk_logic.eqv 
                                                             (dk_logic.ebP 
                                                                (Product_regular_additive_monoid__rf_equal 
                                                                   x y)) 
                                                             (dk_logic.and 
                                                                (dk_logic.ebP 
                                                                   (_p_M1_equal 
                                                                    (Product_regular_additive_monoid__rf_first 
                                                                    x) 
                                                                    (Product_regular_additive_monoid__rf_first 
                                                                    y))) 
                                                                (dk_logic.ebP 
                                                                   (_p_M2_equal 
                                                                    (Product_regular_additive_monoid__rf_second 
                                                                    x) 
                                                                    (Product_regular_additive_monoid__rf_second 
                                                                    y)))))))) ->
  Product_regular_additive_monoid__rf_equal_symmetric:(dk_logic.eP 
                                                         (dk_logic.forall 
                                                            Product_regular_additive_monoid__rf_T 
                                                            (x:
                                                             (cc.eT 
                                                                Product_regular_additive_monoid__rf_T) =>
                                                             dk_logic.forall 
                                                               Product_regular_additive_monoid__rf_T 
                                                               (y:
                                                                (cc.eT 
                                                                   Product_regular_additive_monoid__rf_T) =>
                                                                dk_logic.imp 
                                                                  (dk_logic.ebP 
                                                                    (Product_regular_additive_monoid__rf_equal 
                                                                    x y)) 
                                                                  (dk_logic.ebP 
                                                                    (Product_regular_additive_monoid__rf_equal 
                                                                    y x)))))) ->
  Product_regular_additive_monoid__rf_equal_transitive:(dk_logic.eP 
                                                          (dk_logic.forall 
                                                             Product_regular_additive_monoid__rf_T 
                                                             (x:
                                                              (cc.eT 
                                                                 Product_regular_additive_monoid__rf_T) =>
                                                              dk_logic.forall 
                                                                Product_regular_additive_monoid__rf_T 
                                                                (y:
                                                                 (cc.eT 
                                                                    Product_regular_additive_monoid__rf_T) =>
                                                                 dk_logic.forall 
                                                                   Product_regular_additive_monoid__rf_T 
                                                                   (z:
                                                                    (
                                                                    cc.eT 
                                                                    Product_regular_additive_monoid__rf_T) =>
                                                                    dk_logic.imp 
                                                                    (dk_logic.ebP 
                                                                    (Product_regular_additive_monoid__rf_equal 
                                                                    x y)) 
                                                                    (dk_logic.imp 
                                                                    (dk_logic.ebP 
                                                                    (Product_regular_additive_monoid__rf_equal 
                                                                    y z)) 
                                                                    (dk_logic.ebP 
                                                                    (Product_regular_additive_monoid__rf_equal 
                                                                    x z)))))))) ->
  Product_regular_additive_monoid__rf_first_substitution_rule:(dk_logic.eP 
                                                                 (dk_logic.forall 
                                                                    Product_regular_additive_monoid__rf_T 
                                                                    (
                                                                    x:
                                                                    (
                                                                    cc.eT 
                                                                    Product_regular_additive_monoid__rf_T) =>
                                                                    dk_logic.forall 
                                                                    Product_regular_additive_monoid__rf_T 
                                                                    (y:
                                                                    (cc.eT 
                                                                    Product_regular_additive_monoid__rf_T) =>
                                                                    dk_logic.imp 
                                                                    (dk_logic.ebP 
                                                                    (Product_regular_additive_monoid__rf_equal 
                                                                    x y)) 
                                                                    (dk_logic.ebP 
                                                                    (_p_M1_equal 
                                                                    (Product_regular_additive_monoid__rf_first 
                                                                    x) 
                                                                    (Product_regular_additive_monoid__rf_first 
                                                                    y))))))) ->
  Product_regular_additive_monoid__rf_is_zero:((cc.eT 
                                                  Product_regular_additive_monoid__rf_T) ->
                                               cc.eT basics.bool__t) ->
  Product_regular_additive_monoid__rf_second_substitution_rule:(dk_logic.eP 
                                                                  (dk_logic.forall 
                                                                    Product_regular_additive_monoid__rf_T 
                                                                    (x:
                                                                    (cc.eT 
                                                                    Product_regular_additive_monoid__rf_T) =>
                                                                    dk_logic.forall 
                                                                    Product_regular_additive_monoid__rf_T 
                                                                    (y:
                                                                    (cc.eT 
                                                                    Product_regular_additive_monoid__rf_T) =>
                                                                    dk_logic.imp 
                                                                    (dk_logic.ebP 
                                                                    (Product_regular_additive_monoid__rf_equal 
                                                                    x y)) 
                                                                    (dk_logic.ebP 
                                                                    (_p_M2_equal 
                                                                    (Product_regular_additive_monoid__rf_second 
                                                                    x) 
                                                                    (Product_regular_additive_monoid__rf_second 
                                                                    y))))))) ->
  Product_regular_additive_monoid__rf_minus_left_substitution_rule:(dk_logic.eP 
                                                                    (dk_logic.forall 
                                                                    Product_regular_additive_monoid__rf_T 
                                                                    (x:
                                                                    (cc.eT 
                                                                    Product_regular_additive_monoid__rf_T) =>
                                                                    dk_logic.forall 
                                                                    Product_regular_additive_monoid__rf_T 
                                                                    (y:
                                                                    (cc.eT 
                                                                    Product_regular_additive_monoid__rf_T) =>
                                                                    dk_logic.forall 
                                                                    Product_regular_additive_monoid__rf_T 
                                                                    (z:
                                                                    (cc.eT 
                                                                    Product_regular_additive_monoid__rf_T) =>
                                                                    dk_logic.imp 
                                                                    (dk_logic.ebP 
                                                                    (Product_regular_additive_monoid__rf_equal 
                                                                    x y)) 
                                                                    (dk_logic.ebP 
                                                                    (Product_regular_additive_monoid__rf_equal 
                                                                    (Product_regular_additive_monoid__rf_minus 
                                                                    x z) 
                                                                    (Product_regular_additive_monoid__rf_minus 
                                                                    y z)))))))) ->
  Product_regular_additive_monoid__rf_minus_right_substitution_rule:(
  dk_logic.eP 
    (dk_logic.forall Product_regular_additive_monoid__rf_T 
       (x:(cc.eT Product_regular_additive_monoid__rf_T) =>
        dk_logic.forall Product_regular_additive_monoid__rf_T 
          (y:(cc.eT Product_regular_additive_monoid__rf_T) =>
           dk_logic.forall Product_regular_additive_monoid__rf_T 
             (z:(cc.eT Product_regular_additive_monoid__rf_T) =>
              dk_logic.imp 
                (dk_logic.ebP (Product_regular_additive_monoid__rf_equal y z)) 
                (dk_logic.ebP 
                   (Product_regular_additive_monoid__rf_equal 
                      (Product_regular_additive_monoid__rf_minus x y) 
                      (Product_regular_additive_monoid__rf_minus x z)))))))) ->
  Product_regular_additive_monoid__rf_pair_left_substitution_rule:(dk_logic.eP 
                                                                    (dk_logic.forall 
                                                                    M1_T 
                                                                    (x_1:
                                                                    (cc.eT 
                                                                    M1_T) =>
                                                                    dk_logic.forall 
                                                                    M1_T 
                                                                    (x_2:
                                                                    (cc.eT 
                                                                    M1_T) =>
                                                                    dk_logic.forall 
                                                                    M2_T 
                                                                    (y:
                                                                    (cc.eT 
                                                                    M2_T) =>
                                                                    dk_logic.imp 
                                                                    (dk_logic.ebP 
                                                                    (_p_M1_equal 
                                                                    x_1 x_2)) 
                                                                    (dk_logic.ebP 
                                                                    (Product_regular_additive_monoid__rf_equal 
                                                                    (Product_regular_additive_monoid__rf_pair 
                                                                    x_1 y) 
                                                                    (Product_regular_additive_monoid__rf_pair 
                                                                    x_2 y)))))))) ->
  Product_regular_additive_monoid__rf_pair_right_substitution_rule:(dk_logic.eP 
                                                                    (dk_logic.forall 
                                                                    M1_T 
                                                                    (x:
                                                                    (cc.eT 
                                                                    M1_T) =>
                                                                    dk_logic.forall 
                                                                    M2_T 
                                                                    (y_1:
                                                                    (cc.eT 
                                                                    M2_T) =>
                                                                    dk_logic.forall 
                                                                    M2_T 
                                                                    (y_2:
                                                                    (cc.eT 
                                                                    M2_T) =>
                                                                    dk_logic.imp 
                                                                    (dk_logic.ebP 
                                                                    (_p_M2_equal 
                                                                    y_1 y_2)) 
                                                                    (dk_logic.ebP 
                                                                    (Product_regular_additive_monoid__rf_equal 
                                                                    (Product_regular_additive_monoid__rf_pair 
                                                                    x y_1) 
                                                                    (Product_regular_additive_monoid__rf_pair 
                                                                    x y_2)))))))) ->
  Product_regular_additive_monoid__rf_second_accessibility:(dk_logic.eP 
                                                              (dk_logic.forall 
                                                                 M2_T 
                                                                 (x:
                                                                  (cc.eT M2_T) =>
                                                                  dk_logic.exists 
                                                                    Product_regular_additive_monoid__rf_T 
                                                                    (
                                                                    s:
                                                                    (
                                                                    cc.eT 
                                                                    Product_regular_additive_monoid__rf_T) =>
                                                                    dk_logic.ebP 
                                                                    (_p_M2_equal 
                                                                    (Product_regular_additive_monoid__rf_second 
                                                                    s) x))))) ->
  Product_regular_additive_monoid__rf_minus_is_well_defined:(dk_logic.eP 
                                                               (dk_logic.forall 
                                                                  Product_regular_additive_monoid__rf_T 
                                                                  (x:
                                                                   (cc.eT 
                                                                    Product_regular_additive_monoid__rf_T) =>
                                                                   dk_logic.forall 
                                                                    Product_regular_additive_monoid__rf_T 
                                                                    (y:
                                                                    (cc.eT 
                                                                    Product_regular_additive_monoid__rf_T) =>
                                                                    dk_logic.forall 
                                                                    Product_regular_additive_monoid__rf_T 
                                                                    (z:
                                                                    (cc.eT 
                                                                    Product_regular_additive_monoid__rf_T) =>
                                                                    dk_logic.imp 
                                                                    (dk_logic.ebP 
                                                                    (Product_regular_additive_monoid__rf_equal 
                                                                    x 
                                                                    (Product_regular_additive_monoid__rf_plus 
                                                                    z y))) 
                                                                    (dk_logic.and 
                                                                    (dk_logic.ebP 
                                                                    (Product_regular_additive_monoid__rf_equal 
                                                                    (Product_regular_additive_monoid__rf_minus 
                                                                    x y) z)) 
                                                                    (dk_logic.ebP 
                                                                    (Product_regular_additive_monoid__rf_equal 
                                                                    (Product_regular_additive_monoid__rf_minus 
                                                                    x z) y)))))))) ->
  Product_regular_additive_monoid__rf_plus_is_associative:(dk_logic.eP 
                                                             (dk_logic.forall 
                                                                Product_regular_additive_monoid__rf_T 
                                                                (x:
                                                                 (cc.eT 
                                                                    Product_regular_additive_monoid__rf_T) =>
                                                                 dk_logic.forall 
                                                                   Product_regular_additive_monoid__rf_T 
                                                                   (y:
                                                                    (
                                                                    cc.eT 
                                                                    Product_regular_additive_monoid__rf_T) =>
                                                                    dk_logic.forall 
                                                                    Product_regular_additive_monoid__rf_T 
                                                                    (z:
                                                                    (cc.eT 
                                                                    Product_regular_additive_monoid__rf_T) =>
                                                                    dk_logic.ebP 
                                                                    (Product_regular_additive_monoid__rf_equal 
                                                                    (Product_regular_additive_monoid__rf_plus 
                                                                    x 
                                                                    (Product_regular_additive_monoid__rf_plus 
                                                                    y z)) 
                                                                    (Product_regular_additive_monoid__rf_plus 
                                                                    (Product_regular_additive_monoid__rf_plus 
                                                                    x y) z))))))) ->
  Product_regular_additive_monoid__rf_plus_is_left_regular:(dk_logic.eP 
                                                              (dk_logic.forall 
                                                                 Product_regular_additive_monoid__rf_T 
                                                                 (x:
                                                                  (cc.eT 
                                                                    Product_regular_additive_monoid__rf_T) =>
                                                                  dk_logic.forall 
                                                                    Product_regular_additive_monoid__rf_T 
                                                                    (
                                                                    y:
                                                                    (
                                                                    cc.eT 
                                                                    Product_regular_additive_monoid__rf_T) =>
                                                                    dk_logic.forall 
                                                                    Product_regular_additive_monoid__rf_T 
                                                                    (z:
                                                                    (cc.eT 
                                                                    Product_regular_additive_monoid__rf_T) =>
                                                                    dk_logic.imp 
                                                                    (dk_logic.ebP 
                                                                    (Product_regular_additive_monoid__rf_equal 
                                                                    (Product_regular_additive_monoid__rf_plus 
                                                                    x y) 
                                                                    (Product_regular_additive_monoid__rf_plus 
                                                                    x z))) 
                                                                    (dk_logic.ebP 
                                                                    (Product_regular_additive_monoid__rf_equal 
                                                                    y z))))))) ->
  Product_regular_additive_monoid__rf_zero_is_neutral:(dk_logic.eP 
                                                         (dk_logic.forall 
                                                            Product_regular_additive_monoid__rf_T 
                                                            (x:
                                                             (cc.eT 
                                                                Product_regular_additive_monoid__rf_T) =>
                                                             dk_logic.and 
                                                               (dk_logic.ebP 
                                                                  (Product_regular_additive_monoid__rf_equal 
                                                                    (Product_regular_additive_monoid__rf_plus 
                                                                    x 
                                                                    Product_regular_additive_monoid__rf_zero) 
                                                                    x)) 
                                                               (dk_logic.ebP 
                                                                  (Product_regular_additive_monoid__rf_equal 
                                                                    (Product_regular_additive_monoid__rf_plus 
                                                                    Product_regular_additive_monoid__rf_zero 
                                                                    x) x))))) ->
  Product_regular_additive_monoid__rf_same_is_not_different:(dk_logic.eP 
                                                               (dk_logic.forall 
                                                                  Product_regular_additive_monoid__rf_T 
                                                                  (x:
                                                                   (cc.eT 
                                                                    Product_regular_additive_monoid__rf_T) =>
                                                                   dk_logic.forall 
                                                                    Product_regular_additive_monoid__rf_T 
                                                                    (y:
                                                                    (cc.eT 
                                                                    Product_regular_additive_monoid__rf_T) =>
                                                                    dk_logic.eqv 
                                                                    (dk_logic.ebP 
                                                                    (Product_regular_additive_monoid__rf_different 
                                                                    x y)) 
                                                                    (dk_logic.not 
                                                                    (dk_logic.ebP 
                                                                    (Product_regular_additive_monoid__rf_equal 
                                                                    x y))))))) ->
  Product_regular_additive_monoid__rf_is_zero_spec:(dk_logic.eP 
                                                      (dk_logic.forall 
                                                         Product_regular_additive_monoid__rf_T 
                                                         (x:
                                                          (cc.eT 
                                                             Product_regular_additive_monoid__rf_T) =>
                                                          dk_logic.eqv 
                                                            (dk_logic.ebP 
                                                               (Product_regular_additive_monoid__rf_is_zero 
                                                                  x)) 
                                                            (dk_logic.or 
                                                               (dk_logic.ebP 
                                                                  (Product_regular_additive_monoid__rf_equal 
                                                                    x 
                                                                    Product_regular_additive_monoid__rf_zero)) 
                                                               (dk_logic.ebP 
                                                                  (Product_regular_additive_monoid__rf_equal 
                                                                    Product_regular_additive_monoid__rf_zero 
                                                                    x)))))) ->
  Product_regular_additive_monoid__rf_pair_substitution_rule:(dk_logic.eP 
                                                                (dk_logic.forall 
                                                                   M1_T 
                                                                   (x_1:
                                                                    (
                                                                    cc.eT 
                                                                    M1_T) =>
                                                                    dk_logic.forall 
                                                                    M1_T 
                                                                    (x_2:
                                                                    (cc.eT 
                                                                    M1_T) =>
                                                                    dk_logic.forall 
                                                                    M2_T 
                                                                    (y_1:
                                                                    (cc.eT 
                                                                    M2_T) =>
                                                                    dk_logic.forall 
                                                                    M2_T 
                                                                    (y_2:
                                                                    (cc.eT 
                                                                    M2_T) =>
                                                                    dk_logic.imp 
                                                                    (dk_logic.ebP 
                                                                    (_p_M1_equal 
                                                                    x_1 x_2)) 
                                                                    (dk_logic.imp 
                                                                    (dk_logic.ebP 
                                                                    (_p_M2_equal 
                                                                    y_1 y_2)) 
                                                                    (dk_logic.ebP 
                                                                    (Product_regular_additive_monoid__rf_equal 
                                                                    (Product_regular_additive_monoid__rf_pair 
                                                                    x_1 y_1) 
                                                                    (Product_regular_additive_monoid__rf_pair 
                                                                    x_2 y_2)))))))))) ->
  Product_regular_additive_monoid__rf_zero_is_right_neutral_for_minus:(
  dk_logic.eP 
    (dk_logic.forall Product_regular_additive_monoid__rf_T 
       (x:(cc.eT Product_regular_additive_monoid__rf_T) =>
        dk_logic.ebP 
          (Product_regular_additive_monoid__rf_equal 
             (Product_regular_additive_monoid__rf_minus x 
                Product_regular_additive_monoid__rf_zero) x)))) ->
  Product_regular_additive_monoid__rf_zero_is_unique:(dk_logic.eP 
                                                        (dk_logic.forall 
                                                           Product_regular_additive_monoid__rf_T 
                                                           (o:
                                                            (cc.eT 
                                                               Product_regular_additive_monoid__rf_T) =>
                                                            dk_logic.imp 
                                                              (dk_logic.forall 
                                                                 Product_regular_additive_monoid__rf_T 
                                                                 (x:
                                                                  (cc.eT 
                                                                    Product_regular_additive_monoid__rf_T) =>
                                                                  dk_logic.ebP 
                                                                    (
                                                                    Product_regular_additive_monoid__rf_equal 
                                                                    x 
                                                                    (Product_regular_additive_monoid__rf_plus 
                                                                    x o)))) 
                                                              (dk_logic.ebP 
                                                                 (Product_regular_additive_monoid__rf_equal 
                                                                    o 
                                                                    Product_regular_additive_monoid__rf_zero))))) ->
  Product_regular_additive_monoid__rf_different_is_complete:(dk_logic.eP 
                                                               (dk_logic.forall 
                                                                  Product_regular_additive_monoid__rf_T 
                                                                  (x:
                                                                   (cc.eT 
                                                                    Product_regular_additive_monoid__rf_T) =>
                                                                   dk_logic.forall 
                                                                    Product_regular_additive_monoid__rf_T 
                                                                    (y:
                                                                    (cc.eT 
                                                                    Product_regular_additive_monoid__rf_T) =>
                                                                    dk_logic.forall 
                                                                    Product_regular_additive_monoid__rf_T 
                                                                    (z:
                                                                    (cc.eT 
                                                                    Product_regular_additive_monoid__rf_T) =>
                                                                    dk_logic.imp 
                                                                    (dk_logic.ebP 
                                                                    (Product_regular_additive_monoid__rf_different 
                                                                    x y)) 
                                                                    (dk_logic.or 
                                                                    (dk_logic.ebP 
                                                                    (Product_regular_additive_monoid__rf_different 
                                                                    x z)) 
                                                                    (dk_logic.ebP 
                                                                    (Product_regular_additive_monoid__rf_different 
                                                                    y z)))))))) ->
  Product_regular_additive_monoid__rf_different_is_irreflexive:(dk_logic.eP 
                                                                  (dk_logic.forall 
                                                                    Product_regular_additive_monoid__rf_T 
                                                                    (x:
                                                                    (cc.eT 
                                                                    Product_regular_additive_monoid__rf_T) =>
                                                                    dk_logic.not 
                                                                    (dk_logic.ebP 
                                                                    (Product_regular_additive_monoid__rf_different 
                                                                    x x))))) ->
  Product_regular_additive_monoid__rf_different_is_symmetric:(dk_logic.eP 
                                                                (dk_logic.forall 
                                                                   Product_regular_additive_monoid__rf_T 
                                                                   (x:
                                                                    (
                                                                    cc.eT 
                                                                    Product_regular_additive_monoid__rf_T) =>
                                                                    dk_logic.forall 
                                                                    Product_regular_additive_monoid__rf_T 
                                                                    (y:
                                                                    (cc.eT 
                                                                    Product_regular_additive_monoid__rf_T) =>
                                                                    dk_logic.imp 
                                                                    (dk_logic.ebP 
                                                                    (Product_regular_additive_monoid__rf_different 
                                                                    x y)) 
                                                                    (dk_logic.ebP 
                                                                    (Product_regular_additive_monoid__rf_different 
                                                                    y x)))))) ->
  Product_regular_additive_monoid__rf_zero_checks_to_zero:(dk_logic.eP 
                                                             (dk_logic.ebP 
                                                                (Product_regular_additive_monoid__rf_is_zero 
                                                                   Product_regular_additive_monoid__rf_zero))) ->
  Product_regular_additive_monoid__rf_plus_commutes:(dk_logic.eP 
                                                       (dk_logic.forall 
                                                          Product_regular_additive_monoid__rf_T 
                                                          (x:
                                                           (cc.eT 
                                                              Product_regular_additive_monoid__rf_T) =>
                                                           dk_logic.forall 
                                                             Product_regular_additive_monoid__rf_T 
                                                             (y:
                                                              (cc.eT 
                                                                 Product_regular_additive_monoid__rf_T) =>
                                                              dk_logic.ebP 
                                                                (Product_regular_additive_monoid__rf_equal 
                                                                   (Product_regular_additive_monoid__rf_plus 
                                                                    x y) 
                                                                   (Product_regular_additive_monoid__rf_plus 
                                                                    y x)))))) ->
  Product_regular_additive_monoid__rf_plus_right_substitution_rule:(dk_logic.eP 
                                                                    (dk_logic.forall 
                                                                    Product_regular_additive_monoid__rf_T 
                                                                    (x:
                                                                    (cc.eT 
                                                                    Product_regular_additive_monoid__rf_T) =>
                                                                    dk_logic.forall 
                                                                    Product_regular_additive_monoid__rf_T 
                                                                    (y:
                                                                    (cc.eT 
                                                                    Product_regular_additive_monoid__rf_T) =>
                                                                    dk_logic.forall 
                                                                    Product_regular_additive_monoid__rf_T 
                                                                    (z:
                                                                    (cc.eT 
                                                                    Product_regular_additive_monoid__rf_T) =>
                                                                    dk_logic.imp 
                                                                    (dk_logic.ebP 
                                                                    (Product_regular_additive_monoid__rf_equal 
                                                                    x y)) 
                                                                    (dk_logic.ebP 
                                                                    (Product_regular_additive_monoid__rf_equal 
                                                                    (Product_regular_additive_monoid__rf_plus 
                                                                    z x) 
                                                                    (Product_regular_additive_monoid__rf_plus 
                                                                    z y)))))))) ->
  Product_regular_additive_monoid__rf_plus_is_right_regular:(dk_logic.eP 
                                                               (dk_logic.forall 
                                                                  Product_regular_additive_monoid__rf_T 
                                                                  (x:
                                                                   (cc.eT 
                                                                    Product_regular_additive_monoid__rf_T) =>
                                                                   dk_logic.forall 
                                                                    Product_regular_additive_monoid__rf_T 
                                                                    (y:
                                                                    (cc.eT 
                                                                    Product_regular_additive_monoid__rf_T) =>
                                                                    dk_logic.forall 
                                                                    Product_regular_additive_monoid__rf_T 
                                                                    (z:
                                                                    (cc.eT 
                                                                    Product_regular_additive_monoid__rf_T) =>
                                                                    dk_logic.imp 
                                                                    (dk_logic.ebP 
                                                                    (Product_regular_additive_monoid__rf_equal 
                                                                    (Product_regular_additive_monoid__rf_plus 
                                                                    x z) 
                                                                    (Product_regular_additive_monoid__rf_plus 
                                                                    y z))) 
                                                                    (dk_logic.ebP 
                                                                    (Product_regular_additive_monoid__rf_equal 
                                                                    x y))))))) ->
  Product_regular_additive_monoid__rf_plus_left_substitution_rule:(dk_logic.eP 
                                                                    (dk_logic.forall 
                                                                    Product_regular_additive_monoid__rf_T 
                                                                    (x:
                                                                    (cc.eT 
                                                                    Product_regular_additive_monoid__rf_T) =>
                                                                    dk_logic.forall 
                                                                    Product_regular_additive_monoid__rf_T 
                                                                    (y:
                                                                    (cc.eT 
                                                                    Product_regular_additive_monoid__rf_T) =>
                                                                    dk_logic.forall 
                                                                    Product_regular_additive_monoid__rf_T 
                                                                    (z:
                                                                    (cc.eT 
                                                                    Product_regular_additive_monoid__rf_T) =>
                                                                    dk_logic.imp 
                                                                    (dk_logic.ebP 
                                                                    (Product_regular_additive_monoid__rf_equal 
                                                                    x y)) 
                                                                    (dk_logic.ebP 
                                                                    (Product_regular_additive_monoid__rf_equal 
                                                                    (Product_regular_additive_monoid__rf_plus 
                                                                    x z) 
                                                                    (Product_regular_additive_monoid__rf_plus 
                                                                    y z)))))))) ->
  Product_regular_additive_monoid__rf_plus_is_regular:(dk_logic.eP 
                                                         (dk_logic.forall 
                                                            Product_regular_additive_monoid__rf_T 
                                                            (x:
                                                             (cc.eT 
                                                                Product_regular_additive_monoid__rf_T) =>
                                                             dk_logic.forall 
                                                               Product_regular_additive_monoid__rf_T 
                                                               (y:
                                                                (cc.eT 
                                                                   Product_regular_additive_monoid__rf_T) =>
                                                                dk_logic.forall 
                                                                  Product_regular_additive_monoid__rf_T 
                                                                  (z:
                                                                   (cc.eT 
                                                                    Product_regular_additive_monoid__rf_T) =>
                                                                   dk_logic.and 
                                                                    (dk_logic.imp 
                                                                    (dk_logic.ebP 
                                                                    (Product_regular_additive_monoid__rf_equal 
                                                                    (Product_regular_additive_monoid__rf_plus 
                                                                    x y) 
                                                                    (Product_regular_additive_monoid__rf_plus 
                                                                    x z))) 
                                                                    (dk_logic.ebP 
                                                                    (Product_regular_additive_monoid__rf_equal 
                                                                    y z))) 
                                                                    (dk_logic.imp 
                                                                    (dk_logic.ebP 
                                                                    (Product_regular_additive_monoid__rf_equal 
                                                                    (Product_regular_additive_monoid__rf_plus 
                                                                    x z) 
                                                                    (Product_regular_additive_monoid__rf_plus 
                                                                    y z))) 
                                                                    (dk_logic.ebP 
                                                                    (Product_regular_additive_monoid__rf_equal 
                                                                    x y)))))))) ->
  Product_regular_additive_monoid__rf_plus_substitution_rule:(dk_logic.eP 
                                                                (dk_logic.forall 
                                                                   Product_regular_additive_monoid__rf_T 
                                                                   (x1:
                                                                    (
                                                                    cc.eT 
                                                                    Product_regular_additive_monoid__rf_T) =>
                                                                    dk_logic.forall 
                                                                    Product_regular_additive_monoid__rf_T 
                                                                    (x2:
                                                                    (cc.eT 
                                                                    Product_regular_additive_monoid__rf_T) =>
                                                                    dk_logic.forall 
                                                                    Product_regular_additive_monoid__rf_T 
                                                                    (y1:
                                                                    (cc.eT 
                                                                    Product_regular_additive_monoid__rf_T) =>
                                                                    dk_logic.forall 
                                                                    Product_regular_additive_monoid__rf_T 
                                                                    (y2:
                                                                    (cc.eT 
                                                                    Product_regular_additive_monoid__rf_T) =>
                                                                    dk_logic.imp 
                                                                    (dk_logic.ebP 
                                                                    (Product_regular_additive_monoid__rf_equal 
                                                                    x1 x2)) 
                                                                    (dk_logic.imp 
                                                                    (dk_logic.ebP 
                                                                    (Product_regular_additive_monoid__rf_equal 
                                                                    y1 y2)) 
                                                                    (dk_logic.ebP 
                                                                    (Product_regular_additive_monoid__rf_equal 
                                                                    (Product_regular_additive_monoid__rf_plus 
                                                                    x1 y1) 
                                                                    (Product_regular_additive_monoid__rf_plus 
                                                                    x2 y2)))))))))) ->
  Product_regular_additive_monoid__me_as_species M1_T M2_T _p_M1_equal 
    _p_M2_equal.

def proj_Product_regular_additive_monoid__rf_T :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_regular_additive_monoid__me_as_species M1_T M2_T 
            _p_M1_equal _p_M2_equal) ->
  cc.uT.

[Product_regular_additive_monoid__rf_T]
  proj_Product_regular_additive_monoid__rf_T _ _ _ _ 
    (Product_regular_additive_monoid__mk_record _ _ _ _ 
    Product_regular_additive_monoid__rf_T _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
  -->
  Product_regular_additive_monoid__rf_T.

def proj_Product_regular_additive_monoid__rf_first :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_regular_additive_monoid__me_as_species M1_T M2_T 
            _p_M1_equal _p_M2_equal) ->
  (cc.eT 
     (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
        _p_M2_equal record)) ->
  cc.eT M1_T.

[Product_regular_additive_monoid__rf_first]
  proj_Product_regular_additive_monoid__rf_first _ _ _ _ 
    (Product_regular_additive_monoid__mk_record _ _ _ _ _ 
    Product_regular_additive_monoid__rf_first _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
  -->
  Product_regular_additive_monoid__rf_first.

def proj_Product_regular_additive_monoid__rf_pair :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_regular_additive_monoid__me_as_species M1_T M2_T 
            _p_M1_equal _p_M2_equal) ->
  (cc.eT M1_T) ->
  (cc.eT M2_T) ->
  cc.eT 
    (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
       _p_M2_equal record).

[Product_regular_additive_monoid__rf_pair]
  proj_Product_regular_additive_monoid__rf_pair _ _ _ _ 
    (Product_regular_additive_monoid__mk_record _ _ _ _ _ _ 
    Product_regular_additive_monoid__rf_pair _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
  -->
  Product_regular_additive_monoid__rf_pair.

def proj_Product_regular_additive_monoid__rf_parse :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_regular_additive_monoid__me_as_species M1_T M2_T 
            _p_M1_equal _p_M2_equal) ->
  (cc.eT basics.string__t) ->
  cc.eT 
    (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
       _p_M2_equal record).

[Product_regular_additive_monoid__rf_parse]
  proj_Product_regular_additive_monoid__rf_parse _ _ _ _ 
    (Product_regular_additive_monoid__mk_record _ _ _ _ _ _ _ 
    Product_regular_additive_monoid__rf_parse _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
  -->
  Product_regular_additive_monoid__rf_parse.

def proj_Product_regular_additive_monoid__rf_print :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_regular_additive_monoid__me_as_species M1_T M2_T 
            _p_M1_equal _p_M2_equal) ->
  (cc.eT 
     (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
        _p_M2_equal record)) ->
  cc.eT basics.string__t.

[Product_regular_additive_monoid__rf_print]
  proj_Product_regular_additive_monoid__rf_print _ _ _ _ 
    (Product_regular_additive_monoid__mk_record _ _ _ _ _ _ _ _ 
    Product_regular_additive_monoid__rf_print _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
  -->
  Product_regular_additive_monoid__rf_print.

def proj_Product_regular_additive_monoid__rf_second :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_regular_additive_monoid__me_as_species M1_T M2_T 
            _p_M1_equal _p_M2_equal) ->
  (cc.eT 
     (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
        _p_M2_equal record)) ->
  cc.eT M2_T.

[Product_regular_additive_monoid__rf_second]
  proj_Product_regular_additive_monoid__rf_second _ _ _ _ 
    (Product_regular_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ 
    Product_regular_additive_monoid__rf_second _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
  -->
  Product_regular_additive_monoid__rf_second.

def proj_Product_regular_additive_monoid__rf_zero :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_regular_additive_monoid__me_as_species M1_T M2_T 
            _p_M1_equal _p_M2_equal) ->
  cc.eT 
    (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
       _p_M2_equal record).

[Product_regular_additive_monoid__rf_zero]
  proj_Product_regular_additive_monoid__rf_zero _ _ _ _ 
    (Product_regular_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ 
    Product_regular_additive_monoid__rf_zero _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
  -->
  Product_regular_additive_monoid__rf_zero.

def proj_Product_regular_additive_monoid__rf_element :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_regular_additive_monoid__me_as_species M1_T M2_T 
            _p_M1_equal _p_M2_equal) ->
  cc.eT 
    (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
       _p_M2_equal record).

[Product_regular_additive_monoid__rf_element]
  proj_Product_regular_additive_monoid__rf_element _ _ _ _ 
    (Product_regular_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ 
    Product_regular_additive_monoid__rf_element _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
  -->
  Product_regular_additive_monoid__rf_element.

def proj_Product_regular_additive_monoid__rf_pair_preserves_first :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_regular_additive_monoid__me_as_species M1_T M2_T 
            _p_M1_equal _p_M2_equal) ->
  dk_logic.eP 
    (dk_logic.forall M1_T 
       (x:(cc.eT M1_T) =>
        dk_logic.forall M2_T 
          (y:(cc.eT M2_T) =>
           dk_logic.ebP 
             (_p_M1_equal 
                (proj_Product_regular_additive_monoid__rf_first M1_T M2_T 
                   _p_M1_equal _p_M2_equal record 
                   (proj_Product_regular_additive_monoid__rf_pair M1_T M2_T 
                      _p_M1_equal _p_M2_equal record x y)) x)))).

[Product_regular_additive_monoid__rf_pair_preserves_first]
  proj_Product_regular_additive_monoid__rf_pair_preserves_first _ _ _ _ 
    (Product_regular_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ 
    Product_regular_additive_monoid__rf_pair_preserves_first _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
  -->
  Product_regular_additive_monoid__rf_pair_preserves_first.

def proj_Product_regular_additive_monoid__rf_equal :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_regular_additive_monoid__me_as_species M1_T M2_T 
            _p_M1_equal _p_M2_equal) ->
  (cc.eT 
     (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
        _p_M2_equal record)) ->
  (cc.eT 
     (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
        _p_M2_equal record)) ->
  cc.eT basics.bool__t.

[Product_regular_additive_monoid__rf_equal]
  proj_Product_regular_additive_monoid__rf_equal _ _ _ _ 
    (Product_regular_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ 
    Product_regular_additive_monoid__rf_equal _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
  -->
  Product_regular_additive_monoid__rf_equal.

def proj_Product_regular_additive_monoid__rf_minus :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_regular_additive_monoid__me_as_species M1_T M2_T 
            _p_M1_equal _p_M2_equal) ->
  (cc.eT 
     (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
        _p_M2_equal record)) ->
  (cc.eT 
     (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
        _p_M2_equal record)) ->
  cc.eT 
    (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
       _p_M2_equal record).

[Product_regular_additive_monoid__rf_minus]
  proj_Product_regular_additive_monoid__rf_minus _ _ _ _ 
    (Product_regular_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    Product_regular_additive_monoid__rf_minus _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
  -->
  Product_regular_additive_monoid__rf_minus.

def proj_Product_regular_additive_monoid__rf_pair_preserves_second :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_regular_additive_monoid__me_as_species M1_T M2_T 
            _p_M1_equal _p_M2_equal) ->
  dk_logic.eP 
    (dk_logic.forall M1_T 
       (x:(cc.eT M1_T) =>
        dk_logic.forall M2_T 
          (y:(cc.eT M2_T) =>
           dk_logic.ebP 
             (_p_M2_equal 
                (proj_Product_regular_additive_monoid__rf_second M1_T M2_T 
                   _p_M1_equal _p_M2_equal record 
                   (proj_Product_regular_additive_monoid__rf_pair M1_T M2_T 
                      _p_M1_equal _p_M2_equal record x y)) y)))).

[Product_regular_additive_monoid__rf_pair_preserves_second]
  proj_Product_regular_additive_monoid__rf_pair_preserves_second _ _ _ _ 
    (Product_regular_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ Product_regular_additive_monoid__rf_pair_preserves_second _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
  -->
  Product_regular_additive_monoid__rf_pair_preserves_second.

def proj_Product_regular_additive_monoid__rf_plus :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_regular_additive_monoid__me_as_species M1_T M2_T 
            _p_M1_equal _p_M2_equal) ->
  (cc.eT 
     (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
        _p_M2_equal record)) ->
  (cc.eT 
     (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
        _p_M2_equal record)) ->
  cc.eT 
    (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
       _p_M2_equal record).

[Product_regular_additive_monoid__rf_plus]
  proj_Product_regular_additive_monoid__rf_plus _ _ _ _ 
    (Product_regular_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ Product_regular_additive_monoid__rf_plus _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
  -->
  Product_regular_additive_monoid__rf_plus.

def proj_Product_regular_additive_monoid__rf_failed :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_regular_additive_monoid__me_as_species M1_T M2_T 
            _p_M1_equal _p_M2_equal) ->
  (cc.eT basics.string__t) ->
  cc.eT 
    (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
       _p_M2_equal record).

[Product_regular_additive_monoid__rf_failed]
  proj_Product_regular_additive_monoid__rf_failed _ _ _ _ 
    (Product_regular_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ Product_regular_additive_monoid__rf_failed _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
  -->
  Product_regular_additive_monoid__rf_failed.

def proj_Product_regular_additive_monoid__rf_first_accessibility :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_regular_additive_monoid__me_as_species M1_T M2_T 
            _p_M1_equal _p_M2_equal) ->
  dk_logic.eP 
    (dk_logic.forall M1_T 
       (x:(cc.eT M1_T) =>
        dk_logic.exists 
          (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
             _p_M2_equal record) 
          (s:
           (cc.eT 
              (proj_Product_regular_additive_monoid__rf_T M1_T M2_T 
                 _p_M1_equal _p_M2_equal record)) =>
           dk_logic.ebP 
             (_p_M1_equal 
                (proj_Product_regular_additive_monoid__rf_first M1_T M2_T 
                   _p_M1_equal _p_M2_equal record s) x)))).

[Product_regular_additive_monoid__rf_first_accessibility]
  proj_Product_regular_additive_monoid__rf_first_accessibility _ _ _ _ 
    (Product_regular_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ Product_regular_additive_monoid__rf_first_accessibility _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
  -->
  Product_regular_additive_monoid__rf_first_accessibility.

def proj_Product_regular_additive_monoid__rf_different :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_regular_additive_monoid__me_as_species M1_T M2_T 
            _p_M1_equal _p_M2_equal) ->
  (cc.eT 
     (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
        _p_M2_equal record)) ->
  (cc.eT 
     (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
        _p_M2_equal record)) ->
  cc.eT basics.bool__t.

[Product_regular_additive_monoid__rf_different]
  proj_Product_regular_additive_monoid__rf_different _ _ _ _ 
    (Product_regular_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ Product_regular_additive_monoid__rf_different _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
  -->
  Product_regular_additive_monoid__rf_different.

def proj_Product_regular_additive_monoid__rf_equal_reflexive :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_regular_additive_monoid__me_as_species M1_T M2_T 
            _p_M1_equal _p_M2_equal) ->
  dk_logic.eP 
    (dk_logic.forall 
       (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
          _p_M2_equal record) 
       (x:
        (cc.eT 
           (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
              _p_M2_equal record)) =>
        dk_logic.ebP 
          (proj_Product_regular_additive_monoid__rf_equal M1_T M2_T 
             _p_M1_equal _p_M2_equal record x x))).

[Product_regular_additive_monoid__rf_equal_reflexive]
  proj_Product_regular_additive_monoid__rf_equal_reflexive _ _ _ _ 
    (Product_regular_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ Product_regular_additive_monoid__rf_equal_reflexive _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
  -->
  Product_regular_additive_monoid__rf_equal_reflexive.

def proj_Product_regular_additive_monoid__rf_equal_spec :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_regular_additive_monoid__me_as_species M1_T M2_T 
            _p_M1_equal _p_M2_equal) ->
  dk_logic.eP 
    (dk_logic.forall 
       (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
          _p_M2_equal record) 
       (x:
        (cc.eT 
           (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
              _p_M2_equal record)) =>
        dk_logic.forall 
          (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
             _p_M2_equal record) 
          (y:
           (cc.eT 
              (proj_Product_regular_additive_monoid__rf_T M1_T M2_T 
                 _p_M1_equal _p_M2_equal record)) =>
           dk_logic.eqv 
             (dk_logic.ebP 
                (proj_Product_regular_additive_monoid__rf_equal M1_T M2_T 
                   _p_M1_equal _p_M2_equal record x y)) 
             (dk_logic.and 
                (dk_logic.ebP 
                   (_p_M1_equal 
                      (proj_Product_regular_additive_monoid__rf_first M1_T 
                         M2_T _p_M1_equal _p_M2_equal record x) 
                      (proj_Product_regular_additive_monoid__rf_first M1_T 
                         M2_T _p_M1_equal _p_M2_equal record y))) 
                (dk_logic.ebP 
                   (_p_M2_equal 
                      (proj_Product_regular_additive_monoid__rf_second M1_T 
                         M2_T _p_M1_equal _p_M2_equal record x) 
                      (proj_Product_regular_additive_monoid__rf_second M1_T 
                         M2_T _p_M1_equal _p_M2_equal record y))))))).

[Product_regular_additive_monoid__rf_equal_spec]
  proj_Product_regular_additive_monoid__rf_equal_spec _ _ _ _ 
    (Product_regular_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ Product_regular_additive_monoid__rf_equal_spec _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
  -->
  Product_regular_additive_monoid__rf_equal_spec.

def proj_Product_regular_additive_monoid__rf_equal_symmetric :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_regular_additive_monoid__me_as_species M1_T M2_T 
            _p_M1_equal _p_M2_equal) ->
  dk_logic.eP 
    (dk_logic.forall 
       (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
          _p_M2_equal record) 
       (x:
        (cc.eT 
           (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
              _p_M2_equal record)) =>
        dk_logic.forall 
          (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
             _p_M2_equal record) 
          (y:
           (cc.eT 
              (proj_Product_regular_additive_monoid__rf_T M1_T M2_T 
                 _p_M1_equal _p_M2_equal record)) =>
           dk_logic.imp 
             (dk_logic.ebP 
                (proj_Product_regular_additive_monoid__rf_equal M1_T M2_T 
                   _p_M1_equal _p_M2_equal record x y)) 
             (dk_logic.ebP 
                (proj_Product_regular_additive_monoid__rf_equal M1_T M2_T 
                   _p_M1_equal _p_M2_equal record y x))))).

[Product_regular_additive_monoid__rf_equal_symmetric]
  proj_Product_regular_additive_monoid__rf_equal_symmetric _ _ _ _ 
    (Product_regular_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ Product_regular_additive_monoid__rf_equal_symmetric _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
  -->
  Product_regular_additive_monoid__rf_equal_symmetric.

def proj_Product_regular_additive_monoid__rf_equal_transitive :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_regular_additive_monoid__me_as_species M1_T M2_T 
            _p_M1_equal _p_M2_equal) ->
  dk_logic.eP 
    (dk_logic.forall 
       (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
          _p_M2_equal record) 
       (x:
        (cc.eT 
           (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
              _p_M2_equal record)) =>
        dk_logic.forall 
          (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
             _p_M2_equal record) 
          (y:
           (cc.eT 
              (proj_Product_regular_additive_monoid__rf_T M1_T M2_T 
                 _p_M1_equal _p_M2_equal record)) =>
           dk_logic.forall 
             (proj_Product_regular_additive_monoid__rf_T M1_T M2_T 
                _p_M1_equal _p_M2_equal record) 
             (z:
              (cc.eT 
                 (proj_Product_regular_additive_monoid__rf_T M1_T M2_T 
                    _p_M1_equal _p_M2_equal record)) =>
              dk_logic.imp 
                (dk_logic.ebP 
                   (proj_Product_regular_additive_monoid__rf_equal M1_T M2_T 
                      _p_M1_equal _p_M2_equal record x y)) 
                (dk_logic.imp 
                   (dk_logic.ebP 
                      (proj_Product_regular_additive_monoid__rf_equal M1_T 
                         M2_T _p_M1_equal _p_M2_equal record y z)) 
                   (dk_logic.ebP 
                      (proj_Product_regular_additive_monoid__rf_equal M1_T 
                         M2_T _p_M1_equal _p_M2_equal record x z))))))).

[Product_regular_additive_monoid__rf_equal_transitive]
  proj_Product_regular_additive_monoid__rf_equal_transitive _ _ _ _ 
    (Product_regular_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ Product_regular_additive_monoid__rf_equal_transitive _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
  -->
  Product_regular_additive_monoid__rf_equal_transitive.

def proj_Product_regular_additive_monoid__rf_first_substitution_rule :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_regular_additive_monoid__me_as_species M1_T M2_T 
            _p_M1_equal _p_M2_equal) ->
  dk_logic.eP 
    (dk_logic.forall 
       (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
          _p_M2_equal record) 
       (x:
        (cc.eT 
           (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
              _p_M2_equal record)) =>
        dk_logic.forall 
          (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
             _p_M2_equal record) 
          (y:
           (cc.eT 
              (proj_Product_regular_additive_monoid__rf_T M1_T M2_T 
                 _p_M1_equal _p_M2_equal record)) =>
           dk_logic.imp 
             (dk_logic.ebP 
                (proj_Product_regular_additive_monoid__rf_equal M1_T M2_T 
                   _p_M1_equal _p_M2_equal record x y)) 
             (dk_logic.ebP 
                (_p_M1_equal 
                   (proj_Product_regular_additive_monoid__rf_first M1_T M2_T 
                      _p_M1_equal _p_M2_equal record x) 
                   (proj_Product_regular_additive_monoid__rf_first M1_T M2_T 
                      _p_M1_equal _p_M2_equal record y)))))).

[Product_regular_additive_monoid__rf_first_substitution_rule]
  proj_Product_regular_additive_monoid__rf_first_substitution_rule _ _ _ _ 
    (Product_regular_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ 
    Product_regular_additive_monoid__rf_first_substitution_rule _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
  -->
  Product_regular_additive_monoid__rf_first_substitution_rule.

def proj_Product_regular_additive_monoid__rf_is_zero :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_regular_additive_monoid__me_as_species M1_T M2_T 
            _p_M1_equal _p_M2_equal) ->
  (cc.eT 
     (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
        _p_M2_equal record)) ->
  cc.eT basics.bool__t.

[Product_regular_additive_monoid__rf_is_zero]
  proj_Product_regular_additive_monoid__rf_is_zero _ _ _ _ 
    (Product_regular_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ Product_regular_additive_monoid__rf_is_zero _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
  -->
  Product_regular_additive_monoid__rf_is_zero.

def proj_Product_regular_additive_monoid__rf_second_substitution_rule :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_regular_additive_monoid__me_as_species M1_T M2_T 
            _p_M1_equal _p_M2_equal) ->
  dk_logic.eP 
    (dk_logic.forall 
       (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
          _p_M2_equal record) 
       (x:
        (cc.eT 
           (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
              _p_M2_equal record)) =>
        dk_logic.forall 
          (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
             _p_M2_equal record) 
          (y:
           (cc.eT 
              (proj_Product_regular_additive_monoid__rf_T M1_T M2_T 
                 _p_M1_equal _p_M2_equal record)) =>
           dk_logic.imp 
             (dk_logic.ebP 
                (proj_Product_regular_additive_monoid__rf_equal M1_T M2_T 
                   _p_M1_equal _p_M2_equal record x y)) 
             (dk_logic.ebP 
                (_p_M2_equal 
                   (proj_Product_regular_additive_monoid__rf_second M1_T 
                      M2_T _p_M1_equal _p_M2_equal record x) 
                   (proj_Product_regular_additive_monoid__rf_second M1_T 
                      M2_T _p_M1_equal _p_M2_equal record y)))))).

[Product_regular_additive_monoid__rf_second_substitution_rule]
  proj_Product_regular_additive_monoid__rf_second_substitution_rule _ _ _ _ 
    (Product_regular_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ 
    Product_regular_additive_monoid__rf_second_substitution_rule _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
  -->
  Product_regular_additive_monoid__rf_second_substitution_rule.

def proj_Product_regular_additive_monoid__rf_minus_left_substitution_rule :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_regular_additive_monoid__me_as_species M1_T M2_T 
            _p_M1_equal _p_M2_equal) ->
  dk_logic.eP 
    (dk_logic.forall 
       (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
          _p_M2_equal record) 
       (x:
        (cc.eT 
           (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
              _p_M2_equal record)) =>
        dk_logic.forall 
          (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
             _p_M2_equal record) 
          (y:
           (cc.eT 
              (proj_Product_regular_additive_monoid__rf_T M1_T M2_T 
                 _p_M1_equal _p_M2_equal record)) =>
           dk_logic.forall 
             (proj_Product_regular_additive_monoid__rf_T M1_T M2_T 
                _p_M1_equal _p_M2_equal record) 
             (z:
              (cc.eT 
                 (proj_Product_regular_additive_monoid__rf_T M1_T M2_T 
                    _p_M1_equal _p_M2_equal record)) =>
              dk_logic.imp 
                (dk_logic.ebP 
                   (proj_Product_regular_additive_monoid__rf_equal M1_T M2_T 
                      _p_M1_equal _p_M2_equal record x y)) 
                (dk_logic.ebP 
                   (proj_Product_regular_additive_monoid__rf_equal M1_T M2_T 
                      _p_M1_equal _p_M2_equal record 
                      (proj_Product_regular_additive_monoid__rf_minus M1_T 
                         M2_T _p_M1_equal _p_M2_equal record x z) 
                      (proj_Product_regular_additive_monoid__rf_minus M1_T 
                         M2_T _p_M1_equal _p_M2_equal record y z))))))).

[Product_regular_additive_monoid__rf_minus_left_substitution_rule]
  proj_Product_regular_additive_monoid__rf_minus_left_substitution_rule _ _ 
    _ _ (Product_regular_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    Product_regular_additive_monoid__rf_minus_left_substitution_rule _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
  -->
  Product_regular_additive_monoid__rf_minus_left_substitution_rule.

def proj_Product_regular_additive_monoid__rf_minus_right_substitution_rule :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_regular_additive_monoid__me_as_species M1_T M2_T 
            _p_M1_equal _p_M2_equal) ->
  dk_logic.eP 
    (dk_logic.forall 
       (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
          _p_M2_equal record) 
       (x:
        (cc.eT 
           (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
              _p_M2_equal record)) =>
        dk_logic.forall 
          (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
             _p_M2_equal record) 
          (y:
           (cc.eT 
              (proj_Product_regular_additive_monoid__rf_T M1_T M2_T 
                 _p_M1_equal _p_M2_equal record)) =>
           dk_logic.forall 
             (proj_Product_regular_additive_monoid__rf_T M1_T M2_T 
                _p_M1_equal _p_M2_equal record) 
             (z:
              (cc.eT 
                 (proj_Product_regular_additive_monoid__rf_T M1_T M2_T 
                    _p_M1_equal _p_M2_equal record)) =>
              dk_logic.imp 
                (dk_logic.ebP 
                   (proj_Product_regular_additive_monoid__rf_equal M1_T M2_T 
                      _p_M1_equal _p_M2_equal record y z)) 
                (dk_logic.ebP 
                   (proj_Product_regular_additive_monoid__rf_equal M1_T M2_T 
                      _p_M1_equal _p_M2_equal record 
                      (proj_Product_regular_additive_monoid__rf_minus M1_T 
                         M2_T _p_M1_equal _p_M2_equal record x y) 
                      (proj_Product_regular_additive_monoid__rf_minus M1_T 
                         M2_T _p_M1_equal _p_M2_equal record x z))))))).

[Product_regular_additive_monoid__rf_minus_right_substitution_rule]
  proj_Product_regular_additive_monoid__rf_minus_right_substitution_rule _ _ 
    _ _ (Product_regular_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    Product_regular_additive_monoid__rf_minus_right_substitution_rule _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
  -->
  Product_regular_additive_monoid__rf_minus_right_substitution_rule.

def proj_Product_regular_additive_monoid__rf_pair_left_substitution_rule :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_regular_additive_monoid__me_as_species M1_T M2_T 
            _p_M1_equal _p_M2_equal) ->
  dk_logic.eP 
    (dk_logic.forall M1_T 
       (x_1:(cc.eT M1_T) =>
        dk_logic.forall M1_T 
          (x_2:(cc.eT M1_T) =>
           dk_logic.forall M2_T 
             (y:(cc.eT M2_T) =>
              dk_logic.imp (dk_logic.ebP (_p_M1_equal x_1 x_2)) 
                (dk_logic.ebP 
                   (proj_Product_regular_additive_monoid__rf_equal M1_T M2_T 
                      _p_M1_equal _p_M2_equal record 
                      (proj_Product_regular_additive_monoid__rf_pair M1_T 
                         M2_T _p_M1_equal _p_M2_equal record x_1 y) 
                      (proj_Product_regular_additive_monoid__rf_pair M1_T 
                         M2_T _p_M1_equal _p_M2_equal record x_2 y))))))).

[Product_regular_additive_monoid__rf_pair_left_substitution_rule]
  proj_Product_regular_additive_monoid__rf_pair_left_substitution_rule _ _ _ 
    _ (Product_regular_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    Product_regular_additive_monoid__rf_pair_left_substitution_rule _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
  -->
  Product_regular_additive_monoid__rf_pair_left_substitution_rule.

def proj_Product_regular_additive_monoid__rf_pair_right_substitution_rule :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_regular_additive_monoid__me_as_species M1_T M2_T 
            _p_M1_equal _p_M2_equal) ->
  dk_logic.eP 
    (dk_logic.forall M1_T 
       (x:(cc.eT M1_T) =>
        dk_logic.forall M2_T 
          (y_1:(cc.eT M2_T) =>
           dk_logic.forall M2_T 
             (y_2:(cc.eT M2_T) =>
              dk_logic.imp (dk_logic.ebP (_p_M2_equal y_1 y_2)) 
                (dk_logic.ebP 
                   (proj_Product_regular_additive_monoid__rf_equal M1_T M2_T 
                      _p_M1_equal _p_M2_equal record 
                      (proj_Product_regular_additive_monoid__rf_pair M1_T 
                         M2_T _p_M1_equal _p_M2_equal record x y_1) 
                      (proj_Product_regular_additive_monoid__rf_pair M1_T 
                         M2_T _p_M1_equal _p_M2_equal record x y_2))))))).

[Product_regular_additive_monoid__rf_pair_right_substitution_rule]
  proj_Product_regular_additive_monoid__rf_pair_right_substitution_rule _ _ 
    _ _ (Product_regular_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    Product_regular_additive_monoid__rf_pair_right_substitution_rule _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _)
  -->
  Product_regular_additive_monoid__rf_pair_right_substitution_rule.

def proj_Product_regular_additive_monoid__rf_second_accessibility :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_regular_additive_monoid__me_as_species M1_T M2_T 
            _p_M1_equal _p_M2_equal) ->
  dk_logic.eP 
    (dk_logic.forall M2_T 
       (x:(cc.eT M2_T) =>
        dk_logic.exists 
          (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
             _p_M2_equal record) 
          (s:
           (cc.eT 
              (proj_Product_regular_additive_monoid__rf_T M1_T M2_T 
                 _p_M1_equal _p_M2_equal record)) =>
           dk_logic.ebP 
             (_p_M2_equal 
                (proj_Product_regular_additive_monoid__rf_second M1_T M2_T 
                   _p_M1_equal _p_M2_equal record s) x)))).

[Product_regular_additive_monoid__rf_second_accessibility]
  proj_Product_regular_additive_monoid__rf_second_accessibility _ _ _ _ 
    (Product_regular_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    Product_regular_additive_monoid__rf_second_accessibility _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _)
  -->
  Product_regular_additive_monoid__rf_second_accessibility.

def proj_Product_regular_additive_monoid__rf_minus_is_well_defined :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_regular_additive_monoid__me_as_species M1_T M2_T 
            _p_M1_equal _p_M2_equal) ->
  dk_logic.eP 
    (dk_logic.forall 
       (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
          _p_M2_equal record) 
       (x:
        (cc.eT 
           (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
              _p_M2_equal record)) =>
        dk_logic.forall 
          (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
             _p_M2_equal record) 
          (y:
           (cc.eT 
              (proj_Product_regular_additive_monoid__rf_T M1_T M2_T 
                 _p_M1_equal _p_M2_equal record)) =>
           dk_logic.forall 
             (proj_Product_regular_additive_monoid__rf_T M1_T M2_T 
                _p_M1_equal _p_M2_equal record) 
             (z:
              (cc.eT 
                 (proj_Product_regular_additive_monoid__rf_T M1_T M2_T 
                    _p_M1_equal _p_M2_equal record)) =>
              dk_logic.imp 
                (dk_logic.ebP 
                   (proj_Product_regular_additive_monoid__rf_equal M1_T M2_T 
                      _p_M1_equal _p_M2_equal record x 
                      (proj_Product_regular_additive_monoid__rf_plus M1_T 
                         M2_T _p_M1_equal _p_M2_equal record z y))) 
                (dk_logic.and 
                   (dk_logic.ebP 
                      (proj_Product_regular_additive_monoid__rf_equal M1_T 
                         M2_T _p_M1_equal _p_M2_equal record 
                         (proj_Product_regular_additive_monoid__rf_minus 
                            M1_T M2_T _p_M1_equal _p_M2_equal record x y) z)) 
                   (dk_logic.ebP 
                      (proj_Product_regular_additive_monoid__rf_equal M1_T 
                         M2_T _p_M1_equal _p_M2_equal record 
                         (proj_Product_regular_additive_monoid__rf_minus 
                            M1_T M2_T _p_M1_equal _p_M2_equal record x z) y))))))).

[Product_regular_additive_monoid__rf_minus_is_well_defined]
  proj_Product_regular_additive_monoid__rf_minus_is_well_defined _ _ _ _ 
    (Product_regular_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    Product_regular_additive_monoid__rf_minus_is_well_defined _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _)
  -->
  Product_regular_additive_monoid__rf_minus_is_well_defined.

def proj_Product_regular_additive_monoid__rf_plus_is_associative :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_regular_additive_monoid__me_as_species M1_T M2_T 
            _p_M1_equal _p_M2_equal) ->
  dk_logic.eP 
    (dk_logic.forall 
       (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
          _p_M2_equal record) 
       (x:
        (cc.eT 
           (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
              _p_M2_equal record)) =>
        dk_logic.forall 
          (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
             _p_M2_equal record) 
          (y:
           (cc.eT 
              (proj_Product_regular_additive_monoid__rf_T M1_T M2_T 
                 _p_M1_equal _p_M2_equal record)) =>
           dk_logic.forall 
             (proj_Product_regular_additive_monoid__rf_T M1_T M2_T 
                _p_M1_equal _p_M2_equal record) 
             (z:
              (cc.eT 
                 (proj_Product_regular_additive_monoid__rf_T M1_T M2_T 
                    _p_M1_equal _p_M2_equal record)) =>
              dk_logic.ebP 
                (proj_Product_regular_additive_monoid__rf_equal M1_T M2_T 
                   _p_M1_equal _p_M2_equal record 
                   (proj_Product_regular_additive_monoid__rf_plus M1_T M2_T 
                      _p_M1_equal _p_M2_equal record x 
                      (proj_Product_regular_additive_monoid__rf_plus M1_T 
                         M2_T _p_M1_equal _p_M2_equal record y z)) 
                   (proj_Product_regular_additive_monoid__rf_plus M1_T M2_T 
                      _p_M1_equal _p_M2_equal record 
                      (proj_Product_regular_additive_monoid__rf_plus M1_T 
                         M2_T _p_M1_equal _p_M2_equal record x y) z)))))).

[Product_regular_additive_monoid__rf_plus_is_associative]
  proj_Product_regular_additive_monoid__rf_plus_is_associative _ _ _ _ 
    (Product_regular_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    Product_regular_additive_monoid__rf_plus_is_associative _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _)
  -->
  Product_regular_additive_monoid__rf_plus_is_associative.

def proj_Product_regular_additive_monoid__rf_plus_is_left_regular :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_regular_additive_monoid__me_as_species M1_T M2_T 
            _p_M1_equal _p_M2_equal) ->
  dk_logic.eP 
    (dk_logic.forall 
       (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
          _p_M2_equal record) 
       (x:
        (cc.eT 
           (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
              _p_M2_equal record)) =>
        dk_logic.forall 
          (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
             _p_M2_equal record) 
          (y:
           (cc.eT 
              (proj_Product_regular_additive_monoid__rf_T M1_T M2_T 
                 _p_M1_equal _p_M2_equal record)) =>
           dk_logic.forall 
             (proj_Product_regular_additive_monoid__rf_T M1_T M2_T 
                _p_M1_equal _p_M2_equal record) 
             (z:
              (cc.eT 
                 (proj_Product_regular_additive_monoid__rf_T M1_T M2_T 
                    _p_M1_equal _p_M2_equal record)) =>
              dk_logic.imp 
                (dk_logic.ebP 
                   (proj_Product_regular_additive_monoid__rf_equal M1_T M2_T 
                      _p_M1_equal _p_M2_equal record 
                      (proj_Product_regular_additive_monoid__rf_plus M1_T 
                         M2_T _p_M1_equal _p_M2_equal record x y) 
                      (proj_Product_regular_additive_monoid__rf_plus M1_T 
                         M2_T _p_M1_equal _p_M2_equal record x z))) 
                (dk_logic.ebP 
                   (proj_Product_regular_additive_monoid__rf_equal M1_T M2_T 
                      _p_M1_equal _p_M2_equal record y z)))))).

[Product_regular_additive_monoid__rf_plus_is_left_regular]
  proj_Product_regular_additive_monoid__rf_plus_is_left_regular _ _ _ _ 
    (Product_regular_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    Product_regular_additive_monoid__rf_plus_is_left_regular _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _)
  -->
  Product_regular_additive_monoid__rf_plus_is_left_regular.

def proj_Product_regular_additive_monoid__rf_zero_is_neutral :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_regular_additive_monoid__me_as_species M1_T M2_T 
            _p_M1_equal _p_M2_equal) ->
  dk_logic.eP 
    (dk_logic.forall 
       (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
          _p_M2_equal record) 
       (x:
        (cc.eT 
           (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
              _p_M2_equal record)) =>
        dk_logic.and 
          (dk_logic.ebP 
             (proj_Product_regular_additive_monoid__rf_equal M1_T M2_T 
                _p_M1_equal _p_M2_equal record 
                (proj_Product_regular_additive_monoid__rf_plus M1_T M2_T 
                   _p_M1_equal _p_M2_equal record x 
                   (proj_Product_regular_additive_monoid__rf_zero M1_T M2_T 
                      _p_M1_equal _p_M2_equal record)) x)) 
          (dk_logic.ebP 
             (proj_Product_regular_additive_monoid__rf_equal M1_T M2_T 
                _p_M1_equal _p_M2_equal record 
                (proj_Product_regular_additive_monoid__rf_plus M1_T M2_T 
                   _p_M1_equal _p_M2_equal record 
                   (proj_Product_regular_additive_monoid__rf_zero M1_T M2_T 
                      _p_M1_equal _p_M2_equal record) x) x)))).

[Product_regular_additive_monoid__rf_zero_is_neutral]
  proj_Product_regular_additive_monoid__rf_zero_is_neutral _ _ _ _ 
    (Product_regular_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    Product_regular_additive_monoid__rf_zero_is_neutral _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _)
  -->
  Product_regular_additive_monoid__rf_zero_is_neutral.

def proj_Product_regular_additive_monoid__rf_same_is_not_different :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_regular_additive_monoid__me_as_species M1_T M2_T 
            _p_M1_equal _p_M2_equal) ->
  dk_logic.eP 
    (dk_logic.forall 
       (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
          _p_M2_equal record) 
       (x:
        (cc.eT 
           (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
              _p_M2_equal record)) =>
        dk_logic.forall 
          (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
             _p_M2_equal record) 
          (y:
           (cc.eT 
              (proj_Product_regular_additive_monoid__rf_T M1_T M2_T 
                 _p_M1_equal _p_M2_equal record)) =>
           dk_logic.eqv 
             (dk_logic.ebP 
                (proj_Product_regular_additive_monoid__rf_different M1_T 
                   M2_T _p_M1_equal _p_M2_equal record x y)) 
             (dk_logic.not 
                (dk_logic.ebP 
                   (proj_Product_regular_additive_monoid__rf_equal M1_T M2_T 
                      _p_M1_equal _p_M2_equal record x y)))))).

[Product_regular_additive_monoid__rf_same_is_not_different]
  proj_Product_regular_additive_monoid__rf_same_is_not_different _ _ _ _ 
    (Product_regular_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    Product_regular_additive_monoid__rf_same_is_not_different _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _)
  -->
  Product_regular_additive_monoid__rf_same_is_not_different.

def proj_Product_regular_additive_monoid__rf_is_zero_spec :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_regular_additive_monoid__me_as_species M1_T M2_T 
            _p_M1_equal _p_M2_equal) ->
  dk_logic.eP 
    (dk_logic.forall 
       (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
          _p_M2_equal record) 
       (x:
        (cc.eT 
           (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
              _p_M2_equal record)) =>
        dk_logic.eqv 
          (dk_logic.ebP 
             (proj_Product_regular_additive_monoid__rf_is_zero M1_T M2_T 
                _p_M1_equal _p_M2_equal record x)) 
          (dk_logic.or 
             (dk_logic.ebP 
                (proj_Product_regular_additive_monoid__rf_equal M1_T M2_T 
                   _p_M1_equal _p_M2_equal record x 
                   (proj_Product_regular_additive_monoid__rf_zero M1_T M2_T 
                      _p_M1_equal _p_M2_equal record))) 
             (dk_logic.ebP 
                (proj_Product_regular_additive_monoid__rf_equal M1_T M2_T 
                   _p_M1_equal _p_M2_equal record 
                   (proj_Product_regular_additive_monoid__rf_zero M1_T M2_T 
                      _p_M1_equal _p_M2_equal record) x))))).

[Product_regular_additive_monoid__rf_is_zero_spec]
  proj_Product_regular_additive_monoid__rf_is_zero_spec _ _ _ _ 
    (Product_regular_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    Product_regular_additive_monoid__rf_is_zero_spec _ _ _ _ _ _ _ _ _ _ _ _ 
    _)
  -->
  Product_regular_additive_monoid__rf_is_zero_spec.

def proj_Product_regular_additive_monoid__rf_pair_substitution_rule :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_regular_additive_monoid__me_as_species M1_T M2_T 
            _p_M1_equal _p_M2_equal) ->
  dk_logic.eP 
    (dk_logic.forall M1_T 
       (x_1:(cc.eT M1_T) =>
        dk_logic.forall M1_T 
          (x_2:(cc.eT M1_T) =>
           dk_logic.forall M2_T 
             (y_1:(cc.eT M2_T) =>
              dk_logic.forall M2_T 
                (y_2:(cc.eT M2_T) =>
                 dk_logic.imp (dk_logic.ebP (_p_M1_equal x_1 x_2)) 
                   (dk_logic.imp (dk_logic.ebP (_p_M2_equal y_1 y_2)) 
                      (dk_logic.ebP 
                         (proj_Product_regular_additive_monoid__rf_equal 
                            M1_T M2_T _p_M1_equal _p_M2_equal record 
                            (proj_Product_regular_additive_monoid__rf_pair 
                               M1_T M2_T _p_M1_equal _p_M2_equal record x_1 
                               y_1) 
                            (proj_Product_regular_additive_monoid__rf_pair 
                               M1_T M2_T _p_M1_equal _p_M2_equal record x_2 
                               y_2))))))))).

[Product_regular_additive_monoid__rf_pair_substitution_rule]
  proj_Product_regular_additive_monoid__rf_pair_substitution_rule _ _ _ _ 
    (Product_regular_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    Product_regular_additive_monoid__rf_pair_substitution_rule _ _ _ _ _ _ _ 
    _ _ _ _ _)
  -->
  Product_regular_additive_monoid__rf_pair_substitution_rule.

def proj_Product_regular_additive_monoid__rf_zero_is_right_neutral_for_minus :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_regular_additive_monoid__me_as_species M1_T M2_T 
            _p_M1_equal _p_M2_equal) ->
  dk_logic.eP 
    (dk_logic.forall 
       (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
          _p_M2_equal record) 
       (x:
        (cc.eT 
           (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
              _p_M2_equal record)) =>
        dk_logic.ebP 
          (proj_Product_regular_additive_monoid__rf_equal M1_T M2_T 
             _p_M1_equal _p_M2_equal record 
             (proj_Product_regular_additive_monoid__rf_minus M1_T M2_T 
                _p_M1_equal _p_M2_equal record x 
                (proj_Product_regular_additive_monoid__rf_zero M1_T M2_T 
                   _p_M1_equal _p_M2_equal record)) x))).

[Product_regular_additive_monoid__rf_zero_is_right_neutral_for_minus]
  proj_Product_regular_additive_monoid__rf_zero_is_right_neutral_for_minus _ 
    _ _ _ (Product_regular_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    Product_regular_additive_monoid__rf_zero_is_right_neutral_for_minus _ _ 
    _ _ _ _ _ _ _ _ _)
  -->
  Product_regular_additive_monoid__rf_zero_is_right_neutral_for_minus.

def proj_Product_regular_additive_monoid__rf_zero_is_unique :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_regular_additive_monoid__me_as_species M1_T M2_T 
            _p_M1_equal _p_M2_equal) ->
  dk_logic.eP 
    (dk_logic.forall 
       (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
          _p_M2_equal record) 
       (o:
        (cc.eT 
           (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
              _p_M2_equal record)) =>
        dk_logic.imp 
          (dk_logic.forall 
             (proj_Product_regular_additive_monoid__rf_T M1_T M2_T 
                _p_M1_equal _p_M2_equal record) 
             (x:
              (cc.eT 
                 (proj_Product_regular_additive_monoid__rf_T M1_T M2_T 
                    _p_M1_equal _p_M2_equal record)) =>
              dk_logic.ebP 
                (proj_Product_regular_additive_monoid__rf_equal M1_T M2_T 
                   _p_M1_equal _p_M2_equal record x 
                   (proj_Product_regular_additive_monoid__rf_plus M1_T M2_T 
                      _p_M1_equal _p_M2_equal record x o)))) 
          (dk_logic.ebP 
             (proj_Product_regular_additive_monoid__rf_equal M1_T M2_T 
                _p_M1_equal _p_M2_equal record o 
                (proj_Product_regular_additive_monoid__rf_zero M1_T M2_T 
                   _p_M1_equal _p_M2_equal record))))).

[Product_regular_additive_monoid__rf_zero_is_unique]
  proj_Product_regular_additive_monoid__rf_zero_is_unique _ _ _ _ 
    (Product_regular_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    Product_regular_additive_monoid__rf_zero_is_unique _ _ _ _ _ _ _ _ _ _)
  -->
  Product_regular_additive_monoid__rf_zero_is_unique.

def proj_Product_regular_additive_monoid__rf_different_is_complete :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_regular_additive_monoid__me_as_species M1_T M2_T 
            _p_M1_equal _p_M2_equal) ->
  dk_logic.eP 
    (dk_logic.forall 
       (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
          _p_M2_equal record) 
       (x:
        (cc.eT 
           (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
              _p_M2_equal record)) =>
        dk_logic.forall 
          (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
             _p_M2_equal record) 
          (y:
           (cc.eT 
              (proj_Product_regular_additive_monoid__rf_T M1_T M2_T 
                 _p_M1_equal _p_M2_equal record)) =>
           dk_logic.forall 
             (proj_Product_regular_additive_monoid__rf_T M1_T M2_T 
                _p_M1_equal _p_M2_equal record) 
             (z:
              (cc.eT 
                 (proj_Product_regular_additive_monoid__rf_T M1_T M2_T 
                    _p_M1_equal _p_M2_equal record)) =>
              dk_logic.imp 
                (dk_logic.ebP 
                   (proj_Product_regular_additive_monoid__rf_different M1_T 
                      M2_T _p_M1_equal _p_M2_equal record x y)) 
                (dk_logic.or 
                   (dk_logic.ebP 
                      (proj_Product_regular_additive_monoid__rf_different 
                         M1_T M2_T _p_M1_equal _p_M2_equal record x z)) 
                   (dk_logic.ebP 
                      (proj_Product_regular_additive_monoid__rf_different 
                         M1_T M2_T _p_M1_equal _p_M2_equal record y z))))))).

[Product_regular_additive_monoid__rf_different_is_complete]
  proj_Product_regular_additive_monoid__rf_different_is_complete _ _ _ _ 
    (Product_regular_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    Product_regular_additive_monoid__rf_different_is_complete _ _ _ _ _ _ _ 
    _ _)
  -->
  Product_regular_additive_monoid__rf_different_is_complete.

def proj_Product_regular_additive_monoid__rf_different_is_irreflexive :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_regular_additive_monoid__me_as_species M1_T M2_T 
            _p_M1_equal _p_M2_equal) ->
  dk_logic.eP 
    (dk_logic.forall 
       (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
          _p_M2_equal record) 
       (x:
        (cc.eT 
           (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
              _p_M2_equal record)) =>
        dk_logic.not 
          (dk_logic.ebP 
             (proj_Product_regular_additive_monoid__rf_different M1_T M2_T 
                _p_M1_equal _p_M2_equal record x x)))).

[Product_regular_additive_monoid__rf_different_is_irreflexive]
  proj_Product_regular_additive_monoid__rf_different_is_irreflexive _ _ _ _ 
    (Product_regular_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    Product_regular_additive_monoid__rf_different_is_irreflexive _ _ _ _ _ _ 
    _ _)
  -->
  Product_regular_additive_monoid__rf_different_is_irreflexive.

def proj_Product_regular_additive_monoid__rf_different_is_symmetric :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_regular_additive_monoid__me_as_species M1_T M2_T 
            _p_M1_equal _p_M2_equal) ->
  dk_logic.eP 
    (dk_logic.forall 
       (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
          _p_M2_equal record) 
       (x:
        (cc.eT 
           (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
              _p_M2_equal record)) =>
        dk_logic.forall 
          (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
             _p_M2_equal record) 
          (y:
           (cc.eT 
              (proj_Product_regular_additive_monoid__rf_T M1_T M2_T 
                 _p_M1_equal _p_M2_equal record)) =>
           dk_logic.imp 
             (dk_logic.ebP 
                (proj_Product_regular_additive_monoid__rf_different M1_T 
                   M2_T _p_M1_equal _p_M2_equal record x y)) 
             (dk_logic.ebP 
                (proj_Product_regular_additive_monoid__rf_different M1_T 
                   M2_T _p_M1_equal _p_M2_equal record y x))))).

[Product_regular_additive_monoid__rf_different_is_symmetric]
  proj_Product_regular_additive_monoid__rf_different_is_symmetric _ _ _ _ 
    (Product_regular_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    Product_regular_additive_monoid__rf_different_is_symmetric _ _ _ _ _ _ _)
  -->
  Product_regular_additive_monoid__rf_different_is_symmetric.

def proj_Product_regular_additive_monoid__rf_zero_checks_to_zero :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_regular_additive_monoid__me_as_species M1_T M2_T 
            _p_M1_equal _p_M2_equal) ->
  dk_logic.eP 
    (dk_logic.ebP 
       (proj_Product_regular_additive_monoid__rf_is_zero M1_T M2_T 
          _p_M1_equal _p_M2_equal record 
          (proj_Product_regular_additive_monoid__rf_zero M1_T M2_T 
             _p_M1_equal _p_M2_equal record))).

[Product_regular_additive_monoid__rf_zero_checks_to_zero]
  proj_Product_regular_additive_monoid__rf_zero_checks_to_zero _ _ _ _ 
    (Product_regular_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    Product_regular_additive_monoid__rf_zero_checks_to_zero _ _ _ _ _ _)
  -->
  Product_regular_additive_monoid__rf_zero_checks_to_zero.

def proj_Product_regular_additive_monoid__rf_plus_commutes :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_regular_additive_monoid__me_as_species M1_T M2_T 
            _p_M1_equal _p_M2_equal) ->
  dk_logic.eP 
    (dk_logic.forall 
       (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
          _p_M2_equal record) 
       (x:
        (cc.eT 
           (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
              _p_M2_equal record)) =>
        dk_logic.forall 
          (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
             _p_M2_equal record) 
          (y:
           (cc.eT 
              (proj_Product_regular_additive_monoid__rf_T M1_T M2_T 
                 _p_M1_equal _p_M2_equal record)) =>
           dk_logic.ebP 
             (proj_Product_regular_additive_monoid__rf_equal M1_T M2_T 
                _p_M1_equal _p_M2_equal record 
                (proj_Product_regular_additive_monoid__rf_plus M1_T M2_T 
                   _p_M1_equal _p_M2_equal record x y) 
                (proj_Product_regular_additive_monoid__rf_plus M1_T M2_T 
                   _p_M1_equal _p_M2_equal record y x))))).

[Product_regular_additive_monoid__rf_plus_commutes]
  proj_Product_regular_additive_monoid__rf_plus_commutes _ _ _ _ 
    (Product_regular_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    Product_regular_additive_monoid__rf_plus_commutes _ _ _ _ _)
  -->
  Product_regular_additive_monoid__rf_plus_commutes.

def proj_Product_regular_additive_monoid__rf_plus_right_substitution_rule :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_regular_additive_monoid__me_as_species M1_T M2_T 
            _p_M1_equal _p_M2_equal) ->
  dk_logic.eP 
    (dk_logic.forall 
       (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
          _p_M2_equal record) 
       (x:
        (cc.eT 
           (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
              _p_M2_equal record)) =>
        dk_logic.forall 
          (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
             _p_M2_equal record) 
          (y:
           (cc.eT 
              (proj_Product_regular_additive_monoid__rf_T M1_T M2_T 
                 _p_M1_equal _p_M2_equal record)) =>
           dk_logic.forall 
             (proj_Product_regular_additive_monoid__rf_T M1_T M2_T 
                _p_M1_equal _p_M2_equal record) 
             (z:
              (cc.eT 
                 (proj_Product_regular_additive_monoid__rf_T M1_T M2_T 
                    _p_M1_equal _p_M2_equal record)) =>
              dk_logic.imp 
                (dk_logic.ebP 
                   (proj_Product_regular_additive_monoid__rf_equal M1_T M2_T 
                      _p_M1_equal _p_M2_equal record x y)) 
                (dk_logic.ebP 
                   (proj_Product_regular_additive_monoid__rf_equal M1_T M2_T 
                      _p_M1_equal _p_M2_equal record 
                      (proj_Product_regular_additive_monoid__rf_plus M1_T 
                         M2_T _p_M1_equal _p_M2_equal record z x) 
                      (proj_Product_regular_additive_monoid__rf_plus M1_T 
                         M2_T _p_M1_equal _p_M2_equal record z y))))))).

[Product_regular_additive_monoid__rf_plus_right_substitution_rule]
  proj_Product_regular_additive_monoid__rf_plus_right_substitution_rule _ _ 
    _ _ (Product_regular_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    Product_regular_additive_monoid__rf_plus_right_substitution_rule _ _ _ _)
  -->
  Product_regular_additive_monoid__rf_plus_right_substitution_rule.

def proj_Product_regular_additive_monoid__rf_plus_is_right_regular :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_regular_additive_monoid__me_as_species M1_T M2_T 
            _p_M1_equal _p_M2_equal) ->
  dk_logic.eP 
    (dk_logic.forall 
       (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
          _p_M2_equal record) 
       (x:
        (cc.eT 
           (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
              _p_M2_equal record)) =>
        dk_logic.forall 
          (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
             _p_M2_equal record) 
          (y:
           (cc.eT 
              (proj_Product_regular_additive_monoid__rf_T M1_T M2_T 
                 _p_M1_equal _p_M2_equal record)) =>
           dk_logic.forall 
             (proj_Product_regular_additive_monoid__rf_T M1_T M2_T 
                _p_M1_equal _p_M2_equal record) 
             (z:
              (cc.eT 
                 (proj_Product_regular_additive_monoid__rf_T M1_T M2_T 
                    _p_M1_equal _p_M2_equal record)) =>
              dk_logic.imp 
                (dk_logic.ebP 
                   (proj_Product_regular_additive_monoid__rf_equal M1_T M2_T 
                      _p_M1_equal _p_M2_equal record 
                      (proj_Product_regular_additive_monoid__rf_plus M1_T 
                         M2_T _p_M1_equal _p_M2_equal record x z) 
                      (proj_Product_regular_additive_monoid__rf_plus M1_T 
                         M2_T _p_M1_equal _p_M2_equal record y z))) 
                (dk_logic.ebP 
                   (proj_Product_regular_additive_monoid__rf_equal M1_T M2_T 
                      _p_M1_equal _p_M2_equal record x y)))))).

[Product_regular_additive_monoid__rf_plus_is_right_regular]
  proj_Product_regular_additive_monoid__rf_plus_is_right_regular _ _ _ _ 
    (Product_regular_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    Product_regular_additive_monoid__rf_plus_is_right_regular _ _ _)
  -->
  Product_regular_additive_monoid__rf_plus_is_right_regular.

def proj_Product_regular_additive_monoid__rf_plus_left_substitution_rule :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_regular_additive_monoid__me_as_species M1_T M2_T 
            _p_M1_equal _p_M2_equal) ->
  dk_logic.eP 
    (dk_logic.forall 
       (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
          _p_M2_equal record) 
       (x:
        (cc.eT 
           (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
              _p_M2_equal record)) =>
        dk_logic.forall 
          (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
             _p_M2_equal record) 
          (y:
           (cc.eT 
              (proj_Product_regular_additive_monoid__rf_T M1_T M2_T 
                 _p_M1_equal _p_M2_equal record)) =>
           dk_logic.forall 
             (proj_Product_regular_additive_monoid__rf_T M1_T M2_T 
                _p_M1_equal _p_M2_equal record) 
             (z:
              (cc.eT 
                 (proj_Product_regular_additive_monoid__rf_T M1_T M2_T 
                    _p_M1_equal _p_M2_equal record)) =>
              dk_logic.imp 
                (dk_logic.ebP 
                   (proj_Product_regular_additive_monoid__rf_equal M1_T M2_T 
                      _p_M1_equal _p_M2_equal record x y)) 
                (dk_logic.ebP 
                   (proj_Product_regular_additive_monoid__rf_equal M1_T M2_T 
                      _p_M1_equal _p_M2_equal record 
                      (proj_Product_regular_additive_monoid__rf_plus M1_T 
                         M2_T _p_M1_equal _p_M2_equal record x z) 
                      (proj_Product_regular_additive_monoid__rf_plus M1_T 
                         M2_T _p_M1_equal _p_M2_equal record y z))))))).

[Product_regular_additive_monoid__rf_plus_left_substitution_rule]
  proj_Product_regular_additive_monoid__rf_plus_left_substitution_rule _ _ _ 
    _ (Product_regular_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    Product_regular_additive_monoid__rf_plus_left_substitution_rule _ _)
  -->
  Product_regular_additive_monoid__rf_plus_left_substitution_rule.

def proj_Product_regular_additive_monoid__rf_plus_is_regular :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_regular_additive_monoid__me_as_species M1_T M2_T 
            _p_M1_equal _p_M2_equal) ->
  dk_logic.eP 
    (dk_logic.forall 
       (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
          _p_M2_equal record) 
       (x:
        (cc.eT 
           (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
              _p_M2_equal record)) =>
        dk_logic.forall 
          (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
             _p_M2_equal record) 
          (y:
           (cc.eT 
              (proj_Product_regular_additive_monoid__rf_T M1_T M2_T 
                 _p_M1_equal _p_M2_equal record)) =>
           dk_logic.forall 
             (proj_Product_regular_additive_monoid__rf_T M1_T M2_T 
                _p_M1_equal _p_M2_equal record) 
             (z:
              (cc.eT 
                 (proj_Product_regular_additive_monoid__rf_T M1_T M2_T 
                    _p_M1_equal _p_M2_equal record)) =>
              dk_logic.and 
                (dk_logic.imp 
                   (dk_logic.ebP 
                      (proj_Product_regular_additive_monoid__rf_equal M1_T 
                         M2_T _p_M1_equal _p_M2_equal record 
                         (proj_Product_regular_additive_monoid__rf_plus M1_T 
                            M2_T _p_M1_equal _p_M2_equal record x y) 
                         (proj_Product_regular_additive_monoid__rf_plus M1_T 
                            M2_T _p_M1_equal _p_M2_equal record x z))) 
                   (dk_logic.ebP 
                      (proj_Product_regular_additive_monoid__rf_equal M1_T 
                         M2_T _p_M1_equal _p_M2_equal record y z))) 
                (dk_logic.imp 
                   (dk_logic.ebP 
                      (proj_Product_regular_additive_monoid__rf_equal M1_T 
                         M2_T _p_M1_equal _p_M2_equal record 
                         (proj_Product_regular_additive_monoid__rf_plus M1_T 
                            M2_T _p_M1_equal _p_M2_equal record x z) 
                         (proj_Product_regular_additive_monoid__rf_plus M1_T 
                            M2_T _p_M1_equal _p_M2_equal record y z))) 
                   (dk_logic.ebP 
                      (proj_Product_regular_additive_monoid__rf_equal M1_T 
                         M2_T _p_M1_equal _p_M2_equal record x y))))))).

[Product_regular_additive_monoid__rf_plus_is_regular]
  proj_Product_regular_additive_monoid__rf_plus_is_regular _ _ _ _ 
    (Product_regular_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    Product_regular_additive_monoid__rf_plus_is_regular _)
  -->
  Product_regular_additive_monoid__rf_plus_is_regular.

def proj_Product_regular_additive_monoid__rf_plus_substitution_rule :
  M1_T:cc.uT ->
  M2_T:cc.uT ->
  _p_M1_equal:((cc.eT M1_T) -> (cc.eT M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT M2_T) -> (cc.eT M2_T) -> cc.eT basics.bool__t) ->
  record:(Product_regular_additive_monoid__me_as_species M1_T M2_T 
            _p_M1_equal _p_M2_equal) ->
  dk_logic.eP 
    (dk_logic.forall 
       (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
          _p_M2_equal record) 
       (x1:
        (cc.eT 
           (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
              _p_M2_equal record)) =>
        dk_logic.forall 
          (proj_Product_regular_additive_monoid__rf_T M1_T M2_T _p_M1_equal 
             _p_M2_equal record) 
          (x2:
           (cc.eT 
              (proj_Product_regular_additive_monoid__rf_T M1_T M2_T 
                 _p_M1_equal _p_M2_equal record)) =>
           dk_logic.forall 
             (proj_Product_regular_additive_monoid__rf_T M1_T M2_T 
                _p_M1_equal _p_M2_equal record) 
             (y1:
              (cc.eT 
                 (proj_Product_regular_additive_monoid__rf_T M1_T M2_T 
                    _p_M1_equal _p_M2_equal record)) =>
              dk_logic.forall 
                (proj_Product_regular_additive_monoid__rf_T M1_T M2_T 
                   _p_M1_equal _p_M2_equal record) 
                (y2:
                 (cc.eT 
                    (proj_Product_regular_additive_monoid__rf_T M1_T M2_T 
                       _p_M1_equal _p_M2_equal record)) =>
                 dk_logic.imp 
                   (dk_logic.ebP 
                      (proj_Product_regular_additive_monoid__rf_equal M1_T 
                         M2_T _p_M1_equal _p_M2_equal record x1 x2)) 
                   (dk_logic.imp 
                      (dk_logic.ebP 
                         (proj_Product_regular_additive_monoid__rf_equal 
                            M1_T M2_T _p_M1_equal _p_M2_equal record y1 y2)) 
                      (dk_logic.ebP 
                         (proj_Product_regular_additive_monoid__rf_equal 
                            M1_T M2_T _p_M1_equal _p_M2_equal record 
                            (proj_Product_regular_additive_monoid__rf_plus 
                               M1_T M2_T _p_M1_equal _p_M2_equal record x1 y1) 
                            (proj_Product_regular_additive_monoid__rf_plus 
                               M1_T M2_T _p_M1_equal _p_M2_equal record x2 y2))))))))).

[Product_regular_additive_monoid__rf_plus_substitution_rule]
  proj_Product_regular_additive_monoid__rf_plus_substitution_rule _ _ _ _ 
    (Product_regular_additive_monoid__mk_record _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
    Product_regular_additive_monoid__rf_plus_substitution_rule)
  -->
  Product_regular_additive_monoid__rf_plus_substitution_rule.

def Product_regular_additive_monoid__minus :
  _p_M1_T:cc.uT ->
  _p_M2_T:cc.uT ->
  _p_M1_minus:((cc.eT _p_M1_T) -> (cc.eT _p_M1_T) -> cc.eT _p_M1_T) ->
  _p_M2_minus:((cc.eT _p_M2_T) -> (cc.eT _p_M2_T) -> cc.eT _p_M2_T) ->
  abst_first:((cc.eT (dk_tuple.prod _p_M1_T _p_M2_T)) -> cc.eT _p_M1_T) ->
  abst_second:((cc.eT (dk_tuple.prod _p_M1_T _p_M2_T)) -> cc.eT _p_M2_T) ->
  a:(cc.eT (dk_tuple.prod _p_M1_T _p_M2_T)) ->
  b:(cc.eT (dk_tuple.prod _p_M1_T _p_M2_T)) ->
  cc.eT (dk_tuple.prod _p_M1_T _p_M2_T)
  :=
  _p_M1_T:cc.uT =>
  _p_M2_T:cc.uT =>
  _p_M1_minus:((cc.eT _p_M1_T) -> (cc.eT _p_M1_T) -> cc.eT _p_M1_T) =>
  _p_M2_minus:((cc.eT _p_M2_T) -> (cc.eT _p_M2_T) -> cc.eT _p_M2_T) =>
  abst_first:((cc.eT (dk_tuple.prod _p_M1_T _p_M2_T)) -> cc.eT _p_M1_T) =>
  abst_second:((cc.eT (dk_tuple.prod _p_M1_T _p_M2_T)) -> cc.eT _p_M2_T) =>
  a:(cc.eT (dk_tuple.prod _p_M1_T _p_M2_T)) =>
  b:(cc.eT (dk_tuple.prod _p_M1_T _p_M2_T)) =>
  (a1:(cc.eT _p_M1_T) =>
   (a2:(cc.eT _p_M2_T) =>
    (b1:(cc.eT _p_M1_T) =>
     (b2:(cc.eT _p_M2_T) =>
      dk_tuple.pair _p_M1_T _p_M2_T (_p_M1_minus a1 b1) (_p_M2_minus a2 b2)) 
       (abst_second b)) (abst_first b)) (abst_second a)) (abst_first a).

def Product_regular_additive_monoid__minus_left_substitution_rule :
  _p_M1_T:cc.uT ->
  _p_M2_T:cc.uT ->
  abst_T:cc.uT ->
  abst_equal:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) ->
  abst_minus:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT abst_T) ->
  dk_logic.eP 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.forall abst_T 
             (z:(cc.eT abst_T) =>
              dk_logic.imp (dk_logic.ebP (abst_equal x y)) 
                (dk_logic.ebP (abst_equal (abst_minus x z) (abst_minus y z)))))))
  :=
  _p_M1_T:cc.uT =>
  _p_M2_T:cc.uT =>
  abst_T:cc.uT =>
  abst_equal:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) =>
  abst_minus:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT abst_T) =>
  dk_builtins.magic_prove 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.forall abst_T 
             (z:(cc.eT abst_T) =>
              dk_logic.imp (dk_logic.ebP (abst_equal x y)) 
                (dk_logic.ebP (abst_equal (abst_minus x z) (abst_minus y z))))))).

def Product_regular_additive_monoid__minus_right_substitution_rule :
  _p_M1_T:cc.uT ->
  _p_M2_T:cc.uT ->
  abst_T:cc.uT ->
  abst_equal:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) ->
  abst_minus:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT abst_T) ->
  dk_logic.eP 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.forall abst_T 
             (z:(cc.eT abst_T) =>
              dk_logic.imp (dk_logic.ebP (abst_equal y z)) 
                (dk_logic.ebP (abst_equal (abst_minus x y) (abst_minus x z)))))))
  :=
  _p_M1_T:cc.uT =>
  _p_M2_T:cc.uT =>
  abst_T:cc.uT =>
  abst_equal:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) =>
  abst_minus:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT abst_T) =>
  dk_builtins.magic_prove 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.forall abst_T 
             (z:(cc.eT abst_T) =>
              dk_logic.imp (dk_logic.ebP (abst_equal y z)) 
                (dk_logic.ebP (abst_equal (abst_minus x y) (abst_minus x z))))))).

def Product_regular_additive_monoid__minus_is_well_defined :
  _p_M1_T:cc.uT ->
  _p_M2_T:cc.uT ->
  abst_T:cc.uT ->
  abst_equal:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) ->
  abst_minus:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT abst_T) ->
  abst_plus:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT abst_T) ->
  dk_logic.eP 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.forall abst_T 
             (z:(cc.eT abst_T) =>
              dk_logic.imp (dk_logic.ebP (abst_equal x (abst_plus z y))) 
                (dk_logic.and (dk_logic.ebP (abst_equal (abst_minus x y) z)) 
                   (dk_logic.ebP (abst_equal (abst_minus x z) y)))))))
  :=
  _p_M1_T:cc.uT =>
  _p_M2_T:cc.uT =>
  abst_T:cc.uT =>
  abst_equal:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) =>
  abst_minus:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT abst_T) =>
  abst_plus:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT abst_T) =>
  dk_builtins.magic_prove 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.forall abst_T 
             (z:(cc.eT abst_T) =>
              dk_logic.imp (dk_logic.ebP (abst_equal x (abst_plus z y))) 
                (dk_logic.and (dk_logic.ebP (abst_equal (abst_minus x y) z)) 
                   (dk_logic.ebP (abst_equal (abst_minus x z) y))))))).

def Product_regular_additive_monoid__plus_is_left_regular :
  _p_M1_T:cc.uT ->
  _p_M2_T:cc.uT ->
  abst_T:cc.uT ->
  abst_equal:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) ->
  abst_plus:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT abst_T) ->
  dk_logic.eP 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.forall abst_T 
             (z:(cc.eT abst_T) =>
              dk_logic.imp 
                (dk_logic.ebP (abst_equal (abst_plus x y) (abst_plus x z))) 
                (dk_logic.ebP (abst_equal y z))))))
  :=
  _p_M1_T:cc.uT =>
  _p_M2_T:cc.uT =>
  abst_T:cc.uT =>
  abst_equal:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) =>
  abst_plus:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT abst_T) =>
  dk_builtins.magic_prove 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.forall abst_T 
             (z:(cc.eT abst_T) =>
              dk_logic.imp 
                (dk_logic.ebP (abst_equal (abst_plus x y) (abst_plus x z))) 
                (dk_logic.ebP (abst_equal y z)))))).

def Product_regular_additive_monoid__collection_create
  :=
  _p_M1_T:cc.uT =>
  _p_M2_T:cc.uT =>
  _p_M1_equal:((cc.eT _p_M1_T) -> (cc.eT _p_M1_T) -> cc.eT basics.bool__t) =>
  _p_M1_minus:((cc.eT _p_M1_T) -> (cc.eT _p_M1_T) -> cc.eT _p_M1_T) =>
  _p_M1_plus:((cc.eT _p_M1_T) -> (cc.eT _p_M1_T) -> cc.eT _p_M1_T) =>
  _p_M1_zero:(cc.eT _p_M1_T) =>
  _p_M1_equal_reflexive:
  (dk_logic.eP 
     (dk_logic.forall _p_M1_T 
        (x:(cc.eT _p_M1_T) => dk_logic.ebP (_p_M1_equal x x)))) =>
  _p_M1_equal_symmetric:
  (dk_logic.eP 
     (dk_logic.forall _p_M1_T 
        (x:(cc.eT _p_M1_T) =>
         dk_logic.forall _p_M1_T 
           (y:(cc.eT _p_M1_T) =>
            dk_logic.imp (dk_logic.ebP (_p_M1_equal x y)) 
              (dk_logic.ebP (_p_M1_equal y x)))))) =>
  _p_M1_equal_transitive:
  (dk_logic.eP 
     (dk_logic.forall _p_M1_T 
        (x:(cc.eT _p_M1_T) =>
         dk_logic.forall _p_M1_T 
           (y:(cc.eT _p_M1_T) =>
            dk_logic.forall _p_M1_T 
              (z:(cc.eT _p_M1_T) =>
               dk_logic.imp (dk_logic.ebP (_p_M1_equal x y)) 
                 (dk_logic.imp (dk_logic.ebP (_p_M1_equal y z)) 
                    (dk_logic.ebP (_p_M1_equal x z)))))))) =>
  _p_M1_plus_commutes:
  (dk_logic.eP 
     (dk_logic.forall _p_M1_T 
        (x:(cc.eT _p_M1_T) =>
         dk_logic.forall _p_M1_T 
           (y:(cc.eT _p_M1_T) =>
            dk_logic.ebP (_p_M1_equal (_p_M1_plus x y) (_p_M1_plus y x)))))) =>
  _p_M1_plus_right_substitution_rule:
  (dk_logic.eP 
     (dk_logic.forall _p_M1_T 
        (x:(cc.eT _p_M1_T) =>
         dk_logic.forall _p_M1_T 
           (y:(cc.eT _p_M1_T) =>
            dk_logic.forall _p_M1_T 
              (z:(cc.eT _p_M1_T) =>
               dk_logic.imp (dk_logic.ebP (_p_M1_equal x y)) 
                 (dk_logic.ebP 
                    (_p_M1_equal (_p_M1_plus z x) (_p_M1_plus z y)))))))) =>
  _p_M1_element:(cc.eT _p_M1_T) =>
  _p_M2_equal:((cc.eT _p_M2_T) -> (cc.eT _p_M2_T) -> cc.eT basics.bool__t) =>
  _p_M2_minus:((cc.eT _p_M2_T) -> (cc.eT _p_M2_T) -> cc.eT _p_M2_T) =>
  _p_M2_plus:((cc.eT _p_M2_T) -> (cc.eT _p_M2_T) -> cc.eT _p_M2_T) =>
  _p_M2_zero:(cc.eT _p_M2_T) =>
  _p_M2_equal_reflexive:
  (dk_logic.eP 
     (dk_logic.forall _p_M2_T 
        (x:(cc.eT _p_M2_T) => dk_logic.ebP (_p_M2_equal x x)))) =>
  _p_M2_equal_symmetric:
  (dk_logic.eP 
     (dk_logic.forall _p_M2_T 
        (x:(cc.eT _p_M2_T) =>
         dk_logic.forall _p_M2_T 
           (y:(cc.eT _p_M2_T) =>
            dk_logic.imp (dk_logic.ebP (_p_M2_equal x y)) 
              (dk_logic.ebP (_p_M2_equal y x)))))) =>
  _p_M2_equal_transitive:
  (dk_logic.eP 
     (dk_logic.forall _p_M2_T 
        (x:(cc.eT _p_M2_T) =>
         dk_logic.forall _p_M2_T 
           (y:(cc.eT _p_M2_T) =>
            dk_logic.forall _p_M2_T 
              (z:(cc.eT _p_M2_T) =>
               dk_logic.imp (dk_logic.ebP (_p_M2_equal x y)) 
                 (dk_logic.imp (dk_logic.ebP (_p_M2_equal y z)) 
                    (dk_logic.ebP (_p_M2_equal x z)))))))) =>
  _p_M2_plus_commutes:
  (dk_logic.eP 
     (dk_logic.forall _p_M2_T 
        (x:(cc.eT _p_M2_T) =>
         dk_logic.forall _p_M2_T 
           (y:(cc.eT _p_M2_T) =>
            dk_logic.ebP (_p_M2_equal (_p_M2_plus x y) (_p_M2_plus y x)))))) =>
  _p_M2_plus_right_substitution_rule:
  (dk_logic.eP 
     (dk_logic.forall _p_M2_T 
        (x:(cc.eT _p_M2_T) =>
         dk_logic.forall _p_M2_T 
           (y:(cc.eT _p_M2_T) =>
            dk_logic.forall _p_M2_T 
              (z:(cc.eT _p_M2_T) =>
               dk_logic.imp (dk_logic.ebP (_p_M2_equal x y)) 
                 (dk_logic.ebP 
                    (_p_M2_equal (_p_M2_plus z x) (_p_M2_plus z y)))))))) =>
  _p_M2_element:(cc.eT _p_M2_T) =>
  Product_regular_additive_monoid__mk_record _p_M1_T _p_M2_T _p_M1_equal 
    _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
    (products.Cartesian_product__first _p_M1_T _p_M2_T) 
    (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
    (basics.Basic_object__parse (dk_tuple.prod _p_M1_T _p_M2_T)) 
    (basics.Basic_object__print (dk_tuple.prod _p_M1_T _p_M2_T)) 
    (products.Cartesian_product__second _p_M1_T _p_M2_T) 
    (Product_additive_monoid__zero _p_M1_T _p_M2_T _p_M1_zero _p_M2_zero) 
    (products.Product_set__element _p_M1_T _p_M2_T _p_M1_element 
       _p_M2_element (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Cartesian_product__pair _p_M1_T _p_M2_T)) 
    (products.Cartesian_product__pair_preserves_first _p_M1_T _p_M2_T 
       _p_M1_equal _p_M1_equal_reflexive) 
    (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal _p_M2_equal 
       (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Cartesian_product__first _p_M1_T _p_M2_T) 
       (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
    (Product_regular_additive_monoid__minus _p_M1_T _p_M2_T _p_M1_minus 
       _p_M2_minus (products.Cartesian_product__first _p_M1_T _p_M2_T) 
       (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
    (products.Cartesian_product__pair_preserves_second _p_M1_T _p_M2_T 
       _p_M2_equal _p_M2_equal_reflexive) 
    (Product_additive_monoid__plus _p_M1_T _p_M2_T _p_M1_plus _p_M2_plus 
       (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Cartesian_product__first _p_M1_T _p_M2_T) 
       (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
       (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
    (sets.Partial_set__failed (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Product_set__element _p_M1_T _p_M2_T _p_M1_element 
          _p_M2_element (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__pair _p_M1_T _p_M2_T))) 
    (products.Product_set__first_accessibility _p_M1_T _p_M2_T _p_M1_equal 
       _p_M2_element (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Cartesian_product__first _p_M1_T _p_M2_T) 
       (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
       (products.Cartesian_product__pair_preserves_first _p_M1_T _p_M2_T 
          _p_M1_equal _p_M1_equal_reflexive)) 
    (sets.Setoid__different (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal _p_M2_equal 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T))) 
    (products.Product_set__equal_reflexive _p_M1_T _p_M2_T _p_M1_equal 
       _p_M1_equal_reflexive _p_M2_equal _p_M2_equal_reflexive 
       (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Cartesian_product__first _p_M1_T _p_M2_T) 
       (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
    (products.Product_set__equal_spec _p_M1_T _p_M2_T _p_M1_equal 
       _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Cartesian_product__first _p_M1_T _p_M2_T) 
       (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
    (products.Product_set__equal_symmetric _p_M1_T _p_M2_T _p_M1_equal 
       _p_M1_equal_symmetric _p_M2_equal _p_M2_equal_symmetric 
       (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Cartesian_product__first _p_M1_T _p_M2_T) 
       (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
    (products.Product_set__equal_transitive _p_M1_T _p_M2_T _p_M1_equal 
       _p_M1_equal_transitive _p_M2_equal _p_M2_equal_transitive 
       (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Cartesian_product__first _p_M1_T _p_M2_T) 
       (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
    (products.Product_set__first_substitution_rule _p_M1_T _p_M2_T 
       _p_M1_equal _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Cartesian_product__first _p_M1_T _p_M2_T) 
       (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
    (constants.Setoid_with_zero__is_zero (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal _p_M2_equal 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (Product_additive_monoid__zero _p_M1_T _p_M2_T _p_M1_zero _p_M2_zero)) 
    (products.Product_set__second_substitution_rule _p_M1_T _p_M2_T 
       _p_M1_equal _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Cartesian_product__first _p_M1_T _p_M2_T) 
       (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
    (Product_regular_additive_monoid__minus_left_substitution_rule _p_M1_T 
       _p_M2_T (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal _p_M2_equal 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (Product_regular_additive_monoid__minus _p_M1_T _p_M2_T _p_M1_minus 
          _p_M2_minus (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T))) 
    (Product_regular_additive_monoid__minus_right_substitution_rule _p_M1_T 
       _p_M2_T (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal _p_M2_equal 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (Product_regular_additive_monoid__minus _p_M1_T _p_M2_T _p_M1_minus 
          _p_M2_minus (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T))) 
    (products.Product_set__pair_left_substitution_rule _p_M1_T _p_M2_T 
       _p_M1_equal _p_M1_equal_symmetric _p_M1_equal_transitive _p_M2_equal 
       _p_M2_equal_reflexive _p_M2_equal_symmetric _p_M2_equal_transitive 
       (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Cartesian_product__first _p_M1_T _p_M2_T) 
       (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
       (products.Cartesian_product__second _p_M1_T _p_M2_T) 
       (products.Cartesian_product__pair_preserves_first _p_M1_T _p_M2_T 
          _p_M1_equal _p_M1_equal_reflexive) 
       (products.Cartesian_product__pair_preserves_second _p_M1_T _p_M2_T 
          _p_M2_equal _p_M2_equal_reflexive)) 
    (products.Product_set__pair_right_substitution_rule _p_M1_T _p_M2_T 
       _p_M1_equal _p_M1_equal_reflexive _p_M1_equal_symmetric 
       _p_M1_equal_transitive _p_M2_equal _p_M2_equal_symmetric 
       _p_M2_equal_transitive (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Cartesian_product__first _p_M1_T _p_M2_T) 
       (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
       (products.Cartesian_product__second _p_M1_T _p_M2_T) 
       (products.Cartesian_product__pair_preserves_first _p_M1_T _p_M2_T 
          _p_M1_equal _p_M1_equal_reflexive) 
       (products.Cartesian_product__pair_preserves_second _p_M1_T _p_M2_T 
          _p_M2_equal _p_M2_equal_reflexive)) 
    (products.Product_set__second_accessibility _p_M1_T _p_M2_T 
       _p_M1_element _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
       (products.Cartesian_product__second _p_M1_T _p_M2_T) 
       (products.Cartesian_product__pair_preserves_second _p_M1_T _p_M2_T 
          _p_M2_equal _p_M2_equal_reflexive)) 
    (Product_regular_additive_monoid__minus_is_well_defined _p_M1_T _p_M2_T 
       (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal _p_M2_equal 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (Product_regular_additive_monoid__minus _p_M1_T _p_M2_T _p_M1_minus 
          _p_M2_minus (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (Product_additive_monoid__plus _p_M1_T _p_M2_T _p_M1_plus _p_M2_plus 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T))) 
    (Product_additive_monoid__plus_is_associative _p_M1_T _p_M2_T 
       (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal _p_M2_equal 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (Product_additive_monoid__plus _p_M1_T _p_M2_T _p_M1_plus _p_M2_plus 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T))) 
    (Product_regular_additive_monoid__plus_is_left_regular _p_M1_T _p_M2_T 
       (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal _p_M2_equal 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (Product_additive_monoid__plus _p_M1_T _p_M2_T _p_M1_plus _p_M2_plus 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T))) 
    (Product_additive_monoid__zero_is_neutral _p_M1_T _p_M2_T 
       (dk_tuple.prod _p_M1_T _p_M2_T) 
       (Product_additive_monoid__zero _p_M1_T _p_M2_T _p_M1_zero _p_M2_zero) 
       (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal _p_M2_equal 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (Product_additive_monoid__plus _p_M1_T _p_M2_T _p_M1_plus _p_M2_plus 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T))) 
    (sets.Setoid__same_is_not_different (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal _p_M2_equal 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T))) 
    (constants.Setoid_with_zero__is_zero_spec 
       (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal _p_M2_equal 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (Product_additive_monoid__zero _p_M1_T _p_M2_T _p_M1_zero _p_M2_zero) 
       (products.Product_set__equal_reflexive _p_M1_T _p_M2_T _p_M1_equal 
          _p_M1_equal_reflexive _p_M2_equal _p_M2_equal_reflexive 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (products.Product_set__equal_symmetric _p_M1_T _p_M2_T _p_M1_equal 
          _p_M1_equal_symmetric _p_M2_equal _p_M2_equal_symmetric 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T))) 
    (products.Product_set__pair_substitution_rule _p_M1_T _p_M2_T 
       _p_M1_equal _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
       (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal _p_M2_equal 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (products.Product_set__equal_transitive _p_M1_T _p_M2_T _p_M1_equal 
          _p_M1_equal_transitive _p_M2_equal _p_M2_equal_transitive 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (products.Product_set__pair_left_substitution_rule _p_M1_T _p_M2_T 
          _p_M1_equal _p_M1_equal_symmetric _p_M1_equal_transitive 
          _p_M2_equal _p_M2_equal_reflexive _p_M2_equal_symmetric 
          _p_M2_equal_transitive (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T) 
          (products.Cartesian_product__pair_preserves_first _p_M1_T _p_M2_T 
             _p_M1_equal _p_M1_equal_reflexive) 
          (products.Cartesian_product__pair_preserves_second _p_M1_T _p_M2_T 
             _p_M2_equal _p_M2_equal_reflexive)) 
       (products.Product_set__pair_right_substitution_rule _p_M1_T _p_M2_T 
          _p_M1_equal _p_M1_equal_reflexive _p_M1_equal_symmetric 
          _p_M1_equal_transitive _p_M2_equal _p_M2_equal_symmetric 
          _p_M2_equal_transitive (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T) 
          (products.Cartesian_product__pair_preserves_first _p_M1_T _p_M2_T 
             _p_M1_equal _p_M1_equal_reflexive) 
          (products.Cartesian_product__pair_preserves_second _p_M1_T _p_M2_T 
             _p_M2_equal _p_M2_equal_reflexive))) 
    (additive_law.Regular_additive_monoid__zero_is_right_neutral_for_minus 
       (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal _p_M2_equal 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (Product_regular_additive_monoid__minus _p_M1_T _p_M2_T _p_M1_minus 
          _p_M2_minus (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (Product_additive_monoid__plus _p_M1_T _p_M2_T _p_M1_plus _p_M2_plus 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (Product_additive_monoid__zero _p_M1_T _p_M2_T _p_M1_zero _p_M2_zero) 
       (products.Product_set__equal_symmetric _p_M1_T _p_M2_T _p_M1_equal 
          _p_M1_equal_symmetric _p_M2_equal _p_M2_equal_symmetric 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (Product_regular_additive_monoid__minus_is_well_defined _p_M1_T 
          _p_M2_T (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal 
             _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
          (Product_regular_additive_monoid__minus _p_M1_T _p_M2_T 
             _p_M1_minus _p_M2_minus 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
          (Product_additive_monoid__plus _p_M1_T _p_M2_T _p_M1_plus 
             _p_M2_plus (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T))) 
       (Product_additive_monoid__zero_is_neutral _p_M1_T _p_M2_T 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (Product_additive_monoid__zero _p_M1_T _p_M2_T _p_M1_zero 
             _p_M2_zero) 
          (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal 
             _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
          (Product_additive_monoid__plus _p_M1_T _p_M2_T _p_M1_plus 
             _p_M2_plus (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T)))) 
    (additive_law.Additive_monoid__zero_is_unique 
       (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal _p_M2_equal 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (Product_additive_monoid__plus _p_M1_T _p_M2_T _p_M1_plus _p_M2_plus 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (Product_additive_monoid__zero _p_M1_T _p_M2_T _p_M1_zero _p_M2_zero) 
       (products.Product_set__equal_symmetric _p_M1_T _p_M2_T _p_M1_equal 
          _p_M1_equal_symmetric _p_M2_equal _p_M2_equal_symmetric 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (products.Product_set__equal_transitive _p_M1_T _p_M2_T _p_M1_equal 
          _p_M1_equal_transitive _p_M2_equal _p_M2_equal_transitive 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (Product_additive_monoid__zero_is_neutral _p_M1_T _p_M2_T 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (Product_additive_monoid__zero _p_M1_T _p_M2_T _p_M1_zero 
             _p_M2_zero) 
          (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal 
             _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
          (Product_additive_monoid__plus _p_M1_T _p_M2_T _p_M1_plus 
             _p_M2_plus (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T)))) 
    (sets.Setoid__different_is_complete (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal _p_M2_equal 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (sets.Setoid__different (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal 
             _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T))) 
       (products.Product_set__equal_reflexive _p_M1_T _p_M2_T _p_M1_equal 
          _p_M1_equal_reflexive _p_M2_equal _p_M2_equal_reflexive 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (products.Product_set__equal_symmetric _p_M1_T _p_M2_T _p_M1_equal 
          _p_M1_equal_symmetric _p_M2_equal _p_M2_equal_symmetric 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (products.Product_set__equal_transitive _p_M1_T _p_M2_T _p_M1_equal 
          _p_M1_equal_transitive _p_M2_equal _p_M2_equal_transitive 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (sets.Setoid__same_is_not_different (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal 
             _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T)))) 
    (sets.Setoid__different_is_irreflexive (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal _p_M2_equal 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (sets.Setoid__different (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal 
             _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T))) 
       (products.Product_set__equal_reflexive _p_M1_T _p_M2_T _p_M1_equal 
          _p_M1_equal_reflexive _p_M2_equal _p_M2_equal_reflexive 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (sets.Setoid__same_is_not_different (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal 
             _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T)))) 
    (sets.Setoid__different_is_symmetric (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal _p_M2_equal 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (sets.Setoid__different (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal 
             _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T))) 
       (products.Product_set__equal_symmetric _p_M1_T _p_M2_T _p_M1_equal 
          _p_M1_equal_symmetric _p_M2_equal _p_M2_equal_symmetric 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (sets.Setoid__same_is_not_different (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal 
             _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T)))) 
    (constants.Setoid_with_zero__zero_checks_to_zero 
       (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal _p_M2_equal 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (Product_additive_monoid__zero _p_M1_T _p_M2_T _p_M1_zero _p_M2_zero) 
       (products.Product_set__equal_reflexive _p_M1_T _p_M2_T _p_M1_equal 
          _p_M1_equal_reflexive _p_M2_equal _p_M2_equal_reflexive 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (constants.Setoid_with_zero__is_zero (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal 
             _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
          (Product_additive_monoid__zero _p_M1_T _p_M2_T _p_M1_zero 
             _p_M2_zero)) 
       (constants.Setoid_with_zero__is_zero_spec 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal 
             _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
          (Product_additive_monoid__zero _p_M1_T _p_M2_T _p_M1_zero 
             _p_M2_zero) 
          (products.Product_set__equal_reflexive _p_M1_T _p_M2_T _p_M1_equal 
             _p_M1_equal_reflexive _p_M2_equal _p_M2_equal_reflexive 
             (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
          (products.Product_set__equal_symmetric _p_M1_T _p_M2_T _p_M1_equal 
             _p_M1_equal_symmetric _p_M2_equal _p_M2_equal_symmetric 
             (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T)))) 
    (Product_additive_monoid__plus_commutes _p_M1_T _p_M2_T _p_M1_equal 
       _p_M1_plus _p_M1_plus_commutes _p_M2_equal _p_M2_plus 
       _p_M2_plus_commutes (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Cartesian_product__first _p_M1_T _p_M2_T) 
       (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
       (products.Cartesian_product__second _p_M1_T _p_M2_T) 
       (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal _p_M2_equal 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (products.Product_set__pair_substitution_rule _p_M1_T _p_M2_T 
          _p_M1_equal _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
          (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal 
             _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
          (products.Product_set__equal_transitive _p_M1_T _p_M2_T 
             _p_M1_equal _p_M1_equal_transitive _p_M2_equal 
             _p_M2_equal_transitive (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
          (products.Product_set__pair_left_substitution_rule _p_M1_T _p_M2_T 
             _p_M1_equal _p_M1_equal_symmetric _p_M1_equal_transitive 
             _p_M2_equal _p_M2_equal_reflexive _p_M2_equal_symmetric 
             _p_M2_equal_transitive (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T) 
             (products.Cartesian_product__pair_preserves_first _p_M1_T 
                _p_M2_T _p_M1_equal _p_M1_equal_reflexive) 
             (products.Cartesian_product__pair_preserves_second _p_M1_T 
                _p_M2_T _p_M2_equal _p_M2_equal_reflexive)) 
          (products.Product_set__pair_right_substitution_rule _p_M1_T 
             _p_M2_T _p_M1_equal _p_M1_equal_reflexive _p_M1_equal_symmetric 
             _p_M1_equal_transitive _p_M2_equal _p_M2_equal_symmetric 
             _p_M2_equal_transitive (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T) 
             (products.Cartesian_product__pair_preserves_first _p_M1_T 
                _p_M2_T _p_M1_equal _p_M1_equal_reflexive) 
             (products.Cartesian_product__pair_preserves_second _p_M1_T 
                _p_M2_T _p_M2_equal _p_M2_equal_reflexive)))) 
    (Product_additive_monoid__plus_right_substitution_rule _p_M1_T _p_M2_T 
       _p_M1_equal _p_M1_plus _p_M1_plus_right_substitution_rule _p_M2_equal 
       _p_M2_plus _p_M2_plus_right_substitution_rule 
       (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Cartesian_product__first _p_M1_T _p_M2_T) 
       (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
       (products.Cartesian_product__second _p_M1_T _p_M2_T) 
       (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal _p_M2_equal 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (products.Product_set__equal_spec _p_M1_T _p_M2_T _p_M1_equal 
          _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (products.Product_set__pair_substitution_rule _p_M1_T _p_M2_T 
          _p_M1_equal _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
          (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal 
             _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
          (products.Product_set__equal_transitive _p_M1_T _p_M2_T 
             _p_M1_equal _p_M1_equal_transitive _p_M2_equal 
             _p_M2_equal_transitive (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
          (products.Product_set__pair_left_substitution_rule _p_M1_T _p_M2_T 
             _p_M1_equal _p_M1_equal_symmetric _p_M1_equal_transitive 
             _p_M2_equal _p_M2_equal_reflexive _p_M2_equal_symmetric 
             _p_M2_equal_transitive (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T) 
             (products.Cartesian_product__pair_preserves_first _p_M1_T 
                _p_M2_T _p_M1_equal _p_M1_equal_reflexive) 
             (products.Cartesian_product__pair_preserves_second _p_M1_T 
                _p_M2_T _p_M2_equal _p_M2_equal_reflexive)) 
          (products.Product_set__pair_right_substitution_rule _p_M1_T 
             _p_M2_T _p_M1_equal _p_M1_equal_reflexive _p_M1_equal_symmetric 
             _p_M1_equal_transitive _p_M2_equal _p_M2_equal_symmetric 
             _p_M2_equal_transitive (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T) 
             (products.Cartesian_product__pair_preserves_first _p_M1_T 
                _p_M2_T _p_M1_equal _p_M1_equal_reflexive) 
             (products.Cartesian_product__pair_preserves_second _p_M1_T 
                _p_M2_T _p_M2_equal _p_M2_equal_reflexive)))) 
    (additive_law.Cancellative_additive_semi_group__plus_is_right_regular 
       (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal _p_M2_equal 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (Product_additive_monoid__plus _p_M1_T _p_M2_T _p_M1_plus _p_M2_plus 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (products.Product_set__equal_transitive _p_M1_T _p_M2_T _p_M1_equal 
          _p_M1_equal_transitive _p_M2_equal _p_M2_equal_transitive 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (Product_additive_monoid__plus_commutes _p_M1_T _p_M2_T _p_M1_equal 
          _p_M1_plus _p_M1_plus_commutes _p_M2_equal _p_M2_plus 
          _p_M2_plus_commutes (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T) 
          (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal 
             _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
          (products.Product_set__pair_substitution_rule _p_M1_T _p_M2_T 
             _p_M1_equal _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
             (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal 
                _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
                (products.Cartesian_product__first _p_M1_T _p_M2_T) 
                (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
             (products.Product_set__equal_transitive _p_M1_T _p_M2_T 
                _p_M1_equal _p_M1_equal_transitive _p_M2_equal 
                _p_M2_equal_transitive (dk_tuple.prod _p_M1_T _p_M2_T) 
                (products.Cartesian_product__first _p_M1_T _p_M2_T) 
                (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
             (products.Product_set__pair_left_substitution_rule _p_M1_T 
                _p_M2_T _p_M1_equal _p_M1_equal_symmetric 
                _p_M1_equal_transitive _p_M2_equal _p_M2_equal_reflexive 
                _p_M2_equal_symmetric _p_M2_equal_transitive 
                (dk_tuple.prod _p_M1_T _p_M2_T) 
                (products.Cartesian_product__first _p_M1_T _p_M2_T) 
                (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
                (products.Cartesian_product__second _p_M1_T _p_M2_T) 
                (products.Cartesian_product__pair_preserves_first _p_M1_T 
                   _p_M2_T _p_M1_equal _p_M1_equal_reflexive) 
                (products.Cartesian_product__pair_preserves_second _p_M1_T 
                   _p_M2_T _p_M2_equal _p_M2_equal_reflexive)) 
             (products.Product_set__pair_right_substitution_rule _p_M1_T 
                _p_M2_T _p_M1_equal _p_M1_equal_reflexive 
                _p_M1_equal_symmetric _p_M1_equal_transitive _p_M2_equal 
                _p_M2_equal_symmetric _p_M2_equal_transitive 
                (dk_tuple.prod _p_M1_T _p_M2_T) 
                (products.Cartesian_product__first _p_M1_T _p_M2_T) 
                (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
                (products.Cartesian_product__second _p_M1_T _p_M2_T) 
                (products.Cartesian_product__pair_preserves_first _p_M1_T 
                   _p_M2_T _p_M1_equal _p_M1_equal_reflexive) 
                (products.Cartesian_product__pair_preserves_second _p_M1_T 
                   _p_M2_T _p_M2_equal _p_M2_equal_reflexive)))) 
       (Product_regular_additive_monoid__plus_is_left_regular _p_M1_T 
          _p_M2_T (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal 
             _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
          (Product_additive_monoid__plus _p_M1_T _p_M2_T _p_M1_plus 
             _p_M2_plus (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T)))) 
    (additive_law.Additive_semi_group__plus_left_substitution_rule 
       (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal _p_M2_equal 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (Product_additive_monoid__plus _p_M1_T _p_M2_T _p_M1_plus _p_M2_plus 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (products.Product_set__equal_transitive _p_M1_T _p_M2_T _p_M1_equal 
          _p_M1_equal_transitive _p_M2_equal _p_M2_equal_transitive 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (Product_additive_monoid__plus_commutes _p_M1_T _p_M2_T _p_M1_equal 
          _p_M1_plus _p_M1_plus_commutes _p_M2_equal _p_M2_plus 
          _p_M2_plus_commutes (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T) 
          (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal 
             _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
          (products.Product_set__pair_substitution_rule _p_M1_T _p_M2_T 
             _p_M1_equal _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
             (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal 
                _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
                (products.Cartesian_product__first _p_M1_T _p_M2_T) 
                (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
             (products.Product_set__equal_transitive _p_M1_T _p_M2_T 
                _p_M1_equal _p_M1_equal_transitive _p_M2_equal 
                _p_M2_equal_transitive (dk_tuple.prod _p_M1_T _p_M2_T) 
                (products.Cartesian_product__first _p_M1_T _p_M2_T) 
                (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
             (products.Product_set__pair_left_substitution_rule _p_M1_T 
                _p_M2_T _p_M1_equal _p_M1_equal_symmetric 
                _p_M1_equal_transitive _p_M2_equal _p_M2_equal_reflexive 
                _p_M2_equal_symmetric _p_M2_equal_transitive 
                (dk_tuple.prod _p_M1_T _p_M2_T) 
                (products.Cartesian_product__first _p_M1_T _p_M2_T) 
                (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
                (products.Cartesian_product__second _p_M1_T _p_M2_T) 
                (products.Cartesian_product__pair_preserves_first _p_M1_T 
                   _p_M2_T _p_M1_equal _p_M1_equal_reflexive) 
                (products.Cartesian_product__pair_preserves_second _p_M1_T 
                   _p_M2_T _p_M2_equal _p_M2_equal_reflexive)) 
             (products.Product_set__pair_right_substitution_rule _p_M1_T 
                _p_M2_T _p_M1_equal _p_M1_equal_reflexive 
                _p_M1_equal_symmetric _p_M1_equal_transitive _p_M2_equal 
                _p_M2_equal_symmetric _p_M2_equal_transitive 
                (dk_tuple.prod _p_M1_T _p_M2_T) 
                (products.Cartesian_product__first _p_M1_T _p_M2_T) 
                (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
                (products.Cartesian_product__second _p_M1_T _p_M2_T) 
                (products.Cartesian_product__pair_preserves_first _p_M1_T 
                   _p_M2_T _p_M1_equal _p_M1_equal_reflexive) 
                (products.Cartesian_product__pair_preserves_second _p_M1_T 
                   _p_M2_T _p_M2_equal _p_M2_equal_reflexive)))) 
       (Product_additive_monoid__plus_right_substitution_rule _p_M1_T 
          _p_M2_T _p_M1_equal _p_M1_plus _p_M1_plus_right_substitution_rule 
          _p_M2_equal _p_M2_plus _p_M2_plus_right_substitution_rule 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T) 
          (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal 
             _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
          (products.Product_set__equal_spec _p_M1_T _p_M2_T _p_M1_equal 
             _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
          (products.Product_set__pair_substitution_rule _p_M1_T _p_M2_T 
             _p_M1_equal _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
             (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal 
                _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
                (products.Cartesian_product__first _p_M1_T _p_M2_T) 
                (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
             (products.Product_set__equal_transitive _p_M1_T _p_M2_T 
                _p_M1_equal _p_M1_equal_transitive _p_M2_equal 
                _p_M2_equal_transitive (dk_tuple.prod _p_M1_T _p_M2_T) 
                (products.Cartesian_product__first _p_M1_T _p_M2_T) 
                (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
             (products.Product_set__pair_left_substitution_rule _p_M1_T 
                _p_M2_T _p_M1_equal _p_M1_equal_symmetric 
                _p_M1_equal_transitive _p_M2_equal _p_M2_equal_reflexive 
                _p_M2_equal_symmetric _p_M2_equal_transitive 
                (dk_tuple.prod _p_M1_T _p_M2_T) 
                (products.Cartesian_product__first _p_M1_T _p_M2_T) 
                (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
                (products.Cartesian_product__second _p_M1_T _p_M2_T) 
                (products.Cartesian_product__pair_preserves_first _p_M1_T 
                   _p_M2_T _p_M1_equal _p_M1_equal_reflexive) 
                (products.Cartesian_product__pair_preserves_second _p_M1_T 
                   _p_M2_T _p_M2_equal _p_M2_equal_reflexive)) 
             (products.Product_set__pair_right_substitution_rule _p_M1_T 
                _p_M2_T _p_M1_equal _p_M1_equal_reflexive 
                _p_M1_equal_symmetric _p_M1_equal_transitive _p_M2_equal 
                _p_M2_equal_symmetric _p_M2_equal_transitive 
                (dk_tuple.prod _p_M1_T _p_M2_T) 
                (products.Cartesian_product__first _p_M1_T _p_M2_T) 
                (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
                (products.Cartesian_product__second _p_M1_T _p_M2_T) 
                (products.Cartesian_product__pair_preserves_first _p_M1_T 
                   _p_M2_T _p_M1_equal _p_M1_equal_reflexive) 
                (products.Cartesian_product__pair_preserves_second _p_M1_T 
                   _p_M2_T _p_M2_equal _p_M2_equal_reflexive))))) 
    (additive_law.Cancellative_additive_semi_group__plus_is_regular 
       (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal _p_M2_equal 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (Product_additive_monoid__plus _p_M1_T _p_M2_T _p_M1_plus _p_M2_plus 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (Product_regular_additive_monoid__plus_is_left_regular _p_M1_T 
          _p_M2_T (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal 
             _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
          (Product_additive_monoid__plus _p_M1_T _p_M2_T _p_M1_plus 
             _p_M2_plus (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T))) 
       (additive_law.Cancellative_additive_semi_group__plus_is_right_regular 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal 
             _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
          (Product_additive_monoid__plus _p_M1_T _p_M2_T _p_M1_plus 
             _p_M2_plus (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
          (products.Product_set__equal_transitive _p_M1_T _p_M2_T 
             _p_M1_equal _p_M1_equal_transitive _p_M2_equal 
             _p_M2_equal_transitive (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
          (Product_additive_monoid__plus_commutes _p_M1_T _p_M2_T 
             _p_M1_equal _p_M1_plus _p_M1_plus_commutes _p_M2_equal 
             _p_M2_plus _p_M2_plus_commutes (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T) 
             (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal 
                _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
                (products.Cartesian_product__first _p_M1_T _p_M2_T) 
                (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
             (products.Product_set__pair_substitution_rule _p_M1_T _p_M2_T 
                _p_M1_equal _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
                (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
                (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal 
                   _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
                   (products.Cartesian_product__first _p_M1_T _p_M2_T) 
                   (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
                (products.Product_set__equal_transitive _p_M1_T _p_M2_T 
                   _p_M1_equal _p_M1_equal_transitive _p_M2_equal 
                   _p_M2_equal_transitive (dk_tuple.prod _p_M1_T _p_M2_T) 
                   (products.Cartesian_product__first _p_M1_T _p_M2_T) 
                   (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
                (products.Product_set__pair_left_substitution_rule _p_M1_T 
                   _p_M2_T _p_M1_equal _p_M1_equal_symmetric 
                   _p_M1_equal_transitive _p_M2_equal _p_M2_equal_reflexive 
                   _p_M2_equal_symmetric _p_M2_equal_transitive 
                   (dk_tuple.prod _p_M1_T _p_M2_T) 
                   (products.Cartesian_product__first _p_M1_T _p_M2_T) 
                   (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
                   (products.Cartesian_product__second _p_M1_T _p_M2_T) 
                   (products.Cartesian_product__pair_preserves_first _p_M1_T 
                      _p_M2_T _p_M1_equal _p_M1_equal_reflexive) 
                   (products.Cartesian_product__pair_preserves_second 
                      _p_M1_T _p_M2_T _p_M2_equal _p_M2_equal_reflexive)) 
                (products.Product_set__pair_right_substitution_rule _p_M1_T 
                   _p_M2_T _p_M1_equal _p_M1_equal_reflexive 
                   _p_M1_equal_symmetric _p_M1_equal_transitive _p_M2_equal 
                   _p_M2_equal_symmetric _p_M2_equal_transitive 
                   (dk_tuple.prod _p_M1_T _p_M2_T) 
                   (products.Cartesian_product__first _p_M1_T _p_M2_T) 
                   (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
                   (products.Cartesian_product__second _p_M1_T _p_M2_T) 
                   (products.Cartesian_product__pair_preserves_first _p_M1_T 
                      _p_M2_T _p_M1_equal _p_M1_equal_reflexive) 
                   (products.Cartesian_product__pair_preserves_second 
                      _p_M1_T _p_M2_T _p_M2_equal _p_M2_equal_reflexive)))) 
          (Product_regular_additive_monoid__plus_is_left_regular _p_M1_T 
             _p_M2_T (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal 
                _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
                (products.Cartesian_product__first _p_M1_T _p_M2_T) 
                (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
             (Product_additive_monoid__plus _p_M1_T _p_M2_T _p_M1_plus 
                _p_M2_plus (dk_tuple.prod _p_M1_T _p_M2_T) 
                (products.Cartesian_product__first _p_M1_T _p_M2_T) 
                (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
                (products.Cartesian_product__second _p_M1_T _p_M2_T))))) 
    (additive_law.Additive_semi_group__plus_substitution_rule 
       (dk_tuple.prod _p_M1_T _p_M2_T) 
       (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal _p_M2_equal 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (Product_additive_monoid__plus _p_M1_T _p_M2_T _p_M1_plus _p_M2_plus 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (products.Product_set__equal_transitive _p_M1_T _p_M2_T _p_M1_equal 
          _p_M1_equal_transitive _p_M2_equal _p_M2_equal_transitive 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
       (Product_additive_monoid__plus_right_substitution_rule _p_M1_T 
          _p_M2_T _p_M1_equal _p_M1_plus _p_M1_plus_right_substitution_rule 
          _p_M2_equal _p_M2_plus _p_M2_plus_right_substitution_rule 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Cartesian_product__first _p_M1_T _p_M2_T) 
          (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
          (products.Cartesian_product__second _p_M1_T _p_M2_T) 
          (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal 
             _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
          (products.Product_set__equal_spec _p_M1_T _p_M2_T _p_M1_equal 
             _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
          (products.Product_set__pair_substitution_rule _p_M1_T _p_M2_T 
             _p_M1_equal _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
             (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal 
                _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
                (products.Cartesian_product__first _p_M1_T _p_M2_T) 
                (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
             (products.Product_set__equal_transitive _p_M1_T _p_M2_T 
                _p_M1_equal _p_M1_equal_transitive _p_M2_equal 
                _p_M2_equal_transitive (dk_tuple.prod _p_M1_T _p_M2_T) 
                (products.Cartesian_product__first _p_M1_T _p_M2_T) 
                (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
             (products.Product_set__pair_left_substitution_rule _p_M1_T 
                _p_M2_T _p_M1_equal _p_M1_equal_symmetric 
                _p_M1_equal_transitive _p_M2_equal _p_M2_equal_reflexive 
                _p_M2_equal_symmetric _p_M2_equal_transitive 
                (dk_tuple.prod _p_M1_T _p_M2_T) 
                (products.Cartesian_product__first _p_M1_T _p_M2_T) 
                (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
                (products.Cartesian_product__second _p_M1_T _p_M2_T) 
                (products.Cartesian_product__pair_preserves_first _p_M1_T 
                   _p_M2_T _p_M1_equal _p_M1_equal_reflexive) 
                (products.Cartesian_product__pair_preserves_second _p_M1_T 
                   _p_M2_T _p_M2_equal _p_M2_equal_reflexive)) 
             (products.Product_set__pair_right_substitution_rule _p_M1_T 
                _p_M2_T _p_M1_equal _p_M1_equal_reflexive 
                _p_M1_equal_symmetric _p_M1_equal_transitive _p_M2_equal 
                _p_M2_equal_symmetric _p_M2_equal_transitive 
                (dk_tuple.prod _p_M1_T _p_M2_T) 
                (products.Cartesian_product__first _p_M1_T _p_M2_T) 
                (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
                (products.Cartesian_product__second _p_M1_T _p_M2_T) 
                (products.Cartesian_product__pair_preserves_first _p_M1_T 
                   _p_M2_T _p_M1_equal _p_M1_equal_reflexive) 
                (products.Cartesian_product__pair_preserves_second _p_M1_T 
                   _p_M2_T _p_M2_equal _p_M2_equal_reflexive)))) 
       (additive_law.Additive_semi_group__plus_left_substitution_rule 
          (dk_tuple.prod _p_M1_T _p_M2_T) 
          (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal 
             _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
          (Product_additive_monoid__plus _p_M1_T _p_M2_T _p_M1_plus 
             _p_M2_plus (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
          (products.Product_set__equal_transitive _p_M1_T _p_M2_T 
             _p_M1_equal _p_M1_equal_transitive _p_M2_equal 
             _p_M2_equal_transitive (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
          (Product_additive_monoid__plus_commutes _p_M1_T _p_M2_T 
             _p_M1_equal _p_M1_plus _p_M1_plus_commutes _p_M2_equal 
             _p_M2_plus _p_M2_plus_commutes (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T) 
             (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal 
                _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
                (products.Cartesian_product__first _p_M1_T _p_M2_T) 
                (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
             (products.Product_set__pair_substitution_rule _p_M1_T _p_M2_T 
                _p_M1_equal _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
                (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
                (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal 
                   _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
                   (products.Cartesian_product__first _p_M1_T _p_M2_T) 
                   (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
                (products.Product_set__equal_transitive _p_M1_T _p_M2_T 
                   _p_M1_equal _p_M1_equal_transitive _p_M2_equal 
                   _p_M2_equal_transitive (dk_tuple.prod _p_M1_T _p_M2_T) 
                   (products.Cartesian_product__first _p_M1_T _p_M2_T) 
                   (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
                (products.Product_set__pair_left_substitution_rule _p_M1_T 
                   _p_M2_T _p_M1_equal _p_M1_equal_symmetric 
                   _p_M1_equal_transitive _p_M2_equal _p_M2_equal_reflexive 
                   _p_M2_equal_symmetric _p_M2_equal_transitive 
                   (dk_tuple.prod _p_M1_T _p_M2_T) 
                   (products.Cartesian_product__first _p_M1_T _p_M2_T) 
                   (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
                   (products.Cartesian_product__second _p_M1_T _p_M2_T) 
                   (products.Cartesian_product__pair_preserves_first _p_M1_T 
                      _p_M2_T _p_M1_equal _p_M1_equal_reflexive) 
                   (products.Cartesian_product__pair_preserves_second 
                      _p_M1_T _p_M2_T _p_M2_equal _p_M2_equal_reflexive)) 
                (products.Product_set__pair_right_substitution_rule _p_M1_T 
                   _p_M2_T _p_M1_equal _p_M1_equal_reflexive 
                   _p_M1_equal_symmetric _p_M1_equal_transitive _p_M2_equal 
                   _p_M2_equal_symmetric _p_M2_equal_transitive 
                   (dk_tuple.prod _p_M1_T _p_M2_T) 
                   (products.Cartesian_product__first _p_M1_T _p_M2_T) 
                   (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
                   (products.Cartesian_product__second _p_M1_T _p_M2_T) 
                   (products.Cartesian_product__pair_preserves_first _p_M1_T 
                      _p_M2_T _p_M1_equal _p_M1_equal_reflexive) 
                   (products.Cartesian_product__pair_preserves_second 
                      _p_M1_T _p_M2_T _p_M2_equal _p_M2_equal_reflexive)))) 
          (Product_additive_monoid__plus_right_substitution_rule _p_M1_T 
             _p_M2_T _p_M1_equal _p_M1_plus 
             _p_M1_plus_right_substitution_rule _p_M2_equal _p_M2_plus 
             _p_M2_plus_right_substitution_rule 
             (dk_tuple.prod _p_M1_T _p_M2_T) 
             (products.Cartesian_product__first _p_M1_T _p_M2_T) 
             (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
             (products.Cartesian_product__second _p_M1_T _p_M2_T) 
             (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal 
                _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
                (products.Cartesian_product__first _p_M1_T _p_M2_T) 
                (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
             (products.Product_set__equal_spec _p_M1_T _p_M2_T _p_M1_equal 
                _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
                (products.Cartesian_product__first _p_M1_T _p_M2_T) 
                (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
             (products.Product_set__pair_substitution_rule _p_M1_T _p_M2_T 
                _p_M1_equal _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
                (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
                (products.Product_set__equal _p_M1_T _p_M2_T _p_M1_equal 
                   _p_M2_equal (dk_tuple.prod _p_M1_T _p_M2_T) 
                   (products.Cartesian_product__first _p_M1_T _p_M2_T) 
                   (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
                (products.Product_set__equal_transitive _p_M1_T _p_M2_T 
                   _p_M1_equal _p_M1_equal_transitive _p_M2_equal 
                   _p_M2_equal_transitive (dk_tuple.prod _p_M1_T _p_M2_T) 
                   (products.Cartesian_product__first _p_M1_T _p_M2_T) 
                   (products.Cartesian_product__second _p_M1_T _p_M2_T)) 
                (products.Product_set__pair_left_substitution_rule _p_M1_T 
                   _p_M2_T _p_M1_equal _p_M1_equal_symmetric 
                   _p_M1_equal_transitive _p_M2_equal _p_M2_equal_reflexive 
                   _p_M2_equal_symmetric _p_M2_equal_transitive 
                   (dk_tuple.prod _p_M1_T _p_M2_T) 
                   (products.Cartesian_product__first _p_M1_T _p_M2_T) 
                   (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
                   (products.Cartesian_product__second _p_M1_T _p_M2_T) 
                   (products.Cartesian_product__pair_preserves_first _p_M1_T 
                      _p_M2_T _p_M1_equal _p_M1_equal_reflexive) 
                   (products.Cartesian_product__pair_preserves_second 
                      _p_M1_T _p_M2_T _p_M2_equal _p_M2_equal_reflexive)) 
                (products.Product_set__pair_right_substitution_rule _p_M1_T 
                   _p_M2_T _p_M1_equal _p_M1_equal_reflexive 
                   _p_M1_equal_symmetric _p_M1_equal_transitive _p_M2_equal 
                   _p_M2_equal_symmetric _p_M2_equal_transitive 
                   (dk_tuple.prod _p_M1_T _p_M2_T) 
                   (products.Cartesian_product__first _p_M1_T _p_M2_T) 
                   (products.Cartesian_product__pair _p_M1_T _p_M2_T) 
                   (products.Cartesian_product__second _p_M1_T _p_M2_T) 
                   (products.Cartesian_product__pair_preserves_first _p_M1_T 
                      _p_M2_T _p_M1_equal _p_M1_equal_reflexive) 
                   (products.Cartesian_product__pair_preserves_second 
                      _p_M1_T _p_M2_T _p_M2_equal _p_M2_equal_reflexive)))))).

def Product_additive_monoid_with_infimum__inf :
  _p_M1_T:cc.uT ->
  _p_M2_T:cc.uT ->
  _p_M1_inf:((cc.eT _p_M1_T) -> (cc.eT _p_M1_T) -> cc.eT _p_M1_T) ->
  _p_M2_inf:((cc.eT _p_M2_T) -> (cc.eT _p_M2_T) -> cc.eT _p_M2_T) ->
  abst_first:((cc.eT (dk_tuple.prod _p_M1_T _p_M2_T)) -> cc.eT _p_M1_T) ->
  abst_second:((cc.eT (dk_tuple.prod _p_M1_T _p_M2_T)) -> cc.eT _p_M2_T) ->
  a:(cc.eT (dk_tuple.prod _p_M1_T _p_M2_T)) ->
  b:(cc.eT (dk_tuple.prod _p_M1_T _p_M2_T)) ->
  cc.eT (dk_tuple.prod _p_M1_T _p_M2_T)
  :=
  _p_M1_T:cc.uT =>
  _p_M2_T:cc.uT =>
  _p_M1_inf:((cc.eT _p_M1_T) -> (cc.eT _p_M1_T) -> cc.eT _p_M1_T) =>
  _p_M2_inf:((cc.eT _p_M2_T) -> (cc.eT _p_M2_T) -> cc.eT _p_M2_T) =>
  abst_first:((cc.eT (dk_tuple.prod _p_M1_T _p_M2_T)) -> cc.eT _p_M1_T) =>
  abst_second:((cc.eT (dk_tuple.prod _p_M1_T _p_M2_T)) -> cc.eT _p_M2_T) =>
  a:(cc.eT (dk_tuple.prod _p_M1_T _p_M2_T)) =>
  b:(cc.eT (dk_tuple.prod _p_M1_T _p_M2_T)) =>
  (a1:(cc.eT _p_M1_T) =>
   (a2:(cc.eT _p_M2_T) =>
    (b1:(cc.eT _p_M1_T) =>
     (b2:(cc.eT _p_M2_T) =>
      dk_tuple.pair _p_M1_T _p_M2_T (_p_M1_inf a1 b1) (_p_M2_inf a2 b2)) 
       (abst_second b)) (abst_first b)) (abst_second a)) (abst_first a).

def Product_additive_monoid_with_infimum__output :
  _p_M1_T:cc.uT ->
  _p_M2_T:cc.uT ->
  _p_M1_print:((cc.eT _p_M1_T) -> cc.eT basics.string__t) ->
  _p_M2_print:((cc.eT _p_M2_T) -> cc.eT basics.string__t) ->
  abst_T:cc.uT ->
  abst_first:((cc.eT abst_T) -> cc.eT _p_M1_T) ->
  abst_second:((cc.eT abst_T) -> cc.eT _p_M2_T) ->
  a:(cc.eT abst_T) ->
  v1:(cc.eT basics.string__t) ->
  v2:(cc.eT basics.string__t) -> cc.eT basics.string__t
  :=
  _p_M1_T:cc.uT =>
  _p_M2_T:cc.uT =>
  _p_M1_print:((cc.eT _p_M1_T) -> cc.eT basics.string__t) =>
  _p_M2_print:((cc.eT _p_M2_T) -> cc.eT basics.string__t) =>
  abst_T:cc.uT =>
  abst_first:((cc.eT abst_T) -> cc.eT _p_M1_T) =>
  abst_second:((cc.eT abst_T) -> cc.eT _p_M2_T) =>
  a:(cc.eT abst_T) =>
  v1:(cc.eT basics.string__t) =>
  v2:(cc.eT basics.string__t) =>
  (a1:(cc.eT _p_M1_T) =>
   (a2:(cc.eT _p_M2_T) =>
    basics._hat_ v1 
      (basics._hat_ 
         (builtins.string_cons 
            (builtins.char_of_nat 
               (builtins.S 
                  (builtins.S 
                     (builtins.S 
                        (builtins.S 
                           (builtins.S 
                              (builtins.S 
                                 (builtins.S 
                                    (builtins.S 
                                       (builtins.S 
                                          (builtins.S 
                                             (builtins.S 
                                                (builtins.S 
                                                   (builtins.S 
                                                      (builtins.S 
                                                         (builtins.S 
                                                            (builtins.S 
                                                               (builtins.S 
                                                                  (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    builtins.0))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) 
            builtins.string_nil) 
         (basics._hat_ (_p_M1_print a1) 
            (basics._hat_ 
               (builtins.string_cons 
                  (builtins.char_of_nat 
                     (builtins.S 
                        (builtins.S 
                           (builtins.S 
                              (builtins.S 
                                 (builtins.S 
                                    (builtins.S 
                                       (builtins.S 
                                          (builtins.S 
                                             (builtins.S 
                                                (builtins.S 
                                                   (builtins.S 
                                                      (builtins.S 
                                                         (builtins.S 
                                                            (builtins.S 
                                                               (builtins.S 
                                                                  (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    builtins.0))))))))))))))))))))))))))))))))))))))))))) 
                  builtins.string_nil) 
               (basics._hat_ v2 
                  (basics._hat_ 
                     (builtins.string_cons 
                        (builtins.char_of_nat 
                           (builtins.S 
                              (builtins.S 
                                 (builtins.S 
                                    (builtins.S 
                                       (builtins.S 
                                          (builtins.S 
                                             (builtins.S 
                                                (builtins.S 
                                                   (builtins.S 
                                                      (builtins.S 
                                                         (builtins.S 
                                                            (builtins.S 
                                                               (builtins.S 
                                                                  (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    builtins.0))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) 
                        builtins.string_nil) (_p_M2_print a2))))))) 
     (abst_second a)) (abst_first a).

def Product_additive_monoid_with_infimum__inf_commutes :
  _p_M1_T:cc.uT ->
  _p_M2_T:cc.uT ->
  abst_T:cc.uT ->
  abst_equal:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) ->
  abst_inf:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT abst_T) ->
  dk_logic.eP 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.ebP (abst_equal (abst_inf x y) (abst_inf y x)))))
  :=
  _p_M1_T:cc.uT =>
  _p_M2_T:cc.uT =>
  abst_T:cc.uT =>
  abst_equal:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) =>
  abst_inf:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT abst_T) =>
  dk_builtins.magic_prove 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.ebP (abst_equal (abst_inf x y) (abst_inf y x))))).

def Product_additive_monoid_with_infimum__inf_idempotent :
  _p_M1_T:cc.uT ->
  _p_M2_T:cc.uT ->
  abst_T:cc.uT ->
  abst_equal:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) ->
  abst_inf:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT abst_T) ->
  dk_logic.eP 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.imp (dk_logic.ebP (abst_equal x y)) 
             (dk_logic.ebP (abst_equal x (abst_inf x y))))))
  :=
  _p_M1_T:cc.uT =>
  _p_M2_T:cc.uT =>
  abst_T:cc.uT =>
  abst_equal:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) =>
  abst_inf:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT abst_T) =>
  dk_builtins.magic_prove 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.imp (dk_logic.ebP (abst_equal x y)) 
             (dk_logic.ebP (abst_equal x (abst_inf x y)))))).

def Product_additive_monoid_with_infimum__inf_is_associative :
  _p_M1_T:cc.uT ->
  _p_M2_T:cc.uT ->
  abst_T:cc.uT ->
  abst_equal:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) ->
  abst_inf:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT abst_T) ->
  dk_logic.eP 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.forall abst_T 
             (z:(cc.eT abst_T) =>
              dk_logic.ebP 
                (abst_equal (abst_inf (abst_inf x y) z) 
                   (abst_inf x (abst_inf y z)))))))
  :=
  _p_M1_T:cc.uT =>
  _p_M2_T:cc.uT =>
  abst_T:cc.uT =>
  abst_equal:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) =>
  abst_inf:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT abst_T) =>
  dk_builtins.magic_prove 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.forall abst_T 
             (z:(cc.eT abst_T) =>
              dk_logic.ebP 
                (abst_equal (abst_inf (abst_inf x y) z) 
                   (abst_inf x (abst_inf y z))))))).

def Product_additive_monoid_with_infimum__inf_left_substitution_rule :
  _p_M1_T:cc.uT ->
  _p_M2_T:cc.uT ->
  abst_T:cc.uT ->
  abst_equal:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) ->
  abst_inf:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT abst_T) ->
  dk_logic.eP 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.forall abst_T 
             (z:(cc.eT abst_T) =>
              dk_logic.imp (dk_logic.ebP (abst_equal x y)) 
                (dk_logic.ebP (abst_equal (abst_inf x z) (abst_inf y z)))))))
  :=
  _p_M1_T:cc.uT =>
  _p_M2_T:cc.uT =>
  abst_T:cc.uT =>
  abst_equal:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) =>
  abst_inf:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT abst_T) =>
  dk_builtins.magic_prove 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.forall abst_T 
             (z:(cc.eT abst_T) =>
              dk_logic.imp (dk_logic.ebP (abst_equal x y)) 
                (dk_logic.ebP (abst_equal (abst_inf x z) (abst_inf y z))))))).

def Product_additive_monoid_with_infimum__print :
  _p_M1_T:cc.uT ->
  _p_M2_T:cc.uT ->
  abst_T:cc.uT ->
  abst_output:((cc.eT abst_T) ->
               (cc.eT basics.string__t) ->
               (cc.eT basics.string__t) -> cc.eT basics.string__t) ->
  a:(cc.eT abst_T) -> cc.eT basics.string__t
  :=
  _p_M1_T:cc.uT =>
  _p_M2_T:cc.uT =>
  abst_T:cc.uT =>
  abst_output:
  ((cc.eT abst_T) ->
   (cc.eT basics.string__t) ->
   (cc.eT basics.string__t) -> cc.eT basics.string__t) =>
  a:(cc.eT abst_T) =>
  abst_output a 
    (builtins.string_cons 
       (builtins.char_of_nat 
          (builtins.S 
             (builtins.S 
                (builtins.S 
                   (builtins.S 
                      (builtins.S 
                         (builtins.S 
                            (builtins.S 
                               (builtins.S 
                                  (builtins.S 
                                     (builtins.S 
                                        (builtins.S 
                                           (builtins.S 
                                              (builtins.S 
                                                 (builtins.S 
                                                    (builtins.S 
                                                       (builtins.S 
                                                          (builtins.S 
                                                             (builtins.S 
                                                                (builtins.S 
                                                                   (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    builtins.0)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) 
       (builtins.string_cons 
          (builtins.char_of_nat 
             (builtins.S 
                (builtins.S 
                   (builtins.S 
                      (builtins.S 
                         (builtins.S 
                            (builtins.S 
                               (builtins.S 
                                  (builtins.S 
                                     (builtins.S 
                                        (builtins.S 
                                           (builtins.S 
                                              (builtins.S 
                                                 (builtins.S 
                                                    (builtins.S 
                                                       (builtins.S 
                                                          (builtins.S 
                                                             (builtins.S 
                                                                (builtins.S 
                                                                   (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    builtins.0)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) 
          (builtins.string_cons 
             (builtins.char_of_nat 
                (builtins.S 
                   (builtins.S 
                      (builtins.S 
                         (builtins.S 
                            (builtins.S 
                               (builtins.S 
                                  (builtins.S 
                                     (builtins.S 
                                        (builtins.S 
                                           (builtins.S 
                                              (builtins.S 
                                                 (builtins.S 
                                                    (builtins.S 
                                                       (builtins.S 
                                                          (builtins.S 
                                                             (builtins.S 
                                                                (builtins.S 
                                                                   (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    builtins.0)))))))))))))))))))))))))))))))))))))))))))))))))) 
             (builtins.string_cons 
                (builtins.char_of_nat 
                   (builtins.S 
                      (builtins.S 
                         (builtins.S 
                            (builtins.S 
                               (builtins.S 
                                  (builtins.S 
                                     (builtins.S 
                                        (builtins.S 
                                           (builtins.S 
                                              (builtins.S 
                                                 (builtins.S 
                                                    (builtins.S 
                                                       (builtins.S 
                                                          (builtins.S 
                                                             (builtins.S 
                                                                (builtins.S 
                                                                   (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    builtins.0)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) 
                builtins.string_nil)))) 
    (builtins.string_cons 
       (builtins.char_of_nat 
          (builtins.S 
             (builtins.S 
                (builtins.S 
                   (builtins.S 
                      (builtins.S 
                         (builtins.S 
                            (builtins.S 
                               (builtins.S 
                                  (builtins.S 
                                     (builtins.S 
                                        (builtins.S 
                                           (builtins.S 
                                              (builtins.S 
                                                 (builtins.S 
                                                    (builtins.S 
                                                       (builtins.S 
                                                          (builtins.S 
                                                             (builtins.S 
                                                                (builtins.S 
                                                                   (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    builtins.0)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) 
       (builtins.string_cons 
          (builtins.char_of_nat 
             (builtins.S 
                (builtins.S 
                   (builtins.S 
                      (builtins.S 
                         (builtins.S 
                            (builtins.S 
                               (builtins.S 
                                  (builtins.S 
                                     (builtins.S 
                                        (builtins.S 
                                           (builtins.S 
                                              (builtins.S 
                                                 (builtins.S 
                                                    (builtins.S 
                                                       (builtins.S 
                                                          (builtins.S 
                                                             (builtins.S 
                                                                (builtins.S 
                                                                   (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    builtins.0)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) 
          (builtins.string_cons 
             (builtins.char_of_nat 
                (builtins.S 
                   (builtins.S 
                      (builtins.S 
                         (builtins.S 
                            (builtins.S 
                               (builtins.S 
                                  (builtins.S 
                                     (builtins.S 
                                        (builtins.S 
                                           (builtins.S 
                                              (builtins.S 
                                                 (builtins.S 
                                                    (builtins.S 
                                                       (builtins.S 
                                                          (builtins.S 
                                                             (builtins.S 
                                                                (builtins.S 
                                                                   (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    builtins.0))))))))))))))))))))))))))))))))))))))))))))))))))) 
             (builtins.string_cons 
                (builtins.char_of_nat 
                   (builtins.S 
                      (builtins.S 
                         (builtins.S 
                            (builtins.S 
                               (builtins.S 
                                  (builtins.S 
                                     (builtins.S 
                                        (builtins.S 
                                           (builtins.S 
                                              (builtins.S 
                                                 (builtins.S 
                                                    (builtins.S 
                                                       (builtins.S 
                                                          (builtins.S 
                                                             (builtins.S 
                                                                (builtins.S 
                                                                   (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    builtins.0)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) 
                builtins.string_nil)))).

def Product_additive_monoid_with_infimum__add_left_distributes_on_inf :
  _p_M1_T:cc.uT ->
  _p_M2_T:cc.uT ->
  abst_T:cc.uT ->
  abst_equal:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) ->
  abst_inf:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT abst_T) ->
  abst_plus:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT abst_T) ->
  dk_logic.eP 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.forall abst_T 
             (z:(cc.eT abst_T) =>
              dk_logic.ebP 
                (abst_equal (abst_plus x (abst_inf y z)) 
                   (abst_inf (abst_plus x y) (abst_plus x z)))))))
  :=
  _p_M1_T:cc.uT =>
  _p_M2_T:cc.uT =>
  abst_T:cc.uT =>
  abst_equal:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) =>
  abst_inf:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT abst_T) =>
  abst_plus:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT abst_T) =>
  dk_builtins.magic_prove 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.forall abst_T 
             (z:(cc.eT abst_T) =>
              dk_logic.ebP 
                (abst_equal (abst_plus x (abst_inf y z)) 
                   (abst_inf (abst_plus x y) (abst_plus x z))))))).

def Product_additive_monoid_with_infimum__add_right_distributes_on_inf :
  _p_M1_T:cc.uT ->
  _p_M2_T:cc.uT ->
  abst_T:cc.uT ->
  abst_equal:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) ->
  abst_inf:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT abst_T) ->
  abst_plus:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT abst_T) ->
  dk_logic.eP 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.forall abst_T 
             (z:(cc.eT abst_T) =>
              dk_logic.ebP 
                (abst_equal (abst_plus (abst_inf x y) z) 
                   (abst_inf (abst_plus x z) (abst_plus y z)))))))
  :=
  _p_M1_T:cc.uT =>
  _p_M2_T:cc.uT =>
  abst_T:cc.uT =>
  abst_equal:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) =>
  abst_inf:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT abst_T) =>
  abst_plus:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT abst_T) =>
  dk_builtins.magic_prove 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.forall abst_T 
             (z:(cc.eT abst_T) =>
              dk_logic.ebP 
                (abst_equal (abst_plus (abst_inf x y) z) 
                   (abst_inf (abst_plus x z) (abst_plus y z))))))).

def Product_additive_monoid_with_infimum__inf_absorbes_add :
  _p_M1_T:cc.uT ->
  _p_M2_T:cc.uT ->
  abst_T:cc.uT ->
  abst_plus:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT abst_T) ->
  abst_order_inf:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) ->
  dk_logic.eP 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.ebP (abst_order_inf x (abst_plus x y)))))
  :=
  _p_M1_T:cc.uT =>
  _p_M2_T:cc.uT =>
  abst_T:cc.uT =>
  abst_plus:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT abst_T) =>
  abst_order_inf:
  ((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) =>
  dk_builtins.magic_prove 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.ebP (abst_order_inf x (abst_plus x y))))).

def Product_additive_monoid_with_supremum__output :
  _p_M1_T:cc.uT ->
  _p_M2_T:cc.uT ->
  _p_M1_print:((cc.eT _p_M1_T) -> cc.eT basics.string__t) ->
  _p_M2_print:((cc.eT _p_M2_T) -> cc.eT basics.string__t) ->
  abst_T:cc.uT ->
  abst_first:((cc.eT abst_T) -> cc.eT _p_M1_T) ->
  abst_second:((cc.eT abst_T) -> cc.eT _p_M2_T) ->
  a:(cc.eT abst_T) ->
  v1:(cc.eT basics.string__t) ->
  v2:(cc.eT basics.string__t) -> cc.eT basics.string__t
  :=
  _p_M1_T:cc.uT =>
  _p_M2_T:cc.uT =>
  _p_M1_print:((cc.eT _p_M1_T) -> cc.eT basics.string__t) =>
  _p_M2_print:((cc.eT _p_M2_T) -> cc.eT basics.string__t) =>
  abst_T:cc.uT =>
  abst_first:((cc.eT abst_T) -> cc.eT _p_M1_T) =>
  abst_second:((cc.eT abst_T) -> cc.eT _p_M2_T) =>
  a:(cc.eT abst_T) =>
  v1:(cc.eT basics.string__t) =>
  v2:(cc.eT basics.string__t) =>
  (a1:(cc.eT _p_M1_T) =>
   (a2:(cc.eT _p_M2_T) =>
    basics._hat_ v1 
      (basics._hat_ 
         (builtins.string_cons 
            (builtins.char_of_nat 
               (builtins.S 
                  (builtins.S 
                     (builtins.S 
                        (builtins.S 
                           (builtins.S 
                              (builtins.S 
                                 (builtins.S 
                                    (builtins.S 
                                       (builtins.S 
                                          (builtins.S 
                                             (builtins.S 
                                                (builtins.S 
                                                   (builtins.S 
                                                      (builtins.S 
                                                         (builtins.S 
                                                            (builtins.S 
                                                               (builtins.S 
                                                                  (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    builtins.0))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) 
            builtins.string_nil) 
         (basics._hat_ (_p_M1_print a1) 
            (basics._hat_ 
               (builtins.string_cons 
                  (builtins.char_of_nat 
                     (builtins.S 
                        (builtins.S 
                           (builtins.S 
                              (builtins.S 
                                 (builtins.S 
                                    (builtins.S 
                                       (builtins.S 
                                          (builtins.S 
                                             (builtins.S 
                                                (builtins.S 
                                                   (builtins.S 
                                                      (builtins.S 
                                                         (builtins.S 
                                                            (builtins.S 
                                                               (builtins.S 
                                                                  (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    builtins.0))))))))))))))))))))))))))))))))))))))))))) 
                  builtins.string_nil) 
               (basics._hat_ v2 
                  (basics._hat_ 
                     (builtins.string_cons 
                        (builtins.char_of_nat 
                           (builtins.S 
                              (builtins.S 
                                 (builtins.S 
                                    (builtins.S 
                                       (builtins.S 
                                          (builtins.S 
                                             (builtins.S 
                                                (builtins.S 
                                                   (builtins.S 
                                                      (builtins.S 
                                                         (builtins.S 
                                                            (builtins.S 
                                                               (builtins.S 
                                                                  (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    builtins.0))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) 
                        builtins.string_nil) (_p_M2_print a2))))))) 
     (abst_second a)) (abst_first a).

def Product_additive_monoid_with_supremum__sup :
  _p_M1_T:cc.uT ->
  _p_M2_T:cc.uT ->
  _p_M1_sup:((cc.eT _p_M1_T) -> (cc.eT _p_M1_T) -> cc.eT _p_M1_T) ->
  _p_M2_sup:((cc.eT _p_M2_T) -> (cc.eT _p_M2_T) -> cc.eT _p_M2_T) ->
  abst_first:((cc.eT (dk_tuple.prod _p_M1_T _p_M2_T)) -> cc.eT _p_M1_T) ->
  abst_second:((cc.eT (dk_tuple.prod _p_M1_T _p_M2_T)) -> cc.eT _p_M2_T) ->
  a:(cc.eT (dk_tuple.prod _p_M1_T _p_M2_T)) ->
  b:(cc.eT (dk_tuple.prod _p_M1_T _p_M2_T)) ->
  cc.eT (dk_tuple.prod _p_M1_T _p_M2_T)
  :=
  _p_M1_T:cc.uT =>
  _p_M2_T:cc.uT =>
  _p_M1_sup:((cc.eT _p_M1_T) -> (cc.eT _p_M1_T) -> cc.eT _p_M1_T) =>
  _p_M2_sup:((cc.eT _p_M2_T) -> (cc.eT _p_M2_T) -> cc.eT _p_M2_T) =>
  abst_first:((cc.eT (dk_tuple.prod _p_M1_T _p_M2_T)) -> cc.eT _p_M1_T) =>
  abst_second:((cc.eT (dk_tuple.prod _p_M1_T _p_M2_T)) -> cc.eT _p_M2_T) =>
  a:(cc.eT (dk_tuple.prod _p_M1_T _p_M2_T)) =>
  b:(cc.eT (dk_tuple.prod _p_M1_T _p_M2_T)) =>
  (a1:(cc.eT _p_M1_T) =>
   (a2:(cc.eT _p_M2_T) =>
    (b1:(cc.eT _p_M1_T) =>
     (b2:(cc.eT _p_M2_T) =>
      dk_tuple.pair _p_M1_T _p_M2_T (_p_M1_sup a1 b1) (_p_M2_sup a2 b2)) 
       (abst_second b)) (abst_first b)) (abst_second a)) (abst_first a).

def Product_additive_monoid_with_supremum__print :
  _p_M1_T:cc.uT ->
  _p_M2_T:cc.uT ->
  abst_T:cc.uT ->
  abst_output:((cc.eT abst_T) ->
               (cc.eT basics.string__t) ->
               (cc.eT basics.string__t) -> cc.eT basics.string__t) ->
  a:(cc.eT abst_T) -> cc.eT basics.string__t
  :=
  _p_M1_T:cc.uT =>
  _p_M2_T:cc.uT =>
  abst_T:cc.uT =>
  abst_output:
  ((cc.eT abst_T) ->
   (cc.eT basics.string__t) ->
   (cc.eT basics.string__t) -> cc.eT basics.string__t) =>
  a:(cc.eT abst_T) =>
  abst_output a 
    (builtins.string_cons 
       (builtins.char_of_nat 
          (builtins.S 
             (builtins.S 
                (builtins.S 
                   (builtins.S 
                      (builtins.S 
                         (builtins.S 
                            (builtins.S 
                               (builtins.S 
                                  (builtins.S 
                                     (builtins.S 
                                        (builtins.S 
                                           (builtins.S 
                                              (builtins.S 
                                                 (builtins.S 
                                                    (builtins.S 
                                                       (builtins.S 
                                                          (builtins.S 
                                                             (builtins.S 
                                                                (builtins.S 
                                                                   (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    builtins.0)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) 
       (builtins.string_cons 
          (builtins.char_of_nat 
             (builtins.S 
                (builtins.S 
                   (builtins.S 
                      (builtins.S 
                         (builtins.S 
                            (builtins.S 
                               (builtins.S 
                                  (builtins.S 
                                     (builtins.S 
                                        (builtins.S 
                                           (builtins.S 
                                              (builtins.S 
                                                 (builtins.S 
                                                    (builtins.S 
                                                       (builtins.S 
                                                          (builtins.S 
                                                             (builtins.S 
                                                                (builtins.S 
                                                                   (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    builtins.0)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) 
          (builtins.string_cons 
             (builtins.char_of_nat 
                (builtins.S 
                   (builtins.S 
                      (builtins.S 
                         (builtins.S 
                            (builtins.S 
                               (builtins.S 
                                  (builtins.S 
                                     (builtins.S 
                                        (builtins.S 
                                           (builtins.S 
                                              (builtins.S 
                                                 (builtins.S 
                                                    (builtins.S 
                                                       (builtins.S 
                                                          (builtins.S 
                                                             (builtins.S 
                                                                (builtins.S 
                                                                   (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    builtins.0)))))))))))))))))))))))))))))))))))))))))))))))))) 
             (builtins.string_cons 
                (builtins.char_of_nat 
                   (builtins.S 
                      (builtins.S 
                         (builtins.S 
                            (builtins.S 
                               (builtins.S 
                                  (builtins.S 
                                     (builtins.S 
                                        (builtins.S 
                                           (builtins.S 
                                              (builtins.S 
                                                 (builtins.S 
                                                    (builtins.S 
                                                       (builtins.S 
                                                          (builtins.S 
                                                             (builtins.S 
                                                                (builtins.S 
                                                                   (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    builtins.0)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) 
                builtins.string_nil)))) 
    (builtins.string_cons 
       (builtins.char_of_nat 
          (builtins.S 
             (builtins.S 
                (builtins.S 
                   (builtins.S 
                      (builtins.S 
                         (builtins.S 
                            (builtins.S 
                               (builtins.S 
                                  (builtins.S 
                                     (builtins.S 
                                        (builtins.S 
                                           (builtins.S 
                                              (builtins.S 
                                                 (builtins.S 
                                                    (builtins.S 
                                                       (builtins.S 
                                                          (builtins.S 
                                                             (builtins.S 
                                                                (builtins.S 
                                                                   (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    builtins.0)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) 
       (builtins.string_cons 
          (builtins.char_of_nat 
             (builtins.S 
                (builtins.S 
                   (builtins.S 
                      (builtins.S 
                         (builtins.S 
                            (builtins.S 
                               (builtins.S 
                                  (builtins.S 
                                     (builtins.S 
                                        (builtins.S 
                                           (builtins.S 
                                              (builtins.S 
                                                 (builtins.S 
                                                    (builtins.S 
                                                       (builtins.S 
                                                          (builtins.S 
                                                             (builtins.S 
                                                                (builtins.S 
                                                                   (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    builtins.0)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) 
          (builtins.string_cons 
             (builtins.char_of_nat 
                (builtins.S 
                   (builtins.S 
                      (builtins.S 
                         (builtins.S 
                            (builtins.S 
                               (builtins.S 
                                  (builtins.S 
                                     (builtins.S 
                                        (builtins.S 
                                           (builtins.S 
                                              (builtins.S 
                                                 (builtins.S 
                                                    (builtins.S 
                                                       (builtins.S 
                                                          (builtins.S 
                                                             (builtins.S 
                                                                (builtins.S 
                                                                   (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    builtins.0))))))))))))))))))))))))))))))))))))))))))))))))))) 
             (builtins.string_cons 
                (builtins.char_of_nat 
                   (builtins.S 
                      (builtins.S 
                         (builtins.S 
                            (builtins.S 
                               (builtins.S 
                                  (builtins.S 
                                     (builtins.S 
                                        (builtins.S 
                                           (builtins.S 
                                              (builtins.S 
                                                 (builtins.S 
                                                    (builtins.S 
                                                       (builtins.S 
                                                          (builtins.S 
                                                             (builtins.S 
                                                                (builtins.S 
                                                                   (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    (builtins.S 
                                                                    builtins.0)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) 
                builtins.string_nil)))).

def Product_additive_monoid_with_supremum__add_left_distributes_on_sup :
  _p_M1_T:cc.uT ->
  _p_M2_T:cc.uT ->
  abst_T:cc.uT ->
  abst_equal:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) ->
  abst_plus:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT abst_T) ->
  abst_sup:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT abst_T) ->
  dk_logic.eP 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.forall abst_T 
             (z:(cc.eT abst_T) =>
              dk_logic.ebP 
                (abst_equal (abst_plus x (abst_sup y z)) 
                   (abst_sup (abst_plus x y) (abst_plus x z)))))))
  :=
  _p_M1_T:cc.uT =>
  _p_M2_T:cc.uT =>
  abst_T:cc.uT =>
  abst_equal:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) =>
  abst_plus:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT abst_T) =>
  abst_sup:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT abst_T) =>
  dk_builtins.magic_prove 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.forall abst_T 
             (z:(cc.eT abst_T) =>
              dk_logic.ebP 
                (abst_equal (abst_plus x (abst_sup y z)) 
                   (abst_sup (abst_plus x y) (abst_plus x z))))))).

def Product_additive_monoid_with_supremum__add_right_distributes_on_sup :
  _p_M1_T:cc.uT ->
  _p_M2_T:cc.uT ->
  abst_T:cc.uT ->
  abst_equal:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) ->
  abst_plus:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT abst_T) ->
  abst_sup:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT abst_T) ->
  dk_logic.eP 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.forall abst_T 
             (z:(cc.eT abst_T) =>
              dk_logic.ebP 
                (abst_equal (abst_plus (abst_sup x y) z) 
                   (abst_sup (abst_plus x z) (abst_plus y z)))))))
  :=
  _p_M1_T:cc.uT =>
  _p_M2_T:cc.uT =>
  abst_T:cc.uT =>
  abst_equal:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) =>
  abst_plus:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT abst_T) =>
  abst_sup:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT abst_T) =>
  dk_builtins.magic_prove 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.forall abst_T 
             (z:(cc.eT abst_T) =>
              dk_logic.ebP 
                (abst_equal (abst_plus (abst_sup x y) z) 
                   (abst_sup (abst_plus x z) (abst_plus y z))))))).

def Product_additive_monoid_with_supremum__sup_commutes :
  _p_M1_T:cc.uT ->
  _p_M2_T:cc.uT ->
  abst_T:cc.uT ->
  abst_equal:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) ->
  abst_sup:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT abst_T) ->
  dk_logic.eP 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.ebP (abst_equal (abst_sup x y) (abst_sup y x)))))
  :=
  _p_M1_T:cc.uT =>
  _p_M2_T:cc.uT =>
  abst_T:cc.uT =>
  abst_equal:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) =>
  abst_sup:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT abst_T) =>
  dk_builtins.magic_prove 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.ebP (abst_equal (abst_sup x y) (abst_sup y x))))).

def Product_additive_monoid_with_supremum__sup_idempotent :
  _p_M1_T:cc.uT ->
  _p_M2_T:cc.uT ->
  abst_T:cc.uT ->
  abst_equal:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) ->
  abst_sup:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT abst_T) ->
  dk_logic.eP 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.imp (dk_logic.ebP (abst_equal x y)) 
             (dk_logic.ebP (abst_equal x (abst_sup x y))))))
  :=
  _p_M1_T:cc.uT =>
  _p_M2_T:cc.uT =>
  abst_T:cc.uT =>
  abst_equal:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) =>
  abst_sup:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT abst_T) =>
  dk_builtins.magic_prove 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.imp (dk_logic.ebP (abst_equal x y)) 
             (dk_logic.ebP (abst_equal x (abst_sup x y)))))).

def Product_additive_monoid_with_supremum__sup_is_associative :
  _p_M1_T:cc.uT ->
  _p_M2_T:cc.uT ->
  abst_T:cc.uT ->
  abst_equal:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) ->
  abst_sup:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT abst_T) ->
  dk_logic.eP 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.forall abst_T 
             (z:(cc.eT abst_T) =>
              dk_logic.ebP 
                (abst_equal (abst_sup (abst_sup x y) z) 
                   (abst_sup x (abst_sup y z)))))))
  :=
  _p_M1_T:cc.uT =>
  _p_M2_T:cc.uT =>
  abst_T:cc.uT =>
  abst_equal:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) =>
  abst_sup:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT abst_T) =>
  dk_builtins.magic_prove 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.forall abst_T 
             (z:(cc.eT abst_T) =>
              dk_logic.ebP 
                (abst_equal (abst_sup (abst_sup x y) z) 
                   (abst_sup x (abst_sup y z))))))).

def Product_additive_monoid_with_supremum__sup_left_substitution_rule :
  _p_M1_T:cc.uT ->
  _p_M2_T:cc.uT ->
  abst_T:cc.uT ->
  abst_equal:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) ->
  abst_sup:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT abst_T) ->
  dk_logic.eP 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.forall abst_T 
             (z:(cc.eT abst_T) =>
              dk_logic.imp (dk_logic.ebP (abst_equal x y)) 
                (dk_logic.ebP (abst_equal (abst_sup x z) (abst_sup y z)))))))
  :=
  _p_M1_T:cc.uT =>
  _p_M2_T:cc.uT =>
  abst_T:cc.uT =>
  abst_equal:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) =>
  abst_sup:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT abst_T) =>
  dk_builtins.magic_prove 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.forall abst_T 
             (z:(cc.eT abst_T) =>
              dk_logic.imp (dk_logic.ebP (abst_equal x y)) 
                (dk_logic.ebP (abst_equal (abst_sup x z) (abst_sup y z))))))).

def Product_additive_monoid_with_supremum__sup_absorbes_add :
  _p_M1_T:cc.uT ->
  _p_M2_T:cc.uT ->
  abst_T:cc.uT ->
  abst_plus:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT abst_T) ->
  abst_order_sup:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) ->
  dk_logic.eP 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.ebP (abst_order_sup (abst_plus x y) x))))
  :=
  _p_M1_T:cc.uT =>
  _p_M2_T:cc.uT =>
  abst_T:cc.uT =>
  abst_plus:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT abst_T) =>
  abst_order_sup:
  ((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) =>
  dk_builtins.magic_prove 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.ebP (abst_order_sup (abst_plus x y) x)))).

def Lexicographic_product_additive_monoid__leq :
  _p_M1_T:cc.uT ->
  _p_M2_T:cc.uT ->
  _p_M1_equal:((cc.eT _p_M1_T) -> (cc.eT _p_M1_T) -> cc.eT basics.bool__t) ->
  _p_M1_lt:((cc.eT _p_M1_T) -> (cc.eT _p_M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_leq:((cc.eT _p_M2_T) -> (cc.eT _p_M2_T) -> cc.eT basics.bool__t) ->
  abst_T:cc.uT ->
  abst_first:((cc.eT abst_T) -> cc.eT _p_M1_T) ->
  abst_second:((cc.eT abst_T) -> cc.eT _p_M2_T) ->
  a:(cc.eT abst_T) -> b:(cc.eT abst_T) -> cc.eT basics.bool__t
  :=
  _p_M1_T:cc.uT =>
  _p_M2_T:cc.uT =>
  _p_M1_equal:((cc.eT _p_M1_T) -> (cc.eT _p_M1_T) -> cc.eT basics.bool__t) =>
  _p_M1_lt:((cc.eT _p_M1_T) -> (cc.eT _p_M1_T) -> cc.eT basics.bool__t) =>
  _p_M2_leq:((cc.eT _p_M2_T) -> (cc.eT _p_M2_T) -> cc.eT basics.bool__t) =>
  abst_T:cc.uT =>
  abst_first:((cc.eT abst_T) -> cc.eT _p_M1_T) =>
  abst_second:((cc.eT abst_T) -> cc.eT _p_M2_T) =>
  a:(cc.eT abst_T) =>
  b:(cc.eT abst_T) =>
  (a1:(cc.eT _p_M1_T) =>
   (a2:(cc.eT _p_M2_T) =>
    (b1:(cc.eT _p_M1_T) =>
     (b2:(cc.eT _p_M2_T) =>
      basics._bar__bar_ (_p_M1_lt a1 b1) 
        (basics._amper__amper_ (_p_M1_equal a1 b1) (_p_M2_leq a2 b2))) 
       (abst_second b)) (abst_first b)) (abst_second a)) (abst_first a).

def Lexicographic_product_additive_monoid__leq_antisymmetric :
  _p_M1_T:cc.uT ->
  _p_M2_T:cc.uT ->
  abst_T:cc.uT ->
  abst_equal:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) ->
  abst_leq:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) ->
  dk_logic.eP 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.imp (dk_logic.ebP (abst_leq x y)) 
             (dk_logic.imp (dk_logic.ebP (abst_leq y x)) 
                (dk_logic.ebP (abst_equal x y))))))
  :=
  _p_M1_T:cc.uT =>
  _p_M2_T:cc.uT =>
  abst_T:cc.uT =>
  abst_equal:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) =>
  abst_leq:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) =>
  dk_builtins.magic_prove 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.imp (dk_logic.ebP (abst_leq x y)) 
             (dk_logic.imp (dk_logic.ebP (abst_leq y x)) 
                (dk_logic.ebP (abst_equal x y)))))).

def Lexicographic_product_additive_monoid__leq_reflexive :
  _p_M1_T:cc.uT ->
  _p_M2_T:cc.uT ->
  abst_T:cc.uT ->
  abst_leq:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) ->
  dk_logic.eP 
    (dk_logic.forall abst_T (x:(cc.eT abst_T) => dk_logic.ebP (abst_leq x x)))
  :=
  _p_M1_T:cc.uT =>
  _p_M2_T:cc.uT =>
  abst_T:cc.uT =>
  abst_leq:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) =>
  dk_builtins.magic_prove 
    (dk_logic.forall abst_T (x:(cc.eT abst_T) => dk_logic.ebP (abst_leq x x))).

def Lexicographic_product_additive_monoid__leq_transitive :
  _p_M1_T:cc.uT ->
  _p_M2_T:cc.uT ->
  abst_T:cc.uT ->
  abst_leq:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) ->
  dk_logic.eP 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.forall abst_T 
             (z:(cc.eT abst_T) =>
              dk_logic.imp (dk_logic.ebP (abst_leq x y)) 
                (dk_logic.imp (dk_logic.ebP (abst_leq y z)) 
                   (dk_logic.ebP (abst_leq x z)))))))
  :=
  _p_M1_T:cc.uT =>
  _p_M2_T:cc.uT =>
  abst_T:cc.uT =>
  abst_leq:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) =>
  dk_builtins.magic_prove 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.forall abst_T 
             (z:(cc.eT abst_T) =>
              dk_logic.imp (dk_logic.ebP (abst_leq x y)) 
                (dk_logic.imp (dk_logic.ebP (abst_leq y z)) 
                   (dk_logic.ebP (abst_leq x z))))))).

def Lexicographic_product_additive_monoid__total_order :
  _p_M1_T:cc.uT ->
  _p_M2_T:cc.uT ->
  abst_T:cc.uT ->
  abst_leq:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) ->
  dk_logic.eP 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.or (dk_logic.ebP (abst_leq x y)) 
             (dk_logic.ebP (abst_leq y x)))))
  :=
  _p_M1_T:cc.uT =>
  _p_M2_T:cc.uT =>
  abst_T:cc.uT =>
  abst_leq:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) =>
  dk_builtins.magic_prove 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.or (dk_logic.ebP (abst_leq x y)) 
             (dk_logic.ebP (abst_leq y x))))).

def Lexicographic_product_additive_monoid__order_compatible_with_cancellation :
  _p_M1_T:cc.uT ->
  _p_M2_T:cc.uT ->
  abst_T:cc.uT ->
  abst_leq:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) ->
  abst_plus:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT abst_T) ->
  dk_logic.eP 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.forall abst_T 
             (z:(cc.eT abst_T) =>
              dk_logic.imp 
                (dk_logic.ebP (abst_leq (abst_plus x z) (abst_plus y z))) 
                (dk_logic.ebP (abst_leq x y))))))
  :=
  _p_M1_T:cc.uT =>
  _p_M2_T:cc.uT =>
  abst_T:cc.uT =>
  abst_leq:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) =>
  abst_plus:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT abst_T) =>
  dk_builtins.magic_prove 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.forall abst_T 
             (z:(cc.eT abst_T) =>
              dk_logic.imp 
                (dk_logic.ebP (abst_leq (abst_plus x z) (abst_plus y z))) 
                (dk_logic.ebP (abst_leq x y)))))).

def Lexicographic_product_additive_monoid__order_compatible_with_plus :
  _p_M1_T:cc.uT ->
  _p_M2_T:cc.uT ->
  abst_T:cc.uT ->
  abst_leq:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) ->
  abst_plus:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT abst_T) ->
  dk_logic.eP 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.forall abst_T 
             (z:(cc.eT abst_T) =>
              dk_logic.imp (dk_logic.ebP (abst_leq x y)) 
                (dk_logic.ebP (abst_leq (abst_plus x z) (abst_plus y z)))))))
  :=
  _p_M1_T:cc.uT =>
  _p_M2_T:cc.uT =>
  abst_T:cc.uT =>
  abst_leq:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) =>
  abst_plus:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT abst_T) =>
  dk_builtins.magic_prove 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.forall abst_T 
             (z:(cc.eT abst_T) =>
              dk_logic.imp (dk_logic.ebP (abst_leq x y)) 
                (dk_logic.ebP (abst_leq (abst_plus x z) (abst_plus y z))))))).

def Lexicographic_product_additive_monoid__leq_refines_order_inf :
  _p_M1_T:cc.uT ->
  _p_M2_T:cc.uT ->
  abst_T:cc.uT ->
  abst_leq:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) ->
  abst_order_inf:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) ->
  dk_logic.eP 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.imp (dk_logic.ebP (abst_order_inf x y)) 
             (dk_logic.ebP (abst_leq x y)))))
  :=
  _p_M1_T:cc.uT =>
  _p_M2_T:cc.uT =>
  abst_T:cc.uT =>
  abst_leq:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) =>
  abst_order_inf:
  ((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) =>
  dk_builtins.magic_prove 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.imp (dk_logic.ebP (abst_order_inf x y)) 
             (dk_logic.ebP (abst_leq x y))))).

def Lexicographic_product_additive_monoid__geq_refines_order_sup :
  _p_M1_T:cc.uT ->
  _p_M2_T:cc.uT ->
  abst_T:cc.uT ->
  abst_geq:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) ->
  abst_order_sup:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) ->
  dk_logic.eP 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.imp (dk_logic.ebP (abst_order_sup x y)) 
             (dk_logic.ebP (abst_geq x y)))))
  :=
  _p_M1_T:cc.uT =>
  _p_M2_T:cc.uT =>
  abst_T:cc.uT =>
  abst_geq:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) =>
  abst_order_sup:
  ((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) =>
  dk_builtins.magic_prove 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.imp (dk_logic.ebP (abst_order_sup x y)) 
             (dk_logic.ebP (abst_geq x y))))).

def Reverse_lexicographic_product_additive_monoid__leq :
  _p_M1_T:cc.uT ->
  _p_M2_T:cc.uT ->
  _p_M1_leq:((cc.eT _p_M1_T) -> (cc.eT _p_M1_T) -> cc.eT basics.bool__t) ->
  _p_M2_equal:((cc.eT _p_M2_T) -> (cc.eT _p_M2_T) -> cc.eT basics.bool__t) ->
  _p_M2_lt:((cc.eT _p_M2_T) -> (cc.eT _p_M2_T) -> cc.eT basics.bool__t) ->
  abst_T:cc.uT ->
  abst_first:((cc.eT abst_T) -> cc.eT _p_M1_T) ->
  abst_second:((cc.eT abst_T) -> cc.eT _p_M2_T) ->
  a:(cc.eT abst_T) -> b:(cc.eT abst_T) -> cc.eT basics.bool__t
  :=
  _p_M1_T:cc.uT =>
  _p_M2_T:cc.uT =>
  _p_M1_leq:((cc.eT _p_M1_T) -> (cc.eT _p_M1_T) -> cc.eT basics.bool__t) =>
  _p_M2_equal:((cc.eT _p_M2_T) -> (cc.eT _p_M2_T) -> cc.eT basics.bool__t) =>
  _p_M2_lt:((cc.eT _p_M2_T) -> (cc.eT _p_M2_T) -> cc.eT basics.bool__t) =>
  abst_T:cc.uT =>
  abst_first:((cc.eT abst_T) -> cc.eT _p_M1_T) =>
  abst_second:((cc.eT abst_T) -> cc.eT _p_M2_T) =>
  a:(cc.eT abst_T) =>
  b:(cc.eT abst_T) =>
  (a1:(cc.eT _p_M1_T) =>
   (a2:(cc.eT _p_M2_T) =>
    (b1:(cc.eT _p_M1_T) =>
     (b2:(cc.eT _p_M2_T) =>
      basics._bar__bar_ (_p_M2_lt a2 b2) 
        (basics._amper__amper_ (_p_M2_equal a2 b2) (_p_M1_leq a1 b1))) 
       (abst_second b)) (abst_first b)) (abst_second a)) (abst_first a).

def Reverse_lexicographic_product_additive_monoid__leq_antisymmetric :
  _p_M1_T:cc.uT ->
  _p_M2_T:cc.uT ->
  abst_T:cc.uT ->
  abst_equal:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) ->
  abst_leq:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) ->
  dk_logic.eP 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.imp (dk_logic.ebP (abst_leq x y)) 
             (dk_logic.imp (dk_logic.ebP (abst_leq y x)) 
                (dk_logic.ebP (abst_equal x y))))))
  :=
  _p_M1_T:cc.uT =>
  _p_M2_T:cc.uT =>
  abst_T:cc.uT =>
  abst_equal:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) =>
  abst_leq:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) =>
  dk_builtins.magic_prove 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.imp (dk_logic.ebP (abst_leq x y)) 
             (dk_logic.imp (dk_logic.ebP (abst_leq y x)) 
                (dk_logic.ebP (abst_equal x y)))))).

def Reverse_lexicographic_product_additive_monoid__leq_reflexive :
  _p_M1_T:cc.uT ->
  _p_M2_T:cc.uT ->
  abst_T:cc.uT ->
  abst_leq:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) ->
  dk_logic.eP 
    (dk_logic.forall abst_T (x:(cc.eT abst_T) => dk_logic.ebP (abst_leq x x)))
  :=
  _p_M1_T:cc.uT =>
  _p_M2_T:cc.uT =>
  abst_T:cc.uT =>
  abst_leq:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) =>
  dk_builtins.magic_prove 
    (dk_logic.forall abst_T (x:(cc.eT abst_T) => dk_logic.ebP (abst_leq x x))).

def Reverse_lexicographic_product_additive_monoid__leq_transitive :
  _p_M1_T:cc.uT ->
  _p_M2_T:cc.uT ->
  abst_T:cc.uT ->
  abst_leq:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) ->
  dk_logic.eP 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.forall abst_T 
             (z:(cc.eT abst_T) =>
              dk_logic.imp (dk_logic.ebP (abst_leq x y)) 
                (dk_logic.imp (dk_logic.ebP (abst_leq y z)) 
                   (dk_logic.ebP (abst_leq x z)))))))
  :=
  _p_M1_T:cc.uT =>
  _p_M2_T:cc.uT =>
  abst_T:cc.uT =>
  abst_leq:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) =>
  dk_builtins.magic_prove 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.forall abst_T 
             (z:(cc.eT abst_T) =>
              dk_logic.imp (dk_logic.ebP (abst_leq x y)) 
                (dk_logic.imp (dk_logic.ebP (abst_leq y z)) 
                   (dk_logic.ebP (abst_leq x z))))))).

def Reverse_lexicographic_product_additive_monoid__total_order :
  _p_M1_T:cc.uT ->
  _p_M2_T:cc.uT ->
  abst_T:cc.uT ->
  abst_leq:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) ->
  dk_logic.eP 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.or (dk_logic.ebP (abst_leq x y)) 
             (dk_logic.ebP (abst_leq y x)))))
  :=
  _p_M1_T:cc.uT =>
  _p_M2_T:cc.uT =>
  abst_T:cc.uT =>
  abst_leq:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) =>
  dk_builtins.magic_prove 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.or (dk_logic.ebP (abst_leq x y)) 
             (dk_logic.ebP (abst_leq y x))))).

def Reverse_lexicographic_product_additive_monoid__order_compatible_with_cancellation :
  _p_M1_T:cc.uT ->
  _p_M2_T:cc.uT ->
  abst_T:cc.uT ->
  abst_leq:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) ->
  abst_plus:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT abst_T) ->
  dk_logic.eP 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.forall abst_T 
             (z:(cc.eT abst_T) =>
              dk_logic.imp 
                (dk_logic.ebP (abst_leq (abst_plus x z) (abst_plus y z))) 
                (dk_logic.ebP (abst_leq x y))))))
  :=
  _p_M1_T:cc.uT =>
  _p_M2_T:cc.uT =>
  abst_T:cc.uT =>
  abst_leq:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) =>
  abst_plus:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT abst_T) =>
  dk_builtins.magic_prove 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.forall abst_T 
             (z:(cc.eT abst_T) =>
              dk_logic.imp 
                (dk_logic.ebP (abst_leq (abst_plus x z) (abst_plus y z))) 
                (dk_logic.ebP (abst_leq x y)))))).

def Reverse_lexicographic_product_additive_monoid__order_compatible_with_plus :
  _p_M1_T:cc.uT ->
  _p_M2_T:cc.uT ->
  abst_T:cc.uT ->
  abst_leq:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) ->
  abst_plus:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT abst_T) ->
  dk_logic.eP 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.forall abst_T 
             (z:(cc.eT abst_T) =>
              dk_logic.imp (dk_logic.ebP (abst_leq x y)) 
                (dk_logic.ebP (abst_leq (abst_plus x z) (abst_plus y z)))))))
  :=
  _p_M1_T:cc.uT =>
  _p_M2_T:cc.uT =>
  abst_T:cc.uT =>
  abst_leq:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) =>
  abst_plus:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT abst_T) =>
  dk_builtins.magic_prove 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.forall abst_T 
             (z:(cc.eT abst_T) =>
              dk_logic.imp (dk_logic.ebP (abst_leq x y)) 
                (dk_logic.ebP (abst_leq (abst_plus x z) (abst_plus y z))))))).

def Reverse_lexicographic_product_additive_monoid__leq_refines_order_inf :
  _p_M1_T:cc.uT ->
  _p_M2_T:cc.uT ->
  abst_T:cc.uT ->
  abst_leq:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) ->
  abst_order_inf:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) ->
  dk_logic.eP 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.imp (dk_logic.ebP (abst_order_inf x y)) 
             (dk_logic.ebP (abst_leq x y)))))
  :=
  _p_M1_T:cc.uT =>
  _p_M2_T:cc.uT =>
  abst_T:cc.uT =>
  abst_leq:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) =>
  abst_order_inf:
  ((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) =>
  dk_builtins.magic_prove 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.imp (dk_logic.ebP (abst_order_inf x y)) 
             (dk_logic.ebP (abst_leq x y))))).

def Reverse_lexicographic_product_additive_monoid__geq_refines_order_sup :
  _p_M1_T:cc.uT ->
  _p_M2_T:cc.uT ->
  abst_T:cc.uT ->
  abst_geq:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) ->
  abst_order_sup:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) ->
  dk_logic.eP 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.imp (dk_logic.ebP (abst_order_sup x y)) 
             (dk_logic.ebP (abst_geq x y)))))
  :=
  _p_M1_T:cc.uT =>
  _p_M2_T:cc.uT =>
  abst_T:cc.uT =>
  abst_geq:((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) =>
  abst_order_sup:
  ((cc.eT abst_T) -> (cc.eT abst_T) -> cc.eT basics.bool__t) =>
  dk_builtins.magic_prove 
    (dk_logic.forall abst_T 
       (x:(cc.eT abst_T) =>
        dk_logic.forall abst_T 
          (y:(cc.eT abst_T) =>
           dk_logic.imp (dk_logic.ebP (abst_order_sup x y)) 
             (dk_logic.ebP (abst_geq x y))))).

