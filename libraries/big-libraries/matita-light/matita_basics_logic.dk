(; This file was automatically generated from Matita. ;)

#NAME matita_basics_logic.

eq :
  A : cic.Univ univs.Type2 ->
  _x : cic.Term univs.Type2 A ->
  __ : cic.Term univs.Type2 A -> cic.Univ cic.prop.

refl :
  A : cic.Univ univs.Type2 ->
  x : cic.Term univs.Type2 A ->
  cic.Term cic.prop (matita_basics_logic.eq A x x).

def match_eq :
      A : cic.Univ univs.Type2 ->
      _x : cic.Term univs.Type2 A ->
      return_sort : cic.Sort ->
      return_type :
        (__ : cic.Term univs.Type2 A ->
         z : cic.Term cic.prop (matita_basics_logic.eq A _x __) ->
         cic.Univ return_sort) ->
      case_refl :
        cic.Term return_sort (return_type _x (matita_basics_logic.refl A _x)) ->
      __ : cic.Term univs.Type2 A ->
      z : cic.Term cic.prop (matita_basics_logic.eq A _x __) ->
      cic.Term return_sort (return_type __ z).

[ A, _x, return_sort, return_type, case_refl ]
  match_eq A _x return_sort return_type case_refl (_x)
    (matita_basics_logic.refl A _x) -->
  case_refl.

def filter_eq :
      A : cic.Univ univs.Type2 ->
      _x : cic.Term univs.Type2 A ->
      __ : cic.Term univs.Type2 A ->
      return_sort : cic.Sort ->
      return_type :
        (z : cic.Term cic.prop (matita_basics_logic.eq A _x __) ->
         cic.Univ return_sort) ->
      return :
        (z : cic.Term cic.prop (matita_basics_logic.eq A _x __) ->
         cic.Term return_sort (return_type z)) ->
      z : cic.Term cic.prop (matita_basics_logic.eq A _x __) ->
      cic.Term return_sort (return_type z).

[ A, x, return_sort, return_type, return ]
  filter_eq (A) (x) (x) return_sort return_type return
    (matita_basics_logic.refl A x) -->
  return (matita_basics_logic.refl A x).

def eq_ind :
      A : cic.Univ univs.Type2 ->
      _x : cic.Term univs.Type2 A ->
      Q_ :
        (x_1 : cic.Term univs.Type2 A ->
         _x_2 : cic.Term cic.prop (matita_basics_logic.eq A _x x_1) ->
         cic.Univ cic.prop) ->
      _H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x)) ->
      x_1 : cic.Term univs.Type2 A ->
      x_2 : cic.Term cic.prop (matita_basics_logic.eq A _x x_1) ->
      cic.Term cic.prop (Q_ x_1 x_2).

def eq_ind_body :
      A : cic.Univ univs.Type2 ->
      _x : cic.Term univs.Type2 A ->
      Q_ :
        (x_1 : cic.Term univs.Type2 A ->
         _x_2 : cic.Term cic.prop (matita_basics_logic.eq A _x x_1) ->
         cic.Univ cic.prop) ->
      _H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x)) ->
      x_1 : cic.Term univs.Type2 A ->
      x_2 : cic.Term cic.prop (matita_basics_logic.eq A _x x_1) ->
      cic.Term cic.prop (Q_ x_1 x_2).

[ A, _x, Q_, _H_refl, x_1, x_2 ] eq_ind A _x Q_ _H_refl x_1 x_2 -->
  matita_basics_logic.filter_eq A _x x_1 cic.prop
    (x_2 : cic.Term cic.prop (matita_basics_logic.eq A _x x_1) => Q_ x_1 x_2)
    (matita_basics_logic.eq_ind_body A _x Q_ _H_refl x_1) x_2.

[ A, _x, Q_, _H_refl, x_1, x_2 ] eq_ind_body A _x Q_ _H_refl x_1 x_2 -->
  matita_basics_logic.match_eq A _x cic.prop Q_ _H_refl x_1 x_2.

def eq_rect_Type4 :
      A : cic.Univ univs.Type2 ->
      _x : cic.Term univs.Type2 A ->
      Q_ :
        (x_4 : cic.Term univs.Type2 A ->
         _x_5 : cic.Term cic.prop (matita_basics_logic.eq A _x x_4) ->
         cic.Univ univs.Type4) ->
      _H_refl :
        cic.Term univs.Type4 (Q_ _x (matita_basics_logic.refl A _x)) ->
      x_4 : cic.Term univs.Type2 A ->
      x_5 : cic.Term cic.prop (matita_basics_logic.eq A _x x_4) ->
      cic.Term univs.Type4 (Q_ x_4 x_5).

def eq_rect_Type4_body :
      A : cic.Univ univs.Type2 ->
      _x : cic.Term univs.Type2 A ->
      Q_ :
        (x_4 : cic.Term univs.Type2 A ->
         _x_5 : cic.Term cic.prop (matita_basics_logic.eq A _x x_4) ->
         cic.Univ univs.Type4) ->
      _H_refl :
        cic.Term univs.Type4 (Q_ _x (matita_basics_logic.refl A _x)) ->
      x_4 : cic.Term univs.Type2 A ->
      x_5 : cic.Term cic.prop (matita_basics_logic.eq A _x x_4) ->
      cic.Term univs.Type4 (Q_ x_4 x_5).

[ A, _x, Q_, _H_refl, x_4, x_5 ] eq_rect_Type4 A _x Q_ _H_refl x_4 x_5 -->
  matita_basics_logic.filter_eq A _x x_4 univs.Type4
    (x_5 : cic.Term cic.prop (matita_basics_logic.eq A _x x_4) => Q_ x_4 x_5)
    (matita_basics_logic.eq_rect_Type4_body A _x Q_ _H_refl x_4) x_5.

[ A, _x, Q_, _H_refl, x_4, x_5 ]
  eq_rect_Type4_body A _x Q_ _H_refl x_4 x_5 -->
  matita_basics_logic.match_eq A _x univs.Type4 Q_ _H_refl x_4 x_5.

def eq_rect_Type5 :
      A : cic.Univ univs.Type2 ->
      _x : cic.Term univs.Type2 A ->
      Q_ :
        (x_7 : cic.Term univs.Type2 A ->
         _x_8 : cic.Term cic.prop (matita_basics_logic.eq A _x x_7) ->
         cic.Univ univs.Type5) ->
      _H_refl :
        cic.Term univs.Type5 (Q_ _x (matita_basics_logic.refl A _x)) ->
      x_7 : cic.Term univs.Type2 A ->
      x_8 : cic.Term cic.prop (matita_basics_logic.eq A _x x_7) ->
      cic.Term univs.Type5 (Q_ x_7 x_8).

def eq_rect_Type5_body :
      A : cic.Univ univs.Type2 ->
      _x : cic.Term univs.Type2 A ->
      Q_ :
        (x_7 : cic.Term univs.Type2 A ->
         _x_8 : cic.Term cic.prop (matita_basics_logic.eq A _x x_7) ->
         cic.Univ univs.Type5) ->
      _H_refl :
        cic.Term univs.Type5 (Q_ _x (matita_basics_logic.refl A _x)) ->
      x_7 : cic.Term univs.Type2 A ->
      x_8 : cic.Term cic.prop (matita_basics_logic.eq A _x x_7) ->
      cic.Term univs.Type5 (Q_ x_7 x_8).

[ A, _x, Q_, _H_refl, x_7, x_8 ] eq_rect_Type5 A _x Q_ _H_refl x_7 x_8 -->
  matita_basics_logic.filter_eq A _x x_7 univs.Type5
    (x_8 : cic.Term cic.prop (matita_basics_logic.eq A _x x_7) => Q_ x_7 x_8)
    (matita_basics_logic.eq_rect_Type5_body A _x Q_ _H_refl x_7) x_8.

[ A, _x, Q_, _H_refl, x_7, x_8 ]
  eq_rect_Type5_body A _x Q_ _H_refl x_7 x_8 -->
  matita_basics_logic.match_eq A _x univs.Type5 Q_ _H_refl x_7 x_8.

def eq_rect_Type3 :
      A : cic.Univ univs.Type2 ->
      _x : cic.Term univs.Type2 A ->
      Q_ :
        (x_10 : cic.Term univs.Type2 A ->
         _x_11 : cic.Term cic.prop (matita_basics_logic.eq A _x x_10) ->
         cic.Univ univs.Type3) ->
      _H_refl :
        cic.Term univs.Type3 (Q_ _x (matita_basics_logic.refl A _x)) ->
      x_10 : cic.Term univs.Type2 A ->
      x_11 : cic.Term cic.prop (matita_basics_logic.eq A _x x_10) ->
      cic.Term univs.Type3 (Q_ x_10 x_11).

def eq_rect_Type3_body :
      A : cic.Univ univs.Type2 ->
      _x : cic.Term univs.Type2 A ->
      Q_ :
        (x_10 : cic.Term univs.Type2 A ->
         _x_11 : cic.Term cic.prop (matita_basics_logic.eq A _x x_10) ->
         cic.Univ univs.Type3) ->
      _H_refl :
        cic.Term univs.Type3 (Q_ _x (matita_basics_logic.refl A _x)) ->
      x_10 : cic.Term univs.Type2 A ->
      x_11 : cic.Term cic.prop (matita_basics_logic.eq A _x x_10) ->
      cic.Term univs.Type3 (Q_ x_10 x_11).

[ A, _x, Q_, _H_refl, x_10, x_11 ]
  eq_rect_Type3 A _x Q_ _H_refl x_10 x_11 -->
  matita_basics_logic.filter_eq A _x x_10 univs.Type3
    (x_11 : cic.Term cic.prop (matita_basics_logic.eq A _x x_10) =>
     Q_ x_10 x_11)
    (matita_basics_logic.eq_rect_Type3_body A _x Q_ _H_refl x_10) x_11.

[ A, _x, Q_, _H_refl, x_10, x_11 ]
  eq_rect_Type3_body A _x Q_ _H_refl x_10 x_11 -->
  matita_basics_logic.match_eq A _x univs.Type3 Q_ _H_refl x_10 x_11.

def eq_rect_Type2 :
      A : cic.Univ univs.Type2 ->
      _x : cic.Term univs.Type2 A ->
      Q_ :
        (x_13 : cic.Term univs.Type2 A ->
         _x_14 : cic.Term cic.prop (matita_basics_logic.eq A _x x_13) ->
         cic.Univ univs.Type2) ->
      _H_refl :
        cic.Term univs.Type2 (Q_ _x (matita_basics_logic.refl A _x)) ->
      x_13 : cic.Term univs.Type2 A ->
      x_14 : cic.Term cic.prop (matita_basics_logic.eq A _x x_13) ->
      cic.Term univs.Type2 (Q_ x_13 x_14).

def eq_rect_Type2_body :
      A : cic.Univ univs.Type2 ->
      _x : cic.Term univs.Type2 A ->
      Q_ :
        (x_13 : cic.Term univs.Type2 A ->
         _x_14 : cic.Term cic.prop (matita_basics_logic.eq A _x x_13) ->
         cic.Univ univs.Type2) ->
      _H_refl :
        cic.Term univs.Type2 (Q_ _x (matita_basics_logic.refl A _x)) ->
      x_13 : cic.Term univs.Type2 A ->
      x_14 : cic.Term cic.prop (matita_basics_logic.eq A _x x_13) ->
      cic.Term univs.Type2 (Q_ x_13 x_14).

[ A, _x, Q_, _H_refl, x_13, x_14 ]
  eq_rect_Type2 A _x Q_ _H_refl x_13 x_14 -->
  matita_basics_logic.filter_eq A _x x_13 univs.Type2
    (x_14 : cic.Term cic.prop (matita_basics_logic.eq A _x x_13) =>
     Q_ x_13 x_14)
    (matita_basics_logic.eq_rect_Type2_body A _x Q_ _H_refl x_13) x_14.

[ A, _x, Q_, _H_refl, x_13, x_14 ]
  eq_rect_Type2_body A _x Q_ _H_refl x_13 x_14 -->
  matita_basics_logic.match_eq A _x univs.Type2 Q_ _H_refl x_13 x_14.

def eq_rect_Type1 :
      A : cic.Univ univs.Type2 ->
      _x : cic.Term univs.Type2 A ->
      Q_ :
        (x_16 : cic.Term univs.Type2 A ->
         _x_17 : cic.Term cic.prop (matita_basics_logic.eq A _x x_16) ->
         cic.Univ univs.Type1) ->
      _H_refl :
        cic.Term univs.Type1 (Q_ _x (matita_basics_logic.refl A _x)) ->
      x_16 : cic.Term univs.Type2 A ->
      x_17 : cic.Term cic.prop (matita_basics_logic.eq A _x x_16) ->
      cic.Term univs.Type1 (Q_ x_16 x_17).

def eq_rect_Type1_body :
      A : cic.Univ univs.Type2 ->
      _x : cic.Term univs.Type2 A ->
      Q_ :
        (x_16 : cic.Term univs.Type2 A ->
         _x_17 : cic.Term cic.prop (matita_basics_logic.eq A _x x_16) ->
         cic.Univ univs.Type1) ->
      _H_refl :
        cic.Term univs.Type1 (Q_ _x (matita_basics_logic.refl A _x)) ->
      x_16 : cic.Term univs.Type2 A ->
      x_17 : cic.Term cic.prop (matita_basics_logic.eq A _x x_16) ->
      cic.Term univs.Type1 (Q_ x_16 x_17).

[ A, _x, Q_, _H_refl, x_16, x_17 ]
  eq_rect_Type1 A _x Q_ _H_refl x_16 x_17 -->
  matita_basics_logic.filter_eq A _x x_16 univs.Type1
    (x_17 : cic.Term cic.prop (matita_basics_logic.eq A _x x_16) =>
     Q_ x_16 x_17)
    (matita_basics_logic.eq_rect_Type1_body A _x Q_ _H_refl x_16) x_17.

[ A, _x, Q_, _H_refl, x_16, x_17 ]
  eq_rect_Type1_body A _x Q_ _H_refl x_16 x_17 -->
  matita_basics_logic.match_eq A _x univs.Type1 Q_ _H_refl x_16 x_17.

def eq_rect_Type0 :
      A : cic.Univ univs.Type2 ->
      _x : cic.Term univs.Type2 A ->
      Q_ :
        (x_19 : cic.Term univs.Type2 A ->
         _x_20 : cic.Term cic.prop (matita_basics_logic.eq A _x x_19) ->
         cic.Univ univs.Type0) ->
      _H_refl :
        cic.Term univs.Type0 (Q_ _x (matita_basics_logic.refl A _x)) ->
      x_19 : cic.Term univs.Type2 A ->
      x_20 : cic.Term cic.prop (matita_basics_logic.eq A _x x_19) ->
      cic.Term univs.Type0 (Q_ x_19 x_20).

def eq_rect_Type0_body :
      A : cic.Univ univs.Type2 ->
      _x : cic.Term univs.Type2 A ->
      Q_ :
        (x_19 : cic.Term univs.Type2 A ->
         _x_20 : cic.Term cic.prop (matita_basics_logic.eq A _x x_19) ->
         cic.Univ univs.Type0) ->
      _H_refl :
        cic.Term univs.Type0 (Q_ _x (matita_basics_logic.refl A _x)) ->
      x_19 : cic.Term univs.Type2 A ->
      x_20 : cic.Term cic.prop (matita_basics_logic.eq A _x x_19) ->
      cic.Term univs.Type0 (Q_ x_19 x_20).

[ A, _x, Q_, _H_refl, x_19, x_20 ]
  eq_rect_Type0 A _x Q_ _H_refl x_19 x_20 -->
  matita_basics_logic.filter_eq A _x x_19 univs.Type0
    (x_20 : cic.Term cic.prop (matita_basics_logic.eq A _x x_19) =>
     Q_ x_19 x_20)
    (matita_basics_logic.eq_rect_Type0_body A _x Q_ _H_refl x_19) x_20.

[ A, _x, Q_, _H_refl, x_19, x_20 ]
  eq_rect_Type0_body A _x Q_ _H_refl x_19 x_20 -->
  matita_basics_logic.match_eq A _x univs.Type0 Q_ _H_refl x_19 x_20.

def eq_rect_CProp4 :
      A : cic.Univ univs.Type2 ->
      _x : cic.Term univs.Type2 A ->
      Q_ :
        (x_22 : cic.Term univs.Type2 A ->
         _x_23 : cic.Term cic.prop (matita_basics_logic.eq A _x x_22) ->
         cic.Univ cic.prop) ->
      _H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x)) ->
      x_22 : cic.Term univs.Type2 A ->
      x_23 : cic.Term cic.prop (matita_basics_logic.eq A _x x_22) ->
      cic.Term cic.prop (Q_ x_22 x_23).

def eq_rect_CProp4_body :
      A : cic.Univ univs.Type2 ->
      _x : cic.Term univs.Type2 A ->
      Q_ :
        (x_22 : cic.Term univs.Type2 A ->
         _x_23 : cic.Term cic.prop (matita_basics_logic.eq A _x x_22) ->
         cic.Univ cic.prop) ->
      _H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x)) ->
      x_22 : cic.Term univs.Type2 A ->
      x_23 : cic.Term cic.prop (matita_basics_logic.eq A _x x_22) ->
      cic.Term cic.prop (Q_ x_22 x_23).

[ A, _x, Q_, _H_refl, x_22, x_23 ]
  eq_rect_CProp4 A _x Q_ _H_refl x_22 x_23 -->
  matita_basics_logic.filter_eq A _x x_22 cic.prop
    (x_23 : cic.Term cic.prop (matita_basics_logic.eq A _x x_22) =>
     Q_ x_22 x_23)
    (matita_basics_logic.eq_rect_CProp4_body A _x Q_ _H_refl x_22) x_23.

[ A, _x, Q_, _H_refl, x_22, x_23 ]
  eq_rect_CProp4_body A _x Q_ _H_refl x_22 x_23 -->
  matita_basics_logic.match_eq A _x cic.prop Q_ _H_refl x_22 x_23.

def eq_rect_CProp5 :
      A : cic.Univ univs.Type2 ->
      _x : cic.Term univs.Type2 A ->
      Q_ :
        (x_25 : cic.Term univs.Type2 A ->
         _x_26 : cic.Term cic.prop (matita_basics_logic.eq A _x x_25) ->
         cic.Univ cic.prop) ->
      _H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x)) ->
      x_25 : cic.Term univs.Type2 A ->
      x_26 : cic.Term cic.prop (matita_basics_logic.eq A _x x_25) ->
      cic.Term cic.prop (Q_ x_25 x_26).

def eq_rect_CProp5_body :
      A : cic.Univ univs.Type2 ->
      _x : cic.Term univs.Type2 A ->
      Q_ :
        (x_25 : cic.Term univs.Type2 A ->
         _x_26 : cic.Term cic.prop (matita_basics_logic.eq A _x x_25) ->
         cic.Univ cic.prop) ->
      _H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x)) ->
      x_25 : cic.Term univs.Type2 A ->
      x_26 : cic.Term cic.prop (matita_basics_logic.eq A _x x_25) ->
      cic.Term cic.prop (Q_ x_25 x_26).

[ A, _x, Q_, _H_refl, x_25, x_26 ]
  eq_rect_CProp5 A _x Q_ _H_refl x_25 x_26 -->
  matita_basics_logic.filter_eq A _x x_25 cic.prop
    (x_26 : cic.Term cic.prop (matita_basics_logic.eq A _x x_25) =>
     Q_ x_25 x_26)
    (matita_basics_logic.eq_rect_CProp5_body A _x Q_ _H_refl x_25) x_26.

[ A, _x, Q_, _H_refl, x_25, x_26 ]
  eq_rect_CProp5_body A _x Q_ _H_refl x_25 x_26 -->
  matita_basics_logic.match_eq A _x cic.prop Q_ _H_refl x_25 x_26.

def eq_rect_CProp3 :
      A : cic.Univ univs.Type2 ->
      _x : cic.Term univs.Type2 A ->
      Q_ :
        (x_28 : cic.Term univs.Type2 A ->
         _x_29 : cic.Term cic.prop (matita_basics_logic.eq A _x x_28) ->
         cic.Univ cic.prop) ->
      _H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x)) ->
      x_28 : cic.Term univs.Type2 A ->
      x_29 : cic.Term cic.prop (matita_basics_logic.eq A _x x_28) ->
      cic.Term cic.prop (Q_ x_28 x_29).

def eq_rect_CProp3_body :
      A : cic.Univ univs.Type2 ->
      _x : cic.Term univs.Type2 A ->
      Q_ :
        (x_28 : cic.Term univs.Type2 A ->
         _x_29 : cic.Term cic.prop (matita_basics_logic.eq A _x x_28) ->
         cic.Univ cic.prop) ->
      _H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x)) ->
      x_28 : cic.Term univs.Type2 A ->
      x_29 : cic.Term cic.prop (matita_basics_logic.eq A _x x_28) ->
      cic.Term cic.prop (Q_ x_28 x_29).

[ A, _x, Q_, _H_refl, x_28, x_29 ]
  eq_rect_CProp3 A _x Q_ _H_refl x_28 x_29 -->
  matita_basics_logic.filter_eq A _x x_28 cic.prop
    (x_29 : cic.Term cic.prop (matita_basics_logic.eq A _x x_28) =>
     Q_ x_28 x_29)
    (matita_basics_logic.eq_rect_CProp3_body A _x Q_ _H_refl x_28) x_29.

[ A, _x, Q_, _H_refl, x_28, x_29 ]
  eq_rect_CProp3_body A _x Q_ _H_refl x_28 x_29 -->
  matita_basics_logic.match_eq A _x cic.prop Q_ _H_refl x_28 x_29.

def eq_rect_CProp2 :
      A : cic.Univ univs.Type2 ->
      _x : cic.Term univs.Type2 A ->
      Q_ :
        (x_31 : cic.Term univs.Type2 A ->
         _x_32 : cic.Term cic.prop (matita_basics_logic.eq A _x x_31) ->
         cic.Univ cic.prop) ->
      _H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x)) ->
      x_31 : cic.Term univs.Type2 A ->
      x_32 : cic.Term cic.prop (matita_basics_logic.eq A _x x_31) ->
      cic.Term cic.prop (Q_ x_31 x_32).

def eq_rect_CProp2_body :
      A : cic.Univ univs.Type2 ->
      _x : cic.Term univs.Type2 A ->
      Q_ :
        (x_31 : cic.Term univs.Type2 A ->
         _x_32 : cic.Term cic.prop (matita_basics_logic.eq A _x x_31) ->
         cic.Univ cic.prop) ->
      _H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x)) ->
      x_31 : cic.Term univs.Type2 A ->
      x_32 : cic.Term cic.prop (matita_basics_logic.eq A _x x_31) ->
      cic.Term cic.prop (Q_ x_31 x_32).

[ A, _x, Q_, _H_refl, x_31, x_32 ]
  eq_rect_CProp2 A _x Q_ _H_refl x_31 x_32 -->
  matita_basics_logic.filter_eq A _x x_31 cic.prop
    (x_32 : cic.Term cic.prop (matita_basics_logic.eq A _x x_31) =>
     Q_ x_31 x_32)
    (matita_basics_logic.eq_rect_CProp2_body A _x Q_ _H_refl x_31) x_32.

[ A, _x, Q_, _H_refl, x_31, x_32 ]
  eq_rect_CProp2_body A _x Q_ _H_refl x_31 x_32 -->
  matita_basics_logic.match_eq A _x cic.prop Q_ _H_refl x_31 x_32.

def eq_rect_CProp1 :
      A : cic.Univ univs.Type2 ->
      _x : cic.Term univs.Type2 A ->
      Q_ :
        (x_34 : cic.Term univs.Type2 A ->
         _x_35 : cic.Term cic.prop (matita_basics_logic.eq A _x x_34) ->
         cic.Univ cic.prop) ->
      _H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x)) ->
      x_34 : cic.Term univs.Type2 A ->
      x_35 : cic.Term cic.prop (matita_basics_logic.eq A _x x_34) ->
      cic.Term cic.prop (Q_ x_34 x_35).

def eq_rect_CProp1_body :
      A : cic.Univ univs.Type2 ->
      _x : cic.Term univs.Type2 A ->
      Q_ :
        (x_34 : cic.Term univs.Type2 A ->
         _x_35 : cic.Term cic.prop (matita_basics_logic.eq A _x x_34) ->
         cic.Univ cic.prop) ->
      _H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x)) ->
      x_34 : cic.Term univs.Type2 A ->
      x_35 : cic.Term cic.prop (matita_basics_logic.eq A _x x_34) ->
      cic.Term cic.prop (Q_ x_34 x_35).

[ A, _x, Q_, _H_refl, x_34, x_35 ]
  eq_rect_CProp1 A _x Q_ _H_refl x_34 x_35 -->
  matita_basics_logic.filter_eq A _x x_34 cic.prop
    (x_35 : cic.Term cic.prop (matita_basics_logic.eq A _x x_34) =>
     Q_ x_34 x_35)
    (matita_basics_logic.eq_rect_CProp1_body A _x Q_ _H_refl x_34) x_35.

[ A, _x, Q_, _H_refl, x_34, x_35 ]
  eq_rect_CProp1_body A _x Q_ _H_refl x_34 x_35 -->
  matita_basics_logic.match_eq A _x cic.prop Q_ _H_refl x_34 x_35.

def eq_rect_CProp0 :
      A : cic.Univ univs.Type2 ->
      _x : cic.Term univs.Type2 A ->
      Q_ :
        (x_37 : cic.Term univs.Type2 A ->
         _x_38 : cic.Term cic.prop (matita_basics_logic.eq A _x x_37) ->
         cic.Univ cic.prop) ->
      _H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x)) ->
      x_37 : cic.Term univs.Type2 A ->
      x_38 : cic.Term cic.prop (matita_basics_logic.eq A _x x_37) ->
      cic.Term cic.prop (Q_ x_37 x_38).

def eq_rect_CProp0_body :
      A : cic.Univ univs.Type2 ->
      _x : cic.Term univs.Type2 A ->
      Q_ :
        (x_37 : cic.Term univs.Type2 A ->
         _x_38 : cic.Term cic.prop (matita_basics_logic.eq A _x x_37) ->
         cic.Univ cic.prop) ->
      _H_refl : cic.Term cic.prop (Q_ _x (matita_basics_logic.refl A _x)) ->
      x_37 : cic.Term univs.Type2 A ->
      x_38 : cic.Term cic.prop (matita_basics_logic.eq A _x x_37) ->
      cic.Term cic.prop (Q_ x_37 x_38).

[ A, _x, Q_, _H_refl, x_37, x_38 ]
  eq_rect_CProp0 A _x Q_ _H_refl x_37 x_38 -->
  matita_basics_logic.filter_eq A _x x_37 cic.prop
    (x_38 : cic.Term cic.prop (matita_basics_logic.eq A _x x_37) =>
     Q_ x_37 x_38)
    (matita_basics_logic.eq_rect_CProp0_body A _x Q_ _H_refl x_37) x_38.

[ A, _x, Q_, _H_refl, x_37, x_38 ]
  eq_rect_CProp0_body A _x Q_ _H_refl x_37 x_38 -->
  matita_basics_logic.match_eq A _x cic.prop Q_ _H_refl x_37 x_38.

def eq_rect_r :
      A : cic.Univ univs.Type2 ->
      a : cic.Term univs.Type2 A ->
      x : cic.Term univs.Type2 A ->
      p : cic.Term cic.prop (matita_basics_logic.eq A x a) ->
      P :
        (x0 : cic.Term univs.Type2 A ->
         __ : cic.Term cic.prop (matita_basics_logic.eq A x0 a) ->
         cic.Univ univs.Type3) ->
      __ : cic.Term univs.Type3 (P a (matita_basics_logic.refl A a)) ->
      cic.Term univs.Type3 (P x p) :=
      A : cic.Univ univs.Type2 =>
      a : cic.Term univs.Type2 A =>
      x : cic.Term univs.Type2 A =>
      p : cic.Term cic.prop (matita_basics_logic.eq A x a) =>
      matita_basics_logic.match_eq A x
        (cic.max univs.Type3 (cic.max (cic.succ univs.Type3) univs.Type2))
        (__ : cic.Term univs.Type2 A =>
         _0 : cic.Term cic.prop (matita_basics_logic.eq A x __) =>
         cic.prod (cic.max (cic.succ univs.Type3) univs.Type2) univs.Type3
           (cic.prod univs.Type2 (cic.succ univs.Type3) A
              (x0 : cic.Term univs.Type2 A =>
               cic.prod cic.prop (cic.succ univs.Type3)
                 (matita_basics_logic.eq A x0 __)
                 (__1 : cic.Term cic.prop (matita_basics_logic.eq A x0 __) =>
                  cic.univ univs.Type3)))
           (P :
              (x0 : cic.Term univs.Type2 A ->
               __1 : cic.Term cic.prop (matita_basics_logic.eq A x0 __) ->
               cic.Univ univs.Type3) =>
            cic.prod univs.Type3 univs.Type3
              (P __ (matita_basics_logic.refl A __))
              (__1 :
                 cic.Term univs.Type3 (P __ (matita_basics_logic.refl A __)) =>
               P x _0)))
        (P :
           (x0 : cic.Term univs.Type2 A ->
            __ : cic.Term cic.prop (matita_basics_logic.eq A x0 x) ->
            cic.Univ univs.Type3) =>
         auto : cic.Term univs.Type3 (P x (matita_basics_logic.refl A x)) =>
         auto)
        a p.

def eq_ind_r :
      A : cic.Univ univs.Type2 ->
      a : cic.Term univs.Type2 A ->
      P :
        (x : cic.Term univs.Type2 A ->
         __ : cic.Term cic.prop (matita_basics_logic.eq A x a) ->
         cic.Univ cic.prop) ->
      __ : cic.Term cic.prop (P a (matita_basics_logic.refl A a)) ->
      x : cic.Term univs.Type2 A ->
      p : cic.Term cic.prop (matita_basics_logic.eq A x a) ->
      cic.Term cic.prop (P x p) :=
      A : cic.Univ univs.Type2 =>
      a : cic.Term univs.Type2 A =>
      P :
        (x : cic.Term univs.Type2 A ->
         __ : cic.Term cic.prop (matita_basics_logic.eq A x a) ->
         cic.Univ cic.prop) =>
      p : cic.Term cic.prop (P a (matita_basics_logic.refl A a)) =>
      x0 : cic.Term univs.Type2 A =>
      p0 : cic.Term cic.prop (matita_basics_logic.eq A x0 a) =>
      matita_basics_logic.eq_rect_r A a x0 p0
        (x01 : cic.Term univs.Type2 A =>
         __ : cic.Term cic.prop (matita_basics_logic.eq A x01 a) =>
         cic.lift cic.prop univs.Type3 (P x01 __))
        p.

def eq_rect_Type0_r :
      A : cic.Univ univs.Type2 ->
      a : cic.Term univs.Type2 A ->
      P :
        (x : cic.Term univs.Type2 A ->
         __ : cic.Term cic.prop (matita_basics_logic.eq A x a) ->
         cic.Univ univs.Type0) ->
      __ : cic.Term univs.Type0 (P a (matita_basics_logic.refl A a)) ->
      x : cic.Term univs.Type2 A ->
      p : cic.Term cic.prop (matita_basics_logic.eq A x a) ->
      cic.Term univs.Type0 (P x p) :=
      A : cic.Univ univs.Type2 =>
      a : cic.Term univs.Type2 A =>
      P :
        (x : cic.Term univs.Type2 A ->
         __ : cic.Term cic.prop (matita_basics_logic.eq A x a) ->
         cic.Univ univs.Type0) =>
      H : cic.Term univs.Type0 (P a (matita_basics_logic.refl A a)) =>
      x : cic.Term univs.Type2 A =>
      p : cic.Term cic.prop (matita_basics_logic.eq A x a) =>
      matita_basics_logic.match_eq A x
        (cic.max univs.Type0 (cic.max (cic.succ univs.Type0) univs.Type2))
        (__ : cic.Term univs.Type2 A =>
         _0 : cic.Term cic.prop (matita_basics_logic.eq A x __) =>
         cic.prod (cic.max (cic.succ univs.Type0) univs.Type2) univs.Type0
           (cic.prod univs.Type2 (cic.succ univs.Type0) A
              (x0 : cic.Term univs.Type2 A =>
               cic.prod cic.prop (cic.succ univs.Type0)
                 (matita_basics_logic.eq A x0 __)
                 (__1 : cic.Term cic.prop (matita_basics_logic.eq A x0 __) =>
                  cic.univ univs.Type0)))
           (f :
              (x0 : cic.Term univs.Type2 A ->
               __1 : cic.Term cic.prop (matita_basics_logic.eq A x0 __) ->
               cic.Univ univs.Type0) =>
            cic.prod univs.Type0 univs.Type0
              (f __ (matita_basics_logic.refl A __))
              (__1 :
                 cic.Term univs.Type0 (f __ (matita_basics_logic.refl A __)) =>
               f x _0)))
        (f :
           (x0 : cic.Term univs.Type2 A ->
            __ : cic.Term cic.prop (matita_basics_logic.eq A x0 x) ->
            cic.Univ univs.Type0) =>
         auto : cic.Term univs.Type0 (f x (matita_basics_logic.refl A x)) =>
         auto)
        a p P H.

def eq_rect_Type1_r :
      A : cic.Univ univs.Type2 ->
      a : cic.Term univs.Type2 A ->
      P :
        (x : cic.Term univs.Type2 A ->
         __ : cic.Term cic.prop (matita_basics_logic.eq A x a) ->
         cic.Univ univs.Type1) ->
      __ : cic.Term univs.Type1 (P a (matita_basics_logic.refl A a)) ->
      x : cic.Term univs.Type2 A ->
      p : cic.Term cic.prop (matita_basics_logic.eq A x a) ->
      cic.Term univs.Type1 (P x p) :=
      A : cic.Univ univs.Type2 =>
      a : cic.Term univs.Type2 A =>
      P :
        (x : cic.Term univs.Type2 A ->
         __ : cic.Term cic.prop (matita_basics_logic.eq A x a) ->
         cic.Univ univs.Type1) =>
      H : cic.Term univs.Type1 (P a (matita_basics_logic.refl A a)) =>
      x : cic.Term univs.Type2 A =>
      p : cic.Term cic.prop (matita_basics_logic.eq A x a) =>
      matita_basics_logic.match_eq A x
        (cic.max univs.Type1 (cic.max (cic.succ univs.Type1) univs.Type2))
        (__ : cic.Term univs.Type2 A =>
         _0 : cic.Term cic.prop (matita_basics_logic.eq A x __) =>
         cic.prod (cic.max (cic.succ univs.Type1) univs.Type2) univs.Type1
           (cic.prod univs.Type2 (cic.succ univs.Type1) A
              (x0 : cic.Term univs.Type2 A =>
               cic.prod cic.prop (cic.succ univs.Type1)
                 (matita_basics_logic.eq A x0 __)
                 (__1 : cic.Term cic.prop (matita_basics_logic.eq A x0 __) =>
                  cic.univ univs.Type1)))
           (f :
              (x0 : cic.Term univs.Type2 A ->
               __1 : cic.Term cic.prop (matita_basics_logic.eq A x0 __) ->
               cic.Univ univs.Type1) =>
            cic.prod univs.Type1 univs.Type1
              (f __ (matita_basics_logic.refl A __))
              (__1 :
                 cic.Term univs.Type1 (f __ (matita_basics_logic.refl A __)) =>
               f x _0)))
        (f :
           (x0 : cic.Term univs.Type2 A ->
            __ : cic.Term cic.prop (matita_basics_logic.eq A x0 x) ->
            cic.Univ univs.Type1) =>
         auto : cic.Term univs.Type1 (f x (matita_basics_logic.refl A x)) =>
         auto)
        a p P H.

def eq_rect_Type2_r :
      A : cic.Univ univs.Type2 ->
      a : cic.Term univs.Type2 A ->
      P :
        (x : cic.Term univs.Type2 A ->
         __ : cic.Term cic.prop (matita_basics_logic.eq A x a) ->
         cic.Univ univs.Type2) ->
      __ : cic.Term univs.Type2 (P a (matita_basics_logic.refl A a)) ->
      x : cic.Term univs.Type2 A ->
      p : cic.Term cic.prop (matita_basics_logic.eq A x a) ->
      cic.Term univs.Type2 (P x p) :=
      A : cic.Univ univs.Type2 =>
      a : cic.Term univs.Type2 A =>
      P :
        (x : cic.Term univs.Type2 A ->
         __ : cic.Term cic.prop (matita_basics_logic.eq A x a) ->
         cic.Univ univs.Type2) =>
      H : cic.Term univs.Type2 (P a (matita_basics_logic.refl A a)) =>
      x : cic.Term univs.Type2 A =>
      p : cic.Term cic.prop (matita_basics_logic.eq A x a) =>
      matita_basics_logic.match_eq A x
        (cic.max univs.Type2 (cic.succ univs.Type2))
        (__ : cic.Term univs.Type2 A =>
         _0 : cic.Term cic.prop (matita_basics_logic.eq A x __) =>
         cic.prod (cic.max (cic.succ univs.Type2) univs.Type2) univs.Type2
           (cic.prod univs.Type2 (cic.succ univs.Type2) A
              (x0 : cic.Term univs.Type2 A =>
               cic.prod cic.prop (cic.succ univs.Type2)
                 (matita_basics_logic.eq A x0 __)
                 (__1 : cic.Term cic.prop (matita_basics_logic.eq A x0 __) =>
                  cic.univ univs.Type2)))
           (f :
              (x0 : cic.Term univs.Type2 A ->
               __1 : cic.Term cic.prop (matita_basics_logic.eq A x0 __) ->
               cic.Univ univs.Type2) =>
            cic.prod univs.Type2 univs.Type2
              (f __ (matita_basics_logic.refl A __))
              (__1 :
                 cic.Term univs.Type2 (f __ (matita_basics_logic.refl A __)) =>
               f x _0)))
        (f :
           (x0 : cic.Term univs.Type2 A ->
            __ : cic.Term cic.prop (matita_basics_logic.eq A x0 x) ->
            cic.Univ univs.Type2) =>
         auto : cic.Term univs.Type2 (f x (matita_basics_logic.refl A x)) =>
         auto)
        a p P H.

def eq_rect_Type3_r :
      A : cic.Univ univs.Type2 ->
      a : cic.Term univs.Type2 A ->
      P :
        (x : cic.Term univs.Type2 A ->
         __ : cic.Term cic.prop (matita_basics_logic.eq A x a) ->
         cic.Univ univs.Type3) ->
      __ : cic.Term univs.Type3 (P a (matita_basics_logic.refl A a)) ->
      x : cic.Term univs.Type2 A ->
      p : cic.Term cic.prop (matita_basics_logic.eq A x a) ->
      cic.Term univs.Type3 (P x p) :=
      A : cic.Univ univs.Type2 =>
      a : cic.Term univs.Type2 A =>
      P :
        (x : cic.Term univs.Type2 A ->
         __ : cic.Term cic.prop (matita_basics_logic.eq A x a) ->
         cic.Univ univs.Type3) =>
      H : cic.Term univs.Type3 (P a (matita_basics_logic.refl A a)) =>
      x : cic.Term univs.Type2 A =>
      p : cic.Term cic.prop (matita_basics_logic.eq A x a) =>
      matita_basics_logic.match_eq A x
        (cic.max univs.Type3 (cic.max (cic.succ univs.Type3) univs.Type2))
        (__ : cic.Term univs.Type2 A =>
         _0 : cic.Term cic.prop (matita_basics_logic.eq A x __) =>
         cic.prod (cic.max (cic.succ univs.Type3) univs.Type2) univs.Type3
           (cic.prod univs.Type2 (cic.succ univs.Type3) A
              (x0 : cic.Term univs.Type2 A =>
               cic.prod cic.prop (cic.succ univs.Type3)
                 (matita_basics_logic.eq A x0 __)
                 (__1 : cic.Term cic.prop (matita_basics_logic.eq A x0 __) =>
                  cic.univ univs.Type3)))
           (f :
              (x0 : cic.Term univs.Type2 A ->
               __1 : cic.Term cic.prop (matita_basics_logic.eq A x0 __) ->
               cic.Univ univs.Type3) =>
            cic.prod univs.Type3 univs.Type3
              (f __ (matita_basics_logic.refl A __))
              (__1 :
                 cic.Term univs.Type3 (f __ (matita_basics_logic.refl A __)) =>
               f x _0)))
        (f :
           (x0 : cic.Term univs.Type2 A ->
            __ : cic.Term cic.prop (matita_basics_logic.eq A x0 x) ->
            cic.Univ univs.Type3) =>
         auto : cic.Term univs.Type3 (f x (matita_basics_logic.refl A x)) =>
         auto)
        a p P H.

def rewrite_l :
      A : cic.Univ univs.Type2 ->
      x : cic.Term univs.Type2 A ->
      P : (__ : cic.Term univs.Type2 A -> cic.Univ univs.Type2) ->
      __ : cic.Term univs.Type2 (P x) ->
      y : cic.Term univs.Type2 A ->
      __1 : cic.Term cic.prop (matita_basics_logic.eq A x y) ->
      cic.Term univs.Type2 (P y) :=
      A : cic.Univ univs.Type2 =>
      x : cic.Term univs.Type2 A =>
      P : (__ : cic.Term univs.Type2 A -> cic.Univ univs.Type2) =>
      Hx : cic.Term univs.Type2 (P x) =>
      y : cic.Term univs.Type2 A =>
      Heq : cic.Term cic.prop (matita_basics_logic.eq A x y) =>
      matita_basics_logic.match_eq A x univs.Type2
        (__ : cic.Term univs.Type2 A =>
         _0 : cic.Term cic.prop (matita_basics_logic.eq A x __) => P __)
        Hx y Heq.

def sym_eq :
      A : cic.Univ univs.Type2 ->
      x : cic.Term univs.Type2 A ->
      y : cic.Term univs.Type2 A ->
      __ : cic.Term cic.prop (matita_basics_logic.eq A x y) ->
      cic.Term cic.prop (matita_basics_logic.eq A y x) :=
      A : cic.Univ univs.Type2 =>
      x : cic.Term univs.Type2 A =>
      y : cic.Term univs.Type2 A =>
      Heq : cic.Term cic.prop (matita_basics_logic.eq A x y) =>
      matita_basics_logic.rewrite_l A x
        (__ : cic.Term univs.Type2 A =>
         cic.lift cic.prop univs.Type2
           ((z : cic.Term univs.Type2 A => matita_basics_logic.eq A z x) __))
        (matita_basics_logic.refl A x) y
        (matita_basics_logic.rewrite_l A x
           (__ : cic.Term univs.Type2 A =>
            cic.lift cic.prop univs.Type2
              ((x0 : cic.Term univs.Type2 A => matita_basics_logic.eq A x x0)
                 __))
           (matita_basics_logic.refl A x) y Heq).

def rewrite_r :
      A : cic.Univ univs.Type2 ->
      x : cic.Term univs.Type2 A ->
      P : (__ : cic.Term univs.Type2 A -> cic.Univ univs.Type2) ->
      __ : cic.Term univs.Type2 (P x) ->
      y : cic.Term univs.Type2 A ->
      __1 : cic.Term cic.prop (matita_basics_logic.eq A y x) ->
      cic.Term univs.Type2 (P y) :=
      A : cic.Univ univs.Type2 =>
      x : cic.Term univs.Type2 A =>
      P : (__ : cic.Term univs.Type2 A -> cic.Univ univs.Type2) =>
      Hx : cic.Term univs.Type2 (P x) =>
      y : cic.Term univs.Type2 A =>
      Heq : cic.Term cic.prop (matita_basics_logic.eq A y x) =>
      matita_basics_logic.match_eq A x univs.Type2
        (__ : cic.Term univs.Type2 A =>
         _0 : cic.Term cic.prop (matita_basics_logic.eq A x __) => P __)
        Hx y (matita_basics_logic.sym_eq A y x Heq).

def eq_coerc :
      A : cic.Univ univs.Type0 ->
      B : cic.Univ univs.Type0 ->
      __ : cic.Term univs.Type0 A ->
      __1 :
        cic.Term cic.prop
          (matita_basics_logic.eq
             (cic.lift (cic.succ univs.Type0) univs.Type2
                (cic.univ univs.Type0))
             A B) ->
      cic.Term univs.Type0 B :=
      A : cic.Univ univs.Type0 =>
      B : cic.Univ univs.Type0 =>
      Ha : cic.Term univs.Type0 A =>
      Heq :
        cic.Term cic.prop
          (matita_basics_logic.eq
             (cic.lift (cic.succ univs.Type0) univs.Type2
                (cic.univ univs.Type0))
             A B) =>
      matita_basics_logic.eq_rect_Type0
        (cic.lift (cic.succ univs.Type0) univs.Type2 (cic.univ univs.Type0))
        A
        (x_19 : cic.Univ univs.Type0 =>
         _x_20 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift (cic.succ univs.Type0) univs.Type2
                   (cic.univ univs.Type0))
                A x_19) =>
         x_19)
        Ha B Heq.

def trans_eq :
      A : cic.Univ univs.Type2 ->
      x : cic.Term univs.Type2 A ->
      y : cic.Term univs.Type2 A ->
      z : cic.Term univs.Type2 A ->
      __ : cic.Term cic.prop (matita_basics_logic.eq A x y) ->
      __1 : cic.Term cic.prop (matita_basics_logic.eq A y z) ->
      cic.Term cic.prop (matita_basics_logic.eq A x z) :=
      A : cic.Univ univs.Type2 =>
      x : cic.Term univs.Type2 A =>
      y : cic.Term univs.Type2 A =>
      z : cic.Term univs.Type2 A =>
      H1 : cic.Term cic.prop (matita_basics_logic.eq A x y) =>
      H2 : cic.Term cic.prop (matita_basics_logic.eq A y z) =>
      matita_basics_logic.eq_ind_r A y
        (x0 : cic.Term univs.Type2 A =>
         __ : cic.Term cic.prop (matita_basics_logic.eq A x0 y) =>
         matita_basics_logic.eq A x0 z)
        (matita_basics_logic.rewrite_l A x
           (__ : cic.Term univs.Type2 A =>
            cic.lift cic.prop univs.Type2
              ((x0 : cic.Term univs.Type2 A => matita_basics_logic.eq A x0 z)
                 __))
           (matita_basics_logic.rewrite_l A x
              (__ : cic.Term univs.Type2 A =>
               cic.lift cic.prop univs.Type2
                 ((x0 : cic.Term univs.Type2 A =>
                   matita_basics_logic.eq A x x0) __))
              (matita_basics_logic.refl A x) z
              (matita_basics_logic.rewrite_r A y
                 (__ : cic.Term univs.Type2 A =>
                  cic.lift cic.prop univs.Type2
                    ((x0 : cic.Term univs.Type2 A =>
                      matita_basics_logic.eq A x0 z) __))
                 H2 x H1))
           y H1)
        x H1.

def eq_f :
      A : cic.Univ univs.Type2 ->
      B : cic.Univ univs.Type2 ->
      f : (__ : cic.Term univs.Type2 A -> cic.Term univs.Type2 B) ->
      x : cic.Term univs.Type2 A ->
      y : cic.Term univs.Type2 A ->
      __ : cic.Term cic.prop (matita_basics_logic.eq A x y) ->
      cic.Term cic.prop (matita_basics_logic.eq B (f x) (f y)) :=
      A : cic.Univ univs.Type2 =>
      B : cic.Univ univs.Type2 =>
      f : (__ : cic.Term univs.Type2 A -> cic.Term univs.Type2 B) =>
      x : cic.Term univs.Type2 A =>
      y : cic.Term univs.Type2 A =>
      H : cic.Term cic.prop (matita_basics_logic.eq A x y) =>
      matita_basics_logic.eq_ind_r A y
        (x0 : cic.Term univs.Type2 A =>
         __ : cic.Term cic.prop (matita_basics_logic.eq A x0 y) =>
         matita_basics_logic.eq B (f x0) (f y))
        (matita_basics_logic.rewrite_l A x
           (__ : cic.Term univs.Type2 A =>
            cic.lift cic.prop univs.Type2
              ((x0 : cic.Term univs.Type2 A =>
                matita_basics_logic.eq B (f x0) (f y)) __))
           (matita_basics_logic.rewrite_l A x
              (__ : cic.Term univs.Type2 A =>
               cic.lift cic.prop univs.Type2
                 ((x0 : cic.Term univs.Type2 A =>
                   matita_basics_logic.eq B (f x) (f x0)) __))
              (matita_basics_logic.refl B (f x)) y H)
           y H)
        x H.

def eq_f2 :
      A : cic.Univ univs.Type2 ->
      B : cic.Univ univs.Type2 ->
      C : cic.Univ univs.Type2 ->
      f :
        (__ : cic.Term univs.Type2 A ->
         __1 : cic.Term univs.Type2 B -> cic.Term univs.Type2 C) ->
      x1 : cic.Term univs.Type2 A ->
      x2 : cic.Term univs.Type2 A ->
      y1 : cic.Term univs.Type2 B ->
      y2 : cic.Term univs.Type2 B ->
      __ : cic.Term cic.prop (matita_basics_logic.eq A x1 x2) ->
      __1 : cic.Term cic.prop (matita_basics_logic.eq B y1 y2) ->
      cic.Term cic.prop (matita_basics_logic.eq C (f x1 y1) (f x2 y2)) :=
      A : cic.Univ univs.Type2 =>
      B : cic.Univ univs.Type2 =>
      C : cic.Univ univs.Type2 =>
      f :
        (__ : cic.Term univs.Type2 A ->
         __1 : cic.Term univs.Type2 B -> cic.Term univs.Type2 C) =>
      x1 : cic.Term univs.Type2 A =>
      x2 : cic.Term univs.Type2 A =>
      y1 : cic.Term univs.Type2 B =>
      y2 : cic.Term univs.Type2 B =>
      E1 : cic.Term cic.prop (matita_basics_logic.eq A x1 x2) =>
      E2 : cic.Term cic.prop (matita_basics_logic.eq B y1 y2) =>
      matita_basics_logic.eq_ind_r A x2
        (x : cic.Term univs.Type2 A =>
         __ : cic.Term cic.prop (matita_basics_logic.eq A x x2) =>
         matita_basics_logic.eq C (f x y1) (f x2 y2))
        (matita_basics_logic.eq_ind_r B y2
           (x : cic.Term univs.Type2 B =>
            __ : cic.Term cic.prop (matita_basics_logic.eq B x y2) =>
            matita_basics_logic.eq C (f x2 x) (f x2 y2))
           (matita_basics_logic.rewrite_l A x1
              (__ : cic.Term univs.Type2 A =>
               cic.lift cic.prop univs.Type2
                 ((x : cic.Term univs.Type2 A =>
                   matita_basics_logic.eq C (f x y2) (f x2 y2)) __))
              (matita_basics_logic.rewrite_l B y1
                 (__ : cic.Term univs.Type2 B =>
                  cic.lift cic.prop univs.Type2
                    ((x : cic.Term univs.Type2 B =>
                      matita_basics_logic.eq C (f x1 x) (f x2 y2)) __))
                 (matita_basics_logic.rewrite_l A x1
                    (__ : cic.Term univs.Type2 A =>
                     cic.lift cic.prop univs.Type2
                       ((x : cic.Term univs.Type2 A =>
                         matita_basics_logic.eq C (f x1 y1) (f x y2)) __))
                    (matita_basics_logic.rewrite_l B y1
                       (__ : cic.Term univs.Type2 B =>
                        cic.lift cic.prop univs.Type2
                          ((x : cic.Term univs.Type2 B =>
                            matita_basics_logic.eq C (f x1 y1) (f x1 x)) __))
                       (matita_basics_logic.refl C (f x1 y1)) y2 E2)
                    x2 E1)
                 y2 E2)
              x2 E1)
           y1 E2)
        x1 E1.

def eq_f3 :
      A : cic.Univ univs.Type2 ->
      B : cic.Univ univs.Type2 ->
      C : cic.Univ univs.Type2 ->
      D : cic.Univ univs.Type2 ->
      f :
        (__ : cic.Term univs.Type2 A ->
         __1 : cic.Term univs.Type2 B ->
         __2 : cic.Term univs.Type2 C -> cic.Term univs.Type2 D) ->
      x1 : cic.Term univs.Type2 A ->
      x2 : cic.Term univs.Type2 A ->
      y1 : cic.Term univs.Type2 B ->
      y2 : cic.Term univs.Type2 B ->
      z1 : cic.Term univs.Type2 C ->
      z2 : cic.Term univs.Type2 C ->
      __ : cic.Term cic.prop (matita_basics_logic.eq A x1 x2) ->
      __1 : cic.Term cic.prop (matita_basics_logic.eq B y1 y2) ->
      __2 : cic.Term cic.prop (matita_basics_logic.eq C z1 z2) ->
      cic.Term cic.prop (matita_basics_logic.eq D (f x1 y1 z1) (f x2 y2 z2))
      :=
      A : cic.Univ univs.Type2 =>
      B : cic.Univ univs.Type2 =>
      C : cic.Univ univs.Type2 =>
      D : cic.Univ univs.Type2 =>
      f :
        (__ : cic.Term univs.Type2 A ->
         __1 : cic.Term univs.Type2 B ->
         __2 : cic.Term univs.Type2 C -> cic.Term univs.Type2 D) =>
      x1 : cic.Term univs.Type2 A =>
      x2 : cic.Term univs.Type2 A =>
      y1 : cic.Term univs.Type2 B =>
      y2 : cic.Term univs.Type2 B =>
      z1 : cic.Term univs.Type2 C =>
      z2 : cic.Term univs.Type2 C =>
      E1 : cic.Term cic.prop (matita_basics_logic.eq A x1 x2) =>
      E2 : cic.Term cic.prop (matita_basics_logic.eq B y1 y2) =>
      E3 : cic.Term cic.prop (matita_basics_logic.eq C z1 z2) =>
      matita_basics_logic.eq_ind_r A x2
        (x : cic.Term univs.Type2 A =>
         __ : cic.Term cic.prop (matita_basics_logic.eq A x x2) =>
         matita_basics_logic.eq D (f x y1 z1) (f x2 y2 z2))
        (matita_basics_logic.eq_ind_r B y2
           (x : cic.Term univs.Type2 B =>
            __ : cic.Term cic.prop (matita_basics_logic.eq B x y2) =>
            matita_basics_logic.eq D (f x2 x z1) (f x2 y2 z2))
           (matita_basics_logic.eq_ind_r C z2
              (x : cic.Term univs.Type2 C =>
               __ : cic.Term cic.prop (matita_basics_logic.eq C x z2) =>
               matita_basics_logic.eq D (f x2 y2 x) (f x2 y2 z2))
              (matita_basics_logic.rewrite_l A x1
                 (__ : cic.Term univs.Type2 A =>
                  cic.lift cic.prop univs.Type2
                    ((x : cic.Term univs.Type2 A =>
                      matita_basics_logic.eq D (f x y2 z2) (f x2 y2 z2)) __))
                 (matita_basics_logic.rewrite_l B y1
                    (__ : cic.Term univs.Type2 B =>
                     cic.lift cic.prop univs.Type2
                       ((x : cic.Term univs.Type2 B =>
                         matita_basics_logic.eq D (f x1 x z2) (f x2 y2 z2))
                          __))
                    (matita_basics_logic.rewrite_l C z1
                       (__ : cic.Term univs.Type2 C =>
                        cic.lift cic.prop univs.Type2
                          ((x : cic.Term univs.Type2 C =>
                            matita_basics_logic.eq D (f x1 y1 x) (f x2 y2 z2))
                             __))
                       (matita_basics_logic.rewrite_l A x1
                          (__ : cic.Term univs.Type2 A =>
                           cic.lift cic.prop univs.Type2
                             ((x : cic.Term univs.Type2 A =>
                               matita_basics_logic.eq D (f x1 y1 z1)
                                 (f x y2 z2))
                                __))
                          (matita_basics_logic.rewrite_l B y1
                             (__ : cic.Term univs.Type2 B =>
                              cic.lift cic.prop univs.Type2
                                ((x : cic.Term univs.Type2 B =>
                                  matita_basics_logic.eq D (f x1 y1 z1)
                                    (f x1 x z2))
                                   __))
                             (matita_basics_logic.rewrite_l C z1
                                (__ : cic.Term univs.Type2 C =>
                                 cic.lift cic.prop univs.Type2
                                   ((x : cic.Term univs.Type2 C =>
                                     matita_basics_logic.eq D (f x1 y1 z1)
                                       (f x1 y1 x))
                                      __))
                                (matita_basics_logic.refl D (f x1 y1 z1)) z2
                                E3)
                             y2 E2)
                          x2 E1)
                       z2 E3)
                    y2 E2)
                 x2 E1)
              z1 E3)
           y1 E2)
        x1 E1.

True : cic.Univ cic.prop.

I : cic.Term cic.prop matita_basics_logic.True.

def match_True :
      return_sort : cic.Sort ->
      return_type :
        (z : cic.Term cic.prop matita_basics_logic.True ->
         cic.Univ return_sort) ->
      case_I : cic.Term return_sort (return_type matita_basics_logic.I) ->
      z : cic.Term cic.prop matita_basics_logic.True ->
      cic.Term return_sort (return_type z).

[ return_sort, return_type, case_I ]
  match_True return_sort return_type case_I matita_basics_logic.I --> case_I.

def filter_True :
      return_sort : cic.Sort ->
      return_type :
        (z : cic.Term cic.prop matita_basics_logic.True ->
         cic.Univ return_sort) ->
      return :
        (z : cic.Term cic.prop matita_basics_logic.True ->
         cic.Term return_sort (return_type z)) ->
      z : cic.Term cic.prop matita_basics_logic.True ->
      cic.Term return_sort (return_type z).

[ return_sort, return_type, return ]
  filter_True return_sort return_type return matita_basics_logic.I -->
  return matita_basics_logic.I.

def True_ind :
      Q_ :
        (_x_40 : cic.Term cic.prop matita_basics_logic.True ->
         cic.Univ cic.prop) ->
      _H_I : cic.Term cic.prop (Q_ matita_basics_logic.I) ->
      x_40 : cic.Term cic.prop matita_basics_logic.True ->
      cic.Term cic.prop (Q_ x_40).

def True_ind_body :
      Q_ :
        (_x_40 : cic.Term cic.prop matita_basics_logic.True ->
         cic.Univ cic.prop) ->
      _H_I : cic.Term cic.prop (Q_ matita_basics_logic.I) ->
      x_40 : cic.Term cic.prop matita_basics_logic.True ->
      cic.Term cic.prop (Q_ x_40).

[ Q_, _H_I, x_40 ] True_ind Q_ _H_I x_40 -->
  matita_basics_logic.filter_True cic.prop
    (x_40 : cic.Term cic.prop matita_basics_logic.True => Q_ x_40)
    (matita_basics_logic.True_ind_body Q_ _H_I) x_40.

[ Q_, _H_I, x_40 ] True_ind_body Q_ _H_I x_40 -->
  matita_basics_logic.match_True cic.prop Q_ _H_I x_40.

def True_rect_Type4 :
      Q_ :
        (_x_42 : cic.Term cic.prop matita_basics_logic.True ->
         cic.Univ univs.Type4) ->
      _H_I : cic.Term univs.Type4 (Q_ matita_basics_logic.I) ->
      x_42 : cic.Term cic.prop matita_basics_logic.True ->
      cic.Term univs.Type4 (Q_ x_42).

def True_rect_Type4_body :
      Q_ :
        (_x_42 : cic.Term cic.prop matita_basics_logic.True ->
         cic.Univ univs.Type4) ->
      _H_I : cic.Term univs.Type4 (Q_ matita_basics_logic.I) ->
      x_42 : cic.Term cic.prop matita_basics_logic.True ->
      cic.Term univs.Type4 (Q_ x_42).

[ Q_, _H_I, x_42 ] True_rect_Type4 Q_ _H_I x_42 -->
  matita_basics_logic.filter_True univs.Type4
    (x_42 : cic.Term cic.prop matita_basics_logic.True => Q_ x_42)
    (matita_basics_logic.True_rect_Type4_body Q_ _H_I) x_42.

[ Q_, _H_I, x_42 ] True_rect_Type4_body Q_ _H_I x_42 -->
  matita_basics_logic.match_True univs.Type4 Q_ _H_I x_42.

def True_rect_Type5 :
      Q_ :
        (_x_44 : cic.Term cic.prop matita_basics_logic.True ->
         cic.Univ univs.Type5) ->
      _H_I : cic.Term univs.Type5 (Q_ matita_basics_logic.I) ->
      x_44 : cic.Term cic.prop matita_basics_logic.True ->
      cic.Term univs.Type5 (Q_ x_44).

def True_rect_Type5_body :
      Q_ :
        (_x_44 : cic.Term cic.prop matita_basics_logic.True ->
         cic.Univ univs.Type5) ->
      _H_I : cic.Term univs.Type5 (Q_ matita_basics_logic.I) ->
      x_44 : cic.Term cic.prop matita_basics_logic.True ->
      cic.Term univs.Type5 (Q_ x_44).

[ Q_, _H_I, x_44 ] True_rect_Type5 Q_ _H_I x_44 -->
  matita_basics_logic.filter_True univs.Type5
    (x_44 : cic.Term cic.prop matita_basics_logic.True => Q_ x_44)
    (matita_basics_logic.True_rect_Type5_body Q_ _H_I) x_44.

[ Q_, _H_I, x_44 ] True_rect_Type5_body Q_ _H_I x_44 -->
  matita_basics_logic.match_True univs.Type5 Q_ _H_I x_44.

def True_rect_Type3 :
      Q_ :
        (_x_46 : cic.Term cic.prop matita_basics_logic.True ->
         cic.Univ univs.Type3) ->
      _H_I : cic.Term univs.Type3 (Q_ matita_basics_logic.I) ->
      x_46 : cic.Term cic.prop matita_basics_logic.True ->
      cic.Term univs.Type3 (Q_ x_46).

def True_rect_Type3_body :
      Q_ :
        (_x_46 : cic.Term cic.prop matita_basics_logic.True ->
         cic.Univ univs.Type3) ->
      _H_I : cic.Term univs.Type3 (Q_ matita_basics_logic.I) ->
      x_46 : cic.Term cic.prop matita_basics_logic.True ->
      cic.Term univs.Type3 (Q_ x_46).

[ Q_, _H_I, x_46 ] True_rect_Type3 Q_ _H_I x_46 -->
  matita_basics_logic.filter_True univs.Type3
    (x_46 : cic.Term cic.prop matita_basics_logic.True => Q_ x_46)
    (matita_basics_logic.True_rect_Type3_body Q_ _H_I) x_46.

[ Q_, _H_I, x_46 ] True_rect_Type3_body Q_ _H_I x_46 -->
  matita_basics_logic.match_True univs.Type3 Q_ _H_I x_46.

def True_rect_Type2 :
      Q_ :
        (_x_48 : cic.Term cic.prop matita_basics_logic.True ->
         cic.Univ univs.Type2) ->
      _H_I : cic.Term univs.Type2 (Q_ matita_basics_logic.I) ->
      x_48 : cic.Term cic.prop matita_basics_logic.True ->
      cic.Term univs.Type2 (Q_ x_48).

def True_rect_Type2_body :
      Q_ :
        (_x_48 : cic.Term cic.prop matita_basics_logic.True ->
         cic.Univ univs.Type2) ->
      _H_I : cic.Term univs.Type2 (Q_ matita_basics_logic.I) ->
      x_48 : cic.Term cic.prop matita_basics_logic.True ->
      cic.Term univs.Type2 (Q_ x_48).

[ Q_, _H_I, x_48 ] True_rect_Type2 Q_ _H_I x_48 -->
  matita_basics_logic.filter_True univs.Type2
    (x_48 : cic.Term cic.prop matita_basics_logic.True => Q_ x_48)
    (matita_basics_logic.True_rect_Type2_body Q_ _H_I) x_48.

[ Q_, _H_I, x_48 ] True_rect_Type2_body Q_ _H_I x_48 -->
  matita_basics_logic.match_True univs.Type2 Q_ _H_I x_48.

def True_rect_Type1 :
      Q_ :
        (_x_50 : cic.Term cic.prop matita_basics_logic.True ->
         cic.Univ univs.Type1) ->
      _H_I : cic.Term univs.Type1 (Q_ matita_basics_logic.I) ->
      x_50 : cic.Term cic.prop matita_basics_logic.True ->
      cic.Term univs.Type1 (Q_ x_50).

def True_rect_Type1_body :
      Q_ :
        (_x_50 : cic.Term cic.prop matita_basics_logic.True ->
         cic.Univ univs.Type1) ->
      _H_I : cic.Term univs.Type1 (Q_ matita_basics_logic.I) ->
      x_50 : cic.Term cic.prop matita_basics_logic.True ->
      cic.Term univs.Type1 (Q_ x_50).

[ Q_, _H_I, x_50 ] True_rect_Type1 Q_ _H_I x_50 -->
  matita_basics_logic.filter_True univs.Type1
    (x_50 : cic.Term cic.prop matita_basics_logic.True => Q_ x_50)
    (matita_basics_logic.True_rect_Type1_body Q_ _H_I) x_50.

[ Q_, _H_I, x_50 ] True_rect_Type1_body Q_ _H_I x_50 -->
  matita_basics_logic.match_True univs.Type1 Q_ _H_I x_50.

def True_rect_Type0 :
      Q_ :
        (_x_52 : cic.Term cic.prop matita_basics_logic.True ->
         cic.Univ univs.Type0) ->
      _H_I : cic.Term univs.Type0 (Q_ matita_basics_logic.I) ->
      x_52 : cic.Term cic.prop matita_basics_logic.True ->
      cic.Term univs.Type0 (Q_ x_52).

def True_rect_Type0_body :
      Q_ :
        (_x_52 : cic.Term cic.prop matita_basics_logic.True ->
         cic.Univ univs.Type0) ->
      _H_I : cic.Term univs.Type0 (Q_ matita_basics_logic.I) ->
      x_52 : cic.Term cic.prop matita_basics_logic.True ->
      cic.Term univs.Type0 (Q_ x_52).

[ Q_, _H_I, x_52 ] True_rect_Type0 Q_ _H_I x_52 -->
  matita_basics_logic.filter_True univs.Type0
    (x_52 : cic.Term cic.prop matita_basics_logic.True => Q_ x_52)
    (matita_basics_logic.True_rect_Type0_body Q_ _H_I) x_52.

[ Q_, _H_I, x_52 ] True_rect_Type0_body Q_ _H_I x_52 -->
  matita_basics_logic.match_True univs.Type0 Q_ _H_I x_52.

def True_rect_CProp4 :
      Q_ :
        (_x_54 : cic.Term cic.prop matita_basics_logic.True ->
         cic.Univ cic.prop) ->
      _H_I : cic.Term cic.prop (Q_ matita_basics_logic.I) ->
      x_54 : cic.Term cic.prop matita_basics_logic.True ->
      cic.Term cic.prop (Q_ x_54).

def True_rect_CProp4_body :
      Q_ :
        (_x_54 : cic.Term cic.prop matita_basics_logic.True ->
         cic.Univ cic.prop) ->
      _H_I : cic.Term cic.prop (Q_ matita_basics_logic.I) ->
      x_54 : cic.Term cic.prop matita_basics_logic.True ->
      cic.Term cic.prop (Q_ x_54).

[ Q_, _H_I, x_54 ] True_rect_CProp4 Q_ _H_I x_54 -->
  matita_basics_logic.filter_True cic.prop
    (x_54 : cic.Term cic.prop matita_basics_logic.True => Q_ x_54)
    (matita_basics_logic.True_rect_CProp4_body Q_ _H_I) x_54.

[ Q_, _H_I, x_54 ] True_rect_CProp4_body Q_ _H_I x_54 -->
  matita_basics_logic.match_True cic.prop Q_ _H_I x_54.

def True_rect_CProp5 :
      Q_ :
        (_x_56 : cic.Term cic.prop matita_basics_logic.True ->
         cic.Univ cic.prop) ->
      _H_I : cic.Term cic.prop (Q_ matita_basics_logic.I) ->
      x_56 : cic.Term cic.prop matita_basics_logic.True ->
      cic.Term cic.prop (Q_ x_56).

def True_rect_CProp5_body :
      Q_ :
        (_x_56 : cic.Term cic.prop matita_basics_logic.True ->
         cic.Univ cic.prop) ->
      _H_I : cic.Term cic.prop (Q_ matita_basics_logic.I) ->
      x_56 : cic.Term cic.prop matita_basics_logic.True ->
      cic.Term cic.prop (Q_ x_56).

[ Q_, _H_I, x_56 ] True_rect_CProp5 Q_ _H_I x_56 -->
  matita_basics_logic.filter_True cic.prop
    (x_56 : cic.Term cic.prop matita_basics_logic.True => Q_ x_56)
    (matita_basics_logic.True_rect_CProp5_body Q_ _H_I) x_56.

[ Q_, _H_I, x_56 ] True_rect_CProp5_body Q_ _H_I x_56 -->
  matita_basics_logic.match_True cic.prop Q_ _H_I x_56.

def True_rect_CProp3 :
      Q_ :
        (_x_58 : cic.Term cic.prop matita_basics_logic.True ->
         cic.Univ cic.prop) ->
      _H_I : cic.Term cic.prop (Q_ matita_basics_logic.I) ->
      x_58 : cic.Term cic.prop matita_basics_logic.True ->
      cic.Term cic.prop (Q_ x_58).

def True_rect_CProp3_body :
      Q_ :
        (_x_58 : cic.Term cic.prop matita_basics_logic.True ->
         cic.Univ cic.prop) ->
      _H_I : cic.Term cic.prop (Q_ matita_basics_logic.I) ->
      x_58 : cic.Term cic.prop matita_basics_logic.True ->
      cic.Term cic.prop (Q_ x_58).

[ Q_, _H_I, x_58 ] True_rect_CProp3 Q_ _H_I x_58 -->
  matita_basics_logic.filter_True cic.prop
    (x_58 : cic.Term cic.prop matita_basics_logic.True => Q_ x_58)
    (matita_basics_logic.True_rect_CProp3_body Q_ _H_I) x_58.

[ Q_, _H_I, x_58 ] True_rect_CProp3_body Q_ _H_I x_58 -->
  matita_basics_logic.match_True cic.prop Q_ _H_I x_58.

def True_rect_CProp2 :
      Q_ :
        (_x_60 : cic.Term cic.prop matita_basics_logic.True ->
         cic.Univ cic.prop) ->
      _H_I : cic.Term cic.prop (Q_ matita_basics_logic.I) ->
      x_60 : cic.Term cic.prop matita_basics_logic.True ->
      cic.Term cic.prop (Q_ x_60).

def True_rect_CProp2_body :
      Q_ :
        (_x_60 : cic.Term cic.prop matita_basics_logic.True ->
         cic.Univ cic.prop) ->
      _H_I : cic.Term cic.prop (Q_ matita_basics_logic.I) ->
      x_60 : cic.Term cic.prop matita_basics_logic.True ->
      cic.Term cic.prop (Q_ x_60).

[ Q_, _H_I, x_60 ] True_rect_CProp2 Q_ _H_I x_60 -->
  matita_basics_logic.filter_True cic.prop
    (x_60 : cic.Term cic.prop matita_basics_logic.True => Q_ x_60)
    (matita_basics_logic.True_rect_CProp2_body Q_ _H_I) x_60.

[ Q_, _H_I, x_60 ] True_rect_CProp2_body Q_ _H_I x_60 -->
  matita_basics_logic.match_True cic.prop Q_ _H_I x_60.

def True_rect_CProp1 :
      Q_ :
        (_x_62 : cic.Term cic.prop matita_basics_logic.True ->
         cic.Univ cic.prop) ->
      _H_I : cic.Term cic.prop (Q_ matita_basics_logic.I) ->
      x_62 : cic.Term cic.prop matita_basics_logic.True ->
      cic.Term cic.prop (Q_ x_62).

def True_rect_CProp1_body :
      Q_ :
        (_x_62 : cic.Term cic.prop matita_basics_logic.True ->
         cic.Univ cic.prop) ->
      _H_I : cic.Term cic.prop (Q_ matita_basics_logic.I) ->
      x_62 : cic.Term cic.prop matita_basics_logic.True ->
      cic.Term cic.prop (Q_ x_62).

[ Q_, _H_I, x_62 ] True_rect_CProp1 Q_ _H_I x_62 -->
  matita_basics_logic.filter_True cic.prop
    (x_62 : cic.Term cic.prop matita_basics_logic.True => Q_ x_62)
    (matita_basics_logic.True_rect_CProp1_body Q_ _H_I) x_62.

[ Q_, _H_I, x_62 ] True_rect_CProp1_body Q_ _H_I x_62 -->
  matita_basics_logic.match_True cic.prop Q_ _H_I x_62.

def True_rect_CProp0 :
      Q_ :
        (_x_64 : cic.Term cic.prop matita_basics_logic.True ->
         cic.Univ cic.prop) ->
      _H_I : cic.Term cic.prop (Q_ matita_basics_logic.I) ->
      x_64 : cic.Term cic.prop matita_basics_logic.True ->
      cic.Term cic.prop (Q_ x_64).

def True_rect_CProp0_body :
      Q_ :
        (_x_64 : cic.Term cic.prop matita_basics_logic.True ->
         cic.Univ cic.prop) ->
      _H_I : cic.Term cic.prop (Q_ matita_basics_logic.I) ->
      x_64 : cic.Term cic.prop matita_basics_logic.True ->
      cic.Term cic.prop (Q_ x_64).

[ Q_, _H_I, x_64 ] True_rect_CProp0 Q_ _H_I x_64 -->
  matita_basics_logic.filter_True cic.prop
    (x_64 : cic.Term cic.prop matita_basics_logic.True => Q_ x_64)
    (matita_basics_logic.True_rect_CProp0_body Q_ _H_I) x_64.

[ Q_, _H_I, x_64 ] True_rect_CProp0_body Q_ _H_I x_64 -->
  matita_basics_logic.match_True cic.prop Q_ _H_I x_64.

def True_inv_ind :
      Hterm : cic.Term cic.prop matita_basics_logic.True ->
      P :
        (_z125 : cic.Term cic.prop matita_basics_logic.True ->
         cic.Univ cic.prop) ->
      _H1 :
        (_z126 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2 matita_basics_logic.True)
                Hterm matita_basics_logic.I) ->
         cic.Term cic.prop (P matita_basics_logic.I)) ->
      cic.Term cic.prop (P Hterm) :=
      Hterm : cic.Term cic.prop matita_basics_logic.True =>
      P :
        (_z125 : cic.Term cic.prop matita_basics_logic.True ->
         cic.Univ cic.prop) =>
      H1 :
        (_z126 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2 matita_basics_logic.True)
                Hterm matita_basics_logic.I) ->
         cic.Term cic.prop (P matita_basics_logic.I)) =>
      (Hcut :
         (_z126 :
            cic.Term cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2 matita_basics_logic.True)
                 Hterm Hterm) ->
          cic.Term cic.prop (P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm))
        (matita_basics_logic.True_ind
           (_x_40 : cic.Term cic.prop matita_basics_logic.True =>
            cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2 matita_basics_logic.True)
                 Hterm _x_40)
              (_z126 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop univs.Type2 matita_basics_logic.True)
                      Hterm _x_40) =>
               P _x_40))
           H1 Hterm).

def True_inv_rect_Type4 :
      Hterm : cic.Term cic.prop matita_basics_logic.True ->
      P :
        (_z131 : cic.Term cic.prop matita_basics_logic.True ->
         cic.Univ univs.Type4) ->
      _H1 :
        (_z132 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2 matita_basics_logic.True)
                Hterm matita_basics_logic.I) ->
         cic.Term univs.Type4 (P matita_basics_logic.I)) ->
      cic.Term univs.Type4 (P Hterm) :=
      Hterm : cic.Term cic.prop matita_basics_logic.True =>
      P :
        (_z131 : cic.Term cic.prop matita_basics_logic.True ->
         cic.Univ univs.Type4) =>
      H1 :
        (_z132 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2 matita_basics_logic.True)
                Hterm matita_basics_logic.I) ->
         cic.Term univs.Type4 (P matita_basics_logic.I)) =>
      (Hcut :
         (_z132 :
            cic.Term cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2 matita_basics_logic.True)
                 Hterm Hterm) ->
          cic.Term univs.Type4 (P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm))
        (matita_basics_logic.True_rect_Type4
           (_x_42 : cic.Term cic.prop matita_basics_logic.True =>
            cic.prod cic.prop univs.Type4
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2 matita_basics_logic.True)
                 Hterm _x_42)
              (_z132 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop univs.Type2 matita_basics_logic.True)
                      Hterm _x_42) =>
               P _x_42))
           H1 Hterm).

def True_inv_rect_Type3 :
      Hterm : cic.Term cic.prop matita_basics_logic.True ->
      P :
        (_z137 : cic.Term cic.prop matita_basics_logic.True ->
         cic.Univ univs.Type3) ->
      _H1 :
        (_z138 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2 matita_basics_logic.True)
                Hterm matita_basics_logic.I) ->
         cic.Term univs.Type3 (P matita_basics_logic.I)) ->
      cic.Term univs.Type3 (P Hterm) :=
      Hterm : cic.Term cic.prop matita_basics_logic.True =>
      P :
        (_z137 : cic.Term cic.prop matita_basics_logic.True ->
         cic.Univ univs.Type3) =>
      H1 :
        (_z138 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2 matita_basics_logic.True)
                Hterm matita_basics_logic.I) ->
         cic.Term univs.Type3 (P matita_basics_logic.I)) =>
      (Hcut :
         (_z138 :
            cic.Term cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2 matita_basics_logic.True)
                 Hterm Hterm) ->
          cic.Term univs.Type3 (P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm))
        (matita_basics_logic.True_rect_Type3
           (_x_46 : cic.Term cic.prop matita_basics_logic.True =>
            cic.prod cic.prop univs.Type3
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2 matita_basics_logic.True)
                 Hterm _x_46)
              (_z138 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop univs.Type2 matita_basics_logic.True)
                      Hterm _x_46) =>
               P _x_46))
           H1 Hterm).

def True_inv_rect_Type2 :
      Hterm : cic.Term cic.prop matita_basics_logic.True ->
      P :
        (_z143 : cic.Term cic.prop matita_basics_logic.True ->
         cic.Univ univs.Type2) ->
      _H1 :
        (_z144 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2 matita_basics_logic.True)
                Hterm matita_basics_logic.I) ->
         cic.Term univs.Type2 (P matita_basics_logic.I)) ->
      cic.Term univs.Type2 (P Hterm) :=
      Hterm : cic.Term cic.prop matita_basics_logic.True =>
      P :
        (_z143 : cic.Term cic.prop matita_basics_logic.True ->
         cic.Univ univs.Type2) =>
      H1 :
        (_z144 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2 matita_basics_logic.True)
                Hterm matita_basics_logic.I) ->
         cic.Term univs.Type2 (P matita_basics_logic.I)) =>
      (Hcut :
         (_z144 :
            cic.Term cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2 matita_basics_logic.True)
                 Hterm Hterm) ->
          cic.Term univs.Type2 (P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm))
        (matita_basics_logic.True_rect_Type2
           (_x_48 : cic.Term cic.prop matita_basics_logic.True =>
            cic.prod cic.prop univs.Type2
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2 matita_basics_logic.True)
                 Hterm _x_48)
              (_z144 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop univs.Type2 matita_basics_logic.True)
                      Hterm _x_48) =>
               P _x_48))
           H1 Hterm).

def True_inv_rect_Type1 :
      Hterm : cic.Term cic.prop matita_basics_logic.True ->
      P :
        (_z149 : cic.Term cic.prop matita_basics_logic.True ->
         cic.Univ univs.Type1) ->
      _H1 :
        (_z150 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2 matita_basics_logic.True)
                Hterm matita_basics_logic.I) ->
         cic.Term univs.Type1 (P matita_basics_logic.I)) ->
      cic.Term univs.Type1 (P Hterm) :=
      Hterm : cic.Term cic.prop matita_basics_logic.True =>
      P :
        (_z149 : cic.Term cic.prop matita_basics_logic.True ->
         cic.Univ univs.Type1) =>
      H1 :
        (_z150 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2 matita_basics_logic.True)
                Hterm matita_basics_logic.I) ->
         cic.Term univs.Type1 (P matita_basics_logic.I)) =>
      (Hcut :
         (_z150 :
            cic.Term cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2 matita_basics_logic.True)
                 Hterm Hterm) ->
          cic.Term univs.Type1 (P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm))
        (matita_basics_logic.True_rect_Type1
           (_x_50 : cic.Term cic.prop matita_basics_logic.True =>
            cic.prod cic.prop univs.Type1
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2 matita_basics_logic.True)
                 Hterm _x_50)
              (_z150 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop univs.Type2 matita_basics_logic.True)
                      Hterm _x_50) =>
               P _x_50))
           H1 Hterm).

def True_inv_rect_Type0 :
      Hterm : cic.Term cic.prop matita_basics_logic.True ->
      P :
        (_z155 : cic.Term cic.prop matita_basics_logic.True ->
         cic.Univ univs.Type0) ->
      _H1 :
        (_z156 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2 matita_basics_logic.True)
                Hterm matita_basics_logic.I) ->
         cic.Term univs.Type0 (P matita_basics_logic.I)) ->
      cic.Term univs.Type0 (P Hterm) :=
      Hterm : cic.Term cic.prop matita_basics_logic.True =>
      P :
        (_z155 : cic.Term cic.prop matita_basics_logic.True ->
         cic.Univ univs.Type0) =>
      H1 :
        (_z156 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2 matita_basics_logic.True)
                Hterm matita_basics_logic.I) ->
         cic.Term univs.Type0 (P matita_basics_logic.I)) =>
      (Hcut :
         (_z156 :
            cic.Term cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2 matita_basics_logic.True)
                 Hterm Hterm) ->
          cic.Term univs.Type0 (P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm))
        (matita_basics_logic.True_rect_Type0
           (_x_52 : cic.Term cic.prop matita_basics_logic.True =>
            cic.prod cic.prop univs.Type0
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2 matita_basics_logic.True)
                 Hterm _x_52)
              (_z156 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop univs.Type2 matita_basics_logic.True)
                      Hterm _x_52) =>
               P _x_52))
           H1 Hterm).

def True_inv_rect_CProp4 :
      Hterm : cic.Term cic.prop matita_basics_logic.True ->
      P :
        (_z161 : cic.Term cic.prop matita_basics_logic.True ->
         cic.Univ cic.prop) ->
      _H1 :
        (_z162 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2 matita_basics_logic.True)
                Hterm matita_basics_logic.I) ->
         cic.Term cic.prop (P matita_basics_logic.I)) ->
      cic.Term cic.prop (P Hterm) :=
      Hterm : cic.Term cic.prop matita_basics_logic.True =>
      P :
        (_z161 : cic.Term cic.prop matita_basics_logic.True ->
         cic.Univ cic.prop) =>
      H1 :
        (_z162 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2 matita_basics_logic.True)
                Hterm matita_basics_logic.I) ->
         cic.Term cic.prop (P matita_basics_logic.I)) =>
      (Hcut :
         (_z162 :
            cic.Term cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2 matita_basics_logic.True)
                 Hterm Hterm) ->
          cic.Term cic.prop (P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm))
        (matita_basics_logic.True_rect_CProp4
           (_x_54 : cic.Term cic.prop matita_basics_logic.True =>
            cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2 matita_basics_logic.True)
                 Hterm _x_54)
              (_z162 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop univs.Type2 matita_basics_logic.True)
                      Hterm _x_54) =>
               P _x_54))
           H1 Hterm).

def True_inv_rect_CProp3 :
      Hterm : cic.Term cic.prop matita_basics_logic.True ->
      P :
        (_z167 : cic.Term cic.prop matita_basics_logic.True ->
         cic.Univ cic.prop) ->
      _H1 :
        (_z168 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2 matita_basics_logic.True)
                Hterm matita_basics_logic.I) ->
         cic.Term cic.prop (P matita_basics_logic.I)) ->
      cic.Term cic.prop (P Hterm) :=
      Hterm : cic.Term cic.prop matita_basics_logic.True =>
      P :
        (_z167 : cic.Term cic.prop matita_basics_logic.True ->
         cic.Univ cic.prop) =>
      H1 :
        (_z168 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2 matita_basics_logic.True)
                Hterm matita_basics_logic.I) ->
         cic.Term cic.prop (P matita_basics_logic.I)) =>
      (Hcut :
         (_z168 :
            cic.Term cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2 matita_basics_logic.True)
                 Hterm Hterm) ->
          cic.Term cic.prop (P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm))
        (matita_basics_logic.True_rect_CProp3
           (_x_58 : cic.Term cic.prop matita_basics_logic.True =>
            cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2 matita_basics_logic.True)
                 Hterm _x_58)
              (_z168 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop univs.Type2 matita_basics_logic.True)
                      Hterm _x_58) =>
               P _x_58))
           H1 Hterm).

def True_inv_rect_CProp2 :
      Hterm : cic.Term cic.prop matita_basics_logic.True ->
      P :
        (_z173 : cic.Term cic.prop matita_basics_logic.True ->
         cic.Univ cic.prop) ->
      _H1 :
        (_z174 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2 matita_basics_logic.True)
                Hterm matita_basics_logic.I) ->
         cic.Term cic.prop (P matita_basics_logic.I)) ->
      cic.Term cic.prop (P Hterm) :=
      Hterm : cic.Term cic.prop matita_basics_logic.True =>
      P :
        (_z173 : cic.Term cic.prop matita_basics_logic.True ->
         cic.Univ cic.prop) =>
      H1 :
        (_z174 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2 matita_basics_logic.True)
                Hterm matita_basics_logic.I) ->
         cic.Term cic.prop (P matita_basics_logic.I)) =>
      (Hcut :
         (_z174 :
            cic.Term cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2 matita_basics_logic.True)
                 Hterm Hterm) ->
          cic.Term cic.prop (P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm))
        (matita_basics_logic.True_rect_CProp2
           (_x_60 : cic.Term cic.prop matita_basics_logic.True =>
            cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2 matita_basics_logic.True)
                 Hterm _x_60)
              (_z174 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop univs.Type2 matita_basics_logic.True)
                      Hterm _x_60) =>
               P _x_60))
           H1 Hterm).

def True_inv_rect_CProp1 :
      Hterm : cic.Term cic.prop matita_basics_logic.True ->
      P :
        (_z179 : cic.Term cic.prop matita_basics_logic.True ->
         cic.Univ cic.prop) ->
      _H1 :
        (_z180 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2 matita_basics_logic.True)
                Hterm matita_basics_logic.I) ->
         cic.Term cic.prop (P matita_basics_logic.I)) ->
      cic.Term cic.prop (P Hterm) :=
      Hterm : cic.Term cic.prop matita_basics_logic.True =>
      P :
        (_z179 : cic.Term cic.prop matita_basics_logic.True ->
         cic.Univ cic.prop) =>
      H1 :
        (_z180 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2 matita_basics_logic.True)
                Hterm matita_basics_logic.I) ->
         cic.Term cic.prop (P matita_basics_logic.I)) =>
      (Hcut :
         (_z180 :
            cic.Term cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2 matita_basics_logic.True)
                 Hterm Hterm) ->
          cic.Term cic.prop (P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm))
        (matita_basics_logic.True_rect_CProp1
           (_x_62 : cic.Term cic.prop matita_basics_logic.True =>
            cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2 matita_basics_logic.True)
                 Hterm _x_62)
              (_z180 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop univs.Type2 matita_basics_logic.True)
                      Hterm _x_62) =>
               P _x_62))
           H1 Hterm).

def True_inv_rect_CProp0 :
      Hterm : cic.Term cic.prop matita_basics_logic.True ->
      P :
        (_z185 : cic.Term cic.prop matita_basics_logic.True ->
         cic.Univ cic.prop) ->
      _H1 :
        (_z186 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2 matita_basics_logic.True)
                Hterm matita_basics_logic.I) ->
         cic.Term cic.prop (P matita_basics_logic.I)) ->
      cic.Term cic.prop (P Hterm) :=
      Hterm : cic.Term cic.prop matita_basics_logic.True =>
      P :
        (_z185 : cic.Term cic.prop matita_basics_logic.True ->
         cic.Univ cic.prop) =>
      H1 :
        (_z186 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2 matita_basics_logic.True)
                Hterm matita_basics_logic.I) ->
         cic.Term cic.prop (P matita_basics_logic.I)) =>
      (Hcut :
         (_z186 :
            cic.Term cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2 matita_basics_logic.True)
                 Hterm Hterm) ->
          cic.Term cic.prop (P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop univs.Type2 matita_basics_logic.True) Hterm))
        (matita_basics_logic.True_rect_CProp0
           (_x_64 : cic.Term cic.prop matita_basics_logic.True =>
            cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2 matita_basics_logic.True)
                 Hterm _x_64)
              (_z186 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop univs.Type2 matita_basics_logic.True)
                      Hterm _x_64) =>
               P _x_64))
           H1 Hterm).

def True_discr :
      x : cic.Term cic.prop matita_basics_logic.True ->
      y : cic.Term cic.prop matita_basics_logic.True ->
      _e :
        cic.Term cic.prop
          (matita_basics_logic.eq
             (cic.lift cic.prop univs.Type2 matita_basics_logic.True) x y) ->
      cic.Term univs.Type2
        (matita_basics_logic.match_True (cic.succ univs.Type2)
           (__ : cic.Term cic.prop matita_basics_logic.True =>
            cic.univ univs.Type2)
           (matita_basics_logic.match_True (cic.succ univs.Type2)
              (__ : cic.Term cic.prop matita_basics_logic.True =>
               cic.univ univs.Type2)
              (cic.prod (cic.succ univs.Type1) univs.Type1
                 (cic.univ univs.Type1)
                 (P : cic.Univ univs.Type1 =>
                  cic.prod univs.Type1 univs.Type1 P
                    (_z5 : cic.Term univs.Type1 P => P)))
              y)
           x)
      :=
      x : cic.Term cic.prop matita_basics_logic.True =>
      y : cic.Term cic.prop matita_basics_logic.True =>
      Deq :
        cic.Term cic.prop
          (matita_basics_logic.eq
             (cic.lift cic.prop univs.Type2 matita_basics_logic.True) x y) =>
      matita_basics_logic.eq_rect_Type2
        (cic.lift cic.prop univs.Type2 matita_basics_logic.True) x
        (x_13 : cic.Term cic.prop matita_basics_logic.True =>
         _x_14 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2 matita_basics_logic.True) x
                x_13) =>
         matita_basics_logic.match_True (cic.succ univs.Type2)
           (__ : cic.Term cic.prop matita_basics_logic.True =>
            cic.univ univs.Type2)
           (matita_basics_logic.match_True (cic.succ univs.Type2)
              (__ : cic.Term cic.prop matita_basics_logic.True =>
               cic.univ univs.Type2)
              (cic.prod (cic.succ univs.Type1) univs.Type1
                 (cic.univ univs.Type1)
                 (P : cic.Univ univs.Type1 =>
                  cic.prod univs.Type1 univs.Type1 P
                    (_z5 : cic.Term univs.Type1 P => P)))
              x_13)
           x)
        (matita_basics_logic.match_True univs.Type2
           (__ : cic.Term cic.prop matita_basics_logic.True =>
            matita_basics_logic.match_True (cic.succ univs.Type2)
              (_0 : cic.Term cic.prop matita_basics_logic.True =>
               cic.univ univs.Type2)
              (matita_basics_logic.match_True (cic.succ univs.Type2)
                 (_0 : cic.Term cic.prop matita_basics_logic.True =>
                  cic.univ univs.Type2)
                 (cic.prod (cic.succ univs.Type1) univs.Type1
                    (cic.univ univs.Type1)
                    (P : cic.Univ univs.Type1 =>
                     cic.prod univs.Type1 univs.Type1 P
                       (_z5 : cic.Term univs.Type1 P => P)))
                 __)
              __)
           (P : cic.Univ univs.Type1 => DH : cic.Term univs.Type1 P => DH) x)
        y Deq.

False : cic.Univ cic.prop.

def match_False :
      return_sort : cic.Sort ->
      return_type :
        (z : cic.Term cic.prop matita_basics_logic.False ->
         cic.Univ return_sort) ->
      z : cic.Term cic.prop matita_basics_logic.False ->
      cic.Term return_sort (return_type z).

def filter_False :
      return_sort : cic.Sort ->
      return_type :
        (z : cic.Term cic.prop matita_basics_logic.False ->
         cic.Univ return_sort) ->
      return :
        (z : cic.Term cic.prop matita_basics_logic.False ->
         cic.Term return_sort (return_type z)) ->
      z : cic.Term cic.prop matita_basics_logic.False ->
      cic.Term return_sort (return_type z).

def False_ind :
      Q_ :
        (_x_66 : cic.Term cic.prop matita_basics_logic.False ->
         cic.Univ cic.prop) ->
      x_66 : cic.Term cic.prop matita_basics_logic.False ->
      cic.Term cic.prop (Q_ x_66).

def False_ind_body :
      Q_ :
        (_x_66 : cic.Term cic.prop matita_basics_logic.False ->
         cic.Univ cic.prop) ->
      x_66 : cic.Term cic.prop matita_basics_logic.False ->
      cic.Term cic.prop (Q_ x_66).

[ Q_, x_66 ] False_ind Q_ x_66 -->
  matita_basics_logic.filter_False cic.prop
    (x_66 : cic.Term cic.prop matita_basics_logic.False => Q_ x_66)
    (matita_basics_logic.False_ind_body Q_) x_66.

[ Q_, x_66 ] False_ind_body Q_ x_66 -->
  matita_basics_logic.match_False cic.prop Q_ x_66.

def False_rect_Type4 :
      Q_ :
        (_x_67 : cic.Term cic.prop matita_basics_logic.False ->
         cic.Univ univs.Type4) ->
      x_67 : cic.Term cic.prop matita_basics_logic.False ->
      cic.Term univs.Type4 (Q_ x_67).

def False_rect_Type4_body :
      Q_ :
        (_x_67 : cic.Term cic.prop matita_basics_logic.False ->
         cic.Univ univs.Type4) ->
      x_67 : cic.Term cic.prop matita_basics_logic.False ->
      cic.Term univs.Type4 (Q_ x_67).

[ Q_, x_67 ] False_rect_Type4 Q_ x_67 -->
  matita_basics_logic.filter_False univs.Type4
    (x_67 : cic.Term cic.prop matita_basics_logic.False => Q_ x_67)
    (matita_basics_logic.False_rect_Type4_body Q_) x_67.

[ Q_, x_67 ] False_rect_Type4_body Q_ x_67 -->
  matita_basics_logic.match_False univs.Type4 Q_ x_67.

def False_rect_Type5 :
      Q_ :
        (_x_68 : cic.Term cic.prop matita_basics_logic.False ->
         cic.Univ univs.Type5) ->
      x_68 : cic.Term cic.prop matita_basics_logic.False ->
      cic.Term univs.Type5 (Q_ x_68).

def False_rect_Type5_body :
      Q_ :
        (_x_68 : cic.Term cic.prop matita_basics_logic.False ->
         cic.Univ univs.Type5) ->
      x_68 : cic.Term cic.prop matita_basics_logic.False ->
      cic.Term univs.Type5 (Q_ x_68).

[ Q_, x_68 ] False_rect_Type5 Q_ x_68 -->
  matita_basics_logic.filter_False univs.Type5
    (x_68 : cic.Term cic.prop matita_basics_logic.False => Q_ x_68)
    (matita_basics_logic.False_rect_Type5_body Q_) x_68.

[ Q_, x_68 ] False_rect_Type5_body Q_ x_68 -->
  matita_basics_logic.match_False univs.Type5 Q_ x_68.

def False_rect_Type3 :
      Q_ :
        (_x_69 : cic.Term cic.prop matita_basics_logic.False ->
         cic.Univ univs.Type3) ->
      x_69 : cic.Term cic.prop matita_basics_logic.False ->
      cic.Term univs.Type3 (Q_ x_69).

def False_rect_Type3_body :
      Q_ :
        (_x_69 : cic.Term cic.prop matita_basics_logic.False ->
         cic.Univ univs.Type3) ->
      x_69 : cic.Term cic.prop matita_basics_logic.False ->
      cic.Term univs.Type3 (Q_ x_69).

[ Q_, x_69 ] False_rect_Type3 Q_ x_69 -->
  matita_basics_logic.filter_False univs.Type3
    (x_69 : cic.Term cic.prop matita_basics_logic.False => Q_ x_69)
    (matita_basics_logic.False_rect_Type3_body Q_) x_69.

[ Q_, x_69 ] False_rect_Type3_body Q_ x_69 -->
  matita_basics_logic.match_False univs.Type3 Q_ x_69.

def False_rect_Type2 :
      Q_ :
        (_x_70 : cic.Term cic.prop matita_basics_logic.False ->
         cic.Univ univs.Type2) ->
      x_70 : cic.Term cic.prop matita_basics_logic.False ->
      cic.Term univs.Type2 (Q_ x_70).

def False_rect_Type2_body :
      Q_ :
        (_x_70 : cic.Term cic.prop matita_basics_logic.False ->
         cic.Univ univs.Type2) ->
      x_70 : cic.Term cic.prop matita_basics_logic.False ->
      cic.Term univs.Type2 (Q_ x_70).

[ Q_, x_70 ] False_rect_Type2 Q_ x_70 -->
  matita_basics_logic.filter_False univs.Type2
    (x_70 : cic.Term cic.prop matita_basics_logic.False => Q_ x_70)
    (matita_basics_logic.False_rect_Type2_body Q_) x_70.

[ Q_, x_70 ] False_rect_Type2_body Q_ x_70 -->
  matita_basics_logic.match_False univs.Type2 Q_ x_70.

def False_rect_Type1 :
      Q_ :
        (_x_71 : cic.Term cic.prop matita_basics_logic.False ->
         cic.Univ univs.Type1) ->
      x_71 : cic.Term cic.prop matita_basics_logic.False ->
      cic.Term univs.Type1 (Q_ x_71).

def False_rect_Type1_body :
      Q_ :
        (_x_71 : cic.Term cic.prop matita_basics_logic.False ->
         cic.Univ univs.Type1) ->
      x_71 : cic.Term cic.prop matita_basics_logic.False ->
      cic.Term univs.Type1 (Q_ x_71).

[ Q_, x_71 ] False_rect_Type1 Q_ x_71 -->
  matita_basics_logic.filter_False univs.Type1
    (x_71 : cic.Term cic.prop matita_basics_logic.False => Q_ x_71)
    (matita_basics_logic.False_rect_Type1_body Q_) x_71.

[ Q_, x_71 ] False_rect_Type1_body Q_ x_71 -->
  matita_basics_logic.match_False univs.Type1 Q_ x_71.

def False_rect_Type0 :
      Q_ :
        (_x_72 : cic.Term cic.prop matita_basics_logic.False ->
         cic.Univ univs.Type0) ->
      x_72 : cic.Term cic.prop matita_basics_logic.False ->
      cic.Term univs.Type0 (Q_ x_72).

def False_rect_Type0_body :
      Q_ :
        (_x_72 : cic.Term cic.prop matita_basics_logic.False ->
         cic.Univ univs.Type0) ->
      x_72 : cic.Term cic.prop matita_basics_logic.False ->
      cic.Term univs.Type0 (Q_ x_72).

[ Q_, x_72 ] False_rect_Type0 Q_ x_72 -->
  matita_basics_logic.filter_False univs.Type0
    (x_72 : cic.Term cic.prop matita_basics_logic.False => Q_ x_72)
    (matita_basics_logic.False_rect_Type0_body Q_) x_72.

[ Q_, x_72 ] False_rect_Type0_body Q_ x_72 -->
  matita_basics_logic.match_False univs.Type0 Q_ x_72.

def False_rect_CProp4 :
      Q_ :
        (_x_73 : cic.Term cic.prop matita_basics_logic.False ->
         cic.Univ cic.prop) ->
      x_73 : cic.Term cic.prop matita_basics_logic.False ->
      cic.Term cic.prop (Q_ x_73).

def False_rect_CProp4_body :
      Q_ :
        (_x_73 : cic.Term cic.prop matita_basics_logic.False ->
         cic.Univ cic.prop) ->
      x_73 : cic.Term cic.prop matita_basics_logic.False ->
      cic.Term cic.prop (Q_ x_73).

[ Q_, x_73 ] False_rect_CProp4 Q_ x_73 -->
  matita_basics_logic.filter_False cic.prop
    (x_73 : cic.Term cic.prop matita_basics_logic.False => Q_ x_73)
    (matita_basics_logic.False_rect_CProp4_body Q_) x_73.

[ Q_, x_73 ] False_rect_CProp4_body Q_ x_73 -->
  matita_basics_logic.match_False cic.prop Q_ x_73.

def False_rect_CProp5 :
      Q_ :
        (_x_74 : cic.Term cic.prop matita_basics_logic.False ->
         cic.Univ cic.prop) ->
      x_74 : cic.Term cic.prop matita_basics_logic.False ->
      cic.Term cic.prop (Q_ x_74).

def False_rect_CProp5_body :
      Q_ :
        (_x_74 : cic.Term cic.prop matita_basics_logic.False ->
         cic.Univ cic.prop) ->
      x_74 : cic.Term cic.prop matita_basics_logic.False ->
      cic.Term cic.prop (Q_ x_74).

[ Q_, x_74 ] False_rect_CProp5 Q_ x_74 -->
  matita_basics_logic.filter_False cic.prop
    (x_74 : cic.Term cic.prop matita_basics_logic.False => Q_ x_74)
    (matita_basics_logic.False_rect_CProp5_body Q_) x_74.

[ Q_, x_74 ] False_rect_CProp5_body Q_ x_74 -->
  matita_basics_logic.match_False cic.prop Q_ x_74.

def False_rect_CProp3 :
      Q_ :
        (_x_75 : cic.Term cic.prop matita_basics_logic.False ->
         cic.Univ cic.prop) ->
      x_75 : cic.Term cic.prop matita_basics_logic.False ->
      cic.Term cic.prop (Q_ x_75).

def False_rect_CProp3_body :
      Q_ :
        (_x_75 : cic.Term cic.prop matita_basics_logic.False ->
         cic.Univ cic.prop) ->
      x_75 : cic.Term cic.prop matita_basics_logic.False ->
      cic.Term cic.prop (Q_ x_75).

[ Q_, x_75 ] False_rect_CProp3 Q_ x_75 -->
  matita_basics_logic.filter_False cic.prop
    (x_75 : cic.Term cic.prop matita_basics_logic.False => Q_ x_75)
    (matita_basics_logic.False_rect_CProp3_body Q_) x_75.

[ Q_, x_75 ] False_rect_CProp3_body Q_ x_75 -->
  matita_basics_logic.match_False cic.prop Q_ x_75.

def False_rect_CProp2 :
      Q_ :
        (_x_76 : cic.Term cic.prop matita_basics_logic.False ->
         cic.Univ cic.prop) ->
      x_76 : cic.Term cic.prop matita_basics_logic.False ->
      cic.Term cic.prop (Q_ x_76).

def False_rect_CProp2_body :
      Q_ :
        (_x_76 : cic.Term cic.prop matita_basics_logic.False ->
         cic.Univ cic.prop) ->
      x_76 : cic.Term cic.prop matita_basics_logic.False ->
      cic.Term cic.prop (Q_ x_76).

[ Q_, x_76 ] False_rect_CProp2 Q_ x_76 -->
  matita_basics_logic.filter_False cic.prop
    (x_76 : cic.Term cic.prop matita_basics_logic.False => Q_ x_76)
    (matita_basics_logic.False_rect_CProp2_body Q_) x_76.

[ Q_, x_76 ] False_rect_CProp2_body Q_ x_76 -->
  matita_basics_logic.match_False cic.prop Q_ x_76.

def False_rect_CProp1 :
      Q_ :
        (_x_77 : cic.Term cic.prop matita_basics_logic.False ->
         cic.Univ cic.prop) ->
      x_77 : cic.Term cic.prop matita_basics_logic.False ->
      cic.Term cic.prop (Q_ x_77).

def False_rect_CProp1_body :
      Q_ :
        (_x_77 : cic.Term cic.prop matita_basics_logic.False ->
         cic.Univ cic.prop) ->
      x_77 : cic.Term cic.prop matita_basics_logic.False ->
      cic.Term cic.prop (Q_ x_77).

[ Q_, x_77 ] False_rect_CProp1 Q_ x_77 -->
  matita_basics_logic.filter_False cic.prop
    (x_77 : cic.Term cic.prop matita_basics_logic.False => Q_ x_77)
    (matita_basics_logic.False_rect_CProp1_body Q_) x_77.

[ Q_, x_77 ] False_rect_CProp1_body Q_ x_77 -->
  matita_basics_logic.match_False cic.prop Q_ x_77.

def False_rect_CProp0 :
      Q_ :
        (_x_78 : cic.Term cic.prop matita_basics_logic.False ->
         cic.Univ cic.prop) ->
      x_78 : cic.Term cic.prop matita_basics_logic.False ->
      cic.Term cic.prop (Q_ x_78).

def False_rect_CProp0_body :
      Q_ :
        (_x_78 : cic.Term cic.prop matita_basics_logic.False ->
         cic.Univ cic.prop) ->
      x_78 : cic.Term cic.prop matita_basics_logic.False ->
      cic.Term cic.prop (Q_ x_78).

[ Q_, x_78 ] False_rect_CProp0 Q_ x_78 -->
  matita_basics_logic.filter_False cic.prop
    (x_78 : cic.Term cic.prop matita_basics_logic.False => Q_ x_78)
    (matita_basics_logic.False_rect_CProp0_body Q_) x_78.

[ Q_, x_78 ] False_rect_CProp0_body Q_ x_78 -->
  matita_basics_logic.match_False cic.prop Q_ x_78.

Not : _A : cic.Univ cic.prop -> cic.Univ cic.prop.

nmk :
  A : cic.Univ cic.prop ->
  __ :
    (__ : cic.Term cic.prop A -> cic.Term cic.prop matita_basics_logic.False) ->
  cic.Term cic.prop (matita_basics_logic.Not A).

def match_Not :
      _A : cic.Univ cic.prop ->
      return_sort : cic.Sort ->
      return_type :
        (z : cic.Term cic.prop (matita_basics_logic.Not _A) ->
         cic.Univ return_sort) ->
      case_nmk :
        (__ :
           (__ : cic.Term cic.prop _A ->
            cic.Term cic.prop matita_basics_logic.False) ->
         cic.Term return_sort (return_type (matita_basics_logic.nmk _A __))) ->
      z : cic.Term cic.prop (matita_basics_logic.Not _A) ->
      cic.Term return_sort (return_type z).

[ _A, return_sort, return_type, case_nmk, __ ]
  match_Not _A return_sort return_type case_nmk
    (matita_basics_logic.nmk _A __) -->
  case_nmk __.

def filter_Not :
      _A : cic.Univ cic.prop ->
      return_sort : cic.Sort ->
      return_type :
        (z : cic.Term cic.prop (matita_basics_logic.Not _A) ->
         cic.Univ return_sort) ->
      return :
        (z : cic.Term cic.prop (matita_basics_logic.Not _A) ->
         cic.Term return_sort (return_type z)) ->
      z : cic.Term cic.prop (matita_basics_logic.Not _A) ->
      cic.Term return_sort (return_type z).

[ A, __, return_sort, return_type, return ]
  filter_Not (A) return_sort return_type return
    (matita_basics_logic.nmk A __) -->
  return (matita_basics_logic.nmk A __).

def Not_ind :
      _A : cic.Univ cic.prop ->
      Q_ :
        (_x_79 : cic.Term cic.prop (matita_basics_logic.Not _A) ->
         cic.Univ cic.prop) ->
      _H_nmk :
        (x_80 :
           (__ : cic.Term cic.prop _A ->
            cic.Term cic.prop matita_basics_logic.False) ->
         cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_80))) ->
      x_79 : cic.Term cic.prop (matita_basics_logic.Not _A) ->
      cic.Term cic.prop (Q_ x_79).

def Not_ind_body :
      _A : cic.Univ cic.prop ->
      Q_ :
        (_x_79 : cic.Term cic.prop (matita_basics_logic.Not _A) ->
         cic.Univ cic.prop) ->
      _H_nmk :
        (x_80 :
           (__ : cic.Term cic.prop _A ->
            cic.Term cic.prop matita_basics_logic.False) ->
         cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_80))) ->
      x_79 : cic.Term cic.prop (matita_basics_logic.Not _A) ->
      cic.Term cic.prop (Q_ x_79).

[ _A, Q_, _H_nmk, x_79 ] Not_ind _A Q_ _H_nmk x_79 -->
  matita_basics_logic.filter_Not _A cic.prop
    (x_79 : cic.Term cic.prop (matita_basics_logic.Not _A) => Q_ x_79)
    (matita_basics_logic.Not_ind_body _A Q_ _H_nmk) x_79.

[ _A, Q_, _H_nmk, x_79 ] Not_ind_body _A Q_ _H_nmk x_79 -->
  matita_basics_logic.match_Not _A cic.prop Q_
    (x_80 :
       (__ : cic.Term cic.prop _A ->
        cic.Term cic.prop matita_basics_logic.False) =>
     _H_nmk x_80)
    x_79.

def Not_rect_Type4 :
      _A : cic.Univ cic.prop ->
      Q_ :
        (_x_82 : cic.Term cic.prop (matita_basics_logic.Not _A) ->
         cic.Univ univs.Type4) ->
      _H_nmk :
        (x_83 :
           (__ : cic.Term cic.prop _A ->
            cic.Term cic.prop matita_basics_logic.False) ->
         cic.Term univs.Type4 (Q_ (matita_basics_logic.nmk _A x_83))) ->
      x_82 : cic.Term cic.prop (matita_basics_logic.Not _A) ->
      cic.Term univs.Type4 (Q_ x_82).

def Not_rect_Type4_body :
      _A : cic.Univ cic.prop ->
      Q_ :
        (_x_82 : cic.Term cic.prop (matita_basics_logic.Not _A) ->
         cic.Univ univs.Type4) ->
      _H_nmk :
        (x_83 :
           (__ : cic.Term cic.prop _A ->
            cic.Term cic.prop matita_basics_logic.False) ->
         cic.Term univs.Type4 (Q_ (matita_basics_logic.nmk _A x_83))) ->
      x_82 : cic.Term cic.prop (matita_basics_logic.Not _A) ->
      cic.Term univs.Type4 (Q_ x_82).

[ _A, Q_, _H_nmk, x_82 ] Not_rect_Type4 _A Q_ _H_nmk x_82 -->
  matita_basics_logic.filter_Not _A univs.Type4
    (x_82 : cic.Term cic.prop (matita_basics_logic.Not _A) => Q_ x_82)
    (matita_basics_logic.Not_rect_Type4_body _A Q_ _H_nmk) x_82.

[ _A, Q_, _H_nmk, x_82 ] Not_rect_Type4_body _A Q_ _H_nmk x_82 -->
  matita_basics_logic.match_Not _A univs.Type4 Q_
    (x_83 :
       (__ : cic.Term cic.prop _A ->
        cic.Term cic.prop matita_basics_logic.False) =>
     _H_nmk x_83)
    x_82.

def Not_rect_Type5 :
      _A : cic.Univ cic.prop ->
      Q_ :
        (_x_85 : cic.Term cic.prop (matita_basics_logic.Not _A) ->
         cic.Univ univs.Type5) ->
      _H_nmk :
        (x_86 :
           (__ : cic.Term cic.prop _A ->
            cic.Term cic.prop matita_basics_logic.False) ->
         cic.Term univs.Type5 (Q_ (matita_basics_logic.nmk _A x_86))) ->
      x_85 : cic.Term cic.prop (matita_basics_logic.Not _A) ->
      cic.Term univs.Type5 (Q_ x_85).

def Not_rect_Type5_body :
      _A : cic.Univ cic.prop ->
      Q_ :
        (_x_85 : cic.Term cic.prop (matita_basics_logic.Not _A) ->
         cic.Univ univs.Type5) ->
      _H_nmk :
        (x_86 :
           (__ : cic.Term cic.prop _A ->
            cic.Term cic.prop matita_basics_logic.False) ->
         cic.Term univs.Type5 (Q_ (matita_basics_logic.nmk _A x_86))) ->
      x_85 : cic.Term cic.prop (matita_basics_logic.Not _A) ->
      cic.Term univs.Type5 (Q_ x_85).

[ _A, Q_, _H_nmk, x_85 ] Not_rect_Type5 _A Q_ _H_nmk x_85 -->
  matita_basics_logic.filter_Not _A univs.Type5
    (x_85 : cic.Term cic.prop (matita_basics_logic.Not _A) => Q_ x_85)
    (matita_basics_logic.Not_rect_Type5_body _A Q_ _H_nmk) x_85.

[ _A, Q_, _H_nmk, x_85 ] Not_rect_Type5_body _A Q_ _H_nmk x_85 -->
  matita_basics_logic.match_Not _A univs.Type5 Q_
    (x_86 :
       (__ : cic.Term cic.prop _A ->
        cic.Term cic.prop matita_basics_logic.False) =>
     _H_nmk x_86)
    x_85.

def Not_rect_Type3 :
      _A : cic.Univ cic.prop ->
      Q_ :
        (_x_88 : cic.Term cic.prop (matita_basics_logic.Not _A) ->
         cic.Univ univs.Type3) ->
      _H_nmk :
        (x_89 :
           (__ : cic.Term cic.prop _A ->
            cic.Term cic.prop matita_basics_logic.False) ->
         cic.Term univs.Type3 (Q_ (matita_basics_logic.nmk _A x_89))) ->
      x_88 : cic.Term cic.prop (matita_basics_logic.Not _A) ->
      cic.Term univs.Type3 (Q_ x_88).

def Not_rect_Type3_body :
      _A : cic.Univ cic.prop ->
      Q_ :
        (_x_88 : cic.Term cic.prop (matita_basics_logic.Not _A) ->
         cic.Univ univs.Type3) ->
      _H_nmk :
        (x_89 :
           (__ : cic.Term cic.prop _A ->
            cic.Term cic.prop matita_basics_logic.False) ->
         cic.Term univs.Type3 (Q_ (matita_basics_logic.nmk _A x_89))) ->
      x_88 : cic.Term cic.prop (matita_basics_logic.Not _A) ->
      cic.Term univs.Type3 (Q_ x_88).

[ _A, Q_, _H_nmk, x_88 ] Not_rect_Type3 _A Q_ _H_nmk x_88 -->
  matita_basics_logic.filter_Not _A univs.Type3
    (x_88 : cic.Term cic.prop (matita_basics_logic.Not _A) => Q_ x_88)
    (matita_basics_logic.Not_rect_Type3_body _A Q_ _H_nmk) x_88.

[ _A, Q_, _H_nmk, x_88 ] Not_rect_Type3_body _A Q_ _H_nmk x_88 -->
  matita_basics_logic.match_Not _A univs.Type3 Q_
    (x_89 :
       (__ : cic.Term cic.prop _A ->
        cic.Term cic.prop matita_basics_logic.False) =>
     _H_nmk x_89)
    x_88.

def Not_rect_Type2 :
      _A : cic.Univ cic.prop ->
      Q_ :
        (_x_91 : cic.Term cic.prop (matita_basics_logic.Not _A) ->
         cic.Univ univs.Type2) ->
      _H_nmk :
        (x_92 :
           (__ : cic.Term cic.prop _A ->
            cic.Term cic.prop matita_basics_logic.False) ->
         cic.Term univs.Type2 (Q_ (matita_basics_logic.nmk _A x_92))) ->
      x_91 : cic.Term cic.prop (matita_basics_logic.Not _A) ->
      cic.Term univs.Type2 (Q_ x_91).

def Not_rect_Type2_body :
      _A : cic.Univ cic.prop ->
      Q_ :
        (_x_91 : cic.Term cic.prop (matita_basics_logic.Not _A) ->
         cic.Univ univs.Type2) ->
      _H_nmk :
        (x_92 :
           (__ : cic.Term cic.prop _A ->
            cic.Term cic.prop matita_basics_logic.False) ->
         cic.Term univs.Type2 (Q_ (matita_basics_logic.nmk _A x_92))) ->
      x_91 : cic.Term cic.prop (matita_basics_logic.Not _A) ->
      cic.Term univs.Type2 (Q_ x_91).

[ _A, Q_, _H_nmk, x_91 ] Not_rect_Type2 _A Q_ _H_nmk x_91 -->
  matita_basics_logic.filter_Not _A univs.Type2
    (x_91 : cic.Term cic.prop (matita_basics_logic.Not _A) => Q_ x_91)
    (matita_basics_logic.Not_rect_Type2_body _A Q_ _H_nmk) x_91.

[ _A, Q_, _H_nmk, x_91 ] Not_rect_Type2_body _A Q_ _H_nmk x_91 -->
  matita_basics_logic.match_Not _A univs.Type2 Q_
    (x_92 :
       (__ : cic.Term cic.prop _A ->
        cic.Term cic.prop matita_basics_logic.False) =>
     _H_nmk x_92)
    x_91.

def Not_rect_Type1 :
      _A : cic.Univ cic.prop ->
      Q_ :
        (_x_94 : cic.Term cic.prop (matita_basics_logic.Not _A) ->
         cic.Univ univs.Type1) ->
      _H_nmk :
        (x_95 :
           (__ : cic.Term cic.prop _A ->
            cic.Term cic.prop matita_basics_logic.False) ->
         cic.Term univs.Type1 (Q_ (matita_basics_logic.nmk _A x_95))) ->
      x_94 : cic.Term cic.prop (matita_basics_logic.Not _A) ->
      cic.Term univs.Type1 (Q_ x_94).

def Not_rect_Type1_body :
      _A : cic.Univ cic.prop ->
      Q_ :
        (_x_94 : cic.Term cic.prop (matita_basics_logic.Not _A) ->
         cic.Univ univs.Type1) ->
      _H_nmk :
        (x_95 :
           (__ : cic.Term cic.prop _A ->
            cic.Term cic.prop matita_basics_logic.False) ->
         cic.Term univs.Type1 (Q_ (matita_basics_logic.nmk _A x_95))) ->
      x_94 : cic.Term cic.prop (matita_basics_logic.Not _A) ->
      cic.Term univs.Type1 (Q_ x_94).

[ _A, Q_, _H_nmk, x_94 ] Not_rect_Type1 _A Q_ _H_nmk x_94 -->
  matita_basics_logic.filter_Not _A univs.Type1
    (x_94 : cic.Term cic.prop (matita_basics_logic.Not _A) => Q_ x_94)
    (matita_basics_logic.Not_rect_Type1_body _A Q_ _H_nmk) x_94.

[ _A, Q_, _H_nmk, x_94 ] Not_rect_Type1_body _A Q_ _H_nmk x_94 -->
  matita_basics_logic.match_Not _A univs.Type1 Q_
    (x_95 :
       (__ : cic.Term cic.prop _A ->
        cic.Term cic.prop matita_basics_logic.False) =>
     _H_nmk x_95)
    x_94.

def Not_rect_Type0 :
      _A : cic.Univ cic.prop ->
      Q_ :
        (_x_97 : cic.Term cic.prop (matita_basics_logic.Not _A) ->
         cic.Univ univs.Type0) ->
      _H_nmk :
        (x_98 :
           (__ : cic.Term cic.prop _A ->
            cic.Term cic.prop matita_basics_logic.False) ->
         cic.Term univs.Type0 (Q_ (matita_basics_logic.nmk _A x_98))) ->
      x_97 : cic.Term cic.prop (matita_basics_logic.Not _A) ->
      cic.Term univs.Type0 (Q_ x_97).

def Not_rect_Type0_body :
      _A : cic.Univ cic.prop ->
      Q_ :
        (_x_97 : cic.Term cic.prop (matita_basics_logic.Not _A) ->
         cic.Univ univs.Type0) ->
      _H_nmk :
        (x_98 :
           (__ : cic.Term cic.prop _A ->
            cic.Term cic.prop matita_basics_logic.False) ->
         cic.Term univs.Type0 (Q_ (matita_basics_logic.nmk _A x_98))) ->
      x_97 : cic.Term cic.prop (matita_basics_logic.Not _A) ->
      cic.Term univs.Type0 (Q_ x_97).

[ _A, Q_, _H_nmk, x_97 ] Not_rect_Type0 _A Q_ _H_nmk x_97 -->
  matita_basics_logic.filter_Not _A univs.Type0
    (x_97 : cic.Term cic.prop (matita_basics_logic.Not _A) => Q_ x_97)
    (matita_basics_logic.Not_rect_Type0_body _A Q_ _H_nmk) x_97.

[ _A, Q_, _H_nmk, x_97 ] Not_rect_Type0_body _A Q_ _H_nmk x_97 -->
  matita_basics_logic.match_Not _A univs.Type0 Q_
    (x_98 :
       (__ : cic.Term cic.prop _A ->
        cic.Term cic.prop matita_basics_logic.False) =>
     _H_nmk x_98)
    x_97.

def Not_rect_CProp4 :
      _A : cic.Univ cic.prop ->
      Q_ :
        (_x_100 : cic.Term cic.prop (matita_basics_logic.Not _A) ->
         cic.Univ cic.prop) ->
      _H_nmk :
        (x_101 :
           (__ : cic.Term cic.prop _A ->
            cic.Term cic.prop matita_basics_logic.False) ->
         cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_101))) ->
      x_100 : cic.Term cic.prop (matita_basics_logic.Not _A) ->
      cic.Term cic.prop (Q_ x_100).

def Not_rect_CProp4_body :
      _A : cic.Univ cic.prop ->
      Q_ :
        (_x_100 : cic.Term cic.prop (matita_basics_logic.Not _A) ->
         cic.Univ cic.prop) ->
      _H_nmk :
        (x_101 :
           (__ : cic.Term cic.prop _A ->
            cic.Term cic.prop matita_basics_logic.False) ->
         cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_101))) ->
      x_100 : cic.Term cic.prop (matita_basics_logic.Not _A) ->
      cic.Term cic.prop (Q_ x_100).

[ _A, Q_, _H_nmk, x_100 ] Not_rect_CProp4 _A Q_ _H_nmk x_100 -->
  matita_basics_logic.filter_Not _A cic.prop
    (x_100 : cic.Term cic.prop (matita_basics_logic.Not _A) => Q_ x_100)
    (matita_basics_logic.Not_rect_CProp4_body _A Q_ _H_nmk) x_100.

[ _A, Q_, _H_nmk, x_100 ] Not_rect_CProp4_body _A Q_ _H_nmk x_100 -->
  matita_basics_logic.match_Not _A cic.prop Q_
    (x_101 :
       (__ : cic.Term cic.prop _A ->
        cic.Term cic.prop matita_basics_logic.False) =>
     _H_nmk x_101)
    x_100.

def Not_rect_CProp5 :
      _A : cic.Univ cic.prop ->
      Q_ :
        (_x_103 : cic.Term cic.prop (matita_basics_logic.Not _A) ->
         cic.Univ cic.prop) ->
      _H_nmk :
        (x_104 :
           (__ : cic.Term cic.prop _A ->
            cic.Term cic.prop matita_basics_logic.False) ->
         cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_104))) ->
      x_103 : cic.Term cic.prop (matita_basics_logic.Not _A) ->
      cic.Term cic.prop (Q_ x_103).

def Not_rect_CProp5_body :
      _A : cic.Univ cic.prop ->
      Q_ :
        (_x_103 : cic.Term cic.prop (matita_basics_logic.Not _A) ->
         cic.Univ cic.prop) ->
      _H_nmk :
        (x_104 :
           (__ : cic.Term cic.prop _A ->
            cic.Term cic.prop matita_basics_logic.False) ->
         cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_104))) ->
      x_103 : cic.Term cic.prop (matita_basics_logic.Not _A) ->
      cic.Term cic.prop (Q_ x_103).

[ _A, Q_, _H_nmk, x_103 ] Not_rect_CProp5 _A Q_ _H_nmk x_103 -->
  matita_basics_logic.filter_Not _A cic.prop
    (x_103 : cic.Term cic.prop (matita_basics_logic.Not _A) => Q_ x_103)
    (matita_basics_logic.Not_rect_CProp5_body _A Q_ _H_nmk) x_103.

[ _A, Q_, _H_nmk, x_103 ] Not_rect_CProp5_body _A Q_ _H_nmk x_103 -->
  matita_basics_logic.match_Not _A cic.prop Q_
    (x_104 :
       (__ : cic.Term cic.prop _A ->
        cic.Term cic.prop matita_basics_logic.False) =>
     _H_nmk x_104)
    x_103.

def Not_rect_CProp3 :
      _A : cic.Univ cic.prop ->
      Q_ :
        (_x_106 : cic.Term cic.prop (matita_basics_logic.Not _A) ->
         cic.Univ cic.prop) ->
      _H_nmk :
        (x_107 :
           (__ : cic.Term cic.prop _A ->
            cic.Term cic.prop matita_basics_logic.False) ->
         cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_107))) ->
      x_106 : cic.Term cic.prop (matita_basics_logic.Not _A) ->
      cic.Term cic.prop (Q_ x_106).

def Not_rect_CProp3_body :
      _A : cic.Univ cic.prop ->
      Q_ :
        (_x_106 : cic.Term cic.prop (matita_basics_logic.Not _A) ->
         cic.Univ cic.prop) ->
      _H_nmk :
        (x_107 :
           (__ : cic.Term cic.prop _A ->
            cic.Term cic.prop matita_basics_logic.False) ->
         cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_107))) ->
      x_106 : cic.Term cic.prop (matita_basics_logic.Not _A) ->
      cic.Term cic.prop (Q_ x_106).

[ _A, Q_, _H_nmk, x_106 ] Not_rect_CProp3 _A Q_ _H_nmk x_106 -->
  matita_basics_logic.filter_Not _A cic.prop
    (x_106 : cic.Term cic.prop (matita_basics_logic.Not _A) => Q_ x_106)
    (matita_basics_logic.Not_rect_CProp3_body _A Q_ _H_nmk) x_106.

[ _A, Q_, _H_nmk, x_106 ] Not_rect_CProp3_body _A Q_ _H_nmk x_106 -->
  matita_basics_logic.match_Not _A cic.prop Q_
    (x_107 :
       (__ : cic.Term cic.prop _A ->
        cic.Term cic.prop matita_basics_logic.False) =>
     _H_nmk x_107)
    x_106.

def Not_rect_CProp2 :
      _A : cic.Univ cic.prop ->
      Q_ :
        (_x_109 : cic.Term cic.prop (matita_basics_logic.Not _A) ->
         cic.Univ cic.prop) ->
      _H_nmk :
        (x_110 :
           (__ : cic.Term cic.prop _A ->
            cic.Term cic.prop matita_basics_logic.False) ->
         cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_110))) ->
      x_109 : cic.Term cic.prop (matita_basics_logic.Not _A) ->
      cic.Term cic.prop (Q_ x_109).

def Not_rect_CProp2_body :
      _A : cic.Univ cic.prop ->
      Q_ :
        (_x_109 : cic.Term cic.prop (matita_basics_logic.Not _A) ->
         cic.Univ cic.prop) ->
      _H_nmk :
        (x_110 :
           (__ : cic.Term cic.prop _A ->
            cic.Term cic.prop matita_basics_logic.False) ->
         cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_110))) ->
      x_109 : cic.Term cic.prop (matita_basics_logic.Not _A) ->
      cic.Term cic.prop (Q_ x_109).

[ _A, Q_, _H_nmk, x_109 ] Not_rect_CProp2 _A Q_ _H_nmk x_109 -->
  matita_basics_logic.filter_Not _A cic.prop
    (x_109 : cic.Term cic.prop (matita_basics_logic.Not _A) => Q_ x_109)
    (matita_basics_logic.Not_rect_CProp2_body _A Q_ _H_nmk) x_109.

[ _A, Q_, _H_nmk, x_109 ] Not_rect_CProp2_body _A Q_ _H_nmk x_109 -->
  matita_basics_logic.match_Not _A cic.prop Q_
    (x_110 :
       (__ : cic.Term cic.prop _A ->
        cic.Term cic.prop matita_basics_logic.False) =>
     _H_nmk x_110)
    x_109.

def Not_rect_CProp1 :
      _A : cic.Univ cic.prop ->
      Q_ :
        (_x_112 : cic.Term cic.prop (matita_basics_logic.Not _A) ->
         cic.Univ cic.prop) ->
      _H_nmk :
        (x_113 :
           (__ : cic.Term cic.prop _A ->
            cic.Term cic.prop matita_basics_logic.False) ->
         cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_113))) ->
      x_112 : cic.Term cic.prop (matita_basics_logic.Not _A) ->
      cic.Term cic.prop (Q_ x_112).

def Not_rect_CProp1_body :
      _A : cic.Univ cic.prop ->
      Q_ :
        (_x_112 : cic.Term cic.prop (matita_basics_logic.Not _A) ->
         cic.Univ cic.prop) ->
      _H_nmk :
        (x_113 :
           (__ : cic.Term cic.prop _A ->
            cic.Term cic.prop matita_basics_logic.False) ->
         cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_113))) ->
      x_112 : cic.Term cic.prop (matita_basics_logic.Not _A) ->
      cic.Term cic.prop (Q_ x_112).

[ _A, Q_, _H_nmk, x_112 ] Not_rect_CProp1 _A Q_ _H_nmk x_112 -->
  matita_basics_logic.filter_Not _A cic.prop
    (x_112 : cic.Term cic.prop (matita_basics_logic.Not _A) => Q_ x_112)
    (matita_basics_logic.Not_rect_CProp1_body _A Q_ _H_nmk) x_112.

[ _A, Q_, _H_nmk, x_112 ] Not_rect_CProp1_body _A Q_ _H_nmk x_112 -->
  matita_basics_logic.match_Not _A cic.prop Q_
    (x_113 :
       (__ : cic.Term cic.prop _A ->
        cic.Term cic.prop matita_basics_logic.False) =>
     _H_nmk x_113)
    x_112.

def Not_rect_CProp0 :
      _A : cic.Univ cic.prop ->
      Q_ :
        (_x_115 : cic.Term cic.prop (matita_basics_logic.Not _A) ->
         cic.Univ cic.prop) ->
      _H_nmk :
        (x_116 :
           (__ : cic.Term cic.prop _A ->
            cic.Term cic.prop matita_basics_logic.False) ->
         cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_116))) ->
      x_115 : cic.Term cic.prop (matita_basics_logic.Not _A) ->
      cic.Term cic.prop (Q_ x_115).

def Not_rect_CProp0_body :
      _A : cic.Univ cic.prop ->
      Q_ :
        (_x_115 : cic.Term cic.prop (matita_basics_logic.Not _A) ->
         cic.Univ cic.prop) ->
      _H_nmk :
        (x_116 :
           (__ : cic.Term cic.prop _A ->
            cic.Term cic.prop matita_basics_logic.False) ->
         cic.Term cic.prop (Q_ (matita_basics_logic.nmk _A x_116))) ->
      x_115 : cic.Term cic.prop (matita_basics_logic.Not _A) ->
      cic.Term cic.prop (Q_ x_115).

[ _A, Q_, _H_nmk, x_115 ] Not_rect_CProp0 _A Q_ _H_nmk x_115 -->
  matita_basics_logic.filter_Not _A cic.prop
    (x_115 : cic.Term cic.prop (matita_basics_logic.Not _A) => Q_ x_115)
    (matita_basics_logic.Not_rect_CProp0_body _A Q_ _H_nmk) x_115.

[ _A, Q_, _H_nmk, x_115 ] Not_rect_CProp0_body _A Q_ _H_nmk x_115 -->
  matita_basics_logic.match_Not _A cic.prop Q_
    (x_116 :
       (__ : cic.Term cic.prop _A ->
        cic.Term cic.prop matita_basics_logic.False) =>
     _H_nmk x_116)
    x_115.

def Not_inv_ind :
      x1 : cic.Univ cic.prop ->
      Hterm : cic.Term cic.prop (matita_basics_logic.Not x1) ->
      P :
        (_z257 : cic.Term cic.prop (matita_basics_logic.Not x1) ->
         cic.Univ cic.prop) ->
      _H1 :
        (x_80 :
           (__ : cic.Term cic.prop x1 ->
            cic.Term cic.prop matita_basics_logic.False) ->
         _z258 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1))
                Hterm (matita_basics_logic.nmk x1 x_80)) ->
         cic.Term cic.prop (P (matita_basics_logic.nmk x1 x_80))) ->
      cic.Term cic.prop (P Hterm) :=
      x1 : cic.Univ cic.prop =>
      Hterm : cic.Term cic.prop (matita_basics_logic.Not x1) =>
      P :
        (_z257 : cic.Term cic.prop (matita_basics_logic.Not x1) ->
         cic.Univ cic.prop) =>
      H1 :
        (x_80 :
           (__ : cic.Term cic.prop x1 ->
            cic.Term cic.prop matita_basics_logic.False) ->
         _z258 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1))
                Hterm (matita_basics_logic.nmk x1 x_80)) ->
         cic.Term cic.prop (P (matita_basics_logic.nmk x1 x_80))) =>
      (Hcut :
         (_z258 :
            cic.Term cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1))
                 Hterm Hterm) ->
          cic.Term cic.prop (P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1))
            Hterm))
        (matita_basics_logic.Not_ind x1
           (_x_79 : cic.Term cic.prop (matita_basics_logic.Not x1) =>
            cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1))
                 Hterm _x_79)
              (_z258 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop univs.Type2
                         (matita_basics_logic.Not x1))
                      Hterm _x_79) =>
               P _x_79))
           H1 Hterm).

def Not_inv_rect_Type4 :
      x1 : cic.Univ cic.prop ->
      Hterm : cic.Term cic.prop (matita_basics_logic.Not x1) ->
      P :
        (_z263 : cic.Term cic.prop (matita_basics_logic.Not x1) ->
         cic.Univ univs.Type4) ->
      _H1 :
        (x_83 :
           (__ : cic.Term cic.prop x1 ->
            cic.Term cic.prop matita_basics_logic.False) ->
         _z264 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1))
                Hterm (matita_basics_logic.nmk x1 x_83)) ->
         cic.Term univs.Type4 (P (matita_basics_logic.nmk x1 x_83))) ->
      cic.Term univs.Type4 (P Hterm) :=
      x1 : cic.Univ cic.prop =>
      Hterm : cic.Term cic.prop (matita_basics_logic.Not x1) =>
      P :
        (_z263 : cic.Term cic.prop (matita_basics_logic.Not x1) ->
         cic.Univ univs.Type4) =>
      H1 :
        (x_83 :
           (__ : cic.Term cic.prop x1 ->
            cic.Term cic.prop matita_basics_logic.False) ->
         _z264 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1))
                Hterm (matita_basics_logic.nmk x1 x_83)) ->
         cic.Term univs.Type4 (P (matita_basics_logic.nmk x1 x_83))) =>
      (Hcut :
         (_z264 :
            cic.Term cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1))
                 Hterm Hterm) ->
          cic.Term univs.Type4 (P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1))
            Hterm))
        (matita_basics_logic.Not_rect_Type4 x1
           (_x_82 : cic.Term cic.prop (matita_basics_logic.Not x1) =>
            cic.prod cic.prop univs.Type4
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1))
                 Hterm _x_82)
              (_z264 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop univs.Type2
                         (matita_basics_logic.Not x1))
                      Hterm _x_82) =>
               P _x_82))
           H1 Hterm).

def Not_inv_rect_Type3 :
      x1 : cic.Univ cic.prop ->
      Hterm : cic.Term cic.prop (matita_basics_logic.Not x1) ->
      P :
        (_z269 : cic.Term cic.prop (matita_basics_logic.Not x1) ->
         cic.Univ univs.Type3) ->
      _H1 :
        (x_89 :
           (__ : cic.Term cic.prop x1 ->
            cic.Term cic.prop matita_basics_logic.False) ->
         _z270 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1))
                Hterm (matita_basics_logic.nmk x1 x_89)) ->
         cic.Term univs.Type3 (P (matita_basics_logic.nmk x1 x_89))) ->
      cic.Term univs.Type3 (P Hterm) :=
      x1 : cic.Univ cic.prop =>
      Hterm : cic.Term cic.prop (matita_basics_logic.Not x1) =>
      P :
        (_z269 : cic.Term cic.prop (matita_basics_logic.Not x1) ->
         cic.Univ univs.Type3) =>
      H1 :
        (x_89 :
           (__ : cic.Term cic.prop x1 ->
            cic.Term cic.prop matita_basics_logic.False) ->
         _z270 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1))
                Hterm (matita_basics_logic.nmk x1 x_89)) ->
         cic.Term univs.Type3 (P (matita_basics_logic.nmk x1 x_89))) =>
      (Hcut :
         (_z270 :
            cic.Term cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1))
                 Hterm Hterm) ->
          cic.Term univs.Type3 (P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1))
            Hterm))
        (matita_basics_logic.Not_rect_Type3 x1
           (_x_88 : cic.Term cic.prop (matita_basics_logic.Not x1) =>
            cic.prod cic.prop univs.Type3
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1))
                 Hterm _x_88)
              (_z270 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop univs.Type2
                         (matita_basics_logic.Not x1))
                      Hterm _x_88) =>
               P _x_88))
           H1 Hterm).

def Not_inv_rect_Type2 :
      x1 : cic.Univ cic.prop ->
      Hterm : cic.Term cic.prop (matita_basics_logic.Not x1) ->
      P :
        (_z275 : cic.Term cic.prop (matita_basics_logic.Not x1) ->
         cic.Univ univs.Type2) ->
      _H1 :
        (x_92 :
           (__ : cic.Term cic.prop x1 ->
            cic.Term cic.prop matita_basics_logic.False) ->
         _z276 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1))
                Hterm (matita_basics_logic.nmk x1 x_92)) ->
         cic.Term univs.Type2 (P (matita_basics_logic.nmk x1 x_92))) ->
      cic.Term univs.Type2 (P Hterm) :=
      x1 : cic.Univ cic.prop =>
      Hterm : cic.Term cic.prop (matita_basics_logic.Not x1) =>
      P :
        (_z275 : cic.Term cic.prop (matita_basics_logic.Not x1) ->
         cic.Univ univs.Type2) =>
      H1 :
        (x_92 :
           (__ : cic.Term cic.prop x1 ->
            cic.Term cic.prop matita_basics_logic.False) ->
         _z276 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1))
                Hterm (matita_basics_logic.nmk x1 x_92)) ->
         cic.Term univs.Type2 (P (matita_basics_logic.nmk x1 x_92))) =>
      (Hcut :
         (_z276 :
            cic.Term cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1))
                 Hterm Hterm) ->
          cic.Term univs.Type2 (P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1))
            Hterm))
        (matita_basics_logic.Not_rect_Type2 x1
           (_x_91 : cic.Term cic.prop (matita_basics_logic.Not x1) =>
            cic.prod cic.prop univs.Type2
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1))
                 Hterm _x_91)
              (_z276 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop univs.Type2
                         (matita_basics_logic.Not x1))
                      Hterm _x_91) =>
               P _x_91))
           H1 Hterm).

def Not_inv_rect_Type1 :
      x1 : cic.Univ cic.prop ->
      Hterm : cic.Term cic.prop (matita_basics_logic.Not x1) ->
      P :
        (_z281 : cic.Term cic.prop (matita_basics_logic.Not x1) ->
         cic.Univ univs.Type1) ->
      _H1 :
        (x_95 :
           (__ : cic.Term cic.prop x1 ->
            cic.Term cic.prop matita_basics_logic.False) ->
         _z282 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1))
                Hterm (matita_basics_logic.nmk x1 x_95)) ->
         cic.Term univs.Type1 (P (matita_basics_logic.nmk x1 x_95))) ->
      cic.Term univs.Type1 (P Hterm) :=
      x1 : cic.Univ cic.prop =>
      Hterm : cic.Term cic.prop (matita_basics_logic.Not x1) =>
      P :
        (_z281 : cic.Term cic.prop (matita_basics_logic.Not x1) ->
         cic.Univ univs.Type1) =>
      H1 :
        (x_95 :
           (__ : cic.Term cic.prop x1 ->
            cic.Term cic.prop matita_basics_logic.False) ->
         _z282 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1))
                Hterm (matita_basics_logic.nmk x1 x_95)) ->
         cic.Term univs.Type1 (P (matita_basics_logic.nmk x1 x_95))) =>
      (Hcut :
         (_z282 :
            cic.Term cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1))
                 Hterm Hterm) ->
          cic.Term univs.Type1 (P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1))
            Hterm))
        (matita_basics_logic.Not_rect_Type1 x1
           (_x_94 : cic.Term cic.prop (matita_basics_logic.Not x1) =>
            cic.prod cic.prop univs.Type1
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1))
                 Hterm _x_94)
              (_z282 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop univs.Type2
                         (matita_basics_logic.Not x1))
                      Hterm _x_94) =>
               P _x_94))
           H1 Hterm).

def Not_inv_rect_Type0 :
      x1 : cic.Univ cic.prop ->
      Hterm : cic.Term cic.prop (matita_basics_logic.Not x1) ->
      P :
        (_z287 : cic.Term cic.prop (matita_basics_logic.Not x1) ->
         cic.Univ univs.Type0) ->
      _H1 :
        (x_98 :
           (__ : cic.Term cic.prop x1 ->
            cic.Term cic.prop matita_basics_logic.False) ->
         _z288 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1))
                Hterm (matita_basics_logic.nmk x1 x_98)) ->
         cic.Term univs.Type0 (P (matita_basics_logic.nmk x1 x_98))) ->
      cic.Term univs.Type0 (P Hterm) :=
      x1 : cic.Univ cic.prop =>
      Hterm : cic.Term cic.prop (matita_basics_logic.Not x1) =>
      P :
        (_z287 : cic.Term cic.prop (matita_basics_logic.Not x1) ->
         cic.Univ univs.Type0) =>
      H1 :
        (x_98 :
           (__ : cic.Term cic.prop x1 ->
            cic.Term cic.prop matita_basics_logic.False) ->
         _z288 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1))
                Hterm (matita_basics_logic.nmk x1 x_98)) ->
         cic.Term univs.Type0 (P (matita_basics_logic.nmk x1 x_98))) =>
      (Hcut :
         (_z288 :
            cic.Term cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1))
                 Hterm Hterm) ->
          cic.Term univs.Type0 (P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1))
            Hterm))
        (matita_basics_logic.Not_rect_Type0 x1
           (_x_97 : cic.Term cic.prop (matita_basics_logic.Not x1) =>
            cic.prod cic.prop univs.Type0
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1))
                 Hterm _x_97)
              (_z288 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop univs.Type2
                         (matita_basics_logic.Not x1))
                      Hterm _x_97) =>
               P _x_97))
           H1 Hterm).

def Not_inv_rect_CProp4 :
      x1 : cic.Univ cic.prop ->
      Hterm : cic.Term cic.prop (matita_basics_logic.Not x1) ->
      P :
        (_z293 : cic.Term cic.prop (matita_basics_logic.Not x1) ->
         cic.Univ cic.prop) ->
      _H1 :
        (x_101 :
           (__ : cic.Term cic.prop x1 ->
            cic.Term cic.prop matita_basics_logic.False) ->
         _z294 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1))
                Hterm (matita_basics_logic.nmk x1 x_101)) ->
         cic.Term cic.prop (P (matita_basics_logic.nmk x1 x_101))) ->
      cic.Term cic.prop (P Hterm) :=
      x1 : cic.Univ cic.prop =>
      Hterm : cic.Term cic.prop (matita_basics_logic.Not x1) =>
      P :
        (_z293 : cic.Term cic.prop (matita_basics_logic.Not x1) ->
         cic.Univ cic.prop) =>
      H1 :
        (x_101 :
           (__ : cic.Term cic.prop x1 ->
            cic.Term cic.prop matita_basics_logic.False) ->
         _z294 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1))
                Hterm (matita_basics_logic.nmk x1 x_101)) ->
         cic.Term cic.prop (P (matita_basics_logic.nmk x1 x_101))) =>
      (Hcut :
         (_z294 :
            cic.Term cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1))
                 Hterm Hterm) ->
          cic.Term cic.prop (P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1))
            Hterm))
        (matita_basics_logic.Not_rect_CProp4 x1
           (_x_100 : cic.Term cic.prop (matita_basics_logic.Not x1) =>
            cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1))
                 Hterm _x_100)
              (_z294 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop univs.Type2
                         (matita_basics_logic.Not x1))
                      Hterm _x_100) =>
               P _x_100))
           H1 Hterm).

def Not_inv_rect_CProp3 :
      x1 : cic.Univ cic.prop ->
      Hterm : cic.Term cic.prop (matita_basics_logic.Not x1) ->
      P :
        (_z299 : cic.Term cic.prop (matita_basics_logic.Not x1) ->
         cic.Univ cic.prop) ->
      _H1 :
        (x_107 :
           (__ : cic.Term cic.prop x1 ->
            cic.Term cic.prop matita_basics_logic.False) ->
         _z300 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1))
                Hterm (matita_basics_logic.nmk x1 x_107)) ->
         cic.Term cic.prop (P (matita_basics_logic.nmk x1 x_107))) ->
      cic.Term cic.prop (P Hterm) :=
      x1 : cic.Univ cic.prop =>
      Hterm : cic.Term cic.prop (matita_basics_logic.Not x1) =>
      P :
        (_z299 : cic.Term cic.prop (matita_basics_logic.Not x1) ->
         cic.Univ cic.prop) =>
      H1 :
        (x_107 :
           (__ : cic.Term cic.prop x1 ->
            cic.Term cic.prop matita_basics_logic.False) ->
         _z300 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1))
                Hterm (matita_basics_logic.nmk x1 x_107)) ->
         cic.Term cic.prop (P (matita_basics_logic.nmk x1 x_107))) =>
      (Hcut :
         (_z300 :
            cic.Term cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1))
                 Hterm Hterm) ->
          cic.Term cic.prop (P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1))
            Hterm))
        (matita_basics_logic.Not_rect_CProp3 x1
           (_x_106 : cic.Term cic.prop (matita_basics_logic.Not x1) =>
            cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1))
                 Hterm _x_106)
              (_z300 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop univs.Type2
                         (matita_basics_logic.Not x1))
                      Hterm _x_106) =>
               P _x_106))
           H1 Hterm).

def Not_inv_rect_CProp2 :
      x1 : cic.Univ cic.prop ->
      Hterm : cic.Term cic.prop (matita_basics_logic.Not x1) ->
      P :
        (_z305 : cic.Term cic.prop (matita_basics_logic.Not x1) ->
         cic.Univ cic.prop) ->
      _H1 :
        (x_110 :
           (__ : cic.Term cic.prop x1 ->
            cic.Term cic.prop matita_basics_logic.False) ->
         _z306 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1))
                Hterm (matita_basics_logic.nmk x1 x_110)) ->
         cic.Term cic.prop (P (matita_basics_logic.nmk x1 x_110))) ->
      cic.Term cic.prop (P Hterm) :=
      x1 : cic.Univ cic.prop =>
      Hterm : cic.Term cic.prop (matita_basics_logic.Not x1) =>
      P :
        (_z305 : cic.Term cic.prop (matita_basics_logic.Not x1) ->
         cic.Univ cic.prop) =>
      H1 :
        (x_110 :
           (__ : cic.Term cic.prop x1 ->
            cic.Term cic.prop matita_basics_logic.False) ->
         _z306 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1))
                Hterm (matita_basics_logic.nmk x1 x_110)) ->
         cic.Term cic.prop (P (matita_basics_logic.nmk x1 x_110))) =>
      (Hcut :
         (_z306 :
            cic.Term cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1))
                 Hterm Hterm) ->
          cic.Term cic.prop (P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1))
            Hterm))
        (matita_basics_logic.Not_rect_CProp2 x1
           (_x_109 : cic.Term cic.prop (matita_basics_logic.Not x1) =>
            cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1))
                 Hterm _x_109)
              (_z306 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop univs.Type2
                         (matita_basics_logic.Not x1))
                      Hterm _x_109) =>
               P _x_109))
           H1 Hterm).

def Not_inv_rect_CProp1 :
      x1 : cic.Univ cic.prop ->
      Hterm : cic.Term cic.prop (matita_basics_logic.Not x1) ->
      P :
        (_z311 : cic.Term cic.prop (matita_basics_logic.Not x1) ->
         cic.Univ cic.prop) ->
      _H1 :
        (x_113 :
           (__ : cic.Term cic.prop x1 ->
            cic.Term cic.prop matita_basics_logic.False) ->
         _z312 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1))
                Hterm (matita_basics_logic.nmk x1 x_113)) ->
         cic.Term cic.prop (P (matita_basics_logic.nmk x1 x_113))) ->
      cic.Term cic.prop (P Hterm) :=
      x1 : cic.Univ cic.prop =>
      Hterm : cic.Term cic.prop (matita_basics_logic.Not x1) =>
      P :
        (_z311 : cic.Term cic.prop (matita_basics_logic.Not x1) ->
         cic.Univ cic.prop) =>
      H1 :
        (x_113 :
           (__ : cic.Term cic.prop x1 ->
            cic.Term cic.prop matita_basics_logic.False) ->
         _z312 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1))
                Hterm (matita_basics_logic.nmk x1 x_113)) ->
         cic.Term cic.prop (P (matita_basics_logic.nmk x1 x_113))) =>
      (Hcut :
         (_z312 :
            cic.Term cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1))
                 Hterm Hterm) ->
          cic.Term cic.prop (P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1))
            Hterm))
        (matita_basics_logic.Not_rect_CProp1 x1
           (_x_112 : cic.Term cic.prop (matita_basics_logic.Not x1) =>
            cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1))
                 Hterm _x_112)
              (_z312 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop univs.Type2
                         (matita_basics_logic.Not x1))
                      Hterm _x_112) =>
               P _x_112))
           H1 Hterm).

def Not_inv_rect_CProp0 :
      x1 : cic.Univ cic.prop ->
      Hterm : cic.Term cic.prop (matita_basics_logic.Not x1) ->
      P :
        (_z317 : cic.Term cic.prop (matita_basics_logic.Not x1) ->
         cic.Univ cic.prop) ->
      _H1 :
        (x_116 :
           (__ : cic.Term cic.prop x1 ->
            cic.Term cic.prop matita_basics_logic.False) ->
         _z318 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1))
                Hterm (matita_basics_logic.nmk x1 x_116)) ->
         cic.Term cic.prop (P (matita_basics_logic.nmk x1 x_116))) ->
      cic.Term cic.prop (P Hterm) :=
      x1 : cic.Univ cic.prop =>
      Hterm : cic.Term cic.prop (matita_basics_logic.Not x1) =>
      P :
        (_z317 : cic.Term cic.prop (matita_basics_logic.Not x1) ->
         cic.Univ cic.prop) =>
      H1 :
        (x_116 :
           (__ : cic.Term cic.prop x1 ->
            cic.Term cic.prop matita_basics_logic.False) ->
         _z318 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1))
                Hterm (matita_basics_logic.nmk x1 x_116)) ->
         cic.Term cic.prop (P (matita_basics_logic.nmk x1 x_116))) =>
      (Hcut :
         (_z318 :
            cic.Term cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1))
                 Hterm Hterm) ->
          cic.Term cic.prop (P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1))
            Hterm))
        (matita_basics_logic.Not_rect_CProp0 x1
           (_x_115 : cic.Term cic.prop (matita_basics_logic.Not x1) =>
            cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2 (matita_basics_logic.Not x1))
                 Hterm _x_115)
              (_z318 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop univs.Type2
                         (matita_basics_logic.Not x1))
                      Hterm _x_115) =>
               P _x_115))
           H1 Hterm).

def absurd :
      A : cic.Univ cic.prop ->
      __ : cic.Term cic.prop A ->
      __1 : cic.Term cic.prop (matita_basics_logic.Not A) ->
      cic.Term cic.prop matita_basics_logic.False :=
      A : cic.Univ cic.prop =>
      H : cic.Term cic.prop A =>
      Hn : cic.Term cic.prop (matita_basics_logic.Not A) =>
      matita_basics_logic.Not_ind A
        (_x_79 : cic.Term cic.prop (matita_basics_logic.Not A) =>
         matita_basics_logic.False)
        (_x_80 :
           (__ : cic.Term cic.prop A ->
            cic.Term cic.prop matita_basics_logic.False) =>
         _x_80 H)
        Hn.

def not_to_not :
      A : cic.Univ cic.prop ->
      B : cic.Univ cic.prop ->
      __ : (__ : cic.Term cic.prop A -> cic.Term cic.prop B) ->
      __1 : cic.Term cic.prop (matita_basics_logic.Not B) ->
      cic.Term cic.prop (matita_basics_logic.Not A) :=
      A : cic.Univ cic.prop =>
      B : cic.Univ cic.prop =>
      auto : (__ : cic.Term cic.prop A -> cic.Term cic.prop B) =>
      auto' : cic.Term cic.prop (matita_basics_logic.Not B) =>
      matita_basics_logic.nmk A
        (auto'' : cic.Term cic.prop A =>
         matita_basics_logic.absurd B (auto auto'') auto').

def sym_not_eq :
      A : cic.Univ univs.Type2 ->
      x : cic.Term univs.Type2 A ->
      y : cic.Term univs.Type2 A ->
      __ :
        cic.Term cic.prop
          (matita_basics_logic.Not (matita_basics_logic.eq A x y)) ->
      cic.Term cic.prop
        (matita_basics_logic.Not (matita_basics_logic.eq A y x))
      :=
      A : cic.Univ univs.Type2 =>
      x : cic.Term univs.Type2 A =>
      y : cic.Term univs.Type2 A =>
      auto :
        cic.Term cic.prop
          (matita_basics_logic.Not (matita_basics_logic.eq A x y)) =>
      matita_basics_logic.nmk (matita_basics_logic.eq A y x)
        (auto' : cic.Term cic.prop (matita_basics_logic.eq A y x) =>
         matita_basics_logic.absurd (matita_basics_logic.eq A x y)
           (matita_basics_logic.rewrite_r A x
              (__ : cic.Term univs.Type2 A =>
               cic.lift cic.prop univs.Type2
                 ((x0 : cic.Term univs.Type2 A =>
                   matita_basics_logic.eq A x x0) __))
              (matita_basics_logic.refl A x) y auto')
           auto).

And : _A : cic.Univ cic.prop -> _B : cic.Univ cic.prop -> cic.Univ cic.prop.

conj :
  A : cic.Univ cic.prop ->
  B : cic.Univ cic.prop ->
  __ : cic.Term cic.prop A ->
  __1 : cic.Term cic.prop B ->
  cic.Term cic.prop (matita_basics_logic.And A B).

def match_And :
      _A : cic.Univ cic.prop ->
      _B : cic.Univ cic.prop ->
      return_sort : cic.Sort ->
      return_type :
        (z : cic.Term cic.prop (matita_basics_logic.And _A _B) ->
         cic.Univ return_sort) ->
      case_conj :
        (__ : cic.Term cic.prop _A ->
         __1 : cic.Term cic.prop _B ->
         cic.Term return_sort
           (return_type (matita_basics_logic.conj _A _B __ __1))) ->
      z : cic.Term cic.prop (matita_basics_logic.And _A _B) ->
      cic.Term return_sort (return_type z).

[ _A, _B, return_sort, return_type, case_conj, __, __1 ]
  match_And _A _B return_sort return_type case_conj
    (matita_basics_logic.conj _A _B __ __1) -->
  case_conj __ __1.

def filter_And :
      _A : cic.Univ cic.prop ->
      _B : cic.Univ cic.prop ->
      return_sort : cic.Sort ->
      return_type :
        (z : cic.Term cic.prop (matita_basics_logic.And _A _B) ->
         cic.Univ return_sort) ->
      return :
        (z : cic.Term cic.prop (matita_basics_logic.And _A _B) ->
         cic.Term return_sort (return_type z)) ->
      z : cic.Term cic.prop (matita_basics_logic.And _A _B) ->
      cic.Term return_sort (return_type z).

[ A, B, __, __1, return_sort, return_type, return ]
  filter_And (A) (B) return_sort return_type return
    (matita_basics_logic.conj A B __ __1) -->
  return (matita_basics_logic.conj A B __ __1).

def And_ind :
      _A : cic.Univ cic.prop ->
      _B : cic.Univ cic.prop ->
      Q_ :
        (_x_118 : cic.Term cic.prop (matita_basics_logic.And _A _B) ->
         cic.Univ cic.prop) ->
      _H_conj :
        (x_120 : cic.Term cic.prop _A ->
         x_119 : cic.Term cic.prop _B ->
         cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_120 x_119))) ->
      x_118 : cic.Term cic.prop (matita_basics_logic.And _A _B) ->
      cic.Term cic.prop (Q_ x_118).

def And_ind_body :
      _A : cic.Univ cic.prop ->
      _B : cic.Univ cic.prop ->
      Q_ :
        (_x_118 : cic.Term cic.prop (matita_basics_logic.And _A _B) ->
         cic.Univ cic.prop) ->
      _H_conj :
        (x_120 : cic.Term cic.prop _A ->
         x_119 : cic.Term cic.prop _B ->
         cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_120 x_119))) ->
      x_118 : cic.Term cic.prop (matita_basics_logic.And _A _B) ->
      cic.Term cic.prop (Q_ x_118).

[ _A, _B, Q_, _H_conj, x_118 ] And_ind _A _B Q_ _H_conj x_118 -->
  matita_basics_logic.filter_And _A _B cic.prop
    (x_118 : cic.Term cic.prop (matita_basics_logic.And _A _B) => Q_ x_118)
    (matita_basics_logic.And_ind_body _A _B Q_ _H_conj) x_118.

[ _A, _B, Q_, _H_conj, x_118 ] And_ind_body _A _B Q_ _H_conj x_118 -->
  matita_basics_logic.match_And _A _B cic.prop Q_
    (x_120 : cic.Term cic.prop _A =>
     x_119 : cic.Term cic.prop _B => _H_conj x_120 x_119)
    x_118.

def And_rect_Type4 :
      _A : cic.Univ cic.prop ->
      _B : cic.Univ cic.prop ->
      Q_ :
        (_x_122 : cic.Term cic.prop (matita_basics_logic.And _A _B) ->
         cic.Univ univs.Type4) ->
      _H_conj :
        (x_124 : cic.Term cic.prop _A ->
         x_123 : cic.Term cic.prop _B ->
         cic.Term univs.Type4
           (Q_ (matita_basics_logic.conj _A _B x_124 x_123))) ->
      x_122 : cic.Term cic.prop (matita_basics_logic.And _A _B) ->
      cic.Term univs.Type4 (Q_ x_122).

def And_rect_Type4_body :
      _A : cic.Univ cic.prop ->
      _B : cic.Univ cic.prop ->
      Q_ :
        (_x_122 : cic.Term cic.prop (matita_basics_logic.And _A _B) ->
         cic.Univ univs.Type4) ->
      _H_conj :
        (x_124 : cic.Term cic.prop _A ->
         x_123 : cic.Term cic.prop _B ->
         cic.Term univs.Type4
           (Q_ (matita_basics_logic.conj _A _B x_124 x_123))) ->
      x_122 : cic.Term cic.prop (matita_basics_logic.And _A _B) ->
      cic.Term univs.Type4 (Q_ x_122).

[ _A, _B, Q_, _H_conj, x_122 ] And_rect_Type4 _A _B Q_ _H_conj x_122 -->
  matita_basics_logic.filter_And _A _B univs.Type4
    (x_122 : cic.Term cic.prop (matita_basics_logic.And _A _B) => Q_ x_122)
    (matita_basics_logic.And_rect_Type4_body _A _B Q_ _H_conj) x_122.

[ _A, _B, Q_, _H_conj, x_122 ] And_rect_Type4_body _A _B Q_ _H_conj x_122 -->
  matita_basics_logic.match_And _A _B univs.Type4 Q_
    (x_124 : cic.Term cic.prop _A =>
     x_123 : cic.Term cic.prop _B => _H_conj x_124 x_123)
    x_122.

def And_rect_Type5 :
      _A : cic.Univ cic.prop ->
      _B : cic.Univ cic.prop ->
      Q_ :
        (_x_126 : cic.Term cic.prop (matita_basics_logic.And _A _B) ->
         cic.Univ univs.Type5) ->
      _H_conj :
        (x_128 : cic.Term cic.prop _A ->
         x_127 : cic.Term cic.prop _B ->
         cic.Term univs.Type5
           (Q_ (matita_basics_logic.conj _A _B x_128 x_127))) ->
      x_126 : cic.Term cic.prop (matita_basics_logic.And _A _B) ->
      cic.Term univs.Type5 (Q_ x_126).

def And_rect_Type5_body :
      _A : cic.Univ cic.prop ->
      _B : cic.Univ cic.prop ->
      Q_ :
        (_x_126 : cic.Term cic.prop (matita_basics_logic.And _A _B) ->
         cic.Univ univs.Type5) ->
      _H_conj :
        (x_128 : cic.Term cic.prop _A ->
         x_127 : cic.Term cic.prop _B ->
         cic.Term univs.Type5
           (Q_ (matita_basics_logic.conj _A _B x_128 x_127))) ->
      x_126 : cic.Term cic.prop (matita_basics_logic.And _A _B) ->
      cic.Term univs.Type5 (Q_ x_126).

[ _A, _B, Q_, _H_conj, x_126 ] And_rect_Type5 _A _B Q_ _H_conj x_126 -->
  matita_basics_logic.filter_And _A _B univs.Type5
    (x_126 : cic.Term cic.prop (matita_basics_logic.And _A _B) => Q_ x_126)
    (matita_basics_logic.And_rect_Type5_body _A _B Q_ _H_conj) x_126.

[ _A, _B, Q_, _H_conj, x_126 ] And_rect_Type5_body _A _B Q_ _H_conj x_126 -->
  matita_basics_logic.match_And _A _B univs.Type5 Q_
    (x_128 : cic.Term cic.prop _A =>
     x_127 : cic.Term cic.prop _B => _H_conj x_128 x_127)
    x_126.

def And_rect_Type3 :
      _A : cic.Univ cic.prop ->
      _B : cic.Univ cic.prop ->
      Q_ :
        (_x_130 : cic.Term cic.prop (matita_basics_logic.And _A _B) ->
         cic.Univ univs.Type3) ->
      _H_conj :
        (x_132 : cic.Term cic.prop _A ->
         x_131 : cic.Term cic.prop _B ->
         cic.Term univs.Type3
           (Q_ (matita_basics_logic.conj _A _B x_132 x_131))) ->
      x_130 : cic.Term cic.prop (matita_basics_logic.And _A _B) ->
      cic.Term univs.Type3 (Q_ x_130).

def And_rect_Type3_body :
      _A : cic.Univ cic.prop ->
      _B : cic.Univ cic.prop ->
      Q_ :
        (_x_130 : cic.Term cic.prop (matita_basics_logic.And _A _B) ->
         cic.Univ univs.Type3) ->
      _H_conj :
        (x_132 : cic.Term cic.prop _A ->
         x_131 : cic.Term cic.prop _B ->
         cic.Term univs.Type3
           (Q_ (matita_basics_logic.conj _A _B x_132 x_131))) ->
      x_130 : cic.Term cic.prop (matita_basics_logic.And _A _B) ->
      cic.Term univs.Type3 (Q_ x_130).

[ _A, _B, Q_, _H_conj, x_130 ] And_rect_Type3 _A _B Q_ _H_conj x_130 -->
  matita_basics_logic.filter_And _A _B univs.Type3
    (x_130 : cic.Term cic.prop (matita_basics_logic.And _A _B) => Q_ x_130)
    (matita_basics_logic.And_rect_Type3_body _A _B Q_ _H_conj) x_130.

[ _A, _B, Q_, _H_conj, x_130 ] And_rect_Type3_body _A _B Q_ _H_conj x_130 -->
  matita_basics_logic.match_And _A _B univs.Type3 Q_
    (x_132 : cic.Term cic.prop _A =>
     x_131 : cic.Term cic.prop _B => _H_conj x_132 x_131)
    x_130.

def And_rect_Type2 :
      _A : cic.Univ cic.prop ->
      _B : cic.Univ cic.prop ->
      Q_ :
        (_x_134 : cic.Term cic.prop (matita_basics_logic.And _A _B) ->
         cic.Univ univs.Type2) ->
      _H_conj :
        (x_136 : cic.Term cic.prop _A ->
         x_135 : cic.Term cic.prop _B ->
         cic.Term univs.Type2
           (Q_ (matita_basics_logic.conj _A _B x_136 x_135))) ->
      x_134 : cic.Term cic.prop (matita_basics_logic.And _A _B) ->
      cic.Term univs.Type2 (Q_ x_134).

def And_rect_Type2_body :
      _A : cic.Univ cic.prop ->
      _B : cic.Univ cic.prop ->
      Q_ :
        (_x_134 : cic.Term cic.prop (matita_basics_logic.And _A _B) ->
         cic.Univ univs.Type2) ->
      _H_conj :
        (x_136 : cic.Term cic.prop _A ->
         x_135 : cic.Term cic.prop _B ->
         cic.Term univs.Type2
           (Q_ (matita_basics_logic.conj _A _B x_136 x_135))) ->
      x_134 : cic.Term cic.prop (matita_basics_logic.And _A _B) ->
      cic.Term univs.Type2 (Q_ x_134).

[ _A, _B, Q_, _H_conj, x_134 ] And_rect_Type2 _A _B Q_ _H_conj x_134 -->
  matita_basics_logic.filter_And _A _B univs.Type2
    (x_134 : cic.Term cic.prop (matita_basics_logic.And _A _B) => Q_ x_134)
    (matita_basics_logic.And_rect_Type2_body _A _B Q_ _H_conj) x_134.

[ _A, _B, Q_, _H_conj, x_134 ] And_rect_Type2_body _A _B Q_ _H_conj x_134 -->
  matita_basics_logic.match_And _A _B univs.Type2 Q_
    (x_136 : cic.Term cic.prop _A =>
     x_135 : cic.Term cic.prop _B => _H_conj x_136 x_135)
    x_134.

def And_rect_Type1 :
      _A : cic.Univ cic.prop ->
      _B : cic.Univ cic.prop ->
      Q_ :
        (_x_138 : cic.Term cic.prop (matita_basics_logic.And _A _B) ->
         cic.Univ univs.Type1) ->
      _H_conj :
        (x_140 : cic.Term cic.prop _A ->
         x_139 : cic.Term cic.prop _B ->
         cic.Term univs.Type1
           (Q_ (matita_basics_logic.conj _A _B x_140 x_139))) ->
      x_138 : cic.Term cic.prop (matita_basics_logic.And _A _B) ->
      cic.Term univs.Type1 (Q_ x_138).

def And_rect_Type1_body :
      _A : cic.Univ cic.prop ->
      _B : cic.Univ cic.prop ->
      Q_ :
        (_x_138 : cic.Term cic.prop (matita_basics_logic.And _A _B) ->
         cic.Univ univs.Type1) ->
      _H_conj :
        (x_140 : cic.Term cic.prop _A ->
         x_139 : cic.Term cic.prop _B ->
         cic.Term univs.Type1
           (Q_ (matita_basics_logic.conj _A _B x_140 x_139))) ->
      x_138 : cic.Term cic.prop (matita_basics_logic.And _A _B) ->
      cic.Term univs.Type1 (Q_ x_138).

[ _A, _B, Q_, _H_conj, x_138 ] And_rect_Type1 _A _B Q_ _H_conj x_138 -->
  matita_basics_logic.filter_And _A _B univs.Type1
    (x_138 : cic.Term cic.prop (matita_basics_logic.And _A _B) => Q_ x_138)
    (matita_basics_logic.And_rect_Type1_body _A _B Q_ _H_conj) x_138.

[ _A, _B, Q_, _H_conj, x_138 ] And_rect_Type1_body _A _B Q_ _H_conj x_138 -->
  matita_basics_logic.match_And _A _B univs.Type1 Q_
    (x_140 : cic.Term cic.prop _A =>
     x_139 : cic.Term cic.prop _B => _H_conj x_140 x_139)
    x_138.

def And_rect_Type0 :
      _A : cic.Univ cic.prop ->
      _B : cic.Univ cic.prop ->
      Q_ :
        (_x_142 : cic.Term cic.prop (matita_basics_logic.And _A _B) ->
         cic.Univ univs.Type0) ->
      _H_conj :
        (x_144 : cic.Term cic.prop _A ->
         x_143 : cic.Term cic.prop _B ->
         cic.Term univs.Type0
           (Q_ (matita_basics_logic.conj _A _B x_144 x_143))) ->
      x_142 : cic.Term cic.prop (matita_basics_logic.And _A _B) ->
      cic.Term univs.Type0 (Q_ x_142).

def And_rect_Type0_body :
      _A : cic.Univ cic.prop ->
      _B : cic.Univ cic.prop ->
      Q_ :
        (_x_142 : cic.Term cic.prop (matita_basics_logic.And _A _B) ->
         cic.Univ univs.Type0) ->
      _H_conj :
        (x_144 : cic.Term cic.prop _A ->
         x_143 : cic.Term cic.prop _B ->
         cic.Term univs.Type0
           (Q_ (matita_basics_logic.conj _A _B x_144 x_143))) ->
      x_142 : cic.Term cic.prop (matita_basics_logic.And _A _B) ->
      cic.Term univs.Type0 (Q_ x_142).

[ _A, _B, Q_, _H_conj, x_142 ] And_rect_Type0 _A _B Q_ _H_conj x_142 -->
  matita_basics_logic.filter_And _A _B univs.Type0
    (x_142 : cic.Term cic.prop (matita_basics_logic.And _A _B) => Q_ x_142)
    (matita_basics_logic.And_rect_Type0_body _A _B Q_ _H_conj) x_142.

[ _A, _B, Q_, _H_conj, x_142 ] And_rect_Type0_body _A _B Q_ _H_conj x_142 -->
  matita_basics_logic.match_And _A _B univs.Type0 Q_
    (x_144 : cic.Term cic.prop _A =>
     x_143 : cic.Term cic.prop _B => _H_conj x_144 x_143)
    x_142.

def And_rect_CProp4 :
      _A : cic.Univ cic.prop ->
      _B : cic.Univ cic.prop ->
      Q_ :
        (_x_146 : cic.Term cic.prop (matita_basics_logic.And _A _B) ->
         cic.Univ cic.prop) ->
      _H_conj :
        (x_148 : cic.Term cic.prop _A ->
         x_147 : cic.Term cic.prop _B ->
         cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_148 x_147))) ->
      x_146 : cic.Term cic.prop (matita_basics_logic.And _A _B) ->
      cic.Term cic.prop (Q_ x_146).

def And_rect_CProp4_body :
      _A : cic.Univ cic.prop ->
      _B : cic.Univ cic.prop ->
      Q_ :
        (_x_146 : cic.Term cic.prop (matita_basics_logic.And _A _B) ->
         cic.Univ cic.prop) ->
      _H_conj :
        (x_148 : cic.Term cic.prop _A ->
         x_147 : cic.Term cic.prop _B ->
         cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_148 x_147))) ->
      x_146 : cic.Term cic.prop (matita_basics_logic.And _A _B) ->
      cic.Term cic.prop (Q_ x_146).

[ _A, _B, Q_, _H_conj, x_146 ] And_rect_CProp4 _A _B Q_ _H_conj x_146 -->
  matita_basics_logic.filter_And _A _B cic.prop
    (x_146 : cic.Term cic.prop (matita_basics_logic.And _A _B) => Q_ x_146)
    (matita_basics_logic.And_rect_CProp4_body _A _B Q_ _H_conj) x_146.

[ _A, _B, Q_, _H_conj, x_146 ]
  And_rect_CProp4_body _A _B Q_ _H_conj x_146 -->
  matita_basics_logic.match_And _A _B cic.prop Q_
    (x_148 : cic.Term cic.prop _A =>
     x_147 : cic.Term cic.prop _B => _H_conj x_148 x_147)
    x_146.

def And_rect_CProp5 :
      _A : cic.Univ cic.prop ->
      _B : cic.Univ cic.prop ->
      Q_ :
        (_x_150 : cic.Term cic.prop (matita_basics_logic.And _A _B) ->
         cic.Univ cic.prop) ->
      _H_conj :
        (x_152 : cic.Term cic.prop _A ->
         x_151 : cic.Term cic.prop _B ->
         cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_152 x_151))) ->
      x_150 : cic.Term cic.prop (matita_basics_logic.And _A _B) ->
      cic.Term cic.prop (Q_ x_150).

def And_rect_CProp5_body :
      _A : cic.Univ cic.prop ->
      _B : cic.Univ cic.prop ->
      Q_ :
        (_x_150 : cic.Term cic.prop (matita_basics_logic.And _A _B) ->
         cic.Univ cic.prop) ->
      _H_conj :
        (x_152 : cic.Term cic.prop _A ->
         x_151 : cic.Term cic.prop _B ->
         cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_152 x_151))) ->
      x_150 : cic.Term cic.prop (matita_basics_logic.And _A _B) ->
      cic.Term cic.prop (Q_ x_150).

[ _A, _B, Q_, _H_conj, x_150 ] And_rect_CProp5 _A _B Q_ _H_conj x_150 -->
  matita_basics_logic.filter_And _A _B cic.prop
    (x_150 : cic.Term cic.prop (matita_basics_logic.And _A _B) => Q_ x_150)
    (matita_basics_logic.And_rect_CProp5_body _A _B Q_ _H_conj) x_150.

[ _A, _B, Q_, _H_conj, x_150 ]
  And_rect_CProp5_body _A _B Q_ _H_conj x_150 -->
  matita_basics_logic.match_And _A _B cic.prop Q_
    (x_152 : cic.Term cic.prop _A =>
     x_151 : cic.Term cic.prop _B => _H_conj x_152 x_151)
    x_150.

def And_rect_CProp3 :
      _A : cic.Univ cic.prop ->
      _B : cic.Univ cic.prop ->
      Q_ :
        (_x_154 : cic.Term cic.prop (matita_basics_logic.And _A _B) ->
         cic.Univ cic.prop) ->
      _H_conj :
        (x_156 : cic.Term cic.prop _A ->
         x_155 : cic.Term cic.prop _B ->
         cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_156 x_155))) ->
      x_154 : cic.Term cic.prop (matita_basics_logic.And _A _B) ->
      cic.Term cic.prop (Q_ x_154).

def And_rect_CProp3_body :
      _A : cic.Univ cic.prop ->
      _B : cic.Univ cic.prop ->
      Q_ :
        (_x_154 : cic.Term cic.prop (matita_basics_logic.And _A _B) ->
         cic.Univ cic.prop) ->
      _H_conj :
        (x_156 : cic.Term cic.prop _A ->
         x_155 : cic.Term cic.prop _B ->
         cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_156 x_155))) ->
      x_154 : cic.Term cic.prop (matita_basics_logic.And _A _B) ->
      cic.Term cic.prop (Q_ x_154).

[ _A, _B, Q_, _H_conj, x_154 ] And_rect_CProp3 _A _B Q_ _H_conj x_154 -->
  matita_basics_logic.filter_And _A _B cic.prop
    (x_154 : cic.Term cic.prop (matita_basics_logic.And _A _B) => Q_ x_154)
    (matita_basics_logic.And_rect_CProp3_body _A _B Q_ _H_conj) x_154.

[ _A, _B, Q_, _H_conj, x_154 ]
  And_rect_CProp3_body _A _B Q_ _H_conj x_154 -->
  matita_basics_logic.match_And _A _B cic.prop Q_
    (x_156 : cic.Term cic.prop _A =>
     x_155 : cic.Term cic.prop _B => _H_conj x_156 x_155)
    x_154.

def And_rect_CProp2 :
      _A : cic.Univ cic.prop ->
      _B : cic.Univ cic.prop ->
      Q_ :
        (_x_158 : cic.Term cic.prop (matita_basics_logic.And _A _B) ->
         cic.Univ cic.prop) ->
      _H_conj :
        (x_160 : cic.Term cic.prop _A ->
         x_159 : cic.Term cic.prop _B ->
         cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_160 x_159))) ->
      x_158 : cic.Term cic.prop (matita_basics_logic.And _A _B) ->
      cic.Term cic.prop (Q_ x_158).

def And_rect_CProp2_body :
      _A : cic.Univ cic.prop ->
      _B : cic.Univ cic.prop ->
      Q_ :
        (_x_158 : cic.Term cic.prop (matita_basics_logic.And _A _B) ->
         cic.Univ cic.prop) ->
      _H_conj :
        (x_160 : cic.Term cic.prop _A ->
         x_159 : cic.Term cic.prop _B ->
         cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_160 x_159))) ->
      x_158 : cic.Term cic.prop (matita_basics_logic.And _A _B) ->
      cic.Term cic.prop (Q_ x_158).

[ _A, _B, Q_, _H_conj, x_158 ] And_rect_CProp2 _A _B Q_ _H_conj x_158 -->
  matita_basics_logic.filter_And _A _B cic.prop
    (x_158 : cic.Term cic.prop (matita_basics_logic.And _A _B) => Q_ x_158)
    (matita_basics_logic.And_rect_CProp2_body _A _B Q_ _H_conj) x_158.

[ _A, _B, Q_, _H_conj, x_158 ]
  And_rect_CProp2_body _A _B Q_ _H_conj x_158 -->
  matita_basics_logic.match_And _A _B cic.prop Q_
    (x_160 : cic.Term cic.prop _A =>
     x_159 : cic.Term cic.prop _B => _H_conj x_160 x_159)
    x_158.

def And_rect_CProp1 :
      _A : cic.Univ cic.prop ->
      _B : cic.Univ cic.prop ->
      Q_ :
        (_x_162 : cic.Term cic.prop (matita_basics_logic.And _A _B) ->
         cic.Univ cic.prop) ->
      _H_conj :
        (x_164 : cic.Term cic.prop _A ->
         x_163 : cic.Term cic.prop _B ->
         cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_164 x_163))) ->
      x_162 : cic.Term cic.prop (matita_basics_logic.And _A _B) ->
      cic.Term cic.prop (Q_ x_162).

def And_rect_CProp1_body :
      _A : cic.Univ cic.prop ->
      _B : cic.Univ cic.prop ->
      Q_ :
        (_x_162 : cic.Term cic.prop (matita_basics_logic.And _A _B) ->
         cic.Univ cic.prop) ->
      _H_conj :
        (x_164 : cic.Term cic.prop _A ->
         x_163 : cic.Term cic.prop _B ->
         cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_164 x_163))) ->
      x_162 : cic.Term cic.prop (matita_basics_logic.And _A _B) ->
      cic.Term cic.prop (Q_ x_162).

[ _A, _B, Q_, _H_conj, x_162 ] And_rect_CProp1 _A _B Q_ _H_conj x_162 -->
  matita_basics_logic.filter_And _A _B cic.prop
    (x_162 : cic.Term cic.prop (matita_basics_logic.And _A _B) => Q_ x_162)
    (matita_basics_logic.And_rect_CProp1_body _A _B Q_ _H_conj) x_162.

[ _A, _B, Q_, _H_conj, x_162 ]
  And_rect_CProp1_body _A _B Q_ _H_conj x_162 -->
  matita_basics_logic.match_And _A _B cic.prop Q_
    (x_164 : cic.Term cic.prop _A =>
     x_163 : cic.Term cic.prop _B => _H_conj x_164 x_163)
    x_162.

def And_rect_CProp0 :
      _A : cic.Univ cic.prop ->
      _B : cic.Univ cic.prop ->
      Q_ :
        (_x_166 : cic.Term cic.prop (matita_basics_logic.And _A _B) ->
         cic.Univ cic.prop) ->
      _H_conj :
        (x_168 : cic.Term cic.prop _A ->
         x_167 : cic.Term cic.prop _B ->
         cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_168 x_167))) ->
      x_166 : cic.Term cic.prop (matita_basics_logic.And _A _B) ->
      cic.Term cic.prop (Q_ x_166).

def And_rect_CProp0_body :
      _A : cic.Univ cic.prop ->
      _B : cic.Univ cic.prop ->
      Q_ :
        (_x_166 : cic.Term cic.prop (matita_basics_logic.And _A _B) ->
         cic.Univ cic.prop) ->
      _H_conj :
        (x_168 : cic.Term cic.prop _A ->
         x_167 : cic.Term cic.prop _B ->
         cic.Term cic.prop (Q_ (matita_basics_logic.conj _A _B x_168 x_167))) ->
      x_166 : cic.Term cic.prop (matita_basics_logic.And _A _B) ->
      cic.Term cic.prop (Q_ x_166).

[ _A, _B, Q_, _H_conj, x_166 ] And_rect_CProp0 _A _B Q_ _H_conj x_166 -->
  matita_basics_logic.filter_And _A _B cic.prop
    (x_166 : cic.Term cic.prop (matita_basics_logic.And _A _B) => Q_ x_166)
    (matita_basics_logic.And_rect_CProp0_body _A _B Q_ _H_conj) x_166.

[ _A, _B, Q_, _H_conj, x_166 ]
  And_rect_CProp0_body _A _B Q_ _H_conj x_166 -->
  matita_basics_logic.match_And _A _B cic.prop Q_
    (x_168 : cic.Term cic.prop _A =>
     x_167 : cic.Term cic.prop _B => _H_conj x_168 x_167)
    x_166.

def And_inv_ind :
      x1 : cic.Univ cic.prop ->
      x2 : cic.Univ cic.prop ->
      Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2) ->
      P :
        (_z323 : cic.Term cic.prop (matita_basics_logic.And x1 x2) ->
         cic.Univ cic.prop) ->
      _H1 :
        (x_120 : cic.Term cic.prop x1 ->
         x_119 : cic.Term cic.prop x2 ->
         _z324 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2
                   (matita_basics_logic.And x1 x2))
                Hterm (matita_basics_logic.conj x1 x2 x_120 x_119)) ->
         cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_120 x_119))) ->
      cic.Term cic.prop (P Hterm) :=
      x1 : cic.Univ cic.prop =>
      x2 : cic.Univ cic.prop =>
      Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2) =>
      P :
        (_z323 : cic.Term cic.prop (matita_basics_logic.And x1 x2) ->
         cic.Univ cic.prop) =>
      H1 :
        (x_120 : cic.Term cic.prop x1 ->
         x_119 : cic.Term cic.prop x2 ->
         _z324 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2
                   (matita_basics_logic.And x1 x2))
                Hterm (matita_basics_logic.conj x1 x2 x_120 x_119)) ->
         cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_120 x_119))) =>
      (Hcut :
         (_z324 :
            cic.Term cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2
                    (matita_basics_logic.And x1 x2))
                 Hterm Hterm) ->
          cic.Term cic.prop (P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2))
            Hterm))
        (matita_basics_logic.And_ind x1 x2
           (_x_118 : cic.Term cic.prop (matita_basics_logic.And x1 x2) =>
            cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2
                    (matita_basics_logic.And x1 x2))
                 Hterm _x_118)
              (_z324 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop univs.Type2
                         (matita_basics_logic.And x1 x2))
                      Hterm _x_118) =>
               P _x_118))
           H1 Hterm).

def And_inv_rect_Type4 :
      x1 : cic.Univ cic.prop ->
      x2 : cic.Univ cic.prop ->
      Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2) ->
      P :
        (_z329 : cic.Term cic.prop (matita_basics_logic.And x1 x2) ->
         cic.Univ univs.Type4) ->
      _H1 :
        (x_124 : cic.Term cic.prop x1 ->
         x_123 : cic.Term cic.prop x2 ->
         _z330 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2
                   (matita_basics_logic.And x1 x2))
                Hterm (matita_basics_logic.conj x1 x2 x_124 x_123)) ->
         cic.Term univs.Type4
           (P (matita_basics_logic.conj x1 x2 x_124 x_123))) ->
      cic.Term univs.Type4 (P Hterm) :=
      x1 : cic.Univ cic.prop =>
      x2 : cic.Univ cic.prop =>
      Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2) =>
      P :
        (_z329 : cic.Term cic.prop (matita_basics_logic.And x1 x2) ->
         cic.Univ univs.Type4) =>
      H1 :
        (x_124 : cic.Term cic.prop x1 ->
         x_123 : cic.Term cic.prop x2 ->
         _z330 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2
                   (matita_basics_logic.And x1 x2))
                Hterm (matita_basics_logic.conj x1 x2 x_124 x_123)) ->
         cic.Term univs.Type4
           (P (matita_basics_logic.conj x1 x2 x_124 x_123))) =>
      (Hcut :
         (_z330 :
            cic.Term cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2
                    (matita_basics_logic.And x1 x2))
                 Hterm Hterm) ->
          cic.Term univs.Type4 (P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2))
            Hterm))
        (matita_basics_logic.And_rect_Type4 x1 x2
           (_x_122 : cic.Term cic.prop (matita_basics_logic.And x1 x2) =>
            cic.prod cic.prop univs.Type4
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2
                    (matita_basics_logic.And x1 x2))
                 Hterm _x_122)
              (_z330 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop univs.Type2
                         (matita_basics_logic.And x1 x2))
                      Hterm _x_122) =>
               P _x_122))
           H1 Hterm).

def And_inv_rect_Type3 :
      x1 : cic.Univ cic.prop ->
      x2 : cic.Univ cic.prop ->
      Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2) ->
      P :
        (_z335 : cic.Term cic.prop (matita_basics_logic.And x1 x2) ->
         cic.Univ univs.Type3) ->
      _H1 :
        (x_132 : cic.Term cic.prop x1 ->
         x_131 : cic.Term cic.prop x2 ->
         _z336 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2
                   (matita_basics_logic.And x1 x2))
                Hterm (matita_basics_logic.conj x1 x2 x_132 x_131)) ->
         cic.Term univs.Type3
           (P (matita_basics_logic.conj x1 x2 x_132 x_131))) ->
      cic.Term univs.Type3 (P Hterm) :=
      x1 : cic.Univ cic.prop =>
      x2 : cic.Univ cic.prop =>
      Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2) =>
      P :
        (_z335 : cic.Term cic.prop (matita_basics_logic.And x1 x2) ->
         cic.Univ univs.Type3) =>
      H1 :
        (x_132 : cic.Term cic.prop x1 ->
         x_131 : cic.Term cic.prop x2 ->
         _z336 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2
                   (matita_basics_logic.And x1 x2))
                Hterm (matita_basics_logic.conj x1 x2 x_132 x_131)) ->
         cic.Term univs.Type3
           (P (matita_basics_logic.conj x1 x2 x_132 x_131))) =>
      (Hcut :
         (_z336 :
            cic.Term cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2
                    (matita_basics_logic.And x1 x2))
                 Hterm Hterm) ->
          cic.Term univs.Type3 (P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2))
            Hterm))
        (matita_basics_logic.And_rect_Type3 x1 x2
           (_x_130 : cic.Term cic.prop (matita_basics_logic.And x1 x2) =>
            cic.prod cic.prop univs.Type3
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2
                    (matita_basics_logic.And x1 x2))
                 Hterm _x_130)
              (_z336 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop univs.Type2
                         (matita_basics_logic.And x1 x2))
                      Hterm _x_130) =>
               P _x_130))
           H1 Hterm).

def And_inv_rect_Type2 :
      x1 : cic.Univ cic.prop ->
      x2 : cic.Univ cic.prop ->
      Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2) ->
      P :
        (_z341 : cic.Term cic.prop (matita_basics_logic.And x1 x2) ->
         cic.Univ univs.Type2) ->
      _H1 :
        (x_136 : cic.Term cic.prop x1 ->
         x_135 : cic.Term cic.prop x2 ->
         _z342 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2
                   (matita_basics_logic.And x1 x2))
                Hterm (matita_basics_logic.conj x1 x2 x_136 x_135)) ->
         cic.Term univs.Type2
           (P (matita_basics_logic.conj x1 x2 x_136 x_135))) ->
      cic.Term univs.Type2 (P Hterm) :=
      x1 : cic.Univ cic.prop =>
      x2 : cic.Univ cic.prop =>
      Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2) =>
      P :
        (_z341 : cic.Term cic.prop (matita_basics_logic.And x1 x2) ->
         cic.Univ univs.Type2) =>
      H1 :
        (x_136 : cic.Term cic.prop x1 ->
         x_135 : cic.Term cic.prop x2 ->
         _z342 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2
                   (matita_basics_logic.And x1 x2))
                Hterm (matita_basics_logic.conj x1 x2 x_136 x_135)) ->
         cic.Term univs.Type2
           (P (matita_basics_logic.conj x1 x2 x_136 x_135))) =>
      (Hcut :
         (_z342 :
            cic.Term cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2
                    (matita_basics_logic.And x1 x2))
                 Hterm Hterm) ->
          cic.Term univs.Type2 (P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2))
            Hterm))
        (matita_basics_logic.And_rect_Type2 x1 x2
           (_x_134 : cic.Term cic.prop (matita_basics_logic.And x1 x2) =>
            cic.prod cic.prop univs.Type2
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2
                    (matita_basics_logic.And x1 x2))
                 Hterm _x_134)
              (_z342 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop univs.Type2
                         (matita_basics_logic.And x1 x2))
                      Hterm _x_134) =>
               P _x_134))
           H1 Hterm).

def And_inv_rect_Type1 :
      x1 : cic.Univ cic.prop ->
      x2 : cic.Univ cic.prop ->
      Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2) ->
      P :
        (_z347 : cic.Term cic.prop (matita_basics_logic.And x1 x2) ->
         cic.Univ univs.Type1) ->
      _H1 :
        (x_140 : cic.Term cic.prop x1 ->
         x_139 : cic.Term cic.prop x2 ->
         _z348 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2
                   (matita_basics_logic.And x1 x2))
                Hterm (matita_basics_logic.conj x1 x2 x_140 x_139)) ->
         cic.Term univs.Type1
           (P (matita_basics_logic.conj x1 x2 x_140 x_139))) ->
      cic.Term univs.Type1 (P Hterm) :=
      x1 : cic.Univ cic.prop =>
      x2 : cic.Univ cic.prop =>
      Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2) =>
      P :
        (_z347 : cic.Term cic.prop (matita_basics_logic.And x1 x2) ->
         cic.Univ univs.Type1) =>
      H1 :
        (x_140 : cic.Term cic.prop x1 ->
         x_139 : cic.Term cic.prop x2 ->
         _z348 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2
                   (matita_basics_logic.And x1 x2))
                Hterm (matita_basics_logic.conj x1 x2 x_140 x_139)) ->
         cic.Term univs.Type1
           (P (matita_basics_logic.conj x1 x2 x_140 x_139))) =>
      (Hcut :
         (_z348 :
            cic.Term cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2
                    (matita_basics_logic.And x1 x2))
                 Hterm Hterm) ->
          cic.Term univs.Type1 (P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2))
            Hterm))
        (matita_basics_logic.And_rect_Type1 x1 x2
           (_x_138 : cic.Term cic.prop (matita_basics_logic.And x1 x2) =>
            cic.prod cic.prop univs.Type1
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2
                    (matita_basics_logic.And x1 x2))
                 Hterm _x_138)
              (_z348 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop univs.Type2
                         (matita_basics_logic.And x1 x2))
                      Hterm _x_138) =>
               P _x_138))
           H1 Hterm).

def And_inv_rect_Type0 :
      x1 : cic.Univ cic.prop ->
      x2 : cic.Univ cic.prop ->
      Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2) ->
      P :
        (_z353 : cic.Term cic.prop (matita_basics_logic.And x1 x2) ->
         cic.Univ univs.Type0) ->
      _H1 :
        (x_144 : cic.Term cic.prop x1 ->
         x_143 : cic.Term cic.prop x2 ->
         _z354 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2
                   (matita_basics_logic.And x1 x2))
                Hterm (matita_basics_logic.conj x1 x2 x_144 x_143)) ->
         cic.Term univs.Type0
           (P (matita_basics_logic.conj x1 x2 x_144 x_143))) ->
      cic.Term univs.Type0 (P Hterm) :=
      x1 : cic.Univ cic.prop =>
      x2 : cic.Univ cic.prop =>
      Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2) =>
      P :
        (_z353 : cic.Term cic.prop (matita_basics_logic.And x1 x2) ->
         cic.Univ univs.Type0) =>
      H1 :
        (x_144 : cic.Term cic.prop x1 ->
         x_143 : cic.Term cic.prop x2 ->
         _z354 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2
                   (matita_basics_logic.And x1 x2))
                Hterm (matita_basics_logic.conj x1 x2 x_144 x_143)) ->
         cic.Term univs.Type0
           (P (matita_basics_logic.conj x1 x2 x_144 x_143))) =>
      (Hcut :
         (_z354 :
            cic.Term cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2
                    (matita_basics_logic.And x1 x2))
                 Hterm Hterm) ->
          cic.Term univs.Type0 (P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2))
            Hterm))
        (matita_basics_logic.And_rect_Type0 x1 x2
           (_x_142 : cic.Term cic.prop (matita_basics_logic.And x1 x2) =>
            cic.prod cic.prop univs.Type0
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2
                    (matita_basics_logic.And x1 x2))
                 Hterm _x_142)
              (_z354 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop univs.Type2
                         (matita_basics_logic.And x1 x2))
                      Hterm _x_142) =>
               P _x_142))
           H1 Hterm).

def And_inv_rect_CProp4 :
      x1 : cic.Univ cic.prop ->
      x2 : cic.Univ cic.prop ->
      Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2) ->
      P :
        (_z359 : cic.Term cic.prop (matita_basics_logic.And x1 x2) ->
         cic.Univ cic.prop) ->
      _H1 :
        (x_148 : cic.Term cic.prop x1 ->
         x_147 : cic.Term cic.prop x2 ->
         _z360 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2
                   (matita_basics_logic.And x1 x2))
                Hterm (matita_basics_logic.conj x1 x2 x_148 x_147)) ->
         cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_148 x_147))) ->
      cic.Term cic.prop (P Hterm) :=
      x1 : cic.Univ cic.prop =>
      x2 : cic.Univ cic.prop =>
      Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2) =>
      P :
        (_z359 : cic.Term cic.prop (matita_basics_logic.And x1 x2) ->
         cic.Univ cic.prop) =>
      H1 :
        (x_148 : cic.Term cic.prop x1 ->
         x_147 : cic.Term cic.prop x2 ->
         _z360 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2
                   (matita_basics_logic.And x1 x2))
                Hterm (matita_basics_logic.conj x1 x2 x_148 x_147)) ->
         cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_148 x_147))) =>
      (Hcut :
         (_z360 :
            cic.Term cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2
                    (matita_basics_logic.And x1 x2))
                 Hterm Hterm) ->
          cic.Term cic.prop (P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2))
            Hterm))
        (matita_basics_logic.And_rect_CProp4 x1 x2
           (_x_146 : cic.Term cic.prop (matita_basics_logic.And x1 x2) =>
            cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2
                    (matita_basics_logic.And x1 x2))
                 Hterm _x_146)
              (_z360 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop univs.Type2
                         (matita_basics_logic.And x1 x2))
                      Hterm _x_146) =>
               P _x_146))
           H1 Hterm).

def And_inv_rect_CProp3 :
      x1 : cic.Univ cic.prop ->
      x2 : cic.Univ cic.prop ->
      Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2) ->
      P :
        (_z365 : cic.Term cic.prop (matita_basics_logic.And x1 x2) ->
         cic.Univ cic.prop) ->
      _H1 :
        (x_156 : cic.Term cic.prop x1 ->
         x_155 : cic.Term cic.prop x2 ->
         _z366 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2
                   (matita_basics_logic.And x1 x2))
                Hterm (matita_basics_logic.conj x1 x2 x_156 x_155)) ->
         cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_156 x_155))) ->
      cic.Term cic.prop (P Hterm) :=
      x1 : cic.Univ cic.prop =>
      x2 : cic.Univ cic.prop =>
      Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2) =>
      P :
        (_z365 : cic.Term cic.prop (matita_basics_logic.And x1 x2) ->
         cic.Univ cic.prop) =>
      H1 :
        (x_156 : cic.Term cic.prop x1 ->
         x_155 : cic.Term cic.prop x2 ->
         _z366 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2
                   (matita_basics_logic.And x1 x2))
                Hterm (matita_basics_logic.conj x1 x2 x_156 x_155)) ->
         cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_156 x_155))) =>
      (Hcut :
         (_z366 :
            cic.Term cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2
                    (matita_basics_logic.And x1 x2))
                 Hterm Hterm) ->
          cic.Term cic.prop (P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2))
            Hterm))
        (matita_basics_logic.And_rect_CProp3 x1 x2
           (_x_154 : cic.Term cic.prop (matita_basics_logic.And x1 x2) =>
            cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2
                    (matita_basics_logic.And x1 x2))
                 Hterm _x_154)
              (_z366 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop univs.Type2
                         (matita_basics_logic.And x1 x2))
                      Hterm _x_154) =>
               P _x_154))
           H1 Hterm).

def And_inv_rect_CProp2 :
      x1 : cic.Univ cic.prop ->
      x2 : cic.Univ cic.prop ->
      Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2) ->
      P :
        (_z371 : cic.Term cic.prop (matita_basics_logic.And x1 x2) ->
         cic.Univ cic.prop) ->
      _H1 :
        (x_160 : cic.Term cic.prop x1 ->
         x_159 : cic.Term cic.prop x2 ->
         _z372 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2
                   (matita_basics_logic.And x1 x2))
                Hterm (matita_basics_logic.conj x1 x2 x_160 x_159)) ->
         cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_160 x_159))) ->
      cic.Term cic.prop (P Hterm) :=
      x1 : cic.Univ cic.prop =>
      x2 : cic.Univ cic.prop =>
      Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2) =>
      P :
        (_z371 : cic.Term cic.prop (matita_basics_logic.And x1 x2) ->
         cic.Univ cic.prop) =>
      H1 :
        (x_160 : cic.Term cic.prop x1 ->
         x_159 : cic.Term cic.prop x2 ->
         _z372 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2
                   (matita_basics_logic.And x1 x2))
                Hterm (matita_basics_logic.conj x1 x2 x_160 x_159)) ->
         cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_160 x_159))) =>
      (Hcut :
         (_z372 :
            cic.Term cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2
                    (matita_basics_logic.And x1 x2))
                 Hterm Hterm) ->
          cic.Term cic.prop (P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2))
            Hterm))
        (matita_basics_logic.And_rect_CProp2 x1 x2
           (_x_158 : cic.Term cic.prop (matita_basics_logic.And x1 x2) =>
            cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2
                    (matita_basics_logic.And x1 x2))
                 Hterm _x_158)
              (_z372 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop univs.Type2
                         (matita_basics_logic.And x1 x2))
                      Hterm _x_158) =>
               P _x_158))
           H1 Hterm).

def And_inv_rect_CProp1 :
      x1 : cic.Univ cic.prop ->
      x2 : cic.Univ cic.prop ->
      Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2) ->
      P :
        (_z377 : cic.Term cic.prop (matita_basics_logic.And x1 x2) ->
         cic.Univ cic.prop) ->
      _H1 :
        (x_164 : cic.Term cic.prop x1 ->
         x_163 : cic.Term cic.prop x2 ->
         _z378 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2
                   (matita_basics_logic.And x1 x2))
                Hterm (matita_basics_logic.conj x1 x2 x_164 x_163)) ->
         cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_164 x_163))) ->
      cic.Term cic.prop (P Hterm) :=
      x1 : cic.Univ cic.prop =>
      x2 : cic.Univ cic.prop =>
      Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2) =>
      P :
        (_z377 : cic.Term cic.prop (matita_basics_logic.And x1 x2) ->
         cic.Univ cic.prop) =>
      H1 :
        (x_164 : cic.Term cic.prop x1 ->
         x_163 : cic.Term cic.prop x2 ->
         _z378 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2
                   (matita_basics_logic.And x1 x2))
                Hterm (matita_basics_logic.conj x1 x2 x_164 x_163)) ->
         cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_164 x_163))) =>
      (Hcut :
         (_z378 :
            cic.Term cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2
                    (matita_basics_logic.And x1 x2))
                 Hterm Hterm) ->
          cic.Term cic.prop (P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2))
            Hterm))
        (matita_basics_logic.And_rect_CProp1 x1 x2
           (_x_162 : cic.Term cic.prop (matita_basics_logic.And x1 x2) =>
            cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2
                    (matita_basics_logic.And x1 x2))
                 Hterm _x_162)
              (_z378 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop univs.Type2
                         (matita_basics_logic.And x1 x2))
                      Hterm _x_162) =>
               P _x_162))
           H1 Hterm).

def And_inv_rect_CProp0 :
      x1 : cic.Univ cic.prop ->
      x2 : cic.Univ cic.prop ->
      Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2) ->
      P :
        (_z383 : cic.Term cic.prop (matita_basics_logic.And x1 x2) ->
         cic.Univ cic.prop) ->
      _H1 :
        (x_168 : cic.Term cic.prop x1 ->
         x_167 : cic.Term cic.prop x2 ->
         _z384 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2
                   (matita_basics_logic.And x1 x2))
                Hterm (matita_basics_logic.conj x1 x2 x_168 x_167)) ->
         cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_168 x_167))) ->
      cic.Term cic.prop (P Hterm) :=
      x1 : cic.Univ cic.prop =>
      x2 : cic.Univ cic.prop =>
      Hterm : cic.Term cic.prop (matita_basics_logic.And x1 x2) =>
      P :
        (_z383 : cic.Term cic.prop (matita_basics_logic.And x1 x2) ->
         cic.Univ cic.prop) =>
      H1 :
        (x_168 : cic.Term cic.prop x1 ->
         x_167 : cic.Term cic.prop x2 ->
         _z384 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2
                   (matita_basics_logic.And x1 x2))
                Hterm (matita_basics_logic.conj x1 x2 x_168 x_167)) ->
         cic.Term cic.prop (P (matita_basics_logic.conj x1 x2 x_168 x_167))) =>
      (Hcut :
         (_z384 :
            cic.Term cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2
                    (matita_basics_logic.And x1 x2))
                 Hterm Hterm) ->
          cic.Term cic.prop (P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop univs.Type2 (matita_basics_logic.And x1 x2))
            Hterm))
        (matita_basics_logic.And_rect_CProp0 x1 x2
           (_x_166 : cic.Term cic.prop (matita_basics_logic.And x1 x2) =>
            cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2
                    (matita_basics_logic.And x1 x2))
                 Hterm _x_166)
              (_z384 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop univs.Type2
                         (matita_basics_logic.And x1 x2))
                      Hterm _x_166) =>
               P _x_166))
           H1 Hterm).

def proj1 :
      A : cic.Univ cic.prop ->
      B : cic.Univ cic.prop ->
      __ : cic.Term cic.prop (matita_basics_logic.And A B) ->
      cic.Term cic.prop A :=
      A : cic.Univ cic.prop =>
      B : cic.Univ cic.prop =>
      AB : cic.Term cic.prop (matita_basics_logic.And A B) =>
      matita_basics_logic.And_ind A B
        (_x_118 : cic.Term cic.prop (matita_basics_logic.And A B) => A)
        (_x_120 : cic.Term cic.prop A =>
         _x_119 : cic.Term cic.prop B => _x_120)
        AB.

def proj2 :
      A : cic.Univ cic.prop ->
      B : cic.Univ cic.prop ->
      __ : cic.Term cic.prop (matita_basics_logic.And A B) ->
      cic.Term cic.prop B :=
      A : cic.Univ cic.prop =>
      B : cic.Univ cic.prop =>
      AB : cic.Term cic.prop (matita_basics_logic.And A B) =>
      matita_basics_logic.And_ind A B
        (_x_118 : cic.Term cic.prop (matita_basics_logic.And A B) => B)
        (_x_120 : cic.Term cic.prop A =>
         _x_119 : cic.Term cic.prop B => _x_119)
        AB.

Or : _A : cic.Univ cic.prop -> _B : cic.Univ cic.prop -> cic.Univ cic.prop.

or_introl :
  A : cic.Univ cic.prop ->
  B : cic.Univ cic.prop ->
  __ : cic.Term cic.prop A -> cic.Term cic.prop (matita_basics_logic.Or A B).

or_intror :
  A : cic.Univ cic.prop ->
  B : cic.Univ cic.prop ->
  __ : cic.Term cic.prop B -> cic.Term cic.prop (matita_basics_logic.Or A B).

def match_Or :
      _A : cic.Univ cic.prop ->
      _B : cic.Univ cic.prop ->
      return_sort : cic.Sort ->
      return_type :
        (z : cic.Term cic.prop (matita_basics_logic.Or _A _B) ->
         cic.Univ return_sort) ->
      case_or_introl :
        (__ : cic.Term cic.prop _A ->
         cic.Term return_sort
           (return_type (matita_basics_logic.or_introl _A _B __))) ->
      case_or_intror :
        (__ : cic.Term cic.prop _B ->
         cic.Term return_sort
           (return_type (matita_basics_logic.or_intror _A _B __))) ->
      z : cic.Term cic.prop (matita_basics_logic.Or _A _B) ->
      cic.Term return_sort (return_type z).

[ _A, _B, return_sort, return_type, case_or_introl, case_or_intror, __ ]
  match_Or _A _B return_sort return_type case_or_introl case_or_intror
    (matita_basics_logic.or_introl _A _B __) -->
  case_or_introl __.

[ _A, _B, return_sort, return_type, case_or_introl, case_or_intror, __ ]
  match_Or _A _B return_sort return_type case_or_introl case_or_intror
    (matita_basics_logic.or_intror _A _B __) -->
  case_or_intror __.

def filter_Or :
      _A : cic.Univ cic.prop ->
      _B : cic.Univ cic.prop ->
      return_sort : cic.Sort ->
      return_type :
        (z : cic.Term cic.prop (matita_basics_logic.Or _A _B) ->
         cic.Univ return_sort) ->
      return :
        (z : cic.Term cic.prop (matita_basics_logic.Or _A _B) ->
         cic.Term return_sort (return_type z)) ->
      z : cic.Term cic.prop (matita_basics_logic.Or _A _B) ->
      cic.Term return_sort (return_type z).

[ A, B, __, return_sort, return_type, return ]
  filter_Or (A) (B) return_sort return_type return
    (matita_basics_logic.or_introl A B __) -->
  return (matita_basics_logic.or_introl A B __).

[ A, B, __, return_sort, return_type, return ]
  filter_Or (A) (B) return_sort return_type return
    (matita_basics_logic.or_intror A B __) -->
  return (matita_basics_logic.or_intror A B __).

def Or_ind :
      _A : cic.Univ cic.prop ->
      _B : cic.Univ cic.prop ->
      Q_ :
        (_x_170 : cic.Term cic.prop (matita_basics_logic.Or _A _B) ->
         cic.Univ cic.prop) ->
      _H_or_introl :
        (x_171 : cic.Term cic.prop _A ->
         cic.Term cic.prop (Q_ (matita_basics_logic.or_introl _A _B x_171))) ->
      _H_or_intror :
        (x_172 : cic.Term cic.prop _B ->
         cic.Term cic.prop (Q_ (matita_basics_logic.or_intror _A _B x_172))) ->
      x_170 : cic.Term cic.prop (matita_basics_logic.Or _A _B) ->
      cic.Term cic.prop (Q_ x_170).

def Or_ind_body :
      _A : cic.Univ cic.prop ->
      _B : cic.Univ cic.prop ->
      Q_ :
        (_x_170 : cic.Term cic.prop (matita_basics_logic.Or _A _B) ->
         cic.Univ cic.prop) ->
      _H_or_introl :
        (x_171 : cic.Term cic.prop _A ->
         cic.Term cic.prop (Q_ (matita_basics_logic.or_introl _A _B x_171))) ->
      _H_or_intror :
        (x_172 : cic.Term cic.prop _B ->
         cic.Term cic.prop (Q_ (matita_basics_logic.or_intror _A _B x_172))) ->
      x_170 : cic.Term cic.prop (matita_basics_logic.Or _A _B) ->
      cic.Term cic.prop (Q_ x_170).

[ _A, _B, Q_, _H_or_introl, _H_or_intror, x_170 ]
  Or_ind _A _B Q_ _H_or_introl _H_or_intror x_170 -->
  matita_basics_logic.filter_Or _A _B cic.prop
    (x_170 : cic.Term cic.prop (matita_basics_logic.Or _A _B) => Q_ x_170)
    (matita_basics_logic.Or_ind_body _A _B Q_ _H_or_introl _H_or_intror)
    x_170.

[ _A, _B, Q_, _H_or_introl, _H_or_intror, x_170 ]
  Or_ind_body _A _B Q_ _H_or_introl _H_or_intror x_170 -->
  matita_basics_logic.match_Or _A _B cic.prop Q_
    (x_171 : cic.Term cic.prop _A => _H_or_introl x_171)
    (x_172 : cic.Term cic.prop _B => _H_or_intror x_172) x_170.

def Or_inv_ind :
      x1 : cic.Univ cic.prop ->
      x2 : cic.Univ cic.prop ->
      Hterm : cic.Term cic.prop (matita_basics_logic.Or x1 x2) ->
      P :
        (_z389 : cic.Term cic.prop (matita_basics_logic.Or x1 x2) ->
         cic.Univ cic.prop) ->
      _H1 :
        (x_171 : cic.Term cic.prop x1 ->
         _z390 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2 (matita_basics_logic.Or x1 x2))
                Hterm (matita_basics_logic.or_introl x1 x2 x_171)) ->
         cic.Term cic.prop (P (matita_basics_logic.or_introl x1 x2 x_171))) ->
      _H2 :
        (x_172 : cic.Term cic.prop x2 ->
         _z390 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2 (matita_basics_logic.Or x1 x2))
                Hterm (matita_basics_logic.or_intror x1 x2 x_172)) ->
         cic.Term cic.prop (P (matita_basics_logic.or_intror x1 x2 x_172))) ->
      cic.Term cic.prop (P Hterm) :=
      x1 : cic.Univ cic.prop =>
      x2 : cic.Univ cic.prop =>
      Hterm : cic.Term cic.prop (matita_basics_logic.Or x1 x2) =>
      P :
        (_z389 : cic.Term cic.prop (matita_basics_logic.Or x1 x2) ->
         cic.Univ cic.prop) =>
      H1 :
        (x_171 : cic.Term cic.prop x1 ->
         _z390 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2 (matita_basics_logic.Or x1 x2))
                Hterm (matita_basics_logic.or_introl x1 x2 x_171)) ->
         cic.Term cic.prop (P (matita_basics_logic.or_introl x1 x2 x_171))) =>
      H2 :
        (x_172 : cic.Term cic.prop x2 ->
         _z390 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2 (matita_basics_logic.Or x1 x2))
                Hterm (matita_basics_logic.or_intror x1 x2 x_172)) ->
         cic.Term cic.prop (P (matita_basics_logic.or_intror x1 x2 x_172))) =>
      (Hcut :
         (_z390 :
            cic.Term cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2
                    (matita_basics_logic.Or x1 x2))
                 Hterm Hterm) ->
          cic.Term cic.prop (P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop univs.Type2 (matita_basics_logic.Or x1 x2))
            Hterm))
        (matita_basics_logic.Or_ind x1 x2
           (_x_170 : cic.Term cic.prop (matita_basics_logic.Or x1 x2) =>
            cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2
                    (matita_basics_logic.Or x1 x2))
                 Hterm _x_170)
              (_z390 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop univs.Type2
                         (matita_basics_logic.Or x1 x2))
                      Hterm _x_170) =>
               P _x_170))
           H1 H2 Hterm).

def decidable : __ : cic.Univ cic.prop -> cic.Univ cic.prop :=
      A : cic.Univ cic.prop =>
      matita_basics_logic.Or A (matita_basics_logic.Not A).

ex :
  A : cic.Univ univs.Type0 ->
  _P : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) ->
  cic.Univ cic.prop.

ex_intro :
  A : cic.Univ univs.Type0 ->
  P : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) ->
  x : cic.Term univs.Type0 A ->
  __ : cic.Term cic.prop (P x) ->
  cic.Term cic.prop (matita_basics_logic.ex A P).

def match_ex :
      A : cic.Univ univs.Type0 ->
      _P : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) ->
      return_sort : cic.Sort ->
      return_type :
        (z : cic.Term cic.prop (matita_basics_logic.ex A _P) ->
         cic.Univ return_sort) ->
      case_ex_intro :
        (x : cic.Term univs.Type0 A ->
         __ : cic.Term cic.prop (_P x) ->
         cic.Term return_sort
           (return_type (matita_basics_logic.ex_intro A _P x __))) ->
      z : cic.Term cic.prop (matita_basics_logic.ex A _P) ->
      cic.Term return_sort (return_type z).

[ A, _P, return_sort, return_type, case_ex_intro, x, __ ]
  match_ex A _P return_sort return_type case_ex_intro
    (matita_basics_logic.ex_intro A _P x __) -->
  case_ex_intro x __.

def filter_ex :
      A : cic.Univ univs.Type0 ->
      _P : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) ->
      return_sort : cic.Sort ->
      return_type :
        (z : cic.Term cic.prop (matita_basics_logic.ex A _P) ->
         cic.Univ return_sort) ->
      return :
        (z : cic.Term cic.prop (matita_basics_logic.ex A _P) ->
         cic.Term return_sort (return_type z)) ->
      z : cic.Term cic.prop (matita_basics_logic.ex A _P) ->
      cic.Term return_sort (return_type z).

[ A, P, x, __, return_sort, return_type, return ]
  filter_ex (A) (P) return_sort return_type return
    (matita_basics_logic.ex_intro A P x __) -->
  return (matita_basics_logic.ex_intro A P x __).

def ex_ind :
      A : cic.Univ univs.Type0 ->
      _P : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) ->
      Q_ :
        (_x_235 : cic.Term cic.prop (matita_basics_logic.ex A _P) ->
         cic.Univ cic.prop) ->
      _H_ex_intro :
        (x : cic.Term univs.Type0 A ->
         x_236 : cic.Term cic.prop (_P x) ->
         cic.Term cic.prop (Q_ (matita_basics_logic.ex_intro A _P x x_236))) ->
      x_235 : cic.Term cic.prop (matita_basics_logic.ex A _P) ->
      cic.Term cic.prop (Q_ x_235).

def ex_ind_body :
      A : cic.Univ univs.Type0 ->
      _P : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) ->
      Q_ :
        (_x_235 : cic.Term cic.prop (matita_basics_logic.ex A _P) ->
         cic.Univ cic.prop) ->
      _H_ex_intro :
        (x : cic.Term univs.Type0 A ->
         x_236 : cic.Term cic.prop (_P x) ->
         cic.Term cic.prop (Q_ (matita_basics_logic.ex_intro A _P x x_236))) ->
      x_235 : cic.Term cic.prop (matita_basics_logic.ex A _P) ->
      cic.Term cic.prop (Q_ x_235).

[ A, _P, Q_, _H_ex_intro, x_235 ] ex_ind A _P Q_ _H_ex_intro x_235 -->
  matita_basics_logic.filter_ex A _P cic.prop
    (x_235 : cic.Term cic.prop (matita_basics_logic.ex A _P) => Q_ x_235)
    (matita_basics_logic.ex_ind_body A _P Q_ _H_ex_intro) x_235.

[ A, _P, Q_, _H_ex_intro, x_235 ] ex_ind_body A _P Q_ _H_ex_intro x_235 -->
  matita_basics_logic.match_ex A _P cic.prop Q_
    (x : cic.Term univs.Type0 A =>
     x_236 : cic.Term cic.prop (_P x) => _H_ex_intro x x_236)
    x_235.

def ex_inv_ind :
      x1 : cic.Univ univs.Type0 ->
      x2 : (__ : cic.Term univs.Type0 x1 -> cic.Univ cic.prop) ->
      Hterm : cic.Term cic.prop (matita_basics_logic.ex x1 x2) ->
      P :
        (_z455 : cic.Term cic.prop (matita_basics_logic.ex x1 x2) ->
         cic.Univ cic.prop) ->
      _H1 :
        (x : cic.Term univs.Type0 x1 ->
         x_236 : cic.Term cic.prop (x2 x) ->
         _z456 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2 (matita_basics_logic.ex x1 x2))
                Hterm (matita_basics_logic.ex_intro x1 x2 x x_236)) ->
         cic.Term cic.prop (P (matita_basics_logic.ex_intro x1 x2 x x_236))) ->
      cic.Term cic.prop (P Hterm) :=
      x1 : cic.Univ univs.Type0 =>
      x2 : (__ : cic.Term univs.Type0 x1 -> cic.Univ cic.prop) =>
      Hterm : cic.Term cic.prop (matita_basics_logic.ex x1 x2) =>
      P :
        (_z455 : cic.Term cic.prop (matita_basics_logic.ex x1 x2) ->
         cic.Univ cic.prop) =>
      H1 :
        (x : cic.Term univs.Type0 x1 ->
         x_236 : cic.Term cic.prop (x2 x) ->
         _z456 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2 (matita_basics_logic.ex x1 x2))
                Hterm (matita_basics_logic.ex_intro x1 x2 x x_236)) ->
         cic.Term cic.prop (P (matita_basics_logic.ex_intro x1 x2 x x_236))) =>
      (Hcut :
         (_z456 :
            cic.Term cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2
                    (matita_basics_logic.ex x1 x2))
                 Hterm Hterm) ->
          cic.Term cic.prop (P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop univs.Type2 (matita_basics_logic.ex x1 x2))
            Hterm))
        (matita_basics_logic.ex_ind x1 x2
           (_x_235 : cic.Term cic.prop (matita_basics_logic.ex x1 x2) =>
            cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2
                    (matita_basics_logic.ex x1 x2))
                 Hterm _x_235)
              (_z456 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop univs.Type2
                         (matita_basics_logic.ex x1 x2))
                      Hterm _x_235) =>
               P _x_235))
           H1 Hterm).

ex2 :
  A : cic.Univ univs.Type0 ->
  _P : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) ->
  _Q : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) ->
  cic.Univ cic.prop.

ex2_intro :
  A : cic.Univ univs.Type0 ->
  P : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) ->
  Q : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) ->
  x : cic.Term univs.Type0 A ->
  __ : cic.Term cic.prop (P x) ->
  __1 : cic.Term cic.prop (Q x) ->
  cic.Term cic.prop (matita_basics_logic.ex2 A P Q).

def match_ex2 :
      A : cic.Univ univs.Type0 ->
      _P : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) ->
      _Q : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) ->
      return_sort : cic.Sort ->
      return_type :
        (z : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q) ->
         cic.Univ return_sort) ->
      case_ex2_intro :
        (x : cic.Term univs.Type0 A ->
         __ : cic.Term cic.prop (_P x) ->
         __1 : cic.Term cic.prop (_Q x) ->
         cic.Term return_sort
           (return_type (matita_basics_logic.ex2_intro A _P _Q x __ __1))) ->
      z : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q) ->
      cic.Term return_sort (return_type z).

[ A, _P, _Q, return_sort, return_type, case_ex2_intro, x, __, __1 ]
  match_ex2 A _P _Q return_sort return_type case_ex2_intro
    (matita_basics_logic.ex2_intro A _P _Q x __ __1) -->
  case_ex2_intro x __ __1.

def filter_ex2 :
      A : cic.Univ univs.Type0 ->
      _P : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) ->
      _Q : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) ->
      return_sort : cic.Sort ->
      return_type :
        (z : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q) ->
         cic.Univ return_sort) ->
      return :
        (z : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q) ->
         cic.Term return_sort (return_type z)) ->
      z : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q) ->
      cic.Term return_sort (return_type z).

[ A, P, Q, x, __, __1, return_sort, return_type, return ]
  filter_ex2 (A) (P) (Q) return_sort return_type return
    (matita_basics_logic.ex2_intro A P Q x __ __1) -->
  return (matita_basics_logic.ex2_intro A P Q x __ __1).

def ex2_ind :
      A : cic.Univ univs.Type0 ->
      _P : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) ->
      _Q : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) ->
      Q_ :
        (_x_274 : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q) ->
         cic.Univ cic.prop) ->
      _H_ex2_intro :
        (x : cic.Term univs.Type0 A ->
         x_276 : cic.Term cic.prop (_P x) ->
         x_275 : cic.Term cic.prop (_Q x) ->
         cic.Term cic.prop
           (Q_ (matita_basics_logic.ex2_intro A _P _Q x x_276 x_275))) ->
      x_274 : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q) ->
      cic.Term cic.prop (Q_ x_274).

def ex2_ind_body :
      A : cic.Univ univs.Type0 ->
      _P : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) ->
      _Q : (__ : cic.Term univs.Type0 A -> cic.Univ cic.prop) ->
      Q_ :
        (_x_274 : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q) ->
         cic.Univ cic.prop) ->
      _H_ex2_intro :
        (x : cic.Term univs.Type0 A ->
         x_276 : cic.Term cic.prop (_P x) ->
         x_275 : cic.Term cic.prop (_Q x) ->
         cic.Term cic.prop
           (Q_ (matita_basics_logic.ex2_intro A _P _Q x x_276 x_275))) ->
      x_274 : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q) ->
      cic.Term cic.prop (Q_ x_274).

[ A, _P, _Q, Q_, _H_ex2_intro, x_274 ]
  ex2_ind A _P _Q Q_ _H_ex2_intro x_274 -->
  matita_basics_logic.filter_ex2 A _P _Q cic.prop
    (x_274 : cic.Term cic.prop (matita_basics_logic.ex2 A _P _Q) => Q_ x_274)
    (matita_basics_logic.ex2_ind_body A _P _Q Q_ _H_ex2_intro) x_274.

[ A, _P, _Q, Q_, _H_ex2_intro, x_274 ]
  ex2_ind_body A _P _Q Q_ _H_ex2_intro x_274 -->
  matita_basics_logic.match_ex2 A _P _Q cic.prop Q_
    (x : cic.Term univs.Type0 A =>
     x_276 : cic.Term cic.prop (_P x) =>
     x_275 : cic.Term cic.prop (_Q x) => _H_ex2_intro x x_276 x_275)
    x_274.

def ex2_inv_ind :
      x1 : cic.Univ univs.Type0 ->
      x2 : (__ : cic.Term univs.Type0 x1 -> cic.Univ cic.prop) ->
      x3 : (__ : cic.Term univs.Type0 x1 -> cic.Univ cic.prop) ->
      Hterm : cic.Term cic.prop (matita_basics_logic.ex2 x1 x2 x3) ->
      P :
        (_z521 : cic.Term cic.prop (matita_basics_logic.ex2 x1 x2 x3) ->
         cic.Univ cic.prop) ->
      _H1 :
        (x : cic.Term univs.Type0 x1 ->
         x_276 : cic.Term cic.prop (x2 x) ->
         x_275 : cic.Term cic.prop (x3 x) ->
         _z522 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2
                   (matita_basics_logic.ex2 x1 x2 x3))
                Hterm (matita_basics_logic.ex2_intro x1 x2 x3 x x_276 x_275)) ->
         cic.Term cic.prop
           (P (matita_basics_logic.ex2_intro x1 x2 x3 x x_276 x_275))) ->
      cic.Term cic.prop (P Hterm) :=
      x1 : cic.Univ univs.Type0 =>
      x2 : (__ : cic.Term univs.Type0 x1 -> cic.Univ cic.prop) =>
      x3 : (__ : cic.Term univs.Type0 x1 -> cic.Univ cic.prop) =>
      Hterm : cic.Term cic.prop (matita_basics_logic.ex2 x1 x2 x3) =>
      P :
        (_z521 : cic.Term cic.prop (matita_basics_logic.ex2 x1 x2 x3) ->
         cic.Univ cic.prop) =>
      H1 :
        (x : cic.Term univs.Type0 x1 ->
         x_276 : cic.Term cic.prop (x2 x) ->
         x_275 : cic.Term cic.prop (x3 x) ->
         _z522 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift cic.prop univs.Type2
                   (matita_basics_logic.ex2 x1 x2 x3))
                Hterm (matita_basics_logic.ex2_intro x1 x2 x3 x x_276 x_275)) ->
         cic.Term cic.prop
           (P (matita_basics_logic.ex2_intro x1 x2 x3 x x_276 x_275))) =>
      (Hcut :
         (_z522 :
            cic.Term cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2
                    (matita_basics_logic.ex2 x1 x2 x3))
                 Hterm Hterm) ->
          cic.Term cic.prop (P Hterm)) =>
       Hcut
         (matita_basics_logic.refl
            (cic.lift cic.prop univs.Type2 (matita_basics_logic.ex2 x1 x2 x3))
            Hterm))
        (matita_basics_logic.ex2_ind x1 x2 x3
           (_x_274 : cic.Term cic.prop (matita_basics_logic.ex2 x1 x2 x3) =>
            cic.prod cic.prop cic.prop
              (matita_basics_logic.eq
                 (cic.lift cic.prop univs.Type2
                    (matita_basics_logic.ex2 x1 x2 x3))
                 Hterm _x_274)
              (_z522 :
                 cic.Term cic.prop
                   (matita_basics_logic.eq
                      (cic.lift cic.prop univs.Type2
                         (matita_basics_logic.ex2 x1 x2 x3))
                      Hterm _x_274) =>
               P _x_274))
           H1 Hterm).

def ex2_commute :
      A0 : cic.Univ univs.Type0 ->
      P0 : (__ : cic.Term univs.Type0 A0 -> cic.Univ cic.prop) ->
      P1 : (__ : cic.Term univs.Type0 A0 -> cic.Univ cic.prop) ->
      __ :
        cic.Term cic.prop
          (matita_basics_logic.ex2 A0 (x0 : cic.Term univs.Type0 A0 => P0 x0)
             (x0 : cic.Term univs.Type0 A0 => P1 x0)) ->
      cic.Term cic.prop
        (matita_basics_logic.ex2 A0 (x0 : cic.Term univs.Type0 A0 => P1 x0)
           (x0 : cic.Term univs.Type0 A0 => P0 x0))
      :=
      A0 : cic.Univ univs.Type0 =>
      P0 : (__ : cic.Term univs.Type0 A0 -> cic.Univ cic.prop) =>
      P1 : (__ : cic.Term univs.Type0 A0 -> cic.Univ cic.prop) =>
      _clearme :
        cic.Term cic.prop
          (matita_basics_logic.ex2 A0 (x0 : cic.Term univs.Type0 A0 => P0 x0)
             (x0 : cic.Term univs.Type0 A0 => P1 x0)) =>
      matita_basics_logic.match_ex2 A0
        (x0 : cic.Term univs.Type0 A0 => P0 x0)
        (x0 : cic.Term univs.Type0 A0 => P1 x0) cic.prop
        (__ :
           cic.Term cic.prop
             (matita_basics_logic.ex2 A0
                (x0 : cic.Term univs.Type0 A0 => P0 x0)
                (x0 : cic.Term univs.Type0 A0 => P1 x0)) =>
         matita_basics_logic.ex2 A0 (x0 : cic.Term univs.Type0 A0 => P1 x0)
           (x0 : cic.Term univs.Type0 A0 => P0 x0))
        (x : cic.Term univs.Type0 A0 =>
         auto : cic.Term cic.prop (P0 x) =>
         auto' : cic.Term cic.prop (P1 x) =>
         matita_basics_logic.ex2_intro A0
           (x0 : cic.Term univs.Type0 A0 => P1 x0)
           (x0 : cic.Term univs.Type0 A0 => P0 x0) x auto' auto)
        _clearme.

def iff :
      _A : cic.Univ cic.prop -> _B : cic.Univ cic.prop -> cic.Univ cic.prop
      :=
      A : cic.Univ cic.prop =>
      B : cic.Univ cic.prop =>
      matita_basics_logic.And
        (cic.prod cic.prop cic.prop A (__ : cic.Term cic.prop A => B))
        (cic.prod cic.prop cic.prop B (__ : cic.Term cic.prop B => A)).

def iff_sym :
      A : cic.Univ cic.prop ->
      B : cic.Univ cic.prop ->
      __ : cic.Term cic.prop (matita_basics_logic.iff A B) ->
      cic.Term cic.prop (matita_basics_logic.iff B A) :=
      A : cic.Univ cic.prop =>
      B : cic.Univ cic.prop =>
      _clearme : cic.Term cic.prop (matita_basics_logic.iff A B) =>
      matita_basics_logic.match_And
        (cic.prod cic.prop cic.prop A (__ : cic.Term cic.prop A => B))
        (cic.prod cic.prop cic.prop B (__ : cic.Term cic.prop B => A))
        cic.prop
        (__ :
           cic.Term cic.prop
             (matita_basics_logic.And
                (cic.prod cic.prop cic.prop A (__ : cic.Term cic.prop A => B))
                (cic.prod cic.prop cic.prop B (__ : cic.Term cic.prop B => A))) =>
         matita_basics_logic.iff B A)
        (auto : (__ : cic.Term cic.prop A -> cic.Term cic.prop B) =>
         auto' : (__ : cic.Term cic.prop B -> cic.Term cic.prop A) =>
         matita_basics_logic.conj
           (cic.prod cic.prop cic.prop B (__ : cic.Term cic.prop B => A))
           (cic.prod cic.prop cic.prop A (__ : cic.Term cic.prop A => B))
           (auto'' : cic.Term cic.prop B => auto' auto'')
           (auto'' : cic.Term cic.prop A => auto auto''))
        _clearme.

def iff_trans :
      A : cic.Univ cic.prop ->
      B : cic.Univ cic.prop ->
      C : cic.Univ cic.prop ->
      __ : cic.Term cic.prop (matita_basics_logic.iff A B) ->
      __1 : cic.Term cic.prop (matita_basics_logic.iff B C) ->
      cic.Term cic.prop (matita_basics_logic.iff A C) :=
      A : cic.Univ cic.prop =>
      B : cic.Univ cic.prop =>
      C : cic.Univ cic.prop =>
      _clearme : cic.Term cic.prop (matita_basics_logic.iff A B) =>
      matita_basics_logic.match_And
        (cic.prod cic.prop cic.prop A (__ : cic.Term cic.prop A => B))
        (cic.prod cic.prop cic.prop B (__ : cic.Term cic.prop B => A))
        cic.prop
        (__ :
           cic.Term cic.prop
             (matita_basics_logic.And
                (cic.prod cic.prop cic.prop A (__ : cic.Term cic.prop A => B))
                (cic.prod cic.prop cic.prop B (__ : cic.Term cic.prop B => A))) =>
         cic.prod cic.prop cic.prop (matita_basics_logic.iff B C)
           (__1 : cic.Term cic.prop (matita_basics_logic.iff B C) =>
            matita_basics_logic.iff A C))
        (H1 : (__ : cic.Term cic.prop A -> cic.Term cic.prop B) =>
         H2 : (__ : cic.Term cic.prop B -> cic.Term cic.prop A) =>
         _clearme0 : cic.Term cic.prop (matita_basics_logic.iff B C) =>
         matita_basics_logic.match_And
           (cic.prod cic.prop cic.prop B (__ : cic.Term cic.prop B => C))
           (cic.prod cic.prop cic.prop C (__ : cic.Term cic.prop C => B))
           cic.prop
           (__ :
              cic.Term cic.prop
                (matita_basics_logic.And
                   (cic.prod cic.prop cic.prop B
                      (__ : cic.Term cic.prop B => C))
                   (cic.prod cic.prop cic.prop C
                      (__ : cic.Term cic.prop C => B))) =>
            matita_basics_logic.iff A C)
           (H3 : (__ : cic.Term cic.prop B -> cic.Term cic.prop C) =>
            H4 : (__ : cic.Term cic.prop C -> cic.Term cic.prop B) =>
            matita_basics_logic.conj
              (cic.prod cic.prop cic.prop A (__ : cic.Term cic.prop A => C))
              (cic.prod cic.prop cic.prop C (__ : cic.Term cic.prop C => A))
              (auto : cic.Term cic.prop A => H3 (H1 auto))
              (auto : cic.Term cic.prop C => H2 (H4 auto)))
           _clearme0)
        _clearme.

def iff_not :
      A : cic.Univ cic.prop ->
      B : cic.Univ cic.prop ->
      __ : cic.Term cic.prop (matita_basics_logic.iff A B) ->
      cic.Term cic.prop
        (matita_basics_logic.iff (matita_basics_logic.Not A)
           (matita_basics_logic.Not B))
      :=
      A : cic.Univ cic.prop =>
      B : cic.Univ cic.prop =>
      _clearme : cic.Term cic.prop (matita_basics_logic.iff A B) =>
      matita_basics_logic.match_And
        (cic.prod cic.prop cic.prop A (__ : cic.Term cic.prop A => B))
        (cic.prod cic.prop cic.prop B (__ : cic.Term cic.prop B => A))
        cic.prop
        (__ :
           cic.Term cic.prop
             (matita_basics_logic.And
                (cic.prod cic.prop cic.prop A (__ : cic.Term cic.prop A => B))
                (cic.prod cic.prop cic.prop B (__ : cic.Term cic.prop B => A))) =>
         matita_basics_logic.iff (matita_basics_logic.Not A)
           (matita_basics_logic.Not B))
        (H1 : (__ : cic.Term cic.prop A -> cic.Term cic.prop B) =>
         H2 : (__ : cic.Term cic.prop B -> cic.Term cic.prop A) =>
         matita_basics_logic.conj
           (cic.prod cic.prop cic.prop (matita_basics_logic.Not A)
              (__ : cic.Term cic.prop (matita_basics_logic.Not A) =>
               matita_basics_logic.Not B))
           (cic.prod cic.prop cic.prop (matita_basics_logic.Not B)
              (__ : cic.Term cic.prop (matita_basics_logic.Not B) =>
               matita_basics_logic.Not A))
           (auto : cic.Term cic.prop (matita_basics_logic.Not A) =>
            matita_basics_logic.not_to_not B A
              (auto' : cic.Term cic.prop B => H2 auto') auto)
           (auto : cic.Term cic.prop (matita_basics_logic.Not B) =>
            matita_basics_logic.not_to_not A B
              (auto' : cic.Term cic.prop A => H1 auto') auto))
        _clearme.

def iff_and_l :
      A : cic.Univ cic.prop ->
      B : cic.Univ cic.prop ->
      C : cic.Univ cic.prop ->
      __ : cic.Term cic.prop (matita_basics_logic.iff A B) ->
      cic.Term cic.prop
        (matita_basics_logic.iff (matita_basics_logic.And C A)
           (matita_basics_logic.And C B))
      :=
      A : cic.Univ cic.prop =>
      B : cic.Univ cic.prop =>
      C : cic.Univ cic.prop =>
      _clearme : cic.Term cic.prop (matita_basics_logic.iff A B) =>
      matita_basics_logic.match_And
        (cic.prod cic.prop cic.prop A (__ : cic.Term cic.prop A => B))
        (cic.prod cic.prop cic.prop B (__ : cic.Term cic.prop B => A))
        cic.prop
        (__ :
           cic.Term cic.prop
             (matita_basics_logic.And
                (cic.prod cic.prop cic.prop A (__ : cic.Term cic.prop A => B))
                (cic.prod cic.prop cic.prop B (__ : cic.Term cic.prop B => A))) =>
         matita_basics_logic.iff (matita_basics_logic.And C A)
           (matita_basics_logic.And C B))
        (H1 : (__ : cic.Term cic.prop A -> cic.Term cic.prop B) =>
         H2 : (__ : cic.Term cic.prop B -> cic.Term cic.prop A) =>
         matita_basics_logic.conj
           (cic.prod cic.prop cic.prop (matita_basics_logic.And C A)
              (__ : cic.Term cic.prop (matita_basics_logic.And C A) =>
               matita_basics_logic.And C B))
           (cic.prod cic.prop cic.prop (matita_basics_logic.And C B)
              (__ : cic.Term cic.prop (matita_basics_logic.And C B) =>
               matita_basics_logic.And C A))
           (_clearme0 : cic.Term cic.prop (matita_basics_logic.And C A) =>
            matita_basics_logic.match_And C A cic.prop
              (__ : cic.Term cic.prop (matita_basics_logic.And C A) =>
               matita_basics_logic.And C B)
              (auto : cic.Term cic.prop C =>
               auto' : cic.Term cic.prop A =>
               matita_basics_logic.conj C B auto (H1 auto'))
              _clearme0)
           (_clearme0 : cic.Term cic.prop (matita_basics_logic.And C B) =>
            matita_basics_logic.match_And C B cic.prop
              (__ : cic.Term cic.prop (matita_basics_logic.And C B) =>
               matita_basics_logic.And C A)
              (auto : cic.Term cic.prop C =>
               auto' : cic.Term cic.prop B =>
               matita_basics_logic.conj C A auto (H2 auto'))
              _clearme0))
        _clearme.

def iff_and_r :
      A : cic.Univ cic.prop ->
      B : cic.Univ cic.prop ->
      C : cic.Univ cic.prop ->
      __ : cic.Term cic.prop (matita_basics_logic.iff A B) ->
      cic.Term cic.prop
        (matita_basics_logic.iff (matita_basics_logic.And A C)
           (matita_basics_logic.And B C))
      :=
      A : cic.Univ cic.prop =>
      B : cic.Univ cic.prop =>
      C : cic.Univ cic.prop =>
      _clearme : cic.Term cic.prop (matita_basics_logic.iff A B) =>
      matita_basics_logic.match_And
        (cic.prod cic.prop cic.prop A (__ : cic.Term cic.prop A => B))
        (cic.prod cic.prop cic.prop B (__ : cic.Term cic.prop B => A))
        cic.prop
        (__ :
           cic.Term cic.prop
             (matita_basics_logic.And
                (cic.prod cic.prop cic.prop A (__ : cic.Term cic.prop A => B))
                (cic.prod cic.prop cic.prop B (__ : cic.Term cic.prop B => A))) =>
         matita_basics_logic.iff (matita_basics_logic.And A C)
           (matita_basics_logic.And B C))
        (H1 : (__ : cic.Term cic.prop A -> cic.Term cic.prop B) =>
         H2 : (__ : cic.Term cic.prop B -> cic.Term cic.prop A) =>
         matita_basics_logic.conj
           (cic.prod cic.prop cic.prop (matita_basics_logic.And A C)
              (__ : cic.Term cic.prop (matita_basics_logic.And A C) =>
               matita_basics_logic.And B C))
           (cic.prod cic.prop cic.prop (matita_basics_logic.And B C)
              (__ : cic.Term cic.prop (matita_basics_logic.And B C) =>
               matita_basics_logic.And A C))
           (_clearme0 : cic.Term cic.prop (matita_basics_logic.And A C) =>
            matita_basics_logic.match_And A C cic.prop
              (__ : cic.Term cic.prop (matita_basics_logic.And A C) =>
               matita_basics_logic.And B C)
              (auto : cic.Term cic.prop A =>
               auto' : cic.Term cic.prop C =>
               matita_basics_logic.conj B C (H1 auto) auto')
              _clearme0)
           (_clearme0 : cic.Term cic.prop (matita_basics_logic.And B C) =>
            matita_basics_logic.match_And B C cic.prop
              (__ : cic.Term cic.prop (matita_basics_logic.And B C) =>
               matita_basics_logic.And A C)
              (auto : cic.Term cic.prop B =>
               auto' : cic.Term cic.prop C =>
               matita_basics_logic.conj A C (H2 auto) auto')
              _clearme0))
        _clearme.

def iff_or_l :
      A : cic.Univ cic.prop ->
      B : cic.Univ cic.prop ->
      C : cic.Univ cic.prop ->
      __ : cic.Term cic.prop (matita_basics_logic.iff A B) ->
      cic.Term cic.prop
        (matita_basics_logic.iff (matita_basics_logic.Or C A)
           (matita_basics_logic.Or C B))
      :=
      A : cic.Univ cic.prop =>
      B : cic.Univ cic.prop =>
      C : cic.Univ cic.prop =>
      _clearme : cic.Term cic.prop (matita_basics_logic.iff A B) =>
      matita_basics_logic.match_And
        (cic.prod cic.prop cic.prop A (__ : cic.Term cic.prop A => B))
        (cic.prod cic.prop cic.prop B (__ : cic.Term cic.prop B => A))
        cic.prop
        (__ :
           cic.Term cic.prop
             (matita_basics_logic.And
                (cic.prod cic.prop cic.prop A (__ : cic.Term cic.prop A => B))
                (cic.prod cic.prop cic.prop B (__ : cic.Term cic.prop B => A))) =>
         matita_basics_logic.iff (matita_basics_logic.Or C A)
           (matita_basics_logic.Or C B))
        (H1 : (__ : cic.Term cic.prop A -> cic.Term cic.prop B) =>
         H2 : (__ : cic.Term cic.prop B -> cic.Term cic.prop A) =>
         matita_basics_logic.conj
           (cic.prod cic.prop cic.prop (matita_basics_logic.Or C A)
              (__ : cic.Term cic.prop (matita_basics_logic.Or C A) =>
               matita_basics_logic.Or C B))
           (cic.prod cic.prop cic.prop (matita_basics_logic.Or C B)
              (__ : cic.Term cic.prop (matita_basics_logic.Or C B) =>
               matita_basics_logic.Or C A))
           (_clearme0 : cic.Term cic.prop (matita_basics_logic.Or C A) =>
            matita_basics_logic.match_Or C A cic.prop
              (__ : cic.Term cic.prop (matita_basics_logic.Or C A) =>
               matita_basics_logic.Or C B)
              (auto : cic.Term cic.prop C =>
               matita_basics_logic.or_introl C B auto)
              (auto : cic.Term cic.prop A =>
               matita_basics_logic.or_intror C B (H1 auto))
              _clearme0)
           (_clearme0 : cic.Term cic.prop (matita_basics_logic.Or C B) =>
            matita_basics_logic.match_Or C B cic.prop
              (__ : cic.Term cic.prop (matita_basics_logic.Or C B) =>
               matita_basics_logic.Or C A)
              (auto : cic.Term cic.prop C =>
               matita_basics_logic.or_introl C A auto)
              (auto : cic.Term cic.prop B =>
               matita_basics_logic.or_intror C A (H2 auto))
              _clearme0))
        _clearme.

def iff_or_r :
      A : cic.Univ cic.prop ->
      B : cic.Univ cic.prop ->
      C : cic.Univ cic.prop ->
      __ : cic.Term cic.prop (matita_basics_logic.iff A B) ->
      cic.Term cic.prop
        (matita_basics_logic.iff (matita_basics_logic.Or A C)
           (matita_basics_logic.Or B C))
      :=
      A : cic.Univ cic.prop =>
      B : cic.Univ cic.prop =>
      C : cic.Univ cic.prop =>
      _clearme : cic.Term cic.prop (matita_basics_logic.iff A B) =>
      matita_basics_logic.match_And
        (cic.prod cic.prop cic.prop A (__ : cic.Term cic.prop A => B))
        (cic.prod cic.prop cic.prop B (__ : cic.Term cic.prop B => A))
        cic.prop
        (__ :
           cic.Term cic.prop
             (matita_basics_logic.And
                (cic.prod cic.prop cic.prop A (__ : cic.Term cic.prop A => B))
                (cic.prod cic.prop cic.prop B (__ : cic.Term cic.prop B => A))) =>
         matita_basics_logic.iff (matita_basics_logic.Or A C)
           (matita_basics_logic.Or B C))
        (H1 : (__ : cic.Term cic.prop A -> cic.Term cic.prop B) =>
         H2 : (__ : cic.Term cic.prop B -> cic.Term cic.prop A) =>
         matita_basics_logic.conj
           (cic.prod cic.prop cic.prop (matita_basics_logic.Or A C)
              (__ : cic.Term cic.prop (matita_basics_logic.Or A C) =>
               matita_basics_logic.Or B C))
           (cic.prod cic.prop cic.prop (matita_basics_logic.Or B C)
              (__ : cic.Term cic.prop (matita_basics_logic.Or B C) =>
               matita_basics_logic.Or A C))
           (_clearme0 : cic.Term cic.prop (matita_basics_logic.Or A C) =>
            matita_basics_logic.match_Or A C cic.prop
              (__ : cic.Term cic.prop (matita_basics_logic.Or A C) =>
               matita_basics_logic.Or B C)
              (auto : cic.Term cic.prop A =>
               matita_basics_logic.or_introl B C (H1 auto))
              (auto : cic.Term cic.prop C =>
               matita_basics_logic.or_intror B C auto)
              _clearme0)
           (_clearme0 : cic.Term cic.prop (matita_basics_logic.Or B C) =>
            matita_basics_logic.match_Or B C cic.prop
              (__ : cic.Term cic.prop (matita_basics_logic.Or B C) =>
               matita_basics_logic.Or A C)
              (auto : cic.Term cic.prop B =>
               matita_basics_logic.or_introl A C (H2 auto))
              (auto : cic.Term cic.prop C =>
               matita_basics_logic.or_intror A C auto)
              _clearme0))
        _clearme.

def R0 :
      T : cic.Univ univs.Type0 ->
      _t : cic.Term univs.Type0 T -> cic.Term univs.Type0 T :=
      T : cic.Univ univs.Type0 => t : cic.Term univs.Type0 T => t.

def R1 :
      A : cic.Univ univs.Type2 ->
      _x : cic.Term univs.Type2 A ->
      Q_ :
        (x_19 : cic.Term univs.Type2 A ->
         _x_20 : cic.Term cic.prop (matita_basics_logic.eq A _x x_19) ->
         cic.Univ univs.Type0) ->
      _H_refl :
        cic.Term univs.Type0 (Q_ _x (matita_basics_logic.refl A _x)) ->
      x_19 : cic.Term univs.Type2 A ->
      x_20 : cic.Term cic.prop (matita_basics_logic.eq A _x x_19) ->
      cic.Term univs.Type0 (Q_ x_19 x_20) :=
      matita_basics_logic.eq_rect_Type0.

def R2 :
      T0 : cic.Univ univs.Type0 ->
      a0 : cic.Term univs.Type0 T0 ->
      T1 :
        (x0 : cic.Term univs.Type0 T0 ->
         __ :
           cic.Term cic.prop
             (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0
                x0) ->
         cic.Univ univs.Type0) ->
      a1 :
        cic.Term univs.Type0
          (T1 a0
             (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0)
                a0)) ->
      T2 :
        (x0 : cic.Term univs.Type0 T0 ->
         p0 :
           cic.Term cic.prop
             (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0
                x0) ->
         x1 : cic.Term univs.Type0 (T1 x0 p0) ->
         __ :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift univs.Type0 univs.Type2 (T1 x0 p0))
                (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0)
                   a0 T1 a1 x0 p0)
                x1) ->
         cic.Univ univs.Type0) ->
      _a2 :
        cic.Term univs.Type0
          (T2 a0
             (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0)
                a0)
             a1
             (matita_basics_logic.refl
                (cic.lift univs.Type0 univs.Type2
                   (T1 a0
                      (matita_basics_logic.refl
                         (cic.lift univs.Type0 univs.Type2 T0) a0)))
                a1)) ->
      b0 : cic.Term univs.Type0 T0 ->
      e0 :
        cic.Term cic.prop
          (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 b0) ->
      b1 : cic.Term univs.Type0 (T1 b0 e0) ->
      e1 :
        cic.Term cic.prop
          (matita_basics_logic.eq
             (cic.lift univs.Type0 univs.Type2 (T1 b0 e0))
             (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0) a0
                T1 a1 b0 e0)
             b1) ->
      cic.Term univs.Type0 (T2 b0 e0 b1 e1) :=
      T0 : cic.Univ univs.Type0 =>
      a0 : cic.Term univs.Type0 T0 =>
      T1 :
        (x0 : cic.Term univs.Type0 T0 ->
         __ :
           cic.Term cic.prop
             (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0
                x0) ->
         cic.Univ univs.Type0) =>
      a1 :
        cic.Term univs.Type0
          (T1 a0
             (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0)
                a0)) =>
      T2 :
        (x0 : cic.Term univs.Type0 T0 ->
         p0 :
           cic.Term cic.prop
             (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0
                x0) ->
         x1 : cic.Term univs.Type0 (T1 x0 p0) ->
         __ :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift univs.Type0 univs.Type2 (T1 x0 p0))
                (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0)
                   a0 T1 a1 x0 p0)
                x1) ->
         cic.Univ univs.Type0) =>
      a2 :
        cic.Term univs.Type0
          (T2 a0
             (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0)
                a0)
             a1
             (matita_basics_logic.refl
                (cic.lift univs.Type0 univs.Type2
                   (T1 a0
                      (matita_basics_logic.refl
                         (cic.lift univs.Type0 univs.Type2 T0) a0)))
                a1)) =>
      b0 : cic.Term univs.Type0 T0 =>
      e0 :
        cic.Term cic.prop
          (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 b0) =>
      b1 : cic.Term univs.Type0 (T1 b0 e0) =>
      e1 :
        cic.Term cic.prop
          (matita_basics_logic.eq
             (cic.lift univs.Type0 univs.Type2 (T1 b0 e0))
             (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0) a0
                T1 a1 b0 e0)
             b1) =>
      matita_basics_logic.eq_rect_Type0
        (cic.lift univs.Type0 univs.Type2 (T1 b0 e0))
        (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0) a0 T1
           a1 b0 e0)
        (T2 b0 e0)
        (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0) a0
           (x_19 : cic.Term univs.Type0 T0 =>
            _x_20 :
              cic.Term cic.prop
                (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0)
                   a0 x_19) =>
            T2 x_19 _x_20
              (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0)
                 a0 T1 a1 x_19 _x_20)
              (matita_basics_logic.refl
                 (cic.lift univs.Type0 univs.Type2 (T1 x_19 _x_20))
                 (matita_basics_logic.R1
                    (cic.lift univs.Type0 univs.Type2 T0) a0 T1 a1 x_19 _x_20)))
           a2 b0 e0)
        b1 e1.

def R3 :
      T0 : cic.Univ univs.Type0 ->
      a0 : cic.Term univs.Type0 T0 ->
      T1 :
        (x0 : cic.Term univs.Type0 T0 ->
         __ :
           cic.Term cic.prop
             (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0
                x0) ->
         cic.Univ univs.Type0) ->
      a1 :
        cic.Term univs.Type0
          (T1 a0
             (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0)
                a0)) ->
      T2 :
        (x0 : cic.Term univs.Type0 T0 ->
         p0 :
           cic.Term cic.prop
             (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0
                x0) ->
         x1 : cic.Term univs.Type0 (T1 x0 p0) ->
         __ :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift univs.Type0 univs.Type2 (T1 x0 p0))
                (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0)
                   a0 T1 a1 x0 p0)
                x1) ->
         cic.Univ univs.Type0) ->
      a2 :
        cic.Term univs.Type0
          (T2 a0
             (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0)
                a0)
             a1
             (matita_basics_logic.refl
                (cic.lift univs.Type0 univs.Type2
                   (T1 a0
                      (matita_basics_logic.refl
                         (cic.lift univs.Type0 univs.Type2 T0) a0)))
                a1)) ->
      T3 :
        (x0 : cic.Term univs.Type0 T0 ->
         p0 :
           cic.Term cic.prop
             (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0
                x0) ->
         x1 : cic.Term univs.Type0 (T1 x0 p0) ->
         p1 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift univs.Type0 univs.Type2 (T1 x0 p0))
                (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0)
                   a0 T1 a1 x0 p0)
                x1) ->
         x2 : cic.Term univs.Type0 (T2 x0 p0 x1 p1) ->
         __ :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift univs.Type0 univs.Type2 (T2 x0 p0 x1 p1))
                (matita_basics_logic.R2 T0 a0 T1 a1 T2 a2 x0 p0 x1 p1) x2) ->
         cic.Univ univs.Type0) ->
      _a3 :
        cic.Term univs.Type0
          (T3 a0
             (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0)
                a0)
             a1
             (matita_basics_logic.refl
                (cic.lift univs.Type0 univs.Type2
                   (T1 a0
                      (matita_basics_logic.refl
                         (cic.lift univs.Type0 univs.Type2 T0) a0)))
                a1)
             a2
             (matita_basics_logic.refl
                (cic.lift univs.Type0 univs.Type2
                   (T2 a0
                      (matita_basics_logic.refl
                         (cic.lift univs.Type0 univs.Type2 T0) a0)
                      a1
                      (matita_basics_logic.refl
                         (cic.lift univs.Type0 univs.Type2
                            (T1 a0
                               (matita_basics_logic.refl
                                  (cic.lift univs.Type0 univs.Type2 T0) a0)))
                         a1)))
                a2)) ->
      b0 : cic.Term univs.Type0 T0 ->
      e0 :
        cic.Term cic.prop
          (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 b0) ->
      b1 : cic.Term univs.Type0 (T1 b0 e0) ->
      e1 :
        cic.Term cic.prop
          (matita_basics_logic.eq
             (cic.lift univs.Type0 univs.Type2 (T1 b0 e0))
             (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0) a0
                T1 a1 b0 e0)
             b1) ->
      b2 : cic.Term univs.Type0 (T2 b0 e0 b1 e1) ->
      e2 :
        cic.Term cic.prop
          (matita_basics_logic.eq
             (cic.lift univs.Type0 univs.Type2 (T2 b0 e0 b1 e1))
             (matita_basics_logic.R2 T0 a0 T1 a1 T2 a2 b0 e0 b1 e1) b2) ->
      cic.Term univs.Type0 (T3 b0 e0 b1 e1 b2 e2) :=
      T0 : cic.Univ univs.Type0 =>
      a0 : cic.Term univs.Type0 T0 =>
      T1 :
        (x0 : cic.Term univs.Type0 T0 ->
         __ :
           cic.Term cic.prop
             (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0
                x0) ->
         cic.Univ univs.Type0) =>
      a1 :
        cic.Term univs.Type0
          (T1 a0
             (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0)
                a0)) =>
      T2 :
        (x0 : cic.Term univs.Type0 T0 ->
         p0 :
           cic.Term cic.prop
             (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0
                x0) ->
         x1 : cic.Term univs.Type0 (T1 x0 p0) ->
         __ :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift univs.Type0 univs.Type2 (T1 x0 p0))
                (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0)
                   a0 T1 a1 x0 p0)
                x1) ->
         cic.Univ univs.Type0) =>
      a2 :
        cic.Term univs.Type0
          (T2 a0
             (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0)
                a0)
             a1
             (matita_basics_logic.refl
                (cic.lift univs.Type0 univs.Type2
                   (T1 a0
                      (matita_basics_logic.refl
                         (cic.lift univs.Type0 univs.Type2 T0) a0)))
                a1)) =>
      T3 :
        (x0 : cic.Term univs.Type0 T0 ->
         p0 :
           cic.Term cic.prop
             (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0
                x0) ->
         x1 : cic.Term univs.Type0 (T1 x0 p0) ->
         p1 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift univs.Type0 univs.Type2 (T1 x0 p0))
                (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0)
                   a0 T1 a1 x0 p0)
                x1) ->
         x2 : cic.Term univs.Type0 (T2 x0 p0 x1 p1) ->
         __ :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift univs.Type0 univs.Type2 (T2 x0 p0 x1 p1))
                (matita_basics_logic.R2 T0 a0 T1 a1 T2 a2 x0 p0 x1 p1) x2) ->
         cic.Univ univs.Type0) =>
      a3 :
        cic.Term univs.Type0
          (T3 a0
             (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0)
                a0)
             a1
             (matita_basics_logic.refl
                (cic.lift univs.Type0 univs.Type2
                   (T1 a0
                      (matita_basics_logic.refl
                         (cic.lift univs.Type0 univs.Type2 T0) a0)))
                a1)
             a2
             (matita_basics_logic.refl
                (cic.lift univs.Type0 univs.Type2
                   (T2 a0
                      (matita_basics_logic.refl
                         (cic.lift univs.Type0 univs.Type2 T0) a0)
                      a1
                      (matita_basics_logic.refl
                         (cic.lift univs.Type0 univs.Type2
                            (T1 a0
                               (matita_basics_logic.refl
                                  (cic.lift univs.Type0 univs.Type2 T0) a0)))
                         a1)))
                a2)) =>
      b0 : cic.Term univs.Type0 T0 =>
      e0 :
        cic.Term cic.prop
          (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 b0) =>
      b1 : cic.Term univs.Type0 (T1 b0 e0) =>
      e1 :
        cic.Term cic.prop
          (matita_basics_logic.eq
             (cic.lift univs.Type0 univs.Type2 (T1 b0 e0))
             (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0) a0
                T1 a1 b0 e0)
             b1) =>
      b2 : cic.Term univs.Type0 (T2 b0 e0 b1 e1) =>
      e2 :
        cic.Term cic.prop
          (matita_basics_logic.eq
             (cic.lift univs.Type0 univs.Type2 (T2 b0 e0 b1 e1))
             (matita_basics_logic.R2 T0 a0 T1 a1 T2 a2 b0 e0 b1 e1) b2) =>
      matita_basics_logic.eq_rect_Type0
        (cic.lift univs.Type0 univs.Type2 (T2 b0 e0 b1 e1))
        (matita_basics_logic.R2 T0 a0 T1 a1 T2 a2 b0 e0 b1 e1)
        (T3 b0 e0 b1 e1)
        (matita_basics_logic.R2 T0 a0 T1 a1
           (x0 : cic.Term univs.Type0 T0 =>
            p0 :
              cic.Term cic.prop
                (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0)
                   a0 x0) =>
            x1 : cic.Term univs.Type0 (T1 x0 p0) =>
            __ :
              cic.Term cic.prop
                (matita_basics_logic.eq
                   (cic.lift univs.Type0 univs.Type2 (T1 x0 p0))
                   (matita_basics_logic.R1
                      (cic.lift univs.Type0 univs.Type2 T0) a0 T1 a1 x0 p0)
                   x1) =>
            T3 x0 p0 x1 __
              (matita_basics_logic.R2 T0 a0 T1 a1 T2 a2 x0 p0 x1 __)
              (matita_basics_logic.refl
                 (cic.lift univs.Type0 univs.Type2 (T2 x0 p0 x1 __))
                 (matita_basics_logic.R2 T0 a0 T1 a1 T2 a2 x0 p0 x1 __)))
           a3 b0 e0 b1 e1)
        b2 e2.

def R4 :
      T0 : cic.Univ univs.Type0 ->
      a0 : cic.Term univs.Type0 T0 ->
      T1 :
        (x0 : cic.Term univs.Type0 T0 ->
         __ :
           cic.Term cic.prop
             (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0
                x0) ->
         cic.Univ univs.Type0) ->
      a1 :
        cic.Term univs.Type0
          (T1 a0
             (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0)
                a0)) ->
      T2 :
        (x0 : cic.Term univs.Type0 T0 ->
         p0 :
           cic.Term cic.prop
             (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0
                x0) ->
         x1 : cic.Term univs.Type0 (T1 x0 p0) ->
         __ :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift univs.Type0 univs.Type2 (T1 x0 p0))
                (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0)
                   a0 T1 a1 x0 p0)
                x1) ->
         cic.Univ univs.Type0) ->
      a2 :
        cic.Term univs.Type0
          (T2 a0
             (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0)
                a0)
             a1
             (matita_basics_logic.refl
                (cic.lift univs.Type0 univs.Type2
                   (T1 a0
                      (matita_basics_logic.refl
                         (cic.lift univs.Type0 univs.Type2 T0) a0)))
                a1)) ->
      T3 :
        (x0 : cic.Term univs.Type0 T0 ->
         p0 :
           cic.Term cic.prop
             (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0
                x0) ->
         x1 : cic.Term univs.Type0 (T1 x0 p0) ->
         p1 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift univs.Type0 univs.Type2 (T1 x0 p0))
                (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0)
                   a0 T1 a1 x0 p0)
                x1) ->
         x2 : cic.Term univs.Type0 (T2 x0 p0 x1 p1) ->
         __ :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift univs.Type0 univs.Type2 (T2 x0 p0 x1 p1))
                (matita_basics_logic.R2 T0 a0 T1 a1 T2 a2 x0 p0 x1 p1) x2) ->
         cic.Univ univs.Type0) ->
      a3 :
        cic.Term univs.Type0
          (T3 a0
             (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0)
                a0)
             a1
             (matita_basics_logic.refl
                (cic.lift univs.Type0 univs.Type2
                   (T1 a0
                      (matita_basics_logic.refl
                         (cic.lift univs.Type0 univs.Type2 T0) a0)))
                a1)
             a2
             (matita_basics_logic.refl
                (cic.lift univs.Type0 univs.Type2
                   (T2 a0
                      (matita_basics_logic.refl
                         (cic.lift univs.Type0 univs.Type2 T0) a0)
                      a1
                      (matita_basics_logic.refl
                         (cic.lift univs.Type0 univs.Type2
                            (T1 a0
                               (matita_basics_logic.refl
                                  (cic.lift univs.Type0 univs.Type2 T0) a0)))
                         a1)))
                a2)) ->
      T4 :
        (x0 : cic.Term univs.Type0 T0 ->
         p0 :
           cic.Term cic.prop
             (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0
                x0) ->
         x1 : cic.Term univs.Type0 (T1 x0 p0) ->
         p1 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift univs.Type0 univs.Type2 (T1 x0 p0))
                (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0)
                   a0 T1 a1 x0 p0)
                x1) ->
         x2 : cic.Term univs.Type0 (T2 x0 p0 x1 p1) ->
         p2 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift univs.Type0 univs.Type2 (T2 x0 p0 x1 p1))
                (matita_basics_logic.R2 T0 a0 T1 a1 T2 a2 x0 p0 x1 p1) x2) ->
         x3 : cic.Term univs.Type0 (T3 x0 p0 x1 p1 x2 p2) ->
         _p3 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift univs.Type0 univs.Type2 (T3 x0 p0 x1 p1 x2 p2))
                (matita_basics_logic.R3 T0 a0 T1 a1 T2 a2 T3 a3 x0 p0 x1 p1
                   x2 p2)
                x3) ->
         cic.Univ univs.Type0) ->
      _a4 :
        cic.Term univs.Type0
          (T4 a0
             (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0)
                a0)
             a1
             (matita_basics_logic.refl
                (cic.lift univs.Type0 univs.Type2
                   (T1 a0
                      (matita_basics_logic.refl
                         (cic.lift univs.Type0 univs.Type2 T0) a0)))
                a1)
             a2
             (matita_basics_logic.refl
                (cic.lift univs.Type0 univs.Type2
                   (T2 a0
                      (matita_basics_logic.refl
                         (cic.lift univs.Type0 univs.Type2 T0) a0)
                      a1
                      (matita_basics_logic.refl
                         (cic.lift univs.Type0 univs.Type2
                            (T1 a0
                               (matita_basics_logic.refl
                                  (cic.lift univs.Type0 univs.Type2 T0) a0)))
                         a1)))
                a2)
             a3
             (matita_basics_logic.refl
                (cic.lift univs.Type0 univs.Type2
                   (T3 a0
                      (matita_basics_logic.refl
                         (cic.lift univs.Type0 univs.Type2 T0) a0)
                      a1
                      (matita_basics_logic.refl
                         (cic.lift univs.Type0 univs.Type2
                            (T1 a0
                               (matita_basics_logic.refl
                                  (cic.lift univs.Type0 univs.Type2 T0) a0)))
                         a1)
                      a2
                      (matita_basics_logic.refl
                         (cic.lift univs.Type0 univs.Type2
                            (T2 a0
                               (matita_basics_logic.refl
                                  (cic.lift univs.Type0 univs.Type2 T0) a0)
                               a1
                               (matita_basics_logic.refl
                                  (cic.lift univs.Type0 univs.Type2
                                     (T1 a0
                                        (matita_basics_logic.refl
                                           (cic.lift univs.Type0 univs.Type2
                                              T0)
                                           a0)))
                                  a1)))
                         a2)))
                a3)) ->
      b0 : cic.Term univs.Type0 T0 ->
      e0 :
        cic.Term cic.prop
          (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 b0) ->
      b1 : cic.Term univs.Type0 (T1 b0 e0) ->
      e1 :
        cic.Term cic.prop
          (matita_basics_logic.eq
             (cic.lift univs.Type0 univs.Type2 (T1 b0 e0))
             (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0) a0
                T1 a1 b0 e0)
             b1) ->
      b2 : cic.Term univs.Type0 (T2 b0 e0 b1 e1) ->
      e2 :
        cic.Term cic.prop
          (matita_basics_logic.eq
             (cic.lift univs.Type0 univs.Type2 (T2 b0 e0 b1 e1))
             (matita_basics_logic.R2 T0 a0 T1 a1 T2 a2 b0 e0 b1 e1) b2) ->
      b3 : cic.Term univs.Type0 (T3 b0 e0 b1 e1 b2 e2) ->
      e3 :
        cic.Term cic.prop
          (matita_basics_logic.eq
             (cic.lift univs.Type0 univs.Type2 (T3 b0 e0 b1 e1 b2 e2))
             (matita_basics_logic.R3 T0 a0 T1 a1 T2 a2 T3 a3 b0 e0 b1 e1 b2
                e2)
             b3) ->
      cic.Term univs.Type0 (T4 b0 e0 b1 e1 b2 e2 b3 e3) :=
      T0 : cic.Univ univs.Type0 =>
      a0 : cic.Term univs.Type0 T0 =>
      T1 :
        (x0 : cic.Term univs.Type0 T0 ->
         __ :
           cic.Term cic.prop
             (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0
                x0) ->
         cic.Univ univs.Type0) =>
      a1 :
        cic.Term univs.Type0
          (T1 a0
             (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0)
                a0)) =>
      T2 :
        (x0 : cic.Term univs.Type0 T0 ->
         p0 :
           cic.Term cic.prop
             (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0
                x0) ->
         x1 : cic.Term univs.Type0 (T1 x0 p0) ->
         __ :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift univs.Type0 univs.Type2 (T1 x0 p0))
                (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0)
                   a0 T1 a1 x0 p0)
                x1) ->
         cic.Univ univs.Type0) =>
      a2 :
        cic.Term univs.Type0
          (T2 a0
             (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0)
                a0)
             a1
             (matita_basics_logic.refl
                (cic.lift univs.Type0 univs.Type2
                   (T1 a0
                      (matita_basics_logic.refl
                         (cic.lift univs.Type0 univs.Type2 T0) a0)))
                a1)) =>
      T3 :
        (x0 : cic.Term univs.Type0 T0 ->
         p0 :
           cic.Term cic.prop
             (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0
                x0) ->
         x1 : cic.Term univs.Type0 (T1 x0 p0) ->
         p1 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift univs.Type0 univs.Type2 (T1 x0 p0))
                (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0)
                   a0 T1 a1 x0 p0)
                x1) ->
         x2 : cic.Term univs.Type0 (T2 x0 p0 x1 p1) ->
         __ :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift univs.Type0 univs.Type2 (T2 x0 p0 x1 p1))
                (matita_basics_logic.R2 T0 a0 T1 a1 T2 a2 x0 p0 x1 p1) x2) ->
         cic.Univ univs.Type0) =>
      a3 :
        cic.Term univs.Type0
          (T3 a0
             (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0)
                a0)
             a1
             (matita_basics_logic.refl
                (cic.lift univs.Type0 univs.Type2
                   (T1 a0
                      (matita_basics_logic.refl
                         (cic.lift univs.Type0 univs.Type2 T0) a0)))
                a1)
             a2
             (matita_basics_logic.refl
                (cic.lift univs.Type0 univs.Type2
                   (T2 a0
                      (matita_basics_logic.refl
                         (cic.lift univs.Type0 univs.Type2 T0) a0)
                      a1
                      (matita_basics_logic.refl
                         (cic.lift univs.Type0 univs.Type2
                            (T1 a0
                               (matita_basics_logic.refl
                                  (cic.lift univs.Type0 univs.Type2 T0) a0)))
                         a1)))
                a2)) =>
      T4 :
        (x0 : cic.Term univs.Type0 T0 ->
         p0 :
           cic.Term cic.prop
             (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0
                x0) ->
         x1 : cic.Term univs.Type0 (T1 x0 p0) ->
         p1 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift univs.Type0 univs.Type2 (T1 x0 p0))
                (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0)
                   a0 T1 a1 x0 p0)
                x1) ->
         x2 : cic.Term univs.Type0 (T2 x0 p0 x1 p1) ->
         p2 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift univs.Type0 univs.Type2 (T2 x0 p0 x1 p1))
                (matita_basics_logic.R2 T0 a0 T1 a1 T2 a2 x0 p0 x1 p1) x2) ->
         x3 : cic.Term univs.Type0 (T3 x0 p0 x1 p1 x2 p2) ->
         _p3 :
           cic.Term cic.prop
             (matita_basics_logic.eq
                (cic.lift univs.Type0 univs.Type2 (T3 x0 p0 x1 p1 x2 p2))
                (matita_basics_logic.R3 T0 a0 T1 a1 T2 a2 T3 a3 x0 p0 x1 p1
                   x2 p2)
                x3) ->
         cic.Univ univs.Type0) =>
      a4 :
        cic.Term univs.Type0
          (T4 a0
             (matita_basics_logic.refl (cic.lift univs.Type0 univs.Type2 T0)
                a0)
             a1
             (matita_basics_logic.refl
                (cic.lift univs.Type0 univs.Type2
                   (T1 a0
                      (matita_basics_logic.refl
                         (cic.lift univs.Type0 univs.Type2 T0) a0)))
                a1)
             a2
             (matita_basics_logic.refl
                (cic.lift univs.Type0 univs.Type2
                   (T2 a0
                      (matita_basics_logic.refl
                         (cic.lift univs.Type0 univs.Type2 T0) a0)
                      a1
                      (matita_basics_logic.refl
                         (cic.lift univs.Type0 univs.Type2
                            (T1 a0
                               (matita_basics_logic.refl
                                  (cic.lift univs.Type0 univs.Type2 T0) a0)))
                         a1)))
                a2)
             a3
             (matita_basics_logic.refl
                (cic.lift univs.Type0 univs.Type2
                   (T3 a0
                      (matita_basics_logic.refl
                         (cic.lift univs.Type0 univs.Type2 T0) a0)
                      a1
                      (matita_basics_logic.refl
                         (cic.lift univs.Type0 univs.Type2
                            (T1 a0
                               (matita_basics_logic.refl
                                  (cic.lift univs.Type0 univs.Type2 T0) a0)))
                         a1)
                      a2
                      (matita_basics_logic.refl
                         (cic.lift univs.Type0 univs.Type2
                            (T2 a0
                               (matita_basics_logic.refl
                                  (cic.lift univs.Type0 univs.Type2 T0) a0)
                               a1
                               (matita_basics_logic.refl
                                  (cic.lift univs.Type0 univs.Type2
                                     (T1 a0
                                        (matita_basics_logic.refl
                                           (cic.lift univs.Type0 univs.Type2
                                              T0)
                                           a0)))
                                  a1)))
                         a2)))
                a3)) =>
      b0 : cic.Term univs.Type0 T0 =>
      e0 :
        cic.Term cic.prop
          (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0) a0 b0) =>
      b1 : cic.Term univs.Type0 (T1 b0 e0) =>
      e1 :
        cic.Term cic.prop
          (matita_basics_logic.eq
             (cic.lift univs.Type0 univs.Type2 (T1 b0 e0))
             (matita_basics_logic.R1 (cic.lift univs.Type0 univs.Type2 T0) a0
                T1 a1 b0 e0)
             b1) =>
      b2 : cic.Term univs.Type0 (T2 b0 e0 b1 e1) =>
      e2 :
        cic.Term cic.prop
          (matita_basics_logic.eq
             (cic.lift univs.Type0 univs.Type2 (T2 b0 e0 b1 e1))
             (matita_basics_logic.R2 T0 a0 T1 a1 T2 a2 b0 e0 b1 e1) b2) =>
      b3 : cic.Term univs.Type0 (T3 b0 e0 b1 e1 b2 e2) =>
      e3 :
        cic.Term cic.prop
          (matita_basics_logic.eq
             (cic.lift univs.Type0 univs.Type2 (T3 b0 e0 b1 e1 b2 e2))
             (matita_basics_logic.R3 T0 a0 T1 a1 T2 a2 T3 a3 b0 e0 b1 e1 b2
                e2)
             b3) =>
      matita_basics_logic.eq_rect_Type0
        (cic.lift univs.Type0 univs.Type2 (T3 b0 e0 b1 e1 b2 e2))
        (matita_basics_logic.R3 T0 a0 T1 a1 T2 a2 T3 a3 b0 e0 b1 e1 b2 e2)
        (T4 b0 e0 b1 e1 b2 e2)
        (matita_basics_logic.R3 T0 a0 T1 a1 T2 a2
           (x0 : cic.Term univs.Type0 T0 =>
            p0 :
              cic.Term cic.prop
                (matita_basics_logic.eq (cic.lift univs.Type0 univs.Type2 T0)
                   a0 x0) =>
            x1 : cic.Term univs.Type0 (T1 x0 p0) =>
            p1 :
              cic.Term cic.prop
                (matita_basics_logic.eq
                   (cic.lift univs.Type0 univs.Type2 (T1 x0 p0))
                   (matita_basics_logic.R1
                      (cic.lift univs.Type0 univs.Type2 T0) a0 T1 a1 x0 p0)
                   x1) =>
            x2 : cic.Term univs.Type0 (T2 x0 p0 x1 p1) =>
            __ :
              cic.Term cic.prop
                (matita_basics_logic.eq
                   (cic.lift univs.Type0 univs.Type2 (T2 x0 p0 x1 p1))
                   (matita_basics_logic.R2 T0 a0 T1 a1 T2 a2 x0 p0 x1 p1) x2) =>
            T4 x0 p0 x1 p1 x2 __
              (matita_basics_logic.R3 T0 a0 T1 a1 T2 a2 T3 a3 x0 p0 x1 p1 x2
                 __)
              (matita_basics_logic.refl
                 (cic.lift univs.Type0 univs.Type2 (T3 x0 p0 x1 p1 x2 __))
                 (matita_basics_logic.R3 T0 a0 T1 a1 T2 a2 T3 a3 x0 p0 x1 p1
                    x2 __)))
           a4 b0 e0 b1 e1 b2 e2)
        b3 e3.

def eqProp :
      A : cic.Univ cic.prop ->
      _x : cic.Term cic.prop A ->
      __ : cic.Term cic.prop A -> cic.Univ cic.prop :=
      A : cic.Univ cic.prop =>
      matita_basics_logic.eq (cic.lift cic.prop univs.Type2 A).

streicherK :
  T : cic.Univ univs.Type2 ->
  t : cic.Term univs.Type2 T ->
  P :
    (__ : cic.Term cic.prop (matita_basics_logic.eq T t t) ->
     cic.Univ univs.Type2) ->
  __ : cic.Term univs.Type2 (P (matita_basics_logic.refl T t)) ->
  p : cic.Term cic.prop (matita_basics_logic.eq T t t) ->
  cic.Term univs.Type2 (P p).


