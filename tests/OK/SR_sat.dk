(; OK ;)

A : Type.
T : A -> Type.
t : a:A -> T a.

a : A.
def b : A -> A -> A.
    c : A -> A -> A.

(; We build definitions with types containing an expression relying on
     2 matching variables + 2 locally bound variables
   Generated constraints are not necessary to check the rules but should
   be discarded without generating any warning (satisfiable constraints).

   See SR_unsat_cstr_i.dk for examples of unsatisfiable constraints.
;)

(; Terms that *may* contain x and *may not* contain y
   are convertible with
   terms that *must*, *may* or *may not* contain x
          and *may* or *may not* contain y ;)
def   c1 : X:(A->A->A) -> Y:(A->A) -> (x:A->y:A-> T (b x a)) -> Type.
[X,Y] c1  (x=>y=>X x y)   (y=>Y y)    ( x => y => t x      ) --> A.
[X,Y] c1  (x=>y=>X x y)   (y=>Y y)    ( x => y => t a      ) --> A.
[X,Y] c1  (x=>y=>X x y)   (y=>Y y)    ( x => y => t (c a a)) --> A.
[X,Y] c1  (x=>y=>X x y)   (y=>Y y)    ( x => y => t (c a x)) --> A.
[X,Y] c1  (x=>y=>X x y)   (y=>Y y)    ( x => y => t (c x x)) --> A.
[X,Y] c1  (x=>y=>X x y)   (y=>Y y)    ( x => y => t (b a a)) --> A.
[X,Y] c1  (x=>y=>X x y)   (y=>Y y)    ( x => y => t (b y a)) --> A.
[X,Y] c1  (x=>y=>X x y)   (y=>Y y)    ( x => y => t (b x a)) --> A.
[X,Y] c1  (x=>y=>X x y)   (y=>Y y)    ( x => y => t (b x y)) --> A.
[X,Y] c1  (x=>y=>X x y)   (y=>Y y)    ( x => y => t (c a a)) --> A.
[X,Y] c1  (x=>y=>X x y)   (y=>Y y)    ( x => y => t (c (Y x) a)) --> A.
[X,Y] c1  (x=>y=>X x y)   (y=>Y y)    ( x => y => t (c x (Y x))) --> A.

(; Terms that *must* contain x
   are convertible with
   terms that *must* or *may* contain x ;)
def d1 : (x:A -> T x) -> Type.
[]  d1   (x   => t x) --> A.
[]  d1   (x   => t (b a x)) --> A.
[]  d1   (x   => t (b (b a a) (b x a))) --> A.

(; Terms that *may not* contain x
   are convertible with
   terms that *may* or *may not* contain x ;)
def e1 : (x:A -> T (b a a)) -> Type.
[]  e1   (x   => t a) --> A.
[]  e1   (x   => t (c a a)) --> A.
[]  e1   (x   => t (b a x)) --> A.
[]  e1   (x   => t (c (b a a) (b x a))) --> A.


(; Terms that *may* contain x but *may not* contain y
   are convertible with
   terms that *may* contain x ;)

def   c3 : F : (A -> A) -> (x:A -> y: A -> T (F x)) -> Type.
[F,G] c3   F               (x   => y    => t (G x)) --> A.
(;  F x  ==  G x is dropped   ;)

def   c4 : F : (A -> A) -> (x:A -> y: A -> T (F x)) -> Type.
[F,G] c4   F               (x   => y    => t (G y)) --> A.
(; F x  ==  G y is dropped ;)



def g1:(x:A -> T (b a a))  -> Type.
[]  g1 (x   => t (c a a)) --> A.

def g2:(x:A -> T (b a a))  -> Type.
[]  g2 (x   => t       a) --> A.

def g3:(x:A -> T (b a a))  -> Type.
[]  g3 (x   => t (c a a)) --> A.
(; b a a  ==  t[a]  is dropped ;)

def f1:(x:A -> T (b a x))  -> Type.
[]  f1 (x   => t (c x a)) --> A.
[]  f1 (x   => t x      ) --> A.

def f2:(x:A -> T (b (b (c a x) a) a))  -> Type.
[]  f2 (x   => t (c x a)) --> A.
[]  f2 (x   => t       x) --> A.
