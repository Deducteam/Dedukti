(; OK -q ;)

A : Type.
T : A -> Type.
t : a:A -> T a.

a : A.
def b : A -> A -> A.
    c : A -> A -> A.

(; Rules with inferred constraints: ;)

def c1 : (x:A -> T x    ) -> Type.
[]  c1   (x   => t (b a x)) --> A.

def c2 : (x:A -> T (b x a)) -> Type.
[]  c2   (x   => t x      ) --> A.
(; x  ==  b ...[x]  is dropped ;)

def   c3 : F : (A -> A) -> (x:A -> y: A -> T (F x)) -> Type.
[F,G] c3   F               (x   => y    => t (G x)) --> A.
(;  F x  ==  G x is dropped   ;)

def   c4 : F : (A -> A) -> (x:A -> y: A -> T (F x)) -> Type.
[F,G] c4   F               (x   => y    => t (G y)) --> A.
(; F x  ==  G y is dropped ;)

def g1:(x:A -> T (b a a))  -> Type.
[]  g1 (x   => t (c a a)) --> A.

def g2:(x:A -> T (b a a))  -> Type.
[]  g2 (x   => t       a) --> A.

def g3:(x:A -> T (b a a))  -> Type.
[]  g3 (x   => t (c a a)) --> A.
(; b a a  ==  t[a]  is dropped ;)
